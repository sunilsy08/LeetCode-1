{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeetCode Solutions Getting Started In this repository, I'll work on solutions to LeetCode problems by C++, Java, and Python as much as I could. Also, I build a website by GitHub Actions to host the code files by markdown files. You can see the built page here: LeetCode Solutions . Coding Style I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat . Python code is formatted by PEP 8 -- Style Guide for Python Code . More Information The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by the end of the year! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"Preface"},{"location":"#leetcode-solutions","text":"","title":"LeetCode Solutions"},{"location":"#getting-started","text":"In this repository, I'll work on solutions to LeetCode problems by C++, Java, and Python as much as I could. Also, I build a website by GitHub Actions to host the code files by markdown files. You can see the built page here: LeetCode Solutions .","title":"Getting Started"},{"location":"#coding-style","text":"I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat . Python code is formatted by PEP 8 -- Style Guide for Python Code .","title":"Coding Style"},{"location":"#more-information","text":"The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by the end of the year! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"More Information"},{"location":"naming/","text":"Naming This document is discussed with @hsins . See the definition of Convention over configuration in Wikipedia . Fundamental Rules Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : `SELECT * FROM name_table`` Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template Rules There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s) Schematic Template We use C++ to demo the idea. Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> dp -> STL -> pointers (TBD) int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; Boundary Conditions 1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value 1 2 return ans ; return {}; Data Structures 1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixSumToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = [] Two Pointers / Sliding Windows Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ; Binary Search Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings 1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> set; for ( const int num : set ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... } Others Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . (TBD) constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Naming"},{"location":"naming/#naming","text":"This document is discussed with @hsins . See the definition of Convention over configuration in Wikipedia .","title":"Naming"},{"location":"naming/#fundamental","text":"","title":"Fundamental"},{"location":"naming/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : `SELECT * FROM name_table``","title":"Rules"},{"location":"naming/#examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"naming/#template","text":"","title":"Template"},{"location":"naming/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s)","title":"Rules"},{"location":"naming/#schematic-template","text":"We use C++ to demo the idea. Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) constexpr/const (size/length) // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; code (explanation): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> dp -> STL -> pointers (TBD) int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; // use const if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; // use const dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"Schematic Template"},{"location":"naming/#boundary-conditions","text":"1 2 3 4 5 6 7 8 9 10 // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"naming/#return-value","text":"1 2 return ans ; return {};","title":"Return Value"},{"location":"naming/#data-structures","text":"1 2 3 4 5 6 7 8 9 10 11 // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixSumToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> q ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); 1 2 3 4 5 6 7 8 // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > q = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); 1 2 3 4 5 6 7 8 9 # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () q = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = []","title":"Data Structures"},{"location":"naming/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. 1 2 int i = 0 ; for ( const int num : nums ) { ... } 1 for ( int i = 0 , j = 0 ; i < n ; ++ i ) { ... } 1 2 3 int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } 1 2 int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"naming/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"naming/#listnode","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"naming/#2d-vector-2-strings","text":"1 2 3 4 5 6 7 8 9 10 // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"naming/#traversing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( const int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( const char c : str ) { ... } // unordered_set<int> set; for ( const int num : set ) { ... } // structured binding // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"naming/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. 1 2 3 4 // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: 1 2 3 // C++ mini , std :: min () maxi , std :: max () 1 2 3 4 # Python mini , min maxi , max summ , sum When there are two maps/stacks, use meaningful names. 1 2 3 // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize vector with 0 or false implicitly . (TBD) constexpr is used if possible. const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Others"},{"location":"problems/0001/","text":"1. Two Sum Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"1. Two Sum"},{"location":"problems/0001/#1-two-sum","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"1. Two Sum"},{"location":"problems/0002/","text":"2. Add Two Numbers Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( l1 || l2 || carry ) { if ( l1 ) { carry += l1 -> val ; l1 = l1 -> next ; } if ( l2 ) { carry += l2 -> val ; l2 = l2 -> next ; } curr -> next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; int carry = 0 ; while ( l1 != null || l2 != null || carry > 0 ) { if ( l1 != null ) { carry += l1 . val ; l1 = l1 . next ; } if ( l2 != null ) { carry += l2 . val ; l2 = l2 . next ; } curr . next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next","title":"2. Add Two Numbers"},{"location":"problems/0002/#2-add-two-numbers","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( l1 || l2 || carry ) { if ( l1 ) { carry += l1 -> val ; l1 = l1 -> next ; } if ( l2 ) { carry += l2 -> val ; l2 = l2 -> next ; } curr -> next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; int carry = 0 ; while ( l1 != null || l2 != null || carry > 0 ) { if ( l1 != null ) { carry += l1 . val ; l1 = l1 . next ; } if ( l2 != null ) { carry += l2 . val ; l2 = l2 . next ; } curr . next = new ListNode ( carry % 10 ); carry /= 10 ; curr = curr . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next","title":"2. Add Two Numbers"},{"location":"problems/0003/","text":"3. Longest Substring Without Repeating Characters Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ]]; while ( count [ s [ r ]] > 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 while count [ c ] > 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"3. Longest Substring Without Repeating Characters"},{"location":"problems/0003/#3-longest-substring-without-repeating-characters","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ]]; while ( count [ s [ r ]] > 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 while count [ c ] > 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"3. Longest Substring Without Repeating Characters"},{"location":"problems/0004/","text":"4. Median of Two Sorted Arrays Time: $O(\\log\\min(m, n))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { const int partition1 = l + ( r - l ) / 2 ; const int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; const int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; const int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { final int partition1 = l + ( r - l ) / 2 ; final int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; final int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; final int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; final int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; final int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1","title":"4. Median of Two Sorted Arrays"},{"location":"problems/0004/#4-median-of-two-sorted-arrays","text":"Time: $O(\\log\\min(m, n))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { const int partition1 = l + ( r - l ) / 2 ; const int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; const int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; const int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { final int partition1 = l + ( r - l ) / 2 ; final int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; final int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; final int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; final int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; final int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1","title":"4. Median of Two Sorted Arrays"},{"location":"problems/0005/","text":"5. Longest Palindromic Substring Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : string longestPalindrome ( string s ) { if ( s . empty ()) return \"\" ; // [start, end] indices of the longest palindrome in s pair < int , int > indices { 0 , 0 }; for ( int i = 0 ; i < s . length (); ++ i ) { const auto & [ l1 , r1 ] = extend ( s , i , i ); if ( r1 - l1 > indices . second - indices . first ) indices = { l1 , r1 }; if ( i + 1 < s . length () && s [ i ] == s [ i + 1 ]) { const auto & [ l2 , r2 ] = extend ( s , i , i + 1 ); if ( r2 - l2 > indices . second - indices . first ) indices = { l2 , r2 }; } } return s . substr ( indices . first , indices . second - indices . first + 1 ); } private : // return [start, end] indices of the longest palindrome extended from s[i..j] pair < int , int > extend ( const string & s , int i , int j ) { for (; i >= 0 && j < s . length (); -- i , ++ j ) if ( s [ i ] != s [ j ]) break ; return { i + 1 , j - 1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String longestPalindrome ( String s ) { if ( s . isEmpty ()) return \"\" ; // [start, end] indices of the longest palindrome in s int [] indices = { 0 , 0 }; for ( int i = 0 ; i < s . length (); ++ i ) { final int [] indices1 = extend ( s , i , i ); if ( indices1 [ 1 ] - indices1 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices1 ; if ( i + 1 < s . length () && s . charAt ( i ) == s . charAt ( i + 1 )) { final int [] indices2 = extend ( s , i , i + 1 ); if ( indices2 [ 1 ] - indices2 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices2 ; } } return s . substring ( indices [ 0 ] , indices [ 1 ] + 1 ); } // return [start, end] indices of the longest palindrome extended from s[i..j] private int [] extend ( final String s , int i , int j ) { for (; i >= 0 && j < s . length (); -- i , ++ j ) if ( s . charAt ( i ) != s . charAt ( j )) break ; return new int [] { i + 1 , j - 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' )","title":"5. Longest Palindromic Substring"},{"location":"problems/0005/#5-longest-palindromic-substring","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : string longestPalindrome ( string s ) { if ( s . empty ()) return \"\" ; // [start, end] indices of the longest palindrome in s pair < int , int > indices { 0 , 0 }; for ( int i = 0 ; i < s . length (); ++ i ) { const auto & [ l1 , r1 ] = extend ( s , i , i ); if ( r1 - l1 > indices . second - indices . first ) indices = { l1 , r1 }; if ( i + 1 < s . length () && s [ i ] == s [ i + 1 ]) { const auto & [ l2 , r2 ] = extend ( s , i , i + 1 ); if ( r2 - l2 > indices . second - indices . first ) indices = { l2 , r2 }; } } return s . substr ( indices . first , indices . second - indices . first + 1 ); } private : // return [start, end] indices of the longest palindrome extended from s[i..j] pair < int , int > extend ( const string & s , int i , int j ) { for (; i >= 0 && j < s . length (); -- i , ++ j ) if ( s [ i ] != s [ j ]) break ; return { i + 1 , j - 1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String longestPalindrome ( String s ) { if ( s . isEmpty ()) return \"\" ; // [start, end] indices of the longest palindrome in s int [] indices = { 0 , 0 }; for ( int i = 0 ; i < s . length (); ++ i ) { final int [] indices1 = extend ( s , i , i ); if ( indices1 [ 1 ] - indices1 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices1 ; if ( i + 1 < s . length () && s . charAt ( i ) == s . charAt ( i + 1 )) { final int [] indices2 = extend ( s , i , i + 1 ); if ( indices2 [ 1 ] - indices2 [ 0 ] > indices [ 1 ] - indices [ 0 ] ) indices = indices2 ; } } return s . substring ( indices [ 0 ] , indices [ 1 ] + 1 ); } // return [start, end] indices of the longest palindrome extended from s[i..j] private int [] extend ( final String s , int i , int j ) { for (; i >= 0 && j < s . length (); -- i , ++ j ) if ( s . charAt ( i ) != s . charAt ( j )) break ; return new int [] { i + 1 , j - 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' )","title":"5. Longest Palindromic Substring"},{"location":"problems/0006/","text":"6. ZigZag Conversion Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string convert ( string s , int numRows ) { string ans ; vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( const char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= -1 ; k += direction ; } for ( const vector < char >& row : rows ) for ( const char c : row ) ans += c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public String convert ( String s , int numRows ) { String ans = \"\" ; List < Character >[] rows = new List [ numRows ] ; int k = 0 ; int direction = numRows == 1 ? 0 : - 1 ; for ( int i = 0 ; i < numRows ; ++ i ) rows [ i ] = new ArrayList <> (); for ( final char c : s . toCharArray ()) { rows [ k ] . add ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( final List < Character > row : rows ) for ( final char c : row ) ans += c ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows )","title":"6. ZigZag Conversion"},{"location":"problems/0006/#6-zigzag-conversion","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string convert ( string s , int numRows ) { string ans ; vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( const char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= -1 ; k += direction ; } for ( const vector < char >& row : rows ) for ( const char c : row ) ans += c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public String convert ( String s , int numRows ) { String ans = \"\" ; List < Character >[] rows = new List [ numRows ] ; int k = 0 ; int direction = numRows == 1 ? 0 : - 1 ; for ( int i = 0 ; i < numRows ; ++ i ) rows [ i ] = new ArrayList <> (); for ( final char c : s . toCharArray ()) { rows [ k ] . add ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( final List < Character > row : rows ) for ( final char c : row ) ans += c ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows )","title":"6. ZigZag Conversion"},{"location":"problems/0007/","text":"7. Reverse Integer Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < INT_MIN || ans > INT_MAX ) ? 0 : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans","title":"7. Reverse Integer"},{"location":"problems/0007/#7-reverse-integer","text":"Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < INT_MIN || ans > INT_MAX ) ? 0 : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans","title":"7. Reverse Integer"},{"location":"problems/0008/","text":"8. String to Integer (atoi) Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int myAtoi ( string & s ) { trim ( s ); if ( s . empty ()) return 0 ; long ans = 0 ; const bool isNegative = s [ 0 ] == '-' ; if ( s [ 0 ] == '+' || s [ 0 ] == '-' ) s = s . substr ( 1 ); for ( const char c : s ) { if ( ! isdigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } return isNegative ? - ans : ans ; } private : void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int myAtoi ( String s ) { s = s . strip (); if ( s . isEmpty ()) return 0 ; long ans = 0 ; final boolean isNegative = s . charAt ( 0 ) == '-' ; if ( s . charAt ( 0 ) == '-' || s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); for ( final char c : s . toCharArray ()) { if ( ! Character . isDigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( ! isNegative && ans >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return isNegative ? ( int ) - ans : ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans ))","title":"8. String to Integer (atoi)"},{"location":"problems/0008/#8-string-to-integer-atoi","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int myAtoi ( string & s ) { trim ( s ); if ( s . empty ()) return 0 ; long ans = 0 ; const bool isNegative = s [ 0 ] == '-' ; if ( s [ 0 ] == '+' || s [ 0 ] == '-' ) s = s . substr ( 1 ); for ( const char c : s ) { if ( ! isdigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } return isNegative ? - ans : ans ; } private : void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int myAtoi ( String s ) { s = s . strip (); if ( s . isEmpty ()) return 0 ; long ans = 0 ; final boolean isNegative = s . charAt ( 0 ) == '-' ; if ( s . charAt ( 0 ) == '-' || s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); for ( final char c : s . toCharArray ()) { if ( ! Character . isDigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( ! isNegative && ans >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return isNegative ? ( int ) - ans : ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans ))","title":"8. String to Integer (atoi)"},{"location":"problems/0009/","text":"9. Palindrome Number Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y > 0 ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x","title":"9. Palindrome Number"},{"location":"problems/0009/#9-palindrome-number","text":"Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y > 0 ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x","title":"9. Palindrome Number"},{"location":"problems/0010/","text":"10. Regular Expression Matching Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; auto isMatch = []( char c1 , char c2 ) { return c1 == c2 || c2 == '.' ; }; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p [ j - 1 ] == '*' ) { const bool noRepeat = dp [ i ][ j - 2 ]; const bool doRepeat = i && isMatch ( s [ i - 1 ], p [ j - 2 ]) && dp [ i - 1 ][ j ]; dp [ i ][ j ] = noRepeat || doRepeat ; } else { dp [ i ][ j ] = i && isMatch ( s [ i - 1 ], p [ j - 1 ]) && dp [ i - 1 ][ j - 1 ]; } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length (); final int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p . charAt ( j - 1 ) == '*' ) { final boolean noRepeat = dp [ i ][ j - 2 ] ; final boolean doRepeat = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 2 )) && dp [ i - 1 ][ j ] ; dp [ i ][ j ] = noRepeat || doRepeat ; } else { dp [ i ][ j ] = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 1 )) && dp [ i - 1 ][ j - 1 ] ; } return dp [ m ][ n ] ; } private boolean isMatch ( char c1 , char c2 ) { return c1 == c2 || c2 == '.' ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"10. Regular Expression Matching"},{"location":"problems/0010/#10-regular-expression-matching","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; auto isMatch = []( char c1 , char c2 ) { return c1 == c2 || c2 == '.' ; }; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p [ j - 1 ] == '*' ) { const bool noRepeat = dp [ i ][ j - 2 ]; const bool doRepeat = i && isMatch ( s [ i - 1 ], p [ j - 2 ]) && dp [ i - 1 ][ j ]; dp [ i ][ j ] = noRepeat || doRepeat ; } else { dp [ i ][ j ] = i && isMatch ( s [ i - 1 ], p [ j - 1 ]) && dp [ i - 1 ][ j - 1 ]; } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length (); final int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p . charAt ( j - 1 ) == '*' ) { final boolean noRepeat = dp [ i ][ j - 2 ] ; final boolean doRepeat = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 2 )) && dp [ i - 1 ][ j ] ; dp [ i ][ j ] = noRepeat || doRepeat ; } else { dp [ i ][ j ] = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 1 )) && dp [ i - 1 ][ j - 1 ] ; } return dp [ m ][ n ] ; } private boolean isMatch ( char c1 , char c2 ) { return c1 == c2 || c2 == '.' ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"10. Regular Expression Matching"},{"location":"problems/0011/","text":"11. Container With Most Water Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { const int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { final int h = Math . min ( height [ l ] , height [ r ] ); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans","title":"11. Container With Most Water"},{"location":"problems/0011/#11-container-with-most-water","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { const int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { final int h = Math . min ( height [ l ] , height [ r ] ); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans","title":"11. Container With Most Water"},{"location":"problems/0012/","text":"12. Integer to Roman Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string intToRoman ( int num ) { const vector < string > M { \"\" , \"M\" , \"MM\" , \"MMM\" }; const vector < string > C { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; const vector < string > X { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; const vector < string > I { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public String intToRoman ( int num ) { final String [] M = { \"\" , \"M\" , \"MM\" , \"MMM\" }; final String [] C = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; final String [] X = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; final String [] I = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ] ; } } Python 1 2 3 4 5 6 7 8 class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ]","title":"12. Integer to Roman"},{"location":"problems/0012/#12-integer-to-roman","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string intToRoman ( int num ) { const vector < string > M { \"\" , \"M\" , \"MM\" , \"MMM\" }; const vector < string > C { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; const vector < string > X { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; const vector < string > I { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public String intToRoman ( int num ) { final String [] M = { \"\" , \"M\" , \"MM\" , \"MMM\" }; final String [] C = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; final String [] X = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; final String [] I = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ] ; } } Python 1 2 3 4 5 6 7 8 class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ]","title":"12. Integer to Roman"},{"location":"problems/0013/","text":"13. Roman to Integer Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) ans -= roman [ s [ i ]]; else ans += roman [ s [ i ]]; return ans + roman [ s . back ()]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) ans -= roman [ s . charAt ( i ) ] ; else ans += roman [ s . charAt ( i ) ] ; return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]]","title":"13. Roman to Integer"},{"location":"problems/0013/#13-roman-to-integer","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; vector < int > roman ( 128 ); roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s [ i ]] < roman [ s [ i + 1 ]]) ans -= roman [ s [ i ]]; else ans += roman [ s [ i ]]; return ans + roman [ s . back ()]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 128 ] ; roman [ 'I' ] = 1 ; roman [ 'V' ] = 5 ; roman [ 'X' ] = 10 ; roman [ 'L' ] = 50 ; roman [ 'C' ] = 100 ; roman [ 'D' ] = 500 ; roman [ 'M' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s . charAt ( i ) ] < roman [ s . charAt ( i + 1 ) ] ) ans -= roman [ s . charAt ( i ) ] ; else ans += roman [ s . charAt ( i ) ] ; return ans + roman [ s . charAt ( s . length () - 1 ) ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]]","title":"13. Roman to Integer"},{"location":"problems/0014/","text":"14. Longest Common Prefix Time: $O(|strs[0]| \\cdot |strs|)$ Space: $O(|strs[0]|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . empty ()) return \"\" ; for ( int i = 0 ; i < strs [ 0 ]. length (); ++ i ) for ( int j = 1 ; j < strs . size (); ++ j ) if ( i == strs [ j ]. length () || strs [ j ][ i ] != strs [ 0 ][ i ]) return strs [ 0 ]. substr ( 0 , i ); return strs [ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String longestCommonPrefix ( String [] strs ) { if ( strs . length == 0 ) return \"\" ; for ( int i = 0 ; i < strs [ 0 ] . length (); ++ i ) for ( int j = 1 ; j < strs . length ; ++ j ) if ( i == strs [ j ] . length () || strs [ j ] . charAt ( i ) != strs [ 0 ] . charAt ( i )) return strs [ 0 ] . substring ( 0 , i ); return strs [ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" mini = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): mini = min ( mini , len ( strs [ i ])) for i in range ( mini ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans","title":"14. Longest Common Prefix"},{"location":"problems/0014/#14-longest-common-prefix","text":"Time: $O(|strs[0]| \\cdot |strs|)$ Space: $O(|strs[0]|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . empty ()) return \"\" ; for ( int i = 0 ; i < strs [ 0 ]. length (); ++ i ) for ( int j = 1 ; j < strs . size (); ++ j ) if ( i == strs [ j ]. length () || strs [ j ][ i ] != strs [ 0 ][ i ]) return strs [ 0 ]. substr ( 0 , i ); return strs [ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String longestCommonPrefix ( String [] strs ) { if ( strs . length == 0 ) return \"\" ; for ( int i = 0 ; i < strs [ 0 ] . length (); ++ i ) for ( int j = 1 ; j < strs . length ; ++ j ) if ( i == strs [ j ] . length () || strs [ j ] . charAt ( i ) != strs [ 0 ] . charAt ( i )) return strs [ 0 ] . substring ( 0 , i ); return strs [ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" mini = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): mini = min ( mini , len ( strs [ i ])) for i in range ( mini ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans","title":"14. Longest Common Prefix"},{"location":"problems/0015/","text":"15. 3Sum Time: $O(n^2)$ Space: $O(ans)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { if ( nums . size () < 3 ) return {}; vector < vector < int >> ans ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; // choose nums[i] as the first num in the triplet, // and search the remaining nums in [i + 1, n - 1] int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { const int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ++ ], nums [ r -- ]}); while ( l < r && nums [ l ] == nums [ l - 1 ]) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ]) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> threeSum ( int [] nums ) { if ( nums . length < 3 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; // choose nums[i] as the first num in the triplet, // and search the remaining nums in [i + 1, n - 1] int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ] , nums [ l ++] , nums [ r --] )); while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans","title":"15. 3Sum"},{"location":"problems/0015/#15-3sum","text":"Time: $O(n^2)$ Space: $O(ans)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { if ( nums . size () < 3 ) return {}; vector < vector < int >> ans ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; // choose nums[i] as the first num in the triplet, // and search the remaining nums in [i + 1, n - 1] int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { const int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ++ ], nums [ r -- ]}); while ( l < r && nums [ l ] == nums [ l - 1 ]) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ]) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> threeSum ( int [] nums ) { if ( nums . length < 3 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; // choose nums[i] as the first num in the triplet, // and search the remaining nums in [i + 1, n - 1] int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ] , nums [ l ++] , nums [ r --] )); while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans","title":"15. 3Sum"},{"location":"problems/0016/","text":"16. 3Sum Closest Time: $O(n^2)$ Space: $O(ans)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { const int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans","title":"16. 3Sum Closest"},{"location":"problems/0016/#16-3sum-closest","text":"Time: $O(n^2)$ Space: $O(ans)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { const int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { final int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans","title":"16. 3Sum Closest"},{"location":"problems/0017/","text":"17. Letter Combinations of a Phone Number Approach 1: DFS Time: $O(n4^n)$ Space: $O(4^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; const vector < string > digitToLetters { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; vector < string > ans ; string path ; function < void ( int ) > dfs = [ & ]( int i ) { if ( i == digits . length ()) { ans . push_back ( path ); return ; } for ( const char letter : digitToLetters [ digits [ i ] - '0' ]) { path . push_back ( letter ); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < String > letterCombinations ( String digits ) { if ( digits . isEmpty ()) return new ArrayList <> (); List < String > ans = new ArrayList <> (); dfs ( digits , 0 , new StringBuilder (), ans ); return ans ; } private static final String [] digitToLetters = { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; private void dfs ( String digits , int i , StringBuilder path , List < String > ans ) { if ( i == digits . length ()) { ans . add ( path . toString ()); return ; } for ( final char c : digitToLetters [ digits . charAt ( i ) - '0' ] . toCharArray ()) { path . append ( c ); dfs ( digits , i + 1 , path , ans ); path . deleteCharAt ( path . length () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans Approach 2: Iterative Time: $O(n4^n)$ Space: $O(4^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans { \"\" }; const vector < string > digitToLetters { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; for ( const char d : digits ) { vector < string > temp ; for ( const string & s : ans ) for ( const char c : digitToLetters [ d - '0' ]) temp . push_back ( s + c ); ans = move ( temp ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public List < String > letterCombinations ( String digits ) { if ( digits . isEmpty ()) return new ArrayList <> (); List < String > ans = new ArrayList <> (); ans . add ( \"\" ); final String [] digitToLetters = { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; for ( final char d : digits . toCharArray ()) { List < String > temp = new ArrayList <> (); for ( final String s : ans ) for ( final char c : digitToLetters [ d - '0' ] . toCharArray ()) temp . add ( s + c ); ans = temp ; } return ans ; } }","title":"17. Letter Combinations of a Phone Number"},{"location":"problems/0017/#17-letter-combinations-of-a-phone-number","text":"","title":"17. Letter Combinations of a Phone Number"},{"location":"problems/0017/#approach-1-dfs","text":"Time: $O(n4^n)$ Space: $O(4^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; const vector < string > digitToLetters { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; vector < string > ans ; string path ; function < void ( int ) > dfs = [ & ]( int i ) { if ( i == digits . length ()) { ans . push_back ( path ); return ; } for ( const char letter : digitToLetters [ digits [ i ] - '0' ]) { path . push_back ( letter ); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < String > letterCombinations ( String digits ) { if ( digits . isEmpty ()) return new ArrayList <> (); List < String > ans = new ArrayList <> (); dfs ( digits , 0 , new StringBuilder (), ans ); return ans ; } private static final String [] digitToLetters = { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; private void dfs ( String digits , int i , StringBuilder path , List < String > ans ) { if ( i == digits . length ()) { ans . add ( path . toString ()); return ; } for ( final char c : digitToLetters [ digits . charAt ( i ) - '0' ] . toCharArray ()) { path . append ( c ); dfs ( digits , i + 1 , path , ans ); path . deleteCharAt ( path . length () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans","title":"Approach 1: DFS"},{"location":"problems/0017/#approach-2-iterative","text":"Time: $O(n4^n)$ Space: $O(4^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans { \"\" }; const vector < string > digitToLetters { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; for ( const char d : digits ) { vector < string > temp ; for ( const string & s : ans ) for ( const char c : digitToLetters [ d - '0' ]) temp . push_back ( s + c ); ans = move ( temp ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public List < String > letterCombinations ( String digits ) { if ( digits . isEmpty ()) return new ArrayList <> (); List < String > ans = new ArrayList <> (); ans . add ( \"\" ); final String [] digitToLetters = { \"\" , \"\" , \"abc\" , \"def\" , \"ghi\" , \"jkl\" , \"mno\" , \"pqrs\" , \"tuv\" , \"wxyz\" }; for ( final char d : digits . toCharArray ()) { List < String > temp = new ArrayList <> (); for ( final String s : ans ) for ( final char c : digitToLetters [ d - '0' ] . toCharArray ()) temp . add ( s + c ); ans = temp ; } return ans ; } }","title":"Approach 2: Iterative"},{"location":"problems/0018/","text":"18. 4Sum Time: $O(n^3)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; // very similar to the sub procedure in 15. 3Sum function < void ( int , int , int ) > twoSum = [ & ]( int target , int l , int r ) { while ( l < r ) { const int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; -- r ; while ( l < r && nums [ l ] == nums [ l - 1 ]) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ]) -- r ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } }; // in [l, r], find n numbers add up to the target function < void ( int , int , int , int ) > nSum = [ & ]( int n , int target , int l , int r ) { if ( r - l + 1 < n || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { twoSum ( target , l , r ); return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( n - 1 , target - nums [ i ], i + 1 , r ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); nSum ( 4 , target , 0 , nums . size () - 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); nSum ( nums , 4 , target , 0 , nums . length - 1 , new ArrayList <> (), ans ); return ans ; } // in [l, r], find n numbers add up to the target private void nSum ( int [] nums , int n , int target , int l , int r , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { // very similar to the sub procedure in 15. 3Sum while ( l < r ) { final int sum = nums [ l ] + nums [ r ] ; if ( sum == target ) { path . add ( nums [ l ] ); path . add ( nums [ r ] ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); ++ l ; -- r ; while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); nSum ( nums , n - 1 , target - nums [ i ] , i + 1 , r , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans","title":"18. 4Sum"},{"location":"problems/0018/#18-4sum","text":"Time: $O(n^3)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; // very similar to the sub procedure in 15. 3Sum function < void ( int , int , int ) > twoSum = [ & ]( int target , int l , int r ) { while ( l < r ) { const int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; -- r ; while ( l < r && nums [ l ] == nums [ l - 1 ]) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ]) -- r ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } }; // in [l, r], find n numbers add up to the target function < void ( int , int , int , int ) > nSum = [ & ]( int n , int target , int l , int r ) { if ( r - l + 1 < n || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { twoSum ( target , l , r ); return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( n - 1 , target - nums [ i ], i + 1 , r ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); nSum ( 4 , target , 0 , nums . size () - 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); nSum ( nums , 4 , target , 0 , nums . length - 1 , new ArrayList <> (), ans ); return ans ; } // in [l, r], find n numbers add up to the target private void nSum ( int [] nums , int n , int target , int l , int r , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { // very similar to the sub procedure in 15. 3Sum while ( l < r ) { final int sum = nums [ l ] + nums [ r ] ; if ( sum == target ) { path . add ( nums [ l ] ); path . add ( nums [ r ] ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); ++ l ; -- r ; while ( l < r && nums [ l ] == nums [ l - 1 ] ) ++ l ; while ( l < r && nums [ r ] == nums [ r + 1 ] ) -- r ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); nSum ( nums , n - 1 , target - nums [ i ] , i + 1 , r , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans","title":"18. 4Sum"},{"location":"problems/0019/","text":"19. Remove Nth Node From End of List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow = head ; ListNode fast = head ; while ( n -- > 0 ) fast = fast . next ; if ( fast == null ) return head . next ; while ( fast . next != null ) { slow = slow . next ; fast = fast . next ; } slow . next = slow . next . next ; return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head","title":"19. Remove Nth Node From End of List"},{"location":"problems/0019/#19-remove-nth-node-from-end-of-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow = head ; ListNode fast = head ; while ( n -- > 0 ) fast = fast . next ; if ( fast == null ) return head . next ; while ( fast . next != null ) { slow = slow . next ; fast = fast . next ; } slow . next = slow . next . next ; return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head","title":"19. Remove Nth Node From End of List"},{"location":"problems/0020/","text":"20. Valid Parentheses Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( const char c : s ) if ( c == '(' || c == '{' || c == '[' ) stack . push ( c ); else { if ( stack . empty ()) return false ; if (( c == ')' && stack . top () == '(' ) || ( c == '}' && stack . top () == '{' ) || ( c == ']' && stack . top () == '[' )) stack . pop (); else return false ; } return stack . empty (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isValid ( String s ) { Stack < Character > stack = new Stack <> (); for ( final char c : s . toCharArray ()) if ( c == '(' ) stack . push ( ')' ); else if ( c == '{' ) stack . push ( '}' ); else if ( c == '[' ) stack . push ( ']' ); else if ( stack . isEmpty () || stack . pop () != c ) return false ; return stack . isEmpty (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"20. Valid Parentheses"},{"location":"problems/0020/#20-valid-parentheses","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( const char c : s ) if ( c == '(' || c == '{' || c == '[' ) stack . push ( c ); else { if ( stack . empty ()) return false ; if (( c == ')' && stack . top () == '(' ) || ( c == '}' && stack . top () == '{' ) || ( c == ']' && stack . top () == '[' )) stack . pop (); else return false ; } return stack . empty (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isValid ( String s ) { Stack < Character > stack = new Stack <> (); for ( final char c : s . toCharArray ()) if ( c == '(' ) stack . push ( ')' ); else if ( c == '{' ) stack . push ( '}' ); else if ( c == '[' ) stack . push ( ']' ); else if ( stack . isEmpty () || stack . pop () != c ) return false ; return stack . isEmpty (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"20. Valid Parentheses"},{"location":"problems/0021/","text":"21. Merge Two Sorted Lists Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode mergeTwoLists ( ListNode l1 , ListNode l2 ) { if ( l1 == null || l2 == null ) return l1 == null ? l2 : l1 ; if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } l1 . next = mergeTwoLists ( l1 . next , l2 ); return l1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1","title":"21. Merge Two Sorted Lists"},{"location":"problems/0021/#21-merge-two-sorted-lists","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode mergeTwoLists ( ListNode l1 , ListNode l2 ) { if ( l1 == null || l2 == null ) return l1 == null ? l2 : l1 ; if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } l1 . next = mergeTwoLists ( l1 . next , l2 ); return l1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1","title":"21. Merge Two Sorted Lists"},{"location":"problems/0022/","text":"22. Generate Parentheses Time: $O(2^{2n})$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; string path ; dfs ( n , n , path , ans ); return ans ; } private : void dfs ( int l , int r , string & path , vector < string >& ans ) { if ( l == 0 && r == 0 ) { ans . push_back ( path ); return ; } if ( l > 0 ) { path . push_back ( '(' ); dfs ( l - 1 , r , path , ans ); path . pop_back (); } if ( l < r ) { path . push_back ( ')' ); dfs ( l , r - 1 , path , ans ); path . pop_back (); } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < String > generateParenthesis ( int n ) { List < String > ans = new ArrayList <> (); dfs ( n , n , new StringBuilder (), ans ); return ans ; } private void dfs ( int l , int r , final StringBuilder path , List < String > ans ) { if ( l == 0 && r == 0 ) { ans . add ( path . toString ()); return ; } if ( l > 0 ) { path . append ( \"(\" ); dfs ( l - 1 , r , path , ans ); path . deleteCharAt ( path . length () - 1 ); } if ( l < r ) { path . append ( \")\" ); dfs ( l , r - 1 , path , ans ); path . deleteCharAt ( path . length () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans )","title":"22. Generate Parentheses"},{"location":"problems/0022/#22-generate-parentheses","text":"Time: $O(2^{2n})$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; string path ; dfs ( n , n , path , ans ); return ans ; } private : void dfs ( int l , int r , string & path , vector < string >& ans ) { if ( l == 0 && r == 0 ) { ans . push_back ( path ); return ; } if ( l > 0 ) { path . push_back ( '(' ); dfs ( l - 1 , r , path , ans ); path . pop_back (); } if ( l < r ) { path . push_back ( ')' ); dfs ( l , r - 1 , path , ans ); path . pop_back (); } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < String > generateParenthesis ( int n ) { List < String > ans = new ArrayList <> (); dfs ( n , n , new StringBuilder (), ans ); return ans ; } private void dfs ( int l , int r , final StringBuilder path , List < String > ans ) { if ( l == 0 && r == 0 ) { ans . add ( path . toString ()); return ; } if ( l > 0 ) { path . append ( \"(\" ); dfs ( l - 1 , r , path , ans ); path . deleteCharAt ( path . length () - 1 ); } if ( l < r ) { path . append ( \")\" ); dfs ( l , r - 1 , path , ans ); path . deleteCharAt ( path . length () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans )","title":"22. Generate Parentheses"},{"location":"problems/0023/","text":"23. Merge k Sorted Lists Time: $O(\\Sigma|list_i|)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; // min-heap }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); for ( ListNode * list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { ListNode * minNode = pq . top (); pq . pop (); if ( minNode -> next ) pq . push ( minNode -> next ); curr -> next = minNode ; curr = curr -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode mergeKLists ( ListNode [] lists ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); // min-heap for ( final ListNode list : lists ) if ( list != null ) pq . offer ( list ); while ( ! pq . isEmpty ()) { ListNode minNode = pq . poll (); if ( minNode . next != null ) pq . offer ( minNode . next ); curr . next = minNode ; curr = curr . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy pq = [] for i , lst in enumerate ( lists ): if lst : heapq . heappush ( pq , ( lst . val , i , lst )) while pq : node = heapq . heappop ( pq ) curr . next = node [ 2 ] curr = curr . next if curr . next : heapq . heappush ( pq , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next","title":"23. Merge k Sorted Lists"},{"location":"problems/0023/#23-merge-k-sorted-lists","text":"Time: $O(\\Sigma|list_i|)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; // min-heap }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); for ( ListNode * list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { ListNode * minNode = pq . top (); pq . pop (); if ( minNode -> next ) pq . push ( minNode -> next ); curr -> next = minNode ; curr = curr -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public ListNode mergeKLists ( ListNode [] lists ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; Queue < ListNode > pq = new PriorityQueue <> (( a , b ) -> a . val - b . val ); // min-heap for ( final ListNode list : lists ) if ( list != null ) pq . offer ( list ); while ( ! pq . isEmpty ()) { ListNode minNode = pq . poll (); if ( minNode . next != null ) pq . offer ( minNode . next ); curr . next = minNode ; curr = curr . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy pq = [] for i , lst in enumerate ( lists ): if lst : heapq . heappush ( pq , ( lst . val , i , lst )) while pq : node = heapq . heappop ( pq ) curr . next = node [ 2 ] curr = curr . next if curr . next : heapq . heappush ( pq , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next","title":"23. Merge k Sorted Lists"},{"location":"problems/0024/","text":"24. Swap Nodes in Pairs Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : ListNode * swapPairs ( ListNode * head ) { const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public ListNode swapPairs ( ListNode head ) { final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode next = curr . next ; curr . next = next . next ; next . next = curr ; prev . next = next ; prev = curr ; curr = curr . next ; } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"24. Swap Nodes in Pairs"},{"location":"problems/0024/#24-swap-nodes-in-pairs","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : ListNode * swapPairs ( ListNode * head ) { const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public ListNode swapPairs ( ListNode head ) { final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode next = curr . next ; curr . next = next . next ; next . next = curr ; prev . next = next ; prev = curr ; curr = curr . next ; } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"24. Swap Nodes in Pairs"},{"location":"problems/0025/","text":"25. Reverse Nodes in k-Group Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) return head ; final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode next = curr . next ; curr . next = next . next ; next . next = prev . next ; prev . next = next ; } prev = curr ; curr = curr . next ; } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"25. Reverse Nodes in k-Group"},{"location":"problems/0025/#25-reverse-nodes-in-k-group","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) return head ; final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode next = curr . next ; curr . next = next . next ; next . next = prev . next ; prev . next = next ; } prev = curr ; curr = curr . next ; } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"25. Reverse Nodes in k-Group"},{"location":"problems/0026/","text":"26. Remove Duplicates from Sorted Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 1 || num > nums [ i - 1 ]) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 1 || num > nums [ i - 1 ] ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1","title":"26. Remove Duplicates from Sorted Array"},{"location":"problems/0026/#26-remove-duplicates-from-sorted-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 1 || num > nums [ i - 1 ]) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 1 || num > nums [ i - 1 ] ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1","title":"26. Remove Duplicates from Sorted Array"},{"location":"problems/0027/","text":"27. Remove Element Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( const int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( final int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i","title":"27. Remove Element"},{"location":"problems/0027/#27-remove-element","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( const int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( final int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i","title":"27. Remove Element"},{"location":"problems/0028/","text":"28. Implement strStr() Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int strStr ( String haystack , String needle ) { final int m = haystack . length (); final int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; ++ i ) if ( haystack . substring ( i , i + n ). equals ( needle )) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1","title":"28. Implement strStr()"},{"location":"problems/0028/#28-implement-strstr","text":"Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int strStr ( String haystack , String needle ) { final int m = haystack . length (); final int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; ++ i ) if ( haystack . substring ( i , i + n ). equals ( needle )) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1","title":"28. Implement strStr()"},{"location":"problems/0029/","text":"29. Divide Two Integers Time: $O(\\log^2 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int divide ( int dividend , int divisor ) { // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1 if ( dividend == INT_MIN && divisor == -1 ) return INT_MAX ; const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1 ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); while ( dvd >= dvs ) { long k = 1 ; while ( k * 2 * dvs <= dvd ) k *= 2 ; dvd -= k * dvs ; ans += k ; } return sign * ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int divide ( long dividend , long divisor ) { // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1 if ( dividend == Integer . MIN_VALUE && divisor == - 1 ) return Integer . MAX_VALUE ; final int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; long ans = 0 ; long dvd = Math . abs ( dividend ); long dvs = Math . abs ( divisor ); while ( dvd >= dvs ) { long k = 1 ; while ( k * 2 * dvs <= dvd ) k *= 2 ; dvd -= k * dvs ; ans += k ; } return sign * ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans","title":"29. Divide Two Integers"},{"location":"problems/0029/#29-divide-two-integers","text":"Time: $O(\\log^2 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int divide ( int dividend , int divisor ) { // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1 if ( dividend == INT_MIN && divisor == -1 ) return INT_MAX ; const int sign = dividend > 0 ^ divisor > 0 ? -1 : 1 ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); while ( dvd >= dvs ) { long k = 1 ; while ( k * 2 * dvs <= dvd ) k *= 2 ; dvd -= k * dvs ; ans += k ; } return sign * ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int divide ( long dividend , long divisor ) { // -2^{31} / -1 = 2^31 -> overflow so return 2^31 - 1 if ( dividend == Integer . MIN_VALUE && divisor == - 1 ) return Integer . MAX_VALUE ; final int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; long ans = 0 ; long dvd = Math . abs ( dividend ); long dvs = Math . abs ( divisor ); while ( dvd >= dvs ) { long k = 1 ; while ( k * 2 * dvs <= dvd ) k *= 2 ; dvd -= k * dvs ; ans += k ; } return sign * ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans","title":"29. Divide Two Integers"},{"location":"problems/0030/","text":"30. Substring with Concatenation of All Words Time: $O(|s||words||words_0|)$ Space: $O(\\Sigma|words_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int k = words . size (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( int i = 0 ; i < s . length () - k * n + 1 ; ++ i ) { unordered_map < string , int > seen ; int j ; for ( j = 0 ; j < k ; ++ j ) { const string & word = s . substr ( i + j * n , n ); if ( ++ seen [ word ] > count [ word ]) break ; } if ( j == k ) ans . push_back ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List < Integer > findSubstring ( String s , String [] words ) { if ( s . isEmpty () || words . length == 0 ) return new ArrayList <> (); final int k = words . length ; final int n = words [ 0 ] . length (); List < Integer > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( int i = 0 ; i <= s . length () - k * n ; ++ i ) { Map < String , Integer > seen = new HashMap <> (); int j = 0 ; for (; j < k ; ++ j ) { final String word = s . substring ( i + j * n , i + j * n + n ); seen . put ( word , seen . getOrDefault ( word , 0 ) + 1 ); if ( seen . get ( word ) > count . getOrDefault ( word , 0 )) break ; } if ( j == k ) ans . add ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if len ( s ) == 0 or words == []: return [] n = len ( words [ 0 ]) ans = [] count = collections . Counter ( words ) for i in range ( len ( s ) - len ( words ) * n + 1 ): seen = collections . defaultdict ( int ) j = 0 while j < len ( words ): word = s [ i + j * n : i + j * n + n ] seen [ word ] += 1 if seen [ word ] > count [ word ]: break j += 1 if j == len ( words ): ans . append ( i ) return ans","title":"30. Substring with Concatenation of All Words"},{"location":"problems/0030/#30-substring-with-concatenation-of-all-words","text":"Time: $O(|s||words||words_0|)$ Space: $O(\\Sigma|words_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int k = words . size (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( int i = 0 ; i < s . length () - k * n + 1 ; ++ i ) { unordered_map < string , int > seen ; int j ; for ( j = 0 ; j < k ; ++ j ) { const string & word = s . substr ( i + j * n , n ); if ( ++ seen [ word ] > count [ word ]) break ; } if ( j == k ) ans . push_back ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List < Integer > findSubstring ( String s , String [] words ) { if ( s . isEmpty () || words . length == 0 ) return new ArrayList <> (); final int k = words . length ; final int n = words [ 0 ] . length (); List < Integer > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( int i = 0 ; i <= s . length () - k * n ; ++ i ) { Map < String , Integer > seen = new HashMap <> (); int j = 0 ; for (; j < k ; ++ j ) { final String word = s . substring ( i + j * n , i + j * n + n ); seen . put ( word , seen . getOrDefault ( word , 0 ) + 1 ); if ( seen . get ( word ) > count . getOrDefault ( word , 0 )) break ; } if ( j == k ) ans . add ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if len ( s ) == 0 or words == []: return [] n = len ( words [ 0 ]) ans = [] count = collections . Counter ( words ) for i in range ( len ( s ) - len ( words ) * n + 1 ): seen = collections . defaultdict ( int ) j = 0 while j < len ( words ): word = s [ i + j * n : i + j * n + n ] seen [ word ] += 1 if seen [ word ] > count [ word ]: break j += 1 if j == len ( words ): ans . append ( i ) return ans","title":"30. Substring with Concatenation of All Words"},{"location":"problems/0031/","text":"31. Next Permutation Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { const int n = nums . size (); // from back to front, find the first num < nums[i + 1] int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; // from back to front, find the first num > nums[i], swap it with nums[i] if ( i >= 0 ) { int j ; for ( j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } // reverse nums[i + 1..n - 1] reverse ( nums , i + 1 , n - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public void nextPermutation ( int [] nums ) { final int n = nums . length ; // from back to front, find the first num < nums[i + 1] int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; // from back to front, find the first num > nums[i], swap it with nums[i] if ( i >= 0 ) { int j ; for ( j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) break ; swap ( nums , i , j ); } // reverse nums[i + 1..n - 1] reverse ( nums , i + 1 , n - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : def reverse ( nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , i , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] reverse ( nums , i + 1 , len ( nums ) - 1 )","title":"31. Next Permutation"},{"location":"problems/0031/#31-next-permutation","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void nextPermutation ( vector < int >& nums ) { const int n = nums . size (); // from back to front, find the first num < nums[i + 1] int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; // from back to front, find the first num > nums[i], swap it with nums[i] if ( i >= 0 ) { int j ; for ( j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } // reverse nums[i + 1..n - 1] reverse ( nums , i + 1 , n - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public void nextPermutation ( int [] nums ) { final int n = nums . length ; // from back to front, find the first num < nums[i + 1] int i ; for ( i = n - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; // from back to front, find the first num > nums[i], swap it with nums[i] if ( i >= 0 ) { int j ; for ( j = n - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) break ; swap ( nums , i , j ); } // reverse nums[i + 1..n - 1] reverse ( nums , i + 1 , n - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : def reverse ( nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , i , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] reverse ( nums , i + 1 , len ( nums ) - 1 )","title":"31. Next Permutation"},{"location":"problems/0032/","text":"32. Longest Valid Parentheses Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int longestValidParentheses ( string s ) { const string s2 = \")\" + s ; // dp[i] := the length of longest valid parentheses substring of s2[1..i] vector < int > dp ( s2 . length ()); for ( int i = 1 ; i < s2 . length (); ++ i ) if ( s2 [ i ] == ')' && s2 [ i - dp [ i - 1 ] - 1 ] == '(' ) dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int longestValidParentheses ( String s ) { final String s2 = \")\" + s ; // dp[i] := the length of longest valid parentheses substring of s2[1..i] int dp [] = new int [ s2 . length () ] ; for ( int i = 1 ; i < s2 . length (); ++ i ) if ( s2 . charAt ( i ) == ')' && s2 . charAt ( i - dp [ i - 1 ] - 1 ) == '(' ) dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; return Arrays . stream ( dp ). max (). getAsInt (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans","title":"32. Longest Valid Parentheses"},{"location":"problems/0032/#32-longest-valid-parentheses","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int longestValidParentheses ( string s ) { const string s2 = \")\" + s ; // dp[i] := the length of longest valid parentheses substring of s2[1..i] vector < int > dp ( s2 . length ()); for ( int i = 1 ; i < s2 . length (); ++ i ) if ( s2 [ i ] == ')' && s2 [ i - dp [ i - 1 ] - 1 ] == '(' ) dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int longestValidParentheses ( String s ) { final String s2 = \")\" + s ; // dp[i] := the length of longest valid parentheses substring of s2[1..i] int dp [] = new int [ s2 . length () ] ; for ( int i = 1 ; i < s2 . length (); ++ i ) if ( s2 . charAt ( i ) == ')' && s2 . charAt ( i - dp [ i - 1 ] - 1 ) == '(' ) dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; return Arrays . stream ( dp ). max (). getAsInt (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans","title":"32. Longest Valid Parentheses"},{"location":"problems/0033/","text":"33. Search in Rotated Sorted Array Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ] ) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1","title":"33. Search in Rotated Sorted Array"},{"location":"problems/0033/#33-search-in-rotated-sorted-array","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ] ) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1","title":"33. Search in Rotated Sorted Array"},{"location":"problems/0034/","text":"34. Find First and Last Position of Element in Sorted Array Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { const int start = firstGreaterEqual ( nums , target ); if ( start == nums . size () || nums [ start ] != target ) return { -1 , -1 }; const int end = firstGreaterEqual ( nums , target + 1 ) - 1 ; return { start , end }; } private : // find the first index l s.t nums[l] >= target int firstGreaterEqual ( const vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int [] searchRange ( int [] nums , int target ) { final int start = firstGreaterEqual ( nums , target ); if ( start == nums . length || nums [ start ] != target ) return new int [] { - 1 , - 1 }; final int end = firstGreaterEqual ( nums , target + 1 ) - 1 ; return new int [] { start , end }; } // find the first index l s.t nums[l] >= target private int firstGreaterEqual ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l","title":"34. Find First and Last Position of Element in Sorted Array"},{"location":"problems/0034/#34-find-first-and-last-position-of-element-in-sorted-array","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { const int start = firstGreaterEqual ( nums , target ); if ( start == nums . size () || nums [ start ] != target ) return { -1 , -1 }; const int end = firstGreaterEqual ( nums , target + 1 ) - 1 ; return { start , end }; } private : // find the first index l s.t nums[l] >= target int firstGreaterEqual ( const vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int [] searchRange ( int [] nums , int target ) { final int start = firstGreaterEqual ( nums , target ); if ( start == nums . length || nums [ start ] != target ) return new int [] { - 1 , - 1 }; final int end = firstGreaterEqual ( nums , target + 1 ) - 1 ; return new int [] { start , end }; } // find the first index l s.t nums[l] >= target private int firstGreaterEqual ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l","title":"34. Find First and Last Position of Element in Sorted Array"},{"location":"problems/0035/","text":"35. Search Insert Position Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l","title":"35. Search Insert Position"},{"location":"problems/0035/#35-search-insert-position","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l","title":"35. Search Insert Position"},{"location":"problems/0036/","text":"36. Valid Sudoku Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < string > seen ; for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; const string c ( 1 , board [ i ][ j ]); if ( ! seen . insert ( c + \"@row\" + to_string ( i )). second || ! seen . insert ( c + \"@col\" + to_string ( j )). second || ! seen . insert ( c + \"@box\" + to_string ( i / 3 ) + to_string ( j / 3 )). second ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isValidSudoku ( char [][] board ) { Set < String > seen = new HashSet <> (); for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; final char c = board [ i ][ j ] ; if ( ! seen . add ( c + \"@row\" + i ) || ! seen . add ( c + \"@col\" + j ) || ! seen . add ( c + \"@box\" + i / 3 + j / 3 )) return false ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : seen = set () for i in range ( 9 ): for j in range ( 9 ): c = board [ i ][ j ] if c == '.' : continue if c + ' in row ' + str ( i ) in seen or \\ c + ' in col ' + str ( j ) in seen or \\ c + ' in box ' + str ( i // 3 ) + str ( j // 3 ) in seen : return False seen . add ( c + ' in row ' + str ( i )) seen . add ( c + ' in col ' + str ( j )) seen . add ( c + ' in box ' + str ( i // 3 ) + str ( j // 3 )) return True","title":"36. Valid Sudoku"},{"location":"problems/0036/#36-valid-sudoku","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < string > seen ; for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; const string c ( 1 , board [ i ][ j ]); if ( ! seen . insert ( c + \"@row\" + to_string ( i )). second || ! seen . insert ( c + \"@col\" + to_string ( j )). second || ! seen . insert ( c + \"@box\" + to_string ( i / 3 ) + to_string ( j / 3 )). second ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isValidSudoku ( char [][] board ) { Set < String > seen = new HashSet <> (); for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; final char c = board [ i ][ j ] ; if ( ! seen . add ( c + \"@row\" + i ) || ! seen . add ( c + \"@col\" + j ) || ! seen . add ( c + \"@box\" + i / 3 + j / 3 )) return false ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : seen = set () for i in range ( 9 ): for j in range ( 9 ): c = board [ i ][ j ] if c == '.' : continue if c + ' in row ' + str ( i ) in seen or \\ c + ' in col ' + str ( j ) in seen or \\ c + ' in box ' + str ( i // 3 ) + str ( j // 3 ) in seen : return False seen . add ( c + ' in row ' + str ( i )) seen . add ( c + ' in col ' + str ( j )) seen . add ( c + ' in box ' + str ( i // 3 ) + str ( j // 3 )) return True","title":"36. Valid Sudoku"},{"location":"problems/0037/","text":"37. Sudoku Solver Time: NP-Complete Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { function < bool ( int ) > dfs = [ & ]( int s ) { if ( s == 81 ) return true ; const int i = s / 9 ; const int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; }; dfs ( 0 ); } private : bool isValid ( vector < vector < char >>& board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public void solveSudoku ( char [][] board ) { dfs ( board , 0 ); } private boolean dfs ( char [][] board , int s ) { if ( s == 81 ) return true ; final int i = s / 9 ; final int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( board , s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( board , s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; } private boolean isValid ( char [][] board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : def isValid ( row : int , col : int , c : str ) -> bool : for i in range ( 9 ): if board [ i ][ col ] == c or \\ board [ row ][ i ] == c or \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True def dfs ( s : int ) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return dfs ( s + 1 ) for c in range ( 1 , 10 ): if isValid ( i , j , str ( c )): board [ i ][ j ] = str ( c ) if dfs ( s + 1 ): return True board [ i ][ j ] = '.' return False dfs ( 0 )","title":"37. Sudoku Solver"},{"location":"problems/0037/#37-sudoku-solver","text":"Time: NP-Complete Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { function < bool ( int ) > dfs = [ & ]( int s ) { if ( s == 81 ) return true ; const int i = s / 9 ; const int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; }; dfs ( 0 ); } private : bool isValid ( vector < vector < char >>& board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public void solveSudoku ( char [][] board ) { dfs ( board , 0 ); } private boolean dfs ( char [][] board , int s ) { if ( s == 81 ) return true ; final int i = s / 9 ; final int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( board , s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( board , s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; } private boolean isValid ( char [][] board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : def isValid ( row : int , col : int , c : str ) -> bool : for i in range ( 9 ): if board [ i ][ col ] == c or \\ board [ row ][ i ] == c or \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True def dfs ( s : int ) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return dfs ( s + 1 ) for c in range ( 1 , 10 ): if isValid ( i , j , str ( c )): board [ i ][ j ] = str ( c ) if dfs ( s + 1 ): return True board [ i ][ j ] = '.' return False dfs ( 0 )","title":"37. Sudoku Solver"},{"location":"problems/0038/","text":"38. Count and Say Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string countAndSay ( int n ) { string ans = \"1\" ; while ( -- n ) { string next ; for ( int i = 0 ; i < ans . length (); ++ i ) { int count = 1 ; while ( i + 1 < ans . length () && ans [ i ] == ans [ i + 1 ]) { ++ count ; ++ i ; } next += to_string ( count ) + ans [ i ]; } ans = move ( next ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public String countAndSay ( int n ) { StringBuilder ans = new StringBuilder ( \"1\" ); while ( -- n > 0 ) { StringBuilder next = new StringBuilder (); for ( int i = 0 ; i < ans . length (); ++ i ) { int count = 1 ; while ( i + 1 < ans . length () && ans . charAt ( i ) == ans . charAt ( i + 1 )) { ++ count ; ++ i ; } next . append ( count ). append ( ans . charAt ( i )); } ans = next ; } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ]","title":"38. Count and Say"},{"location":"problems/0038/#38-count-and-say","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string countAndSay ( int n ) { string ans = \"1\" ; while ( -- n ) { string next ; for ( int i = 0 ; i < ans . length (); ++ i ) { int count = 1 ; while ( i + 1 < ans . length () && ans [ i ] == ans [ i + 1 ]) { ++ count ; ++ i ; } next += to_string ( count ) + ans [ i ]; } ans = move ( next ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public String countAndSay ( int n ) { StringBuilder ans = new StringBuilder ( \"1\" ); while ( -- n > 0 ) { StringBuilder next = new StringBuilder (); for ( int i = 0 ; i < ans . length (); ++ i ) { int count = 1 ; while ( i + 1 < ans . length () && ans . charAt ( i ) == ans . charAt ( i + 1 )) { ++ count ; ++ i ; } next . append ( count ). append ( ans . charAt ( i )); } ans = next ; } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ]","title":"38. Count and Say"},{"location":"problems/0039/","text":"39. Combination Sum Time: $O(|candidates|^{target})$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"39. Combination Sum"},{"location":"problems/0039/#39-combination-sum","text":"Time: $O(|candidates|^{target})$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"39. Combination Sum"},{"location":"problems/0040/","text":"40. Combination Sum II Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i + 1 ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ] ) continue ; path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"40. Combination Sum II"},{"location":"problems/0040/#40-combination-sum-ii","text":"Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i + 1 ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ] ) continue ; path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"40. Combination Sum II"},{"location":"problems/0041/","text":"41. First Missing Positive Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { const int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int firstMissingPositive ( int [] nums ) { final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ] ) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1","title":"41. First Missing Positive"},{"location":"problems/0041/#41-first-missing-positive","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { const int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int firstMissingPositive ( int [] nums ) { final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ] ) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1","title":"41. First Missing Positive"},{"location":"problems/0042/","text":"42. Trapping Rain Water Approach 1: $O(n)$ space Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int trap ( vector < int >& height ) { const int n = height . size (); int ans = 0 ; vector < int > l ( n ); // l[i] := max in height[0..i] vector < int > r ( n ); // r[i] := max in height[i..n - 1] for ( int i = 0 ; i < n ; ++ i ) l [ i ] = i == 0 ? height [ i ] : max ( height [ i ], l [ i - 1 ]); for ( int i = n - 1 ; i >= 0 ; -- i ) r [ i ] = i == n - 1 ? height [ i ] : max ( height [ i ], r [ i + 1 ]); for ( int i = 0 ; i < n ; ++ i ) ans += min ( l [ i ], r [ i ]) - height [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int trap ( int [] height ) { final int n = height . length ; int ans = 0 ; int [] l = new int [ n ] ; // l[i] := max in height[0..i] int [] r = new int [ n ] ; // r[i] := max in height[i..n - 1] for ( int i = 0 ; i < n ; ++ i ) l [ i ] = i == 0 ? height [ i ] : Math . max ( height [ i ] , l [ i - 1 ] ); for ( int i = n - 1 ; i >= 0 ; -- i ) r [ i ] = i == n - 1 ? height [ i ] : Math . max ( height [ i ] , r [ i + 1 ] ); for ( int i = 0 ; i < n ; ++ i ) ans += Math . min ( l [ i ] , r [ i ] ) - height [ i ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans Approach 2: $O(1)$ space Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int trap ( vector < int >& height ) { if ( height . empty ()) return 0 ; int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxL = height [ l ]; int maxR = height [ r ]; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ]; maxL = max ( maxL , height [ ++ l ]); } else { ans += maxR - height [ r ]; maxR = max ( maxR , height [ -- r ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int trap ( int [] height ) { if ( height . length == 0 ) return 0 ; int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxL = height [ l ] ; int maxR = height [ r ] ; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ] ; maxL = Math . max ( maxL , height [++ l ] ); } else { ans += maxR - height [ r ] ; maxR = Math . max ( maxR , height [-- r ] ); } return ans ; } }","title":"42. Trapping Rain Water"},{"location":"problems/0042/#42-trapping-rain-water","text":"","title":"42. Trapping Rain Water"},{"location":"problems/0042/#approach-1-on-space","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int trap ( vector < int >& height ) { const int n = height . size (); int ans = 0 ; vector < int > l ( n ); // l[i] := max in height[0..i] vector < int > r ( n ); // r[i] := max in height[i..n - 1] for ( int i = 0 ; i < n ; ++ i ) l [ i ] = i == 0 ? height [ i ] : max ( height [ i ], l [ i - 1 ]); for ( int i = n - 1 ; i >= 0 ; -- i ) r [ i ] = i == n - 1 ? height [ i ] : max ( height [ i ], r [ i + 1 ]); for ( int i = 0 ; i < n ; ++ i ) ans += min ( l [ i ], r [ i ]) - height [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int trap ( int [] height ) { final int n = height . length ; int ans = 0 ; int [] l = new int [ n ] ; // l[i] := max in height[0..i] int [] r = new int [ n ] ; // r[i] := max in height[i..n - 1] for ( int i = 0 ; i < n ; ++ i ) l [ i ] = i == 0 ? height [ i ] : Math . max ( height [ i ] , l [ i - 1 ] ); for ( int i = n - 1 ; i >= 0 ; -- i ) r [ i ] = i == n - 1 ? height [ i ] : Math . max ( height [ i ] , r [ i + 1 ] ); for ( int i = 0 ; i < n ; ++ i ) ans += Math . min ( l [ i ] , r [ i ] ) - height [ i ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans","title":"Approach 1: $O(n)$ space"},{"location":"problems/0042/#approach-2-o1-space","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int trap ( vector < int >& height ) { if ( height . empty ()) return 0 ; int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxL = height [ l ]; int maxR = height [ r ]; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ]; maxL = max ( maxL , height [ ++ l ]); } else { ans += maxR - height [ r ]; maxR = max ( maxR , height [ -- r ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int trap ( int [] height ) { if ( height . length == 0 ) return 0 ; int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxL = height [ l ] ; int maxR = height [ r ] ; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ] ; maxL = Math . max ( maxL , height [++ l ] ); } else { ans += maxR - height [ r ] ; maxR = Math . max ( maxR , height [-- r ] ); } return ans ; } }","title":"Approach 2: $O(1)$ space"},{"location":"problems/0043/","text":"43. Multiply Strings Time: $O(|num1||num2|)$ Space: $O(|num1| + |num2|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string multiply ( string num1 , string num2 ) { string ans ; vector < int > pos ( num1 . length () + num2 . length ()); for ( int i = num1 . length () - 1 ; i >= 0 ; -- i ) for ( int j = num2 . length () - 1 ; j >= 0 ; -- j ) { const int multiply = ( num1 [ i ] - '0' ) * ( num2 [ j ] - '0' ); const int sum = multiply + pos [ i + j + 1 ]; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( const int p : pos ) if ( p > 0 || ! ans . empty ()) ans += to_string ( p ); return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String multiply ( String num1 , String num2 ) { final int m = num1 . length (); final int n = num2 . length (); StringBuilder ans = new StringBuilder (); int [] pos = new int [ m + n ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { final int multiply = ( num1 . charAt ( i ) - '0' ) * ( num2 . charAt ( j ) - '0' ); final int sum = multiply + pos [ i + j + 1 ] ; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( final int p : pos ) if ( p > 0 || ans . length () > 0 ) ans . append ( p ); return ans . length () == 0 ? \"0\" : ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : m = len ( num1 ) n = len ( num2 ) ans = '' pos = [ 0 ] * ( m + n ) for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: multiply = ( ord ( num1 [ i ]) - ord ( '0' )) * \\ ( ord ( num2 [ j ]) - ord ( '0' )) sum = multiply + pos [ i + j + 1 ] pos [ i + j ] += sum // 10 pos [ i + j + 1 ] = ( sum ) % 10 for p in pos : if not ( not ans and p == 0 ): ans += str ( p ) return '0' if not ans else ans","title":"43. Multiply Strings"},{"location":"problems/0043/#43-multiply-strings","text":"Time: $O(|num1||num2|)$ Space: $O(|num1| + |num2|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string multiply ( string num1 , string num2 ) { string ans ; vector < int > pos ( num1 . length () + num2 . length ()); for ( int i = num1 . length () - 1 ; i >= 0 ; -- i ) for ( int j = num2 . length () - 1 ; j >= 0 ; -- j ) { const int multiply = ( num1 [ i ] - '0' ) * ( num2 [ j ] - '0' ); const int sum = multiply + pos [ i + j + 1 ]; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( const int p : pos ) if ( p > 0 || ! ans . empty ()) ans += to_string ( p ); return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String multiply ( String num1 , String num2 ) { final int m = num1 . length (); final int n = num2 . length (); StringBuilder ans = new StringBuilder (); int [] pos = new int [ m + n ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { final int multiply = ( num1 . charAt ( i ) - '0' ) * ( num2 . charAt ( j ) - '0' ); final int sum = multiply + pos [ i + j + 1 ] ; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( final int p : pos ) if ( p > 0 || ans . length () > 0 ) ans . append ( p ); return ans . length () == 0 ? \"0\" : ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : m = len ( num1 ) n = len ( num2 ) ans = '' pos = [ 0 ] * ( m + n ) for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: multiply = ( ord ( num1 [ i ]) - ord ( '0' )) * \\ ( ord ( num2 [ j ]) - ord ( '0' )) sum = multiply + pos [ i + j + 1 ] pos [ i + j ] += sum // 10 pos [ i + j + 1 ] = ( sum ) % 10 for p in pos : if not ( not ans and p == 0 ): ans += str ( p ) return '0' if not ans else ans","title":"43. Multiply Strings"},{"location":"problems/0044/","text":"44. Wildcard Matching Time: $O(|s||p|)$ Space: $O(|s||p|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; auto isMatch = []( char c1 , char c2 ) { return c1 == c2 || c2 == '?' ; }; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p [ j - 1 ] == '*' ) { const bool matchEmpty = dp [ i ][ j - 1 ]; const bool matchNew = i && dp [ i - 1 ][ j ]; dp [ i ][ j ] = matchEmpty || matchNew ; } else { dp [ i ][ j ] = i && isMatch ( s [ i - 1 ], p [ j - 1 ]) && dp [ i - 1 ][ j - 1 ]; } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length (); final int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p . charAt ( j - 1 ) == '*' ) { final boolean matchEmpty = dp [ i ][ j - 1 ] ; final boolean matchNew = i > 0 && dp [ i - 1 ][ j ] ; dp [ i ][ j ] = matchEmpty || matchNew ; } else { dp [ i ][ j ] = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 1 )) && dp [ i - 1 ][ j - 1 ] ; } return dp [ m ][ n ] ; } private boolean isMatch ( char c1 , char c2 ) { return c1 == c2 || c2 == '?' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ]","title":"44. Wildcard Matching"},{"location":"problems/0044/#44-wildcard-matching","text":"Time: $O(|s||p|)$ Space: $O(|s||p|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; auto isMatch = []( char c1 , char c2 ) { return c1 == c2 || c2 == '?' ; }; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p [ j - 1 ] == '*' ) { const bool matchEmpty = dp [ i ][ j - 1 ]; const bool matchNew = i && dp [ i - 1 ][ j ]; dp [ i ][ j ] = matchEmpty || matchNew ; } else { dp [ i ][ j ] = i && isMatch ( s [ i - 1 ], p [ j - 1 ]) && dp [ i - 1 ][ j - 1 ]; } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isMatch ( String s , String p ) { final int m = s . length (); final int n = p . length (); // dp[i][j] := true if s[0..i) matches p[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( p . charAt ( j - 1 ) == '*' ) { final boolean matchEmpty = dp [ i ][ j - 1 ] ; final boolean matchNew = i > 0 && dp [ i - 1 ][ j ] ; dp [ i ][ j ] = matchEmpty || matchNew ; } else { dp [ i ][ j ] = i > 0 && isMatch ( s . charAt ( i - 1 ), p . charAt ( j - 1 )) && dp [ i - 1 ][ j - 1 ] ; } return dp [ m ][ n ] ; } private boolean isMatch ( char c1 , char c2 ) { return c1 == c2 || c2 == '?' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ]","title":"44. Wildcard Matching"},{"location":"problems/0045/","text":"45. Jump Game II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans","title":"45. Jump Game II"},{"location":"problems/0045/#45-jump-game-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans","title":"45. Jump Game II"},{"location":"problems/0046/","text":"46. Permutations Time: $O(n!)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size ()); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); used [ i ] = false ; path . pop_back (); } }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> permute ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , new boolean [ nums . length ] , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True dfs ( path + [ nums [ i ]]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) dfs ([]) return ans","title":"46. Permutations"},{"location":"problems/0046/#46-permutations","text":"Time: $O(n!)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size ()); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); used [ i ] = false ; path . pop_back (); } }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> permute ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , new boolean [ nums . length ] , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True dfs ( path + [ nums [ i ]]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) dfs ([]) return ans","title":"46. Permutations"},{"location":"problems/0047/","text":"47. Permutations II Time: $O(n!)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; sort ( begin ( nums ), end ( nums )); dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < List < Integer >> permuteUnique ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , new boolean [ nums . length ] , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i , num in enumerate ( nums ): if used [ i ]: continue if i > 0 and nums [ i ] == nums [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ num ]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) nums . sort () dfs ([]) return ans","title":"47. Permutations II"},{"location":"problems/0047/#47-permutations-ii","text":"Time: $O(n!)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; sort ( begin ( nums ), end ( nums )); dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < List < Integer >> permuteUnique ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , new boolean [ nums . length ] , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i , num in enumerate ( nums ): if used [ i ]: continue if i > 0 and nums [ i ] == nums [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ num ]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) nums . sort () dfs ([]) return ans","title":"47. Permutations II"},{"location":"problems/0048/","text":"48. Rotate Image Approach 1: Reverse Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { reverse ( begin ( matrix ), end ( matrix )); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = i + 1 ; j < matrix . size (); ++ j ) swap ( matrix [ i ][ j ], matrix [ j ][ i ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void rotate ( int [][] matrix ) { for ( int i = 0 , j = matrix . length - 1 ; i < j ; ++ i , -- j ) { final int [] temp = matrix [ i ] ; matrix [ i ] = matrix [ j ] ; matrix [ j ] = temp ; } for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = i + 1 ; j < matrix . length ; ++ j ) { final int temp = matrix [ i ][ j ] ; matrix [ i ][ j ] = matrix [ j ][ i ] ; matrix [ j ][ i ] = temp ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top Approach 2: Indexing Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { const int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { const int offset = i - min ; const int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; ++ min ) { final int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; ++ i ) { final int offset = i - min ; final int top = matrix [ min ][ i ] ; matrix [ min ][ i ] = matrix [ max - offset ][ min ] ; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] ; matrix [ max ][ max - offset ] = matrix [ i ][ max ] ; matrix [ i ][ max ] = top ; } } } }","title":"48. Rotate Image"},{"location":"problems/0048/#48-rotate-image","text":"","title":"48. Rotate Image"},{"location":"problems/0048/#approach-1-reverse","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { reverse ( begin ( matrix ), end ( matrix )); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = i + 1 ; j < matrix . size (); ++ j ) swap ( matrix [ i ][ j ], matrix [ j ][ i ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void rotate ( int [][] matrix ) { for ( int i = 0 , j = matrix . length - 1 ; i < j ; ++ i , -- j ) { final int [] temp = matrix [ i ] ; matrix [ i ] = matrix [ j ] ; matrix [ j ] = temp ; } for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = i + 1 ; j < matrix . length ; ++ j ) { final int temp = matrix [ i ][ j ] ; matrix [ i ][ j ] = matrix [ j ][ i ] ; matrix [ j ][ i ] = temp ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top","title":"Approach 1: Reverse"},{"location":"problems/0048/#approach-2-indexing","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { const int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { const int offset = i - min ; const int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; ++ min ) { final int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; ++ i ) { final int offset = i - min ; final int top = matrix [ min ][ i ] ; matrix [ min ][ i ] = matrix [ max - offset ][ min ] ; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] ; matrix [ max ][ max - offset ] = matrix [ i ][ max ] ; matrix [ i ][ max ] = top ; } } } }","title":"Approach 2: Indexing"},{"location":"problems/0049/","text":"49. Group Anagrams Time: $O(nk\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> keyToAnagrams ; for ( const string & str : strs ) { string key = str ; sort ( begin ( key ), end ( key )); keyToAnagrams [ key ]. push_back ( str ); } for ( const auto & [ _ , anagrams ] : keyToAnagrams ) ans . push_back ( anagrams ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> keyToAnagrams = new HashMap <> (); for ( final String str : strs ) { char [] chars = str . toCharArray (); Arrays . sort ( chars ); String key = String . valueOf ( chars ); keyToAnagrams . computeIfAbsent ( key , k -> new ArrayList <> ()). add ( str ); } return new ArrayList <> ( keyToAnagrams . values ()); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) return dict . values ()","title":"49. Group Anagrams"},{"location":"problems/0049/#49-group-anagrams","text":"Time: $O(nk\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> keyToAnagrams ; for ( const string & str : strs ) { string key = str ; sort ( begin ( key ), end ( key )); keyToAnagrams [ key ]. push_back ( str ); } for ( const auto & [ _ , anagrams ] : keyToAnagrams ) ans . push_back ( anagrams ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { Map < String , List < String >> keyToAnagrams = new HashMap <> (); for ( final String str : strs ) { char [] chars = str . toCharArray (); Arrays . sort ( chars ); String key = String . valueOf ( chars ); keyToAnagrams . computeIfAbsent ( key , k -> new ArrayList <> ()). add ( str ); } return new ArrayList <> ( keyToAnagrams . values ()); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) return dict . values ()","title":"49. Group Anagrams"},{"location":"problems/0050/","text":"50. Pow(x, n) Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n & 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"50. Pow(x, n)"},{"location":"problems/0050/#50-powx-n","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n & 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"50. Pow(x, n)"},{"location":"problems/0051/","text":"51. N-Queens Time: $O(n \\cdot n!)$ Space: $|\\text{ans}|$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ans . push_back ( board ); return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public List < List < String >> solveNQueens ( int n ) { List < List < String >> ans = new ArrayList <> (); char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) Arrays . fill ( board [ i ] , '.' ); dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] , board , ans ); return ans ; } private void dfs ( int n , int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 , char [][] board , List < List < String >> ans ) { if ( i == n ) { ans . add ( construct ( board )); return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 , board , ans ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } } private List < String > construct ( char [][] board ) { List < String > listBoard = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) listBoard . add ( String . valueOf ( board [ i ] )); return listBoard ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: def dfs ( i : int , board : List [ str ]) -> None : if i == n : ans . append ( board ) return for j in range ( n ): if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ]: continue cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True dfs ( i + 1 , board + [ '.' * j + 'Q' + '.' * ( n - j - 1 )]) cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False ans = [] cols = [ False ] * n diag1 = [ False ] * ( 2 * n - 1 ) diag2 = [ False ] * ( 2 * n - 1 ) dfs ( 0 , []) return ans","title":"51. N-Queens"},{"location":"problems/0051/#51-n-queens","text":"Time: $O(n \\cdot n!)$ Space: $|\\text{ans}|$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ans . push_back ( board ); return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public List < List < String >> solveNQueens ( int n ) { List < List < String >> ans = new ArrayList <> (); char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) Arrays . fill ( board [ i ] , '.' ); dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] , board , ans ); return ans ; } private void dfs ( int n , int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 , char [][] board , List < List < String >> ans ) { if ( i == n ) { ans . add ( construct ( board )); return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 , board , ans ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } } private List < String > construct ( char [][] board ) { List < String > listBoard = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) listBoard . add ( String . valueOf ( board [ i ] )); return listBoard ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: def dfs ( i : int , board : List [ str ]) -> None : if i == n : ans . append ( board ) return for j in range ( n ): if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ]: continue cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True dfs ( i + 1 , board + [ '.' * j + 'Q' + '.' * ( n - j - 1 )]) cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False ans = [] cols = [ False ] * n diag1 = [ False ] * ( 2 * n - 1 ) diag2 = [ False ] * ( 2 * n - 1 ) dfs ( 0 , []) return ans","title":"51. N-Queens"},{"location":"problems/0052/","text":"52. N-Queens II Time: $O(n \\cdot n!)$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int totalNQueens ( int n ) { dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] ); return ans ; } private int ans = 0 ; private void dfs ( int n , int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False","title":"52. N-Queens II"},{"location":"problems/0052/#52-n-queens-ii","text":"Time: $O(n \\cdot n!)$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int totalNQueens ( int n ) { dfs ( n , 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] ); return ans ; } private int ans = 0 ; private void dfs ( int n , int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ] ) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( n , i + 1 , cols , diag1 , diag2 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False","title":"52. N-Queens II"},{"location":"problems/0053/","text":"53. Maximum Subarray Approach 1: Gready Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( const int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( final int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans Approach 2: Divide and Conquer Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct T { int left ; // sum of the subarray w/ max sum (starting from the first num) int right ; // sum of the subarray w/ max sum (ending at the the last num) int mid ; // sum of the subarray w/ max sum int sum ; // sum of the whole array }; class Solution { public : int maxSubArray ( vector < int >& nums ) { const T t = divideAndConquer ( nums , 0 , nums . size () - 1 ); return t . mid ; } private : T divideAndConquer ( const vector < int >& nums , int l , int r ) { if ( l == r ) return { nums [ l ], nums [ l ], nums [ l ], nums [ l ]}; const int m = l + ( r - l ) / 2 ; const T t1 = divideAndConquer ( nums , l , m ); const T t2 = divideAndConquer ( nums , m + 1 , r ); const int left = max ( t1 . left , t1 . sum + t2 . left ); const int right = max ( t1 . right + t2 . sum , t2 . right ); const int mid = max ({ t1 . right + t2 . left , t1 . mid , t2 . mid }); const int sum = t1 . sum + t2 . sum ; return { left , right , mid , sum }; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int maxSubArray ( int [] nums ) { final T t = divideAndConquer ( nums , 0 , nums . length - 1 ); return t . mid ; } private T divideAndConquer ( final int [] nums , int l , int r ) { if ( l == r ) return new T ( nums [ l ] , nums [ l ] , nums [ l ] , nums [ l ] ); final int m = l + ( r - l ) / 2 ; final T t1 = divideAndConquer ( nums , l , m ); final T t2 = divideAndConquer ( nums , m + 1 , r ); final int left = Math . max ( t1 . left , t1 . sum + t2 . left ); final int right = Math . max ( t1 . right + t2 . sum , t2 . right ); final int mid = Math . max ( t1 . right + t2 . left , Math . max ( t1 . mid , t2 . mid )); final int sum = t1 . sum + t2 . sum ; return new T ( left , right , mid , sum ); } } class T { public int left ; // sum of the subarray w/ max sum (starting from the first num) public int right ; // sum of the subarray w/ max sum (ending at the the last num) public int mid ; // sum of the subarray w/ max sum public int sum ; // sum of the whole array public T ( int left , int right , int mid , int sum ) { this . left = left ; this . right = right ; this . mid = mid ; this . sum = sum ; } } Approach 3: DP Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { const int n = nums . size (); // dp[i] := sum of the subarray with max sum ending w/ nums[i] vector < int > dp ( n ); dp [ 0 ] = nums [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] > 0 ? dp [ i - 1 ] : 0 ) + nums [ i ]; return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { final int n = nums . length ; // dp[i] := sum of the subarray with max sum ending w/ nums[i] int [] dp = new int [ n ] ; dp [ 0 ] = nums [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] > 0 ? dp [ i - 1 ] : 0 ) + nums [ i ] ; return Arrays . stream ( dp ). max (). getAsInt (); } }","title":"53. Maximum Subarray"},{"location":"problems/0053/#53-maximum-subarray","text":"","title":"53. Maximum Subarray"},{"location":"problems/0053/#approach-1-gready","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( const int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( final int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans","title":"Approach 1: Gready"},{"location":"problems/0053/#approach-2-divide-and-conquer","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct T { int left ; // sum of the subarray w/ max sum (starting from the first num) int right ; // sum of the subarray w/ max sum (ending at the the last num) int mid ; // sum of the subarray w/ max sum int sum ; // sum of the whole array }; class Solution { public : int maxSubArray ( vector < int >& nums ) { const T t = divideAndConquer ( nums , 0 , nums . size () - 1 ); return t . mid ; } private : T divideAndConquer ( const vector < int >& nums , int l , int r ) { if ( l == r ) return { nums [ l ], nums [ l ], nums [ l ], nums [ l ]}; const int m = l + ( r - l ) / 2 ; const T t1 = divideAndConquer ( nums , l , m ); const T t2 = divideAndConquer ( nums , m + 1 , r ); const int left = max ( t1 . left , t1 . sum + t2 . left ); const int right = max ( t1 . right + t2 . sum , t2 . right ); const int mid = max ({ t1 . right + t2 . left , t1 . mid , t2 . mid }); const int sum = t1 . sum + t2 . sum ; return { left , right , mid , sum }; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int maxSubArray ( int [] nums ) { final T t = divideAndConquer ( nums , 0 , nums . length - 1 ); return t . mid ; } private T divideAndConquer ( final int [] nums , int l , int r ) { if ( l == r ) return new T ( nums [ l ] , nums [ l ] , nums [ l ] , nums [ l ] ); final int m = l + ( r - l ) / 2 ; final T t1 = divideAndConquer ( nums , l , m ); final T t2 = divideAndConquer ( nums , m + 1 , r ); final int left = Math . max ( t1 . left , t1 . sum + t2 . left ); final int right = Math . max ( t1 . right + t2 . sum , t2 . right ); final int mid = Math . max ( t1 . right + t2 . left , Math . max ( t1 . mid , t2 . mid )); final int sum = t1 . sum + t2 . sum ; return new T ( left , right , mid , sum ); } } class T { public int left ; // sum of the subarray w/ max sum (starting from the first num) public int right ; // sum of the subarray w/ max sum (ending at the the last num) public int mid ; // sum of the subarray w/ max sum public int sum ; // sum of the whole array public T ( int left , int right , int mid , int sum ) { this . left = left ; this . right = right ; this . mid = mid ; this . sum = sum ; } }","title":"Approach 2: Divide and Conquer"},{"location":"problems/0053/#approach-3-dp","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { const int n = nums . size (); // dp[i] := sum of the subarray with max sum ending w/ nums[i] vector < int > dp ( n ); dp [ 0 ] = nums [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] > 0 ? dp [ i - 1 ] : 0 ) + nums [ i ]; return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { final int n = nums . length ; // dp[i] := sum of the subarray with max sum ending w/ nums[i] int [] dp = new int [ n ] ; dp [ 0 ] = nums [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] > 0 ? dp [ i - 1 ] : 0 ) + nums [ i ] ; return Arrays . stream ( dp ). max (). getAsInt (); } }","title":"Approach 3: DP"},{"location":"problems/0054/","text":"54. Spiral Matrix Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ] . length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . add ( matrix [ r1 ][ c ] ); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . add ( matrix [ r ][ c2 ] ); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . add ( matrix [ r2 ][ c ] ); for ( int r = r2 ; r > r1 ; -- r ) ans . add ( matrix [ r ][ c1 ] ); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans","title":"54. Spiral Matrix"},{"location":"problems/0054/#54-spiral-matrix","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ] . length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . add ( matrix [ r1 ][ c ] ); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . add ( matrix [ r ][ c2 ] ); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . add ( matrix [ r2 ][ c ] ); for ( int r = r2 ; r > r1 ; -- r ) ans . add ( matrix [ r ][ c1 ] ); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans","title":"54. Spiral Matrix"},{"location":"problems/0055/","text":"55. Jump Game Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int i = 0 ; for ( int reach = 0 ; i < nums . size () && i <= reach ; ++ i ) reach = max ( reach , i + nums [ i ]); return i == nums . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean canJump ( int [] nums ) { int i = 0 ; for ( int reach = 0 ; i < nums . length && i <= reach ; ++ i ) reach = Math . max ( reach , i + nums [ i ] ); return i == nums . length ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0","title":"55. Jump Game"},{"location":"problems/0055/#55-jump-game","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int i = 0 ; for ( int reach = 0 ; i < nums . size () && i <= reach ; ++ i ) reach = max ( reach , i + nums [ i ]); return i == nums . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean canJump ( int [] nums ) { int i = 0 ; for ( int reach = 0 ; i < nums . length && i <= reach ; ++ i ) reach = Math . max ( reach , i + nums [ i ] ); return i == nums . length ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0","title":"55. Jump Game"},{"location":"problems/0056/","text":"56. Merge Intervals Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( begin ( intervals ), end ( intervals )); for ( const vector < int >& interval : intervals ) if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] )); for ( final int [] interval : intervals ) if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] for interval in sorted ( intervals ): if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"56. Merge Intervals"},{"location":"problems/0056/#56-merge-intervals","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( begin ( intervals ), end ( intervals )); for ( const vector < int >& interval : intervals ) if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] )); for ( final int [] interval : intervals ) if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] for interval in sorted ( intervals ): if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"56. Merge Intervals"},{"location":"problems/0057/","text":"57. Insert Interval Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { const int n = intervals . size (); vector < vector < int >> ans ; int i = 0 ; while ( i < n && intervals [ i ][ 1 ] < newInterval [ 0 ]) ans . push_back ( intervals [ i ++ ]); // merge overlapping intervals while ( i < n && intervals [ i ][ 0 ] <= newInterval [ 1 ]) { newInterval [ 0 ] = min ( newInterval [ 0 ], intervals [ i ][ 0 ]); newInterval [ 1 ] = max ( newInterval [ 1 ], intervals [ i ][ 1 ]); ++ i ; } ans . push_back ( newInterval ); while ( i < n ) ans . push_back ( intervals [ i ++ ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { final int n = intervals . length ; List < int []> ans = new ArrayList <> (); int i = 0 ; while ( i < n && intervals [ i ][ 1 ] < newInterval [ 0 ] ) ans . add ( intervals [ i ++] ); while ( i < n && intervals [ i ][ 0 ] <= newInterval [ 1 ] ) { newInterval [ 0 ] = Math . min ( newInterval [ 0 ] , intervals [ i ][ 0 ] ); newInterval [ 1 ] = Math . max ( newInterval [ 1 ] , intervals [ i ][ 1 ] ); ++ i ; } ans . add ( newInterval ); while ( i < n ) ans . add ( intervals [ i ++] ); return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"57. Insert Interval"},{"location":"problems/0057/#57-insert-interval","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { const int n = intervals . size (); vector < vector < int >> ans ; int i = 0 ; while ( i < n && intervals [ i ][ 1 ] < newInterval [ 0 ]) ans . push_back ( intervals [ i ++ ]); // merge overlapping intervals while ( i < n && intervals [ i ][ 0 ] <= newInterval [ 1 ]) { newInterval [ 0 ] = min ( newInterval [ 0 ], intervals [ i ][ 0 ]); newInterval [ 1 ] = max ( newInterval [ 1 ], intervals [ i ][ 1 ]); ++ i ; } ans . push_back ( newInterval ); while ( i < n ) ans . push_back ( intervals [ i ++ ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { final int n = intervals . length ; List < int []> ans = new ArrayList <> (); int i = 0 ; while ( i < n && intervals [ i ][ 1 ] < newInterval [ 0 ] ) ans . add ( intervals [ i ++] ); while ( i < n && intervals [ i ][ 0 ] <= newInterval [ 1 ] ) { newInterval [ 0 ] = Math . min ( newInterval [ 0 ] , intervals [ i ][ 0 ] ); newInterval [ 1 ] = Math . max ( newInterval [ 1 ] , intervals [ i ][ 1 ] ); ++ i ; } ans . add ( newInterval ); while ( i < n ) ans . add ( intervals [ i ++] ); return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"57. Insert Interval"},{"location":"problems/0058/","text":"58. Length of Last Word Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int lengthOfLastWord ( string s ) { int i = s . length () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; const int lastIndex = i ; while ( i >= 0 && s [ i ] != ' ' ) -- i ; return lastIndex - i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int lengthOfLastWord ( String s ) { int i = s . length () - 1 ; while ( i >= 0 && s . charAt ( i ) == ' ' ) -- i ; final int lastIndex = i ; while ( i >= 0 && s . charAt ( i ) != ' ' ) -- i ; return lastIndex - i ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans","title":"58. Length of Last Word"},{"location":"problems/0058/#58-length-of-last-word","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int lengthOfLastWord ( string s ) { int i = s . length () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; const int lastIndex = i ; while ( i >= 0 && s [ i ] != ' ' ) -- i ; return lastIndex - i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int lengthOfLastWord ( String s ) { int i = s . length () - 1 ; while ( i >= 0 && s . charAt ( i ) == ' ' ) -- i ; final int lastIndex = i ; while ( i >= 0 && s . charAt ( i ) != ' ' ) -- i ; return lastIndex - i ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans","title":"58. Length of Last Word"},{"location":"problems/0059/","text":"59. Spiral Matrix II Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { const int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ] ; int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { final int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans","title":"59. Spiral Matrix II"},{"location":"problems/0059/#59-spiral-matrix-ii","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { const int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ] ; int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { final int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans","title":"59. Spiral Matrix II"},{"location":"problems/0060/","text":"60. Permutation Sequence Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > factorial ( n + 1 , 1 ); // factorial[i] := i! for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 2 ; i <= n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; // 0-indexed for ( int i = n - 1 ; i >= 0 ; -- i ) { const int j = k / factorial [ i ]; k %= factorial [ i ]; ans += to_string ( nums [ j ]); nums . erase ( begin ( nums ) + j ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public String getPermutation ( int n , int k ) { StringBuilder ans = new StringBuilder (); List < Integer > nums = new ArrayList <> (); int [] factorial = new int [ n + 1 ] ; // factorial[i] := i! for ( int i = 1 ; i <= n ; ++ i ) nums . add ( i ); Arrays . fill ( factorial , 1 ); for ( int i = 2 ; i <= n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; // 0-indexed for ( int i = n - 1 ; i >= 0 ; -- i ) { final int j = k / factorial [ i ] ; k %= factorial [ i ] ; ans . append ( nums . get ( j )); nums . remove ( j ); } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] factorial = [ 1 ] * n for i in range ( 1 , n ): factorial [ i ] = factorial [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // factorial [ i - 1 ] k %= factorial [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"60. Permutation Sequence"},{"location":"problems/0060/#60-permutation-sequence","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > factorial ( n + 1 , 1 ); // factorial[i] := i! for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 2 ; i <= n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; // 0-indexed for ( int i = n - 1 ; i >= 0 ; -- i ) { const int j = k / factorial [ i ]; k %= factorial [ i ]; ans += to_string ( nums [ j ]); nums . erase ( begin ( nums ) + j ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public String getPermutation ( int n , int k ) { StringBuilder ans = new StringBuilder (); List < Integer > nums = new ArrayList <> (); int [] factorial = new int [ n + 1 ] ; // factorial[i] := i! for ( int i = 1 ; i <= n ; ++ i ) nums . add ( i ); Arrays . fill ( factorial , 1 ); for ( int i = 2 ; i <= n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; // 0-indexed for ( int i = n - 1 ; i >= 0 ; -- i ) { final int j = k / factorial [ i ] ; k %= factorial [ i ] ; ans . append ( nums . get ( j )); nums . remove ( j ); } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] factorial = [ 1 ] * n for i in range ( 1 , n ): factorial [ i ] = factorial [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // factorial [ i - 1 ] k %= factorial [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"60. Permutation Sequence"},{"location":"problems/0061/","text":"61. Rotate List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; ListNode * tail ; int length = 1 ; for ( tail = head ; tail -> next ; tail = tail -> next ) ++ length ; tail -> next = head ; // circle the list const int t = length - k % length ; for ( int i = 0 ; i < t ; ++ i ) tail = tail -> next ; ListNode * newHead = tail -> next ; tail -> next = nullptr ; return newHead ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || head . next == null || k == 0 ) return head ; int length = 1 ; ListNode tail = head ; for (; tail . next != null ; tail = tail . next ) ++ length ; tail . next = head ; // circle the list final int t = length - k % length ; for ( int i = 0 ; i < t ; ++ i ) tail = tail . next ; ListNode newHead = tail . next ; tail . next = null ; return newHead ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans","title":"61. Rotate List"},{"location":"problems/0061/#61-rotate-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; ListNode * tail ; int length = 1 ; for ( tail = head ; tail -> next ; tail = tail -> next ) ++ length ; tail -> next = head ; // circle the list const int t = length - k % length ; for ( int i = 0 ; i < t ; ++ i ) tail = tail -> next ; ListNode * newHead = tail -> next ; tail -> next = nullptr ; return newHead ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || head . next == null || k == 0 ) return head ; int length = 1 ; ListNode tail = head ; for (; tail . next != null ; tail = tail . next ) ++ length ; tail . next = head ; // circle the list final int t = length - k % length ; for ( int i = 0 ; i < t ; ++ i ) tail = tail . next ; ListNode newHead = tail . next ; tail . next = null ; return newHead ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans","title":"61. Rotate List"},{"location":"problems/0062/","text":"62. Unique Paths Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int uniquePaths ( int m , int n ) { // dp[i][j] := unique paths from (0, 0) to (i, j) vector < vector < int >> dp ( m , vector < int > ( n , 1 )); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m - 1 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int uniquePaths ( int m , int n ) { // dp[i][j] := unique paths from (0, 0) to (i, j) int [][] dp = new int [ m ][ n ] ; for ( int [] row : dp ) Arrays . fill ( row , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] ; return dp [ m - 1 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } }","title":"62. Unique Paths"},{"location":"problems/0062/#62-unique-paths","text":"","title":"62. Unique Paths"},{"location":"problems/0062/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int uniquePaths ( int m , int n ) { // dp[i][j] := unique paths from (0, 0) to (i, j) vector < vector < int >> dp ( m , vector < int > ( n , 1 )); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m - 1 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int uniquePaths ( int m , int n ) { // dp[i][j] := unique paths from (0, 0) to (i, j) int [][] dp = new int [ m ][ n ] ; for ( int [] row : dp ) Arrays . fill ( row , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] ; return dp [ m - 1 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"Approach 1: 2D DP"},{"location":"problems/0062/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0063/","text":"63. Unique Paths II Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1) vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 , 0 )); dp [ 0 ][ 1 ] = 1 ; // can also set dp[1][0] = 1; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( ! obstacleGrid [ i - 1 ][ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1) long [][] dp = new long [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 1 ] = 1 ; // can also set dp[1][0] = 1; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( obstacleGrid [ i - 1 ][ j - 1 ] == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] ; return ( int ) dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; int [] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } }","title":"63. Unique Paths II"},{"location":"problems/0063/#63-unique-paths-ii","text":"","title":"63. Unique Paths II"},{"location":"problems/0063/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1) vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 , 0 )); dp [ 0 ][ 1 ] = 1 ; // can also set dp[1][0] = 1; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( ! obstacleGrid [ i - 1 ][ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; // dp[i][j] := unique paths from (0, 0) to (i - 1, j - 1) long [][] dp = new long [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 1 ] = 1 ; // can also set dp[1][0] = 1; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( obstacleGrid [ i - 1 ][ j - 1 ] == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ] ; return ( int ) dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"Approach 1: 2D DP"},{"location":"problems/0063/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; int [] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0064/","text":"64. Minimum Path Sum Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; return grid [ m - 1 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ] , grid [ i ][ j - 1 ] ); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] ; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] ; return grid [ m - 1 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ]","title":"64. Minimum Path Sum"},{"location":"problems/0064/#64-minimum-path-sum","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; return grid [ m - 1 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ] , grid [ i ][ j - 1 ] ); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] ; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] ; return grid [ m - 1 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ]","title":"64. Minimum Path Sum"},{"location":"problems/0065/","text":"65. Valid Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : bool isNumber ( string s ) { trim ( s ); if ( s . empty ()) return false ; bool seenNum = false ; bool seenDot = false ; bool seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s [ i - 1 ] != 'e' ) return false ; seenNum = false ; break ; default : if ( ! isdigit ( s [ i ])) return false ; seenNum = true ; } } return seenNum ; } private : void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean isNumber ( String s ) { s = s . trim (); if ( s . isEmpty ()) return false ; boolean seenNum = false ; boolean seenDot = false ; boolean seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s . charAt ( i )) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s . charAt ( i - 1 ) != 'e' ) return false ; seenNum = false ; break ; default : if ( ! Character . isDigit ( s . charAt ( i ))) return false ; seenNum = true ; } } return seenNum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def isNumber ( self , s : str ) -> bool : s = s . strip () if not s : return False seenNum = False seenDot = False seenE = False for i , c in enumerate ( s ): if c == '.' : if seenDot or seenE : return False seenDot = True elif c == 'e' : if seenE or not seenNum : return False seenE = True seenNum = False elif c in '+-' : if i > 0 and s [ i - 1 ] != 'e' : return False seenNum = False else : if not c . isdigit (): return False seenNum = True return seenNum","title":"65. Valid Number"},{"location":"problems/0065/#65-valid-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : bool isNumber ( string s ) { trim ( s ); if ( s . empty ()) return false ; bool seenNum = false ; bool seenDot = false ; bool seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s [ i - 1 ] != 'e' ) return false ; seenNum = false ; break ; default : if ( ! isdigit ( s [ i ])) return false ; seenNum = true ; } } return seenNum ; } private : void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean isNumber ( String s ) { s = s . trim (); if ( s . isEmpty ()) return false ; boolean seenNum = false ; boolean seenDot = false ; boolean seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s . charAt ( i )) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s . charAt ( i - 1 ) != 'e' ) return false ; seenNum = false ; break ; default : if ( ! Character . isDigit ( s . charAt ( i ))) return false ; seenNum = true ; } } return seenNum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def isNumber ( self , s : str ) -> bool : s = s . strip () if not s : return False seenNum = False seenDot = False seenE = False for i , c in enumerate ( s ): if c == '.' : if seenDot or seenE : return False seenDot = True elif c == 'e' : if seenE or not seenNum : return False seenE = True seenNum = False elif c in '+-' : if i > 0 and s [ i - 1 ] != 'e' : return False seenNum = False else : if not c . isdigit (): return False seenNum = True return seenNum","title":"65. Valid Number"},{"location":"problems/0066/","text":"66. Plus One Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { for ( int i = digits . size () - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } digits . insert ( begin ( digits ), 1 ); return digits ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] plusOne ( int [] digits ) { for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { ++ digits [ i ] ; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ digits . length + 1 ] ; ans [ 0 ] = 1 ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n","title":"66. Plus One"},{"location":"problems/0066/#66-plus-one","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { for ( int i = digits . size () - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } digits . insert ( begin ( digits ), 1 ); return digits ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] plusOne ( int [] digits ) { for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { ++ digits [ i ] ; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ digits . length + 1 ] ; ans [ 0 ] = 1 ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n","title":"66. Plus One"},{"location":"problems/0067/","text":"67. Add Binary Time: $O(\\max(|a|, |b|))$ Space: $O(\\max(|a|, |b|))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans += carry % 2 + '0' ; carry /= 2 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String addBinary ( String a , String b ) { StringBuilder sb = new StringBuilder (); int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += b . charAt ( j -- ) - '0' ; sb . append ( carry % 2 ); carry /= 2 ; } return sb . reverse (). toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while carry == 1 or i >= 0 or j >= 0 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans","title":"67. Add Binary"},{"location":"problems/0067/#67-add-binary","text":"Time: $O(\\max(|a|, |b|))$ Space: $O(\\max(|a|, |b|))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans += carry % 2 + '0' ; carry /= 2 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String addBinary ( String a , String b ) { StringBuilder sb = new StringBuilder (); int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += b . charAt ( j -- ) - '0' ; sb . append ( carry % 2 ); carry /= 2 ; } return sb . reverse (). toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while carry == 1 or i >= 0 or j >= 0 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans","title":"67. Add Binary"},{"location":"problems/0068/","text":"68. Text Justification Time: $O(\\Sigma|words_i|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < string > fullJustify ( vector < string >& words , size_t maxWidth ) { vector < string > ans ; vector < string > row ; size_t rowLetters = 0 ; for ( const string & word : words ) { // if we put the word in this row, it'll exceed the maxWidth, // so we cannot put the word to this row and have to pad spaces to // each word in this row if ( rowLetters + row . size () + word . length () > maxWidth ) { const int spaces = maxWidth - rowLetters ; if ( row . size () == 1 ) { // pad all spaces after row[0] for ( int i = 0 ; i < spaces ; ++ i ) row [ 0 ] += \" \" ; } else { // evenly pad spaces to each word (expect the last one) in this row for ( int i = 0 ; i < spaces ; ++ i ) row [ i % ( row . size () - 1 )] += \" \" ; } ans . push_back ( join ( row , \"\" )); row . clear (); rowLetters = 0 ; } row . push_back ( word ); rowLetters += word . length (); } ans . push_back ( ljust ( join ( row , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = begin ( v ); p != end ( v ); ++ p ) { s += * p ; if ( p != end ( v ) - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < String > fullJustify ( String [] words , int maxWidth ) { List < String > ans = new ArrayList <> (); List < StringBuilder > row = new ArrayList <> (); int rowLetters = 0 ; for ( final String word : words ) { if ( rowLetters + row . size () + word . length () > maxWidth ) { final int spaces = maxWidth - rowLetters ; if ( row . size () == 1 ) { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( 0 ). append ( \" \" ); } else { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( i % ( row . size () - 1 )). append ( \" \" ); } final String joinedRow = row . stream (). map ( StringBuilder :: toString ). collect ( Collectors . joining ( \"\" )); ans . add ( joinedRow ); row . clear (); rowLetters = 0 ; } row . add ( new StringBuilder ( word )); rowLetters += word . length (); } final String lastRow = row . stream (). map ( StringBuilder :: toString ). collect ( Collectors . joining ( \" \" )); StringBuilder sb = new StringBuilder ( lastRow ); final int spacesToBeAdded = maxWidth - sb . length (); for ( int i = 0 ; i < spacesToBeAdded ; ++ i ) sb . append ( \" \" ); ans . add ( sb . toString ()); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )]","title":"68. Text Justification"},{"location":"problems/0068/#68-text-justification","text":"Time: $O(\\Sigma|words_i|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < string > fullJustify ( vector < string >& words , size_t maxWidth ) { vector < string > ans ; vector < string > row ; size_t rowLetters = 0 ; for ( const string & word : words ) { // if we put the word in this row, it'll exceed the maxWidth, // so we cannot put the word to this row and have to pad spaces to // each word in this row if ( rowLetters + row . size () + word . length () > maxWidth ) { const int spaces = maxWidth - rowLetters ; if ( row . size () == 1 ) { // pad all spaces after row[0] for ( int i = 0 ; i < spaces ; ++ i ) row [ 0 ] += \" \" ; } else { // evenly pad spaces to each word (expect the last one) in this row for ( int i = 0 ; i < spaces ; ++ i ) row [ i % ( row . size () - 1 )] += \" \" ; } ans . push_back ( join ( row , \"\" )); row . clear (); rowLetters = 0 ; } row . push_back ( word ); rowLetters += word . length (); } ans . push_back ( ljust ( join ( row , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = begin ( v ); p != end ( v ); ++ p ) { s += * p ; if ( p != end ( v ) - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < String > fullJustify ( String [] words , int maxWidth ) { List < String > ans = new ArrayList <> (); List < StringBuilder > row = new ArrayList <> (); int rowLetters = 0 ; for ( final String word : words ) { if ( rowLetters + row . size () + word . length () > maxWidth ) { final int spaces = maxWidth - rowLetters ; if ( row . size () == 1 ) { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( 0 ). append ( \" \" ); } else { for ( int i = 0 ; i < spaces ; ++ i ) row . get ( i % ( row . size () - 1 )). append ( \" \" ); } final String joinedRow = row . stream (). map ( StringBuilder :: toString ). collect ( Collectors . joining ( \"\" )); ans . add ( joinedRow ); row . clear (); rowLetters = 0 ; } row . add ( new StringBuilder ( word )); rowLetters += word . length (); } final String lastRow = row . stream (). map ( StringBuilder :: toString ). collect ( Collectors . joining ( \" \" )); StringBuilder sb = new StringBuilder ( lastRow ); final int spacesToBeAdded = maxWidth - sb . length (); for ( int i = 0 ; i < spacesToBeAdded ; ++ i ) sb . append ( \" \" ); ans . add ( sb . toString ()); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )]","title":"68. Text Justification"},{"location":"problems/0069/","text":"69. Sqrt(x) Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { const unsigned m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } // l: smallest number s.t. l * l > x return l - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int mySqrt ( long x ) { long l = 1 ; long r = x + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } // l: smallest number s.t. l * l > x return ( int ) l - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def mySqrt ( self , x : int ) -> int : l = 1 r = x + 1 while l < r : m = ( l + r ) // 2 if m * m > x : r = m else : l = m + 1 return l - 1","title":"69. Sqrt(x)"},{"location":"problems/0069/#69-sqrtx","text":"Time: $O(\\log x)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { const unsigned m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } // l: smallest number s.t. l * l > x return l - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int mySqrt ( long x ) { long l = 1 ; long r = x + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } // l: smallest number s.t. l * l > x return ( int ) l - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def mySqrt ( self , x : int ) -> int : l = 1 r = x + 1 while l < r : m = ( l + r ) // 2 if m * m > x : r = m else : l = m + 1 return l - 1","title":"69. Sqrt(x)"},{"location":"problems/0070/","text":"70. Climbing Stairs Approach 1: 2D DP Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int climbStairs ( int n ) { vector < int > dp ( n + 1 ); // dp[i] := # of distinct ways to climb to ith stair dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int climbStairs ( int n ) { int [] dp = new int [ n + 1 ] ; // dp[i] := # of distinct ways to climb to ith stair dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ] Approach 2: 1D DP Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int climbStairs ( int n ) { int prev1 = 1 ; // dp[i - 1] int prev2 = 1 ; // dp[i - 2] for ( int i = 2 ; i <= n ; ++ i ) { const int dp = prev1 + prev2 ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int climbStairs ( int n ) { int prev1 = 1 ; // dp[i - 1] int prev2 = 1 ; // dp[i - 2] for ( int i = 2 ; i <= n ; ++ i ) { final int dp = prev1 + prev2 ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }","title":"70. Climbing Stairs"},{"location":"problems/0070/#70-climbing-stairs","text":"","title":"70. Climbing Stairs"},{"location":"problems/0070/#approach-1-2d-dp","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int climbStairs ( int n ) { vector < int > dp ( n + 1 ); // dp[i] := # of distinct ways to climb to ith stair dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int climbStairs ( int n ) { int [] dp = new int [ n + 1 ] ; // dp[i] := # of distinct ways to climb to ith stair dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ]","title":"Approach 1: 2D DP"},{"location":"problems/0070/#approach-2-1d-dp","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int climbStairs ( int n ) { int prev1 = 1 ; // dp[i - 1] int prev2 = 1 ; // dp[i - 2] for ( int i = 2 ; i <= n ; ++ i ) { const int dp = prev1 + prev2 ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int climbStairs ( int n ) { int prev1 = 1 ; // dp[i - 1] int prev2 = 1 ; // dp[i - 2] for ( int i = 2 ; i <= n ; ++ i ) { final int dp = prev1 + prev2 ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0071/","text":"71. Simplify Path Time: $O(|path|)$ Space: $O(|path|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string simplifyPath ( string path ) { string ans ; istringstream iss ( path ); vector < string > stack ; for ( string dir ; getline ( iss , dir , '/' );) { if ( dir == \".\" || dir == \"\" ) continue ; if ( dir == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( dir ); } } for ( const string & s : stack ) ans += \"/\" + s ; return ans . empty () ? \"/\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String simplifyPath ( String path ) { final String [] dirs = path . split ( \"/\" ); Stack < String > stack = new Stack <> (); for ( final String dir : dirs ) { if ( dir . equals ( \".\" ) || dir . isEmpty ()) continue ; if ( dir . equals ( \"..\" )) { if ( ! stack . isEmpty ()) stack . pop (); } else { stack . push ( dir ); } } return \"/\" + String . join ( \"/\" , new ArrayList ( stack )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack )","title":"71. Simplify Path"},{"location":"problems/0071/#71-simplify-path","text":"Time: $O(|path|)$ Space: $O(|path|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string simplifyPath ( string path ) { string ans ; istringstream iss ( path ); vector < string > stack ; for ( string dir ; getline ( iss , dir , '/' );) { if ( dir == \".\" || dir == \"\" ) continue ; if ( dir == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( dir ); } } for ( const string & s : stack ) ans += \"/\" + s ; return ans . empty () ? \"/\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String simplifyPath ( String path ) { final String [] dirs = path . split ( \"/\" ); Stack < String > stack = new Stack <> (); for ( final String dir : dirs ) { if ( dir . equals ( \".\" ) || dir . isEmpty ()) continue ; if ( dir . equals ( \"..\" )) { if ( ! stack . isEmpty ()) stack . pop (); } else { stack . push ( dir ); } } return \"/\" + String . join ( \"/\" , new ArrayList ( stack )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack )","title":"71. Simplify Path"},{"location":"problems/0072/","text":"72. Edit Distance Time: $O(mn)$ Space: $O(mn) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 [ i - 1 ] == word2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int minDistance ( String word1 , String word2 ) { final int m = word1 . length (); final int n = word2 . length (); // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 . charAt ( i - 1 ) == word2 . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j - 1 ] , Math . min ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] )) + 1 ; return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ]","title":"72. Edit Distance"},{"location":"problems/0072/#72-edit-distance","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 [ i - 1 ] == word2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int minDistance ( String word1 , String word2 ) { final int m = word1 . length (); final int n = word2 . length (); // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 . charAt ( i - 1 ) == word2 . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j - 1 ] , Math . min ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] )) + 1 ; return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ]","title":"72. Edit Distance"},{"location":"problems/0073/","text":"73. Set Matrix Zeroes Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool shouldFillFirstRow = false ; bool shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; boolean shouldFillFirstRow = false ; boolean shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0","title":"73. Set Matrix Zeroes"},{"location":"problems/0073/#73-set-matrix-zeroes","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool shouldFillFirstRow = false ; bool shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; boolean shouldFillFirstRow = false ; boolean shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0","title":"73. Set Matrix Zeroes"},{"location":"problems/0074/","text":"74. Search a 2D Matrix Time: $O(mn\\log mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; const int i = mid / n ; const int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int l = 0 ; int r = m * n ; while ( l < r ) { final int mid = l + ( r - l ) / 2 ; final int i = mid / n ; final int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False","title":"74. Search a 2D Matrix"},{"location":"problems/0074/#74-search-a-2d-matrix","text":"Time: $O(mn\\log mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; const int i = mid / n ; const int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int l = 0 ; int r = m * n ; while ( l < r ) { final int mid = l + ( r - l ) / 2 ; final int i = mid / n ; final int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False","title":"74. Search a 2D Matrix"},{"location":"problems/0075/","text":"75. Sort Colors Approach 1: 3 pointers Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = -1 ; int one = -1 ; int two = -1 ; for ( const int num : nums ) if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( final int num : nums ) if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2 Approach 2: 2 pointers + swapping Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : void sortColors ( vector < int >& nums ) { int l = 0 ; // next 0 should be put in l int r = nums . size () - 1 ; // next 2 should be put in r for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums [ i ++ ], nums [ l ++ ]); else if ( nums [ i ] == 1 ) ++ i ; else // we may swap a 0 to index i, but we're still not sure whether // this 0 is put in the correct index, so we can't move pointer i swap ( nums [ i ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public void sortColors ( int [] nums ) { int l = 0 ; // next 0 should be put in l int r = nums . length - 1 ; // next 2 should be put in r for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums , i ++ , l ++ ); else if ( nums [ i ] == 1 ) ++ i ; else // we may swap a 0 to index i, but we're still not sure whether // this 0 is put in the correct index, so we can't move pointer i swap ( nums , i , r -- ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"75. Sort Colors"},{"location":"problems/0075/#75-sort-colors","text":"","title":"75. Sort Colors"},{"location":"problems/0075/#approach-1-3-pointers","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = -1 ; int one = -1 ; int two = -1 ; for ( const int num : nums ) if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( final int num : nums ) if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2","title":"Approach 1: 3 pointers"},{"location":"problems/0075/#approach-2-2-pointers-swapping","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : void sortColors ( vector < int >& nums ) { int l = 0 ; // next 0 should be put in l int r = nums . size () - 1 ; // next 2 should be put in r for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums [ i ++ ], nums [ l ++ ]); else if ( nums [ i ] == 1 ) ++ i ; else // we may swap a 0 to index i, but we're still not sure whether // this 0 is put in the correct index, so we can't move pointer i swap ( nums [ i ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public void sortColors ( int [] nums ) { int l = 0 ; // next 0 should be put in l int r = nums . length - 1 ; // next 2 should be put in r for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums , i ++ , l ++ ); else if ( nums [ i ] == 1 ) ++ i ; else // we may swap a 0 to index i, but we're still not sure whether // this 0 is put in the correct index, so we can't move pointer i swap ( nums , i , r -- ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"Approach 2: 2 pointers + swapping"},{"location":"problems/0076/","text":"76. Minimum Window Substring Time: $O(|s| + |t|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string minWindow ( string s , string t ) { vector < int > count ( 128 ); int required = t . length (); int bestLeft = -1 ; int minLength = INT_MAX ; for ( const char c : t ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return minLength == INT_MAX ? \"\" : s . substr ( bestLeft , minLength ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public String minWindow ( String s , String t ) { int [] count = new int [ 128 ] ; int required = t . length (); int bestLeft = - 1 ; int minLength = Integer . MAX_VALUE ; for ( final char c : t . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return minLength == Integer . MAX_VALUE ? \"\" : s . substring ( bestLeft , bestLeft + minLength ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def minWindow ( self , s : str , t : str ) -> str : count = collections . Counter ( t ) required = len ( t ) bestLeft = 0 minLength = float ( 'inf' ) l = 0 for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 while required == 0 : if r - l + 1 < minLength : bestLeft = l minLength = r - l + 1 count [ s [ l ]] += 1 if count [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if minLength == float ( 'inf' ) else s [ bestLeft : bestLeft + minLength ]","title":"76. Minimum Window Substring"},{"location":"problems/0076/#76-minimum-window-substring","text":"Time: $O(|s| + |t|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string minWindow ( string s , string t ) { vector < int > count ( 128 ); int required = t . length (); int bestLeft = -1 ; int minLength = INT_MAX ; for ( const char c : t ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return minLength == INT_MAX ? \"\" : s . substr ( bestLeft , minLength ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public String minWindow ( String s , String t ) { int [] count = new int [ 128 ] ; int required = t . length (); int bestLeft = - 1 ; int minLength = Integer . MAX_VALUE ; for ( final char c : t . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return minLength == Integer . MAX_VALUE ? \"\" : s . substring ( bestLeft , bestLeft + minLength ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def minWindow ( self , s : str , t : str ) -> str : count = collections . Counter ( t ) required = len ( t ) bestLeft = 0 minLength = float ( 'inf' ) l = 0 for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 while required == 0 : if r - l + 1 < minLength : bestLeft = l minLength = r - l + 1 count [ s [ l ]] += 1 if count [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if minLength == float ( 'inf' ) else s [ bestLeft : bestLeft + minLength ]","title":"76. Minimum Window Substring"},{"location":"problems/0077/","text":"77. Combinations Time: $O(C(n, k))$ Space: $O(k \\cdot C(n, k))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int k , int s ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , i + 1 ); path . pop_back (); } }; dfs ( k , 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> combine ( int n , int k ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( n , k , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int n , int k , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i <= n ; ++ i ) { path . add ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans )","title":"77. Combinations"},{"location":"problems/0077/#77-combinations","text":"Time: $O(C(n, k))$ Space: $O(k \\cdot C(n, k))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int k , int s ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , i + 1 ); path . pop_back (); } }; dfs ( k , 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> combine ( int n , int k ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( n , k , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int n , int k , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i <= n ; ++ i ) { path . add ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans )","title":"77. Combinations"},{"location":"problems/0078/","text":"78. Subsets Time: $O(2^n)$ Space: $O(n \\cdot 2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"78. Subsets"},{"location":"problems/0078/#78-subsets","text":"Time: $O(2^n)$ Space: $O(n \\cdot 2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"78. Subsets"},{"location":"problems/0079/","text":"79. Word Search Time: $O(4^{|word|})$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { const int m = board . size (); const int n = board [ 0 ]. size (); function < bool ( int , int , int ) > dfs = [ & ]( int i , int j , int s ) { if ( i < 0 || i == m || j < 0 || j == n ) return false ; if ( board [ i ][ j ] != word [ s ] || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; const char cache = board [ i ][ j ]; board [ i ][ j ] = '*' ; const bool isExist = dfs ( i + 1 , j , s + 1 ) || dfs ( i - 1 , j , s + 1 ) || dfs ( i , j + 1 , s + 1 ) || dfs ( i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( dfs ( i , j , 0 )) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean exist ( char [][] board , String word ) { for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int s ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return false ; if ( board [ i ][ j ] != word . charAt ( s ) || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; final char cache = board [ i ][ j ] ; board [ i ][ j ] = '*' ; final boolean isExist = dfs ( board , word , i + 1 , j , s + 1 ) || dfs ( board , word , i - 1 , j , s + 1 ) || dfs ( board , word , i , j + 1 , s + 1 ) || dfs ( board , word , i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False","title":"79. Word Search"},{"location":"problems/0079/#79-word-search","text":"Time: $O(4^{|word|})$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { const int m = board . size (); const int n = board [ 0 ]. size (); function < bool ( int , int , int ) > dfs = [ & ]( int i , int j , int s ) { if ( i < 0 || i == m || j < 0 || j == n ) return false ; if ( board [ i ][ j ] != word [ s ] || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; const char cache = board [ i ][ j ]; board [ i ][ j ] = '*' ; const bool isExist = dfs ( i + 1 , j , s + 1 ) || dfs ( i - 1 , j , s + 1 ) || dfs ( i , j + 1 , s + 1 ) || dfs ( i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( dfs ( i , j , 0 )) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean exist ( char [][] board , String word ) { for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int s ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return false ; if ( board [ i ][ j ] != word . charAt ( s ) || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; final char cache = board [ i ][ j ] ; board [ i ][ j ] = '*' ; final boolean isExist = dfs ( board , word , i + 1 , j , s + 1 ) || dfs ( board , word , i - 1 , j , s + 1 ) || dfs ( board , word , i , j + 1 , s + 1 ) || dfs ( board , word , i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False","title":"79. Word Search"},{"location":"problems/0080/","text":"80. Remove Duplicates from Sorted Array II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 2 || num > nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 2 || num > nums [ i - 2 ] ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"80. Remove Duplicates from Sorted Array II"},{"location":"problems/0080/#80-remove-duplicates-from-sorted-array-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 2 || num > nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( i < 2 || num > nums [ i - 2 ] ) nums [ i ++] = num ; return i ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"80. Remove Duplicates from Sorted Array II"},{"location":"problems/0081/","text":"81. Search in Rotated Sorted Array II Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ] ) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ] ) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False","title":"81. Search in Rotated Sorted Array II"},{"location":"problems/0081/#81-search-in-rotated-sorted-array-ii","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ] ) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ] ) { // nums[l..m] are sorted if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { // nums[m..n - 1] are sorted if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False","title":"81. Search in Rotated Sorted Array II"},{"location":"problems/0082/","text":"82. Remove Duplicates from Sorted List II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; while ( head != null ) { while ( head . next != null && head . val == head . next . val ) head = head . next ; if ( prev . next == head ) prev = prev . next ; else prev . next = head . next ; head = head . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next","title":"82. Remove Duplicates from Sorted List II"},{"location":"problems/0082/#82-remove-duplicates-from-sorted-list-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; while ( head != null ) { while ( head . next != null && head . val == head . next . val ) head = head . next ; if ( prev . next == head ) prev = prev . next ; else prev . next = head . next ; head = head . next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next","title":"82. Remove Duplicates from Sorted List II"},{"location":"problems/0083/","text":"83. Remove Duplicates from Sorted List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode curr = head ; while ( curr != null ) { while ( curr . next != null && curr . val == curr . next . val ) curr . next = curr . next . next ; curr = curr . next ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head","title":"83. Remove Duplicates from Sorted List"},{"location":"problems/0083/#83-remove-duplicates-from-sorted-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode curr = head ; while ( curr != null ) { while ( curr . next != null && curr . val == curr . next . val ) curr . next = curr . next . next ; curr = curr . next ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head","title":"83. Remove Duplicates from Sorted List"},{"location":"problems/0084/","text":"84. Largest Rectangle in Histogram Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ stack . peek () ] > heights [ i ] )) { final int h = heights [ stack . pop () ] ; final int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans","title":"84. Largest Rectangle in Histogram"},{"location":"problems/0084/#84-largest-rectangle-in-histogram","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ stack . peek () ] > heights [ i ] )) { final int h = heights [ stack . pop () ] ; final int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans","title":"84. Largest Rectangle in Histogram"},{"location":"problems/0085/","text":"85. Maximal Rectangle Time: $O(mn)$, where m = len(matrix) and n = len(matrix[i]) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( const vector < char >& row : matrix ) { for ( int i = 0 ; i < row . size (); ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ] . length ] ; for ( char [] row : matrix ) { for ( int i = 0 ; i < row . length ; ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ stack . peek () ] > heights [ i ] )) { final int h = heights [ stack . pop () ] ; final int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for row in matrix : for i , num in enumerate ( row ): temp [ i ] = 0 if num == '0' else temp [ i ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans","title":"85. Maximal Rectangle"},{"location":"problems/0085/#85-maximal-rectangle","text":"Time: $O(mn)$, where m = len(matrix) and n = len(matrix[i]) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( const vector < char >& row : matrix ) { for ( int i = 0 ; i < row . size (); ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ] . length ] ; for ( char [] row : matrix ) { for ( int i = 0 ; i < row . length ; ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ stack . peek () ] > heights [ i ] )) { final int h = heights [ stack . pop () ] ; final int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for row in matrix : for i , num in enumerate ( row ): temp [ i ] = 0 if num == '0' else temp [ i ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans","title":"85. Maximal Rectangle"},{"location":"problems/0086/","text":"86. Partition List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; for (; head ; head = head -> next ) if ( head -> val < x ) { before -> next = head ; before = head ; } else { after -> next = head ; after = head ; } after -> next = nullptr ; before -> next = afterHead . next ; return beforeHead . next ; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode partition ( ListNode head , int x ) { ListNode beforeHead = new ListNode ( 0 ); ListNode afterHead = new ListNode ( 0 ); ListNode before = beforeHead ; ListNode after = afterHead ; for (; head != null ; head = head . next ) if ( head . val < x ) { before . next = head ; before = head ; } else { after . next = head ; after = head ; } after . next = null ; before . next = afterHead . next ; return beforeHead . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = head else : after . next = head after = head head = head . next after . next = None before . next = afterHead . next return beforeHead . next","title":"86. Partition List"},{"location":"problems/0086/#86-partition-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; for (; head ; head = head -> next ) if ( head -> val < x ) { before -> next = head ; before = head ; } else { after -> next = head ; after = head ; } after -> next = nullptr ; before -> next = afterHead . next ; return beforeHead . next ; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode partition ( ListNode head , int x ) { ListNode beforeHead = new ListNode ( 0 ); ListNode afterHead = new ListNode ( 0 ); ListNode before = beforeHead ; ListNode after = afterHead ; for (; head != null ; head = head . next ) if ( head . val < x ) { before . next = head ; before = head ; } else { after . next = head ; after = head ; } after . next = null ; before . next = afterHead . next ; return beforeHead . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = head else : after . next = head after = head head = head . next after . next = None before . next = afterHead . next return beforeHead . next","title":"86. Partition List"},{"location":"problems/0087/","text":"87. Scramble String Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : bool isScramble ( string s1 , string s2 ) { if ( s1 == s2 ) return true ; if ( s1 . length () != s2 . length ()) return false ; const string hashedKey = s1 + '+' + s2 ; if ( memo . count ( hashedKey )) return memo [ hashedKey ]; vector < int > count ( 128 ); for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 [ i ]]; -- count [ s2 [ i ]]; } if ( any_of ( begin ( count ), end ( count ), []( int c ) { return c != 0 ; })) return memo [ hashedKey ] = false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( 0 , i )) && isScramble ( s1 . substr ( i ), s2 . substr ( i ))) return memo [ hashedKey ] = true ; if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( s2 . length () - i )) && isScramble ( s1 . substr ( i ), s2 . substr ( 0 , s2 . length () - i ))) return memo [ hashedKey ] = true ; } return memo [ hashedKey ] = false ; } private : unordered_map < string , bool > memo ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 )) return true ; if ( s1 . length () != s2 . length ()) return false ; final String hashedKey = s1 + \"+\" + s2 ; if ( memo . containsKey ( hashedKey )) return memo . get ( hashedKey ); int [] count = new int [ 128 ] ; for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 . charAt ( i ) ] ; -- count [ s2 . charAt ( i ) ] ; } for ( final int c : count ) if ( c != 0 ) { memo . put ( hashedKey , false ); return false ; } for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( 0 , i )) && isScramble ( s1 . substring ( i ), s2 . substring ( i ))) { memo . put ( hashedKey , true ); return true ; } if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( s2 . length () - i )) && isScramble ( s1 . substring ( i ), s2 . substring ( 0 , s2 . length () - i ))) { memo . put ( hashedKey , true ); return true ; } } memo . put ( hashedKey , false ); return false ; } private Map < String , Boolean > memo = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isScramble ( self , s1 : str , s2 : str ) -> bool : if s1 == s2 : return True if len ( s1 ) != len ( s2 ): return False if collections . Counter ( s1 ) != collections . Counter ( s2 ): return False for i in range ( 1 , len ( s1 )): if self . isScramble ( s1 [: i ], s2 [: i ]) and self . isScramble ( s1 [ i :], s2 [ i :]): return True if self . isScramble ( s1 [: i ], s2 [ len ( s2 ) - i :]) and self . isScramble ( s1 [ i :], s2 [: len ( s2 ) - i ]): return True return False","title":"87. Scramble String"},{"location":"problems/0087/#87-scramble-string","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : bool isScramble ( string s1 , string s2 ) { if ( s1 == s2 ) return true ; if ( s1 . length () != s2 . length ()) return false ; const string hashedKey = s1 + '+' + s2 ; if ( memo . count ( hashedKey )) return memo [ hashedKey ]; vector < int > count ( 128 ); for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 [ i ]]; -- count [ s2 [ i ]]; } if ( any_of ( begin ( count ), end ( count ), []( int c ) { return c != 0 ; })) return memo [ hashedKey ] = false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( 0 , i )) && isScramble ( s1 . substr ( i ), s2 . substr ( i ))) return memo [ hashedKey ] = true ; if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( s2 . length () - i )) && isScramble ( s1 . substr ( i ), s2 . substr ( 0 , s2 . length () - i ))) return memo [ hashedKey ] = true ; } return memo [ hashedKey ] = false ; } private : unordered_map < string , bool > memo ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 )) return true ; if ( s1 . length () != s2 . length ()) return false ; final String hashedKey = s1 + \"+\" + s2 ; if ( memo . containsKey ( hashedKey )) return memo . get ( hashedKey ); int [] count = new int [ 128 ] ; for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 . charAt ( i ) ] ; -- count [ s2 . charAt ( i ) ] ; } for ( final int c : count ) if ( c != 0 ) { memo . put ( hashedKey , false ); return false ; } for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( 0 , i )) && isScramble ( s1 . substring ( i ), s2 . substring ( i ))) { memo . put ( hashedKey , true ); return true ; } if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( s2 . length () - i )) && isScramble ( s1 . substring ( i ), s2 . substring ( 0 , s2 . length () - i ))) { memo . put ( hashedKey , true ); return true ; } } memo . put ( hashedKey , false ); return false ; } private Map < String , Boolean > memo = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isScramble ( self , s1 : str , s2 : str ) -> bool : if s1 == s2 : return True if len ( s1 ) != len ( s2 ): return False if collections . Counter ( s1 ) != collections . Counter ( s2 ): return False for i in range ( 1 , len ( s1 )): if self . isScramble ( s1 [: i ], s2 [: i ]) and self . isScramble ( s1 [ i :], s2 [ i :]): return True if self . isScramble ( s1 [: i ], s2 [ len ( s2 ) - i :]) and self . isScramble ( s1 [ i :], s2 [: len ( s2 ) - i ]): return True return False","title":"87. Scramble String"},{"location":"problems/0088/","text":"88. Merge Sorted Array Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n - 1 ; -- m ; -- n ; while ( n >= 0 ) if ( m >= 0 && nums1 [ m ] > nums2 [ n ]) nums1 [ k -- ] = nums1 [ m -- ]; else nums1 [ k -- ] = nums2 [ n -- ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n - 1 ; -- m ; -- n ; while ( n >= 0 ) if ( m >= 0 && nums1 [ m ] > nums2 [ n ] ) nums1 [ k --] = nums1 [ m --] ; else nums1 [ k --] = nums2 [ n --] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ]","title":"88. Merge Sorted Array"},{"location":"problems/0088/#88-merge-sorted-array","text":"Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n - 1 ; -- m ; -- n ; while ( n >= 0 ) if ( m >= 0 && nums1 [ m ] > nums2 [ n ]) nums1 [ k -- ] = nums1 [ m -- ]; else nums1 [ k -- ] = nums2 [ n -- ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n - 1 ; -- m ; -- n ; while ( n >= 0 ) if ( m >= 0 && nums1 [ m ] > nums2 [ n ] ) nums1 [ k --] = nums1 [ m --] ; else nums1 [ k --] = nums2 [ n --] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ]","title":"88. Merge Sorted Array"},{"location":"problems/0089/","text":"89. Gray Code Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > grayCode ( int n ) { List < Integer > ans = new ArrayList <> (); ans . add ( 0 ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . add ( ans . get ( j ) | 1 << i ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans","title":"89. Gray Code"},{"location":"problems/0089/#89-gray-code","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > grayCode ( int n ) { List < Integer > ans = new ArrayList <> (); ans . add ( 0 ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . add ( ans . get ( j ) | 1 << i ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans","title":"89. Gray Code"},{"location":"problems/0090/","text":"90. Subsets II Time: $O(n2^n)$ Space: $O(n2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"90. Subsets II"},{"location":"problems/0090/#90-subsets-ii","text":"Time: $O(n2^n)$ Space: $O(n2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"90. Subsets II"},{"location":"problems/0091/","text":"91. Decode Ways Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numDecodings ( string s ) { const int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] vector < int > dp ( n + 1 ); dp [ n ] = 1 ; // \"\" dp [ n - 1 ] = isValid ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s [ i ])) dp [ i ] += dp [ i + 1 ]; if ( isValid ( s [ i ], s [ i + 1 ])) dp [ i ] += dp [ i + 2 ]; } return dp [ 0 ]; } private : bool isValid ( char c ) { return '1' <= c && c <= '9' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int numDecodings ( String s ) { final int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] int [] dp = new int [ n + 1 ] ; dp [ n ] = 1 ; // \"\" dp [ n - 1 ] = isValid ( s . charAt ( n - 1 )) ? 1 : 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s . charAt ( i ))) dp [ i ] += dp [ i + 1 ] ; if ( isValid ( s . charAt ( i ), s . charAt ( i + 1 ))) dp [ i ] += dp [ i + 2 ] ; } return dp [ 0 ] ; } private boolean isValid ( char c ) { return '1' <= c && c <= '9' ; } private boolean isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0'","title":"91. Decode Ways"},{"location":"problems/0091/#91-decode-ways","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numDecodings ( string s ) { const int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] vector < int > dp ( n + 1 ); dp [ n ] = 1 ; // \"\" dp [ n - 1 ] = isValid ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s [ i ])) dp [ i ] += dp [ i + 1 ]; if ( isValid ( s [ i ], s [ i + 1 ])) dp [ i ] += dp [ i + 2 ]; } return dp [ 0 ]; } private : bool isValid ( char c ) { return '1' <= c && c <= '9' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int numDecodings ( String s ) { final int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] int [] dp = new int [ n + 1 ] ; dp [ n ] = 1 ; // \"\" dp [ n - 1 ] = isValid ( s . charAt ( n - 1 )) ? 1 : 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s . charAt ( i ))) dp [ i ] += dp [ i + 1 ] ; if ( isValid ( s . charAt ( i ), s . charAt ( i + 1 ))) dp [ i ] += dp [ i + 2 ] ; } return dp [ 0 ] ; } private boolean isValid ( char c ) { return '1' <= c && c <= '9' ; } private boolean isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0'","title":"91. Decode Ways"},{"location":"problems/0092/","text":"92. Reverse Linked List II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head || m == n ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev -> next ; // point to the node before the sublist [m, n] ListNode * tail = prev -> next ; // will be the tail of the sublist [m, n] // reverse the sublist [m, n] one by one for ( int i = 0 ; i < n - m ; ++ i ) { ListNode * cache = tail -> next ; tail -> next = cache -> next ; cache -> next = prev -> next ; prev -> next = cache ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( head == null || m == n ) return head ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev . next ; // point to the node before the sublist [m, n] ListNode tail = prev . next ; // will be the tail of the sublist [m, n] // reverse the sublist [m, n] one by one for ( int i = 0 ; i < n - m ; ++ i ) { ListNode cache = tail . next ; tail . next = cache . next ; cache . next = prev . next ; prev . next = cache ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head","title":"92. Reverse Linked List II"},{"location":"problems/0092/#92-reverse-linked-list-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head || m == n ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev -> next ; // point to the node before the sublist [m, n] ListNode * tail = prev -> next ; // will be the tail of the sublist [m, n] // reverse the sublist [m, n] one by one for ( int i = 0 ; i < n - m ; ++ i ) { ListNode * cache = tail -> next ; tail -> next = cache -> next ; cache -> next = prev -> next ; prev -> next = cache ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( head == null || m == n ) return head ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev . next ; // point to the node before the sublist [m, n] ListNode tail = prev . next ; // will be the tail of the sublist [m, n] // reverse the sublist [m, n] one by one for ( int i = 0 ; i < n - m ; ++ i ) { ListNode cache = tail . next ; tail . next = cache . next ; cache . next = prev . next ; prev . next = cache ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head","title":"92. Reverse Linked List II"},{"location":"problems/0093/","text":"93. Restore IP Addresses Time: $O(3^4)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < string > restoreIpAddresses ( const string & s ) { vector < string > ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int start ) { if ( path . size () == 4 && start == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( path . size () == 4 || start == s . length ()) return ; for ( int length = 1 ; length <= 3 ; ++ length ) { if ( start + length > s . length ()) return ; // out of bound if ( length > 1 && s [ start ] == '0' ) return ; // leading '0' const string & num = s . substr ( start , length ); if ( stoi ( num ) > 255 ) return ; path . push_back ( num ); dfs ( start + length ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < String > restoreIpAddresses ( final String s ) { List < String > ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int start , List < String > path , List < String > ans ) { if ( path . size () == 4 && start == s . length ()) { ans . add ( String . join ( \".\" , path )); return ; } if ( path . size () == 4 || start == s . length ()) return ; for ( int length = 1 ; length <= 3 ; ++ length ) { if ( start + length > s . length ()) // out of bound return ; if ( length > 1 && s . charAt ( start ) == '0' ) // leading '0' return ; final String num = s . substring ( start , start + length ); if ( Integer . parseInt ( num ) > 255 ) return ; path . add ( num ); dfs ( s , start + length , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: def dfs ( index : int , path : List [ str ]): if len ( path ) == 4 and index == len ( s ): ans . append ( path [ 0 ] + '.' + path [ 1 ] + '.' + path [ 2 ] + '.' + path [ 3 ]) return if len ( path ) == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return num = s [ index : index + i ] if int ( num ) > 255 : return dfs ( index + i , path + [ num ]) ans = [] dfs ( 0 , []) return ans","title":"93. Restore IP Addresses"},{"location":"problems/0093/#93-restore-ip-addresses","text":"Time: $O(3^4)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < string > restoreIpAddresses ( const string & s ) { vector < string > ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int start ) { if ( path . size () == 4 && start == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( path . size () == 4 || start == s . length ()) return ; for ( int length = 1 ; length <= 3 ; ++ length ) { if ( start + length > s . length ()) return ; // out of bound if ( length > 1 && s [ start ] == '0' ) return ; // leading '0' const string & num = s . substr ( start , length ); if ( stoi ( num ) > 255 ) return ; path . push_back ( num ); dfs ( start + length ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < String > restoreIpAddresses ( final String s ) { List < String > ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int start , List < String > path , List < String > ans ) { if ( path . size () == 4 && start == s . length ()) { ans . add ( String . join ( \".\" , path )); return ; } if ( path . size () == 4 || start == s . length ()) return ; for ( int length = 1 ; length <= 3 ; ++ length ) { if ( start + length > s . length ()) // out of bound return ; if ( length > 1 && s . charAt ( start ) == '0' ) // leading '0' return ; final String num = s . substring ( start , start + length ); if ( Integer . parseInt ( num ) > 255 ) return ; path . add ( num ); dfs ( s , start + length , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: def dfs ( index : int , path : List [ str ]): if len ( path ) == 4 and index == len ( s ): ans . append ( path [ 0 ] + '.' + path [ 1 ] + '.' + path [ 2 ] + '.' + path [ 3 ]) return if len ( path ) == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return num = s [ index : index + i ] if int ( num ) > 255 : return dfs ( index + i , path + [ num ]) ans = [] dfs ( 0 , []) return ans","title":"93. Restore IP Addresses"},{"location":"problems/0094/","text":"94. Binary Tree Inorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; while ( root || ! stack . empty ()) { while ( root ) { stack . push ( root ); root = root -> left ; } root = stack . top (), stack . pop (); ans . push_back ( root -> val ); root = root -> right ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); while ( root != null || ! stack . isEmpty ()) { while ( root != null ) { stack . push ( root ); root = root . left ; } root = stack . pop (); ans . add ( root . val ); root = root . right ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans","title":"94. Binary Tree Inorder Traversal"},{"location":"problems/0094/#94-binary-tree-inorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; while ( root || ! stack . empty ()) { while ( root ) { stack . push ( root ); root = root -> left ; } root = stack . top (), stack . pop (); ans . push_back ( root -> val ); root = root -> right ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); while ( root != null || ! stack . isEmpty ()) { while ( root != null ) { stack . push ( root ); root = root . left ; } root = stack . pop (); ans . add ( root . val ); root = root . right ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans","title":"94. Binary Tree Inorder Traversal"},{"location":"problems/0095/","text":"95. Unique Binary Search Trees II Time: $O(3^n)$ Space: $O(3^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return generateTrees ( 1 , n ); } private : vector < TreeNode *> generateTrees ( int min , int max ) { if ( min > max ) return { nullptr }; vector < TreeNode *> ans ; for ( int i = min ; i <= max ; ++ i ) for ( TreeNode * left : generateTrees ( min , i - 1 )) for ( TreeNode * right : generateTrees ( i + 1 , max )) { ans . push_back ( new TreeNode ( i )); ans . back () -> left = left ; ans . back () -> right = right ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < TreeNode > generateTrees ( int n ) { if ( n == 0 ) return new ArrayList <> (); return generateTrees ( 1 , n ); } private List < TreeNode > generateTrees ( int min , int max ) { if ( min > max ) return Arrays . asList (( TreeNode ) null ); List < TreeNode > ans = new ArrayList <> (); for ( int i = min ; i <= max ; ++ i ) for ( TreeNode left : generateTrees ( min , i - 1 )) for ( TreeNode right : generateTrees ( i + 1 , max )) { ans . add ( new TreeNode ( i )); ans . get ( ans . size () - 1 ). left = left ; ans . get ( ans . size () - 1 ). right = right ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans","title":"95. Unique Binary Search Trees II"},{"location":"problems/0095/#95-unique-binary-search-trees-ii","text":"Time: $O(3^n)$ Space: $O(3^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return generateTrees ( 1 , n ); } private : vector < TreeNode *> generateTrees ( int min , int max ) { if ( min > max ) return { nullptr }; vector < TreeNode *> ans ; for ( int i = min ; i <= max ; ++ i ) for ( TreeNode * left : generateTrees ( min , i - 1 )) for ( TreeNode * right : generateTrees ( i + 1 , max )) { ans . push_back ( new TreeNode ( i )); ans . back () -> left = left ; ans . back () -> right = right ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < TreeNode > generateTrees ( int n ) { if ( n == 0 ) return new ArrayList <> (); return generateTrees ( 1 , n ); } private List < TreeNode > generateTrees ( int min , int max ) { if ( min > max ) return Arrays . asList (( TreeNode ) null ); List < TreeNode > ans = new ArrayList <> (); for ( int i = min ; i <= max ; ++ i ) for ( TreeNode left : generateTrees ( min , i - 1 )) for ( TreeNode right : generateTrees ( i + 1 , max )) { ans . add ( new TreeNode ( i )); ans . get ( ans . size () - 1 ). left = left ; ans . get ( ans . size () - 1 ). right = right ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans","title":"95. Unique Binary Search Trees II"},{"location":"problems/0096/","text":"96. Unique Binary Search Trees Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); // G[i] := # of unique BST's that store values 1..i G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int numTrees ( int n ) { int [] G = new int [ n + 1 ] ; // G[i] := # of unique BST's that store values 1..i G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ] ; return G [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ]","title":"96. Unique Binary Search Trees"},{"location":"problems/0096/#96-unique-binary-search-trees","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); // G[i] := # of unique BST's that store values 1..i G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int numTrees ( int n ) { int [] G = new int [ n + 1 ] ; // G[i] := # of unique BST's that store values 1..i G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ] ; return G [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ]","title":"96. Unique Binary Search Trees"},{"location":"problems/0097/","text":"97. Interleaving String Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { const int m = s1 . length (); const int n = s2 . length (); if ( m + n != s3 . length ()) return false ; // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of // s1[0..i) and s2[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] && s1 [ i - 1 ] == s3 [ i - 1 ]; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && s2 [ j - 1 ] == s3 [ j - 1 ]; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ] || dp [ i ][ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isInterleave ( String s1 , String s2 , String s3 ) { final int m = s1 . length (); final int n = s2 . length (); if ( m + n != s3 . length ()) return false ; // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of // s1[0..i) and s2[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i - 1 ); for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( j - 1 ); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) || dp [ i ][ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )] Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { const int m = s1 . length (); const int n = s2 . length (); if ( m + n != s3 . length ()) return false ; vector < bool > dp ( n + 1 ); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i - 1 ]; else dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ] || dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isInterleave ( String s1 , String s2 , String s3 ) { final int m = s1 . length (); final int n = s2 . length (); if ( m + n != s3 . length ()) return false ; boolean [] dp = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( j - 1 ); else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i - 1 ); else dp [ j ] = dp [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) || dp [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ); return dp [ n ] ; } }","title":"97. Interleaving String"},{"location":"problems/0097/#97-interleaving-string","text":"","title":"97. Interleaving String"},{"location":"problems/0097/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { const int m = s1 . length (); const int n = s2 . length (); if ( m + n != s3 . length ()) return false ; // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of // s1[0..i) and s2[0..j) vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] && s1 [ i - 1 ] == s3 [ i - 1 ]; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && s2 [ j - 1 ] == s3 [ j - 1 ]; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ] || dp [ i ][ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isInterleave ( String s1 , String s2 , String s3 ) { final int m = s1 . length (); final int n = s2 . length (); if ( m + n != s3 . length ()) return false ; // dp[i][j] := true if s3[0..i + j) is formed by the interleaving of // s1[0..i) and s2[0..j) boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i - 1 ); for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( j - 1 ); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) || dp [ i ][ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )]","title":"Approach 1: 2D DP"},{"location":"problems/0097/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { const int m = s1 . length (); const int n = s2 . length (); if ( m + n != s3 . length ()) return false ; vector < bool > dp ( n + 1 ); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i - 1 ]; else dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ] || dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isInterleave ( String s1 , String s2 , String s3 ) { final int m = s1 . length (); final int n = s2 . length (); if ( m + n != s3 . length ()) return false ; boolean [] dp = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( j - 1 ); else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i - 1 ); else dp [ j ] = dp [ j ] && s1 . charAt ( i - 1 ) == s3 . charAt ( i + j - 1 ) || dp [ j - 1 ] && s2 . charAt ( j - 1 ) == s3 . charAt ( i + j - 1 ); return dp [ n ] ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0098/","text":"98. Validate Binary Search Tree Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isValidBST ( TreeNode * root ) { return dfs ( root , nullptr , nullptr ); } private : bool dfs ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && minNode -> val >= root -> val || maxNode && maxNode -> val <= root -> val ) return false ; return dfs ( root -> left , minNode , root ) && dfs ( root -> right , root , maxNode ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isValidBST ( TreeNode root ) { return dfs ( root , null , null ); } private boolean dfs ( TreeNode root , TreeNode minNode , TreeNode maxNode ) { if ( root == null ) return true ; if ( minNode != null && minNode . val >= root . val || maxNode != null && maxNode . val <= root . val ) return false ; return dfs ( root . left , minNode , root ) && dfs ( root . right , root , maxNode ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isValidBST ( self , root : TreeNode ) -> bool : def dfs ( root : TreeNode , minNode : TreeNode , maxNode : TreeNode ): if not root : return True if minNode and minNode . val >= root . val or \\ maxNode and maxNode . val <= root . val : return False return dfs ( root . left , minNode , root ) and \\ dfs ( root . right , root , maxNode ) return dfs ( root , None , None )","title":"98. Validate Binary Search Tree"},{"location":"problems/0098/#98-validate-binary-search-tree","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isValidBST ( TreeNode * root ) { return dfs ( root , nullptr , nullptr ); } private : bool dfs ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && minNode -> val >= root -> val || maxNode && maxNode -> val <= root -> val ) return false ; return dfs ( root -> left , minNode , root ) && dfs ( root -> right , root , maxNode ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isValidBST ( TreeNode root ) { return dfs ( root , null , null ); } private boolean dfs ( TreeNode root , TreeNode minNode , TreeNode maxNode ) { if ( root == null ) return true ; if ( minNode != null && minNode . val >= root . val || maxNode != null && maxNode . val <= root . val ) return false ; return dfs ( root . left , minNode , root ) && dfs ( root . right , root , maxNode ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isValidBST ( self , root : TreeNode ) -> bool : def dfs ( root : TreeNode , minNode : TreeNode , maxNode : TreeNode ): if not root : return True if minNode and minNode . val >= root . val or \\ maxNode and maxNode . val <= root . val : return False return dfs ( root . left , minNode , root ) and \\ dfs ( root . right , root , maxNode ) return dfs ( root , None , None )","title":"98. Validate Binary Search Tree"},{"location":"problems/0099/","text":"99. Recover Binary Search Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : void recoverTree ( TreeNode * root ) { inorder ( root ); const int temp = first -> val ; first -> val = second -> val ; second -> val = temp ; } private : TreeNode * pred = new TreeNode ( INT_MIN ); TreeNode * first ; TreeNode * second ; void inorder ( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( ! first && pred -> val > root -> val ) first = pred ; if ( first && pred -> val > root -> val ) second = root ; pred = root ; inorder ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public void recoverTree ( TreeNode root ) { inorder ( root ); final int temp = first . val ; first . val = second . val ; second . val = temp ; } private TreeNode pred = new TreeNode ( Integer . MIN_VALUE ); private TreeNode first = null ; private TreeNode second = null ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ); if ( first == null && pred . val > root . val ) first = pred ; if ( first != null && pred . val > root . val ) second = root ; pred = root ; inorder ( root . right ); } }","title":"99. Recover Binary Search Tree"},{"location":"problems/0099/#99-recover-binary-search-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : void recoverTree ( TreeNode * root ) { inorder ( root ); const int temp = first -> val ; first -> val = second -> val ; second -> val = temp ; } private : TreeNode * pred = new TreeNode ( INT_MIN ); TreeNode * first ; TreeNode * second ; void inorder ( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( ! first && pred -> val > root -> val ) first = pred ; if ( first && pred -> val > root -> val ) second = root ; pred = root ; inorder ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public void recoverTree ( TreeNode root ) { inorder ( root ); final int temp = first . val ; first . val = second . val ; second . val = temp ; } private TreeNode pred = new TreeNode ( Integer . MIN_VALUE ); private TreeNode first = null ; private TreeNode second = null ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ); if ( first == null && pred . val > root . val ) first = pred ; if ( first != null && pred . val > root . val ) second = root ; pred = root ; inorder ( root . right ); } }","title":"99. Recover Binary Search Tree"},{"location":"problems/0100/","text":"100. Same Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } }; Java 1 2 3 4 5 6 7 8 class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ); } } Python 1 2 3 4 5 6 7 8 class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"100. Same Tree"},{"location":"problems/0100/#100-same-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } }; Java 1 2 3 4 5 6 7 8 class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ); } } Python 1 2 3 4 5 6 7 8 class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"100. Same Tree"},{"location":"problems/0101/","text":"101. Symmetric Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isSymmetric ( TreeNode * root ) { return isSymmetric ( root , root ); } private : bool isSymmetric ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSymmetric ( p -> left , q -> right ) && isSymmetric ( p -> right , q -> left ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isSymmetric ( TreeNode root ) { return isSymmetric ( root , root ); } private boolean isSymmetric ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSymmetric ( p . left , q . right ) && isSymmetric ( p . right , q . left ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : def helper ( p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ helper ( p . left , q . right ) and \\ helper ( p . right , q . left ) return helper ( root , root )","title":"101. Symmetric Tree"},{"location":"problems/0101/#101-symmetric-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isSymmetric ( TreeNode * root ) { return isSymmetric ( root , root ); } private : bool isSymmetric ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSymmetric ( p -> left , q -> right ) && isSymmetric ( p -> right , q -> left ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isSymmetric ( TreeNode root ) { return isSymmetric ( root , root ); } private boolean isSymmetric ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSymmetric ( p . left , q . right ) && isSymmetric ( p . right , q . left ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : def helper ( p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ helper ( p . left , q . right ) and \\ helper ( p . right , q . left ) return helper ( root , root )","title":"101. Symmetric Tree"},{"location":"problems/0102/","text":"102. Binary Tree Level Order Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( currLevel ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> levelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } ans . add ( currLevel ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans","title":"102. Binary Tree Level Order Traversal"},{"location":"problems/0102/#102-binary-tree-level-order-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( currLevel ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> levelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } ans . add ( currLevel ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans","title":"102. Binary Tree Level Order Traversal"},{"location":"problems/0103/","text":"103. Binary Tree Zigzag Level Order Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> q {{ root }}; bool isLeftToRight = true ; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = q . front (), q . pop_front (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push_back ( root -> left ); if ( root -> right ) q . push_back ( root -> right ); } else { root = q . back (), q . pop_back (); currLevel . push_back ( root -> val ); if ( root -> right ) q . push_front ( root -> right ); if ( root -> left ) q . push_front ( root -> left ); } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> zigzagLevelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Deque < TreeNode > q = new ArrayDeque <> (); q . addLast ( root ); boolean isLeftToRight = true ; while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = q . pollFirst (); currLevel . add ( root . val ); if ( root . left != null ) q . addLast ( root . left ); if ( root . right != null ) q . addLast ( root . right ); } else { root = q . pollLast (); currLevel . add ( root . val ); if ( root . right != null ) q . addFirst ( root . right ); if ( root . left != null ) q . addFirst ( root . left ); } ans . add ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans","title":"103. Binary Tree Zigzag Level Order Traversal"},{"location":"problems/0103/#103-binary-tree-zigzag-level-order-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> q {{ root }}; bool isLeftToRight = true ; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = q . front (), q . pop_front (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push_back ( root -> left ); if ( root -> right ) q . push_back ( root -> right ); } else { root = q . back (), q . pop_back (); currLevel . push_back ( root -> val ); if ( root -> right ) q . push_front ( root -> right ); if ( root -> left ) q . push_front ( root -> left ); } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> zigzagLevelOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Deque < TreeNode > q = new ArrayDeque <> (); q . addLast ( root ); boolean isLeftToRight = true ; while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = q . pollFirst (); currLevel . add ( root . val ); if ( root . left != null ) q . addLast ( root . left ); if ( root . right != null ) q . addLast ( root . right ); } else { root = q . pollLast (); currLevel . add ( root . val ); if ( root . right != null ) q . addFirst ( root . right ); if ( root . left != null ) q . addFirst ( root . left ); } ans . add ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans","title":"103. Binary Tree Zigzag Level Order Traversal"},{"location":"problems/0104/","text":"104. Maximum Depth of Binary Tree Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Java 1 2 3 4 5 6 7 8 class Solution { public int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } } Python 1 2 3 4 5 6 class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"104. Maximum Depth of Binary Tree"},{"location":"problems/0104/#104-maximum-depth-of-binary-tree","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Java 1 2 3 4 5 6 7 8 class Solution { public int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } } Python 1 2 3 4 5 6 class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"104. Maximum Depth of Binary Tree"},{"location":"problems/0105/","text":"105. Construct Binary Tree from Preorder and Inorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int pL , int pR , int iL , int iR ) -> TreeNode * { if ( pL > pR ) return nullptr ; const int i = inorderToIndex [ preorder [ pL ]]; TreeNode * curr = new TreeNode ( preorder [ pL ]); curr -> left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ); curr -> right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ); return curr ; }; return helper ( 0 , preorder . size () - 1 , 0 , inorder . size () - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] preorder , int pL , int pR , int [] inorder , int iL , int iR , Map < Integer , Integer > inorderToIndex ) { if ( pL > pR ) return null ; final int i = inorderToIndex . get ( preorder [ pL ] ); TreeNode curr = new TreeNode ( preorder [ pL ] ); curr . left = helper ( preorder , pL + 1 , pL + i - iL , inorder , iL , i - 1 , inorderToIndex ); curr . right = helper ( preorder , pL + i - iL + 1 , pR , inorder , i + 1 , iR , inorderToIndex ); return curr ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pL : int , pR : int , iL : int , iR : int ) -> TreeNode : if pL > pR : return None i = inorderToIndex [ preorder [ pL ]] curr = TreeNode ( preorder [ pL ]) curr . left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ) curr . right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 )","title":"105. Construct Binary Tree from Preorder and Inorder Traversal"},{"location":"problems/0105/#105-construct-binary-tree-from-preorder-and-inorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int pL , int pR , int iL , int iR ) -> TreeNode * { if ( pL > pR ) return nullptr ; const int i = inorderToIndex [ preorder [ pL ]]; TreeNode * curr = new TreeNode ( preorder [ pL ]); curr -> left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ); curr -> right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ); return curr ; }; return helper ( 0 , preorder . size () - 1 , 0 , inorder . size () - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] preorder , int pL , int pR , int [] inorder , int iL , int iR , Map < Integer , Integer > inorderToIndex ) { if ( pL > pR ) return null ; final int i = inorderToIndex . get ( preorder [ pL ] ); TreeNode curr = new TreeNode ( preorder [ pL ] ); curr . left = helper ( preorder , pL + 1 , pL + i - iL , inorder , iL , i - 1 , inorderToIndex ); curr . right = helper ( preorder , pL + i - iL + 1 , pR , inorder , i + 1 , iR , inorderToIndex ); return curr ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pL : int , pR : int , iL : int , iR : int ) -> TreeNode : if pL > pR : return None i = inorderToIndex [ preorder [ pL ]] curr = TreeNode ( preorder [ pL ]) curr . left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ) curr . right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 )","title":"105. Construct Binary Tree from Preorder and Inorder Traversal"},{"location":"problems/0106/","text":"106. Construct Binary Tree from Inorder and Postorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int iL , int iR , int pL , int pR ) -> TreeNode * { if ( iL > iR ) return nullptr ; const int i = inorderToIndex [ postorder [ pR ]]; TreeNode * curr = new TreeNode ( postorder [ pR ]); curr -> left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ); curr -> right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ); return curr ; }; return helper ( 0 , inorder . size () - 1 , 0 , postorder . size () - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] inorder , int iL , int iR , int [] postorder , int pL , int pR , Map < Integer , Integer > inorderToIndex ) { if ( iL > iR ) return null ; final int i = inorderToIndex . get ( postorder [ pR ] ); TreeNode curr = new TreeNode ( postorder [ pR ] ); curr . left = helper ( inorder , iL , i - 1 , postorder , pL , pL + i - iL - 1 , inorderToIndex ); curr . right = helper ( inorder , i + 1 , iR , postorder , pL + i - iL , pR - 1 , inorderToIndex ); return curr ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iL : int , iR : int , pL : int , pR : int ) -> TreeNode : if iL > iR : return None i = inorderToIndex [ postorder [ pR ]] curr = TreeNode ( postorder [ pR ]) curr . left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ) curr . right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 )","title":"106. Construct Binary Tree from Inorder and Postorder Traversal"},{"location":"problems/0106/#106-construct-binary-tree-from-inorder-and-postorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int iL , int iR , int pL , int pR ) -> TreeNode * { if ( iL > iR ) return nullptr ; const int i = inorderToIndex [ postorder [ pR ]]; TreeNode * curr = new TreeNode ( postorder [ pR ]); curr -> left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ); curr -> right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ); return curr ; }; return helper ( 0 , inorder . size () - 1 , 0 , postorder . size () - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] inorder , int iL , int iR , int [] postorder , int pL , int pR , Map < Integer , Integer > inorderToIndex ) { if ( iL > iR ) return null ; final int i = inorderToIndex . get ( postorder [ pR ] ); TreeNode curr = new TreeNode ( postorder [ pR ] ); curr . left = helper ( inorder , iL , i - 1 , postorder , pL , pL + i - iL - 1 , inorderToIndex ); curr . right = helper ( inorder , i + 1 , iR , postorder , pL + i - iL , pR - 1 , inorderToIndex ); return curr ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iL : int , iR : int , pL : int , pR : int ) -> TreeNode : if iL > iR : return None i = inorderToIndex [ postorder [ pR ]] curr = TreeNode ( postorder [ pR ]) curr . left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ) curr . right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 )","title":"106. Construct Binary Tree from Inorder and Postorder Traversal"},{"location":"problems/0107/","text":"107. Binary Tree Level Order Traversal II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( currLevel ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> levelOrderBottom ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } ans . add ( currLevel ); } Collections . reverse ( ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans","title":"107. Binary Tree Level Order Traversal II"},{"location":"problems/0107/#107-binary-tree-level-order-traversal-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( currLevel ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> levelOrderBottom ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } ans . add ( currLevel ); } Collections . reverse ( ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans","title":"107. Binary Tree Level Order Traversal II"},{"location":"problems/0108/","text":"108. Convert Sorted Array to Binary Search Tree Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return nullptr ; const int m = l + ( r - l ) / 2 ; TreeNode * root = new TreeNode ( nums [ m ]); root -> left = helper ( nums , l , m - 1 ); root -> right = helper ( nums , m + 1 , r ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode sortedArrayToBST ( int [] nums ) { return helper ( nums , 0 , nums . length - 1 ); } private TreeNode helper ( int nums [] , int l , int r ) { if ( l > r ) return null ; final int m = l + ( r - l ) / 2 ; TreeNode root = new TreeNode ( nums [ m ] ); root . left = helper ( nums , l , m - 1 ); root . right = helper ( nums , m + 1 , r ); return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : def helper ( l : int , r : int ) -> TreeNode : if l > r : return None m = ( l + r ) // 2 root = TreeNode ( nums [ m ]) root . left = helper ( l , m - 1 ) root . right = helper ( m + 1 , r ) return root return helper ( 0 , len ( nums ) - 1 )","title":"108. Convert Sorted Array to Binary Search Tree"},{"location":"problems/0108/#108-convert-sorted-array-to-binary-search-tree","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return nullptr ; const int m = l + ( r - l ) / 2 ; TreeNode * root = new TreeNode ( nums [ m ]); root -> left = helper ( nums , l , m - 1 ); root -> right = helper ( nums , m + 1 , r ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode sortedArrayToBST ( int [] nums ) { return helper ( nums , 0 , nums . length - 1 ); } private TreeNode helper ( int nums [] , int l , int r ) { if ( l > r ) return null ; final int m = l + ( r - l ) / 2 ; TreeNode root = new TreeNode ( nums [ m ] ); root . left = helper ( nums , l , m - 1 ); root . right = helper ( nums , m + 1 , r ); return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : def helper ( l : int , r : int ) -> TreeNode : if l > r : return None m = ( l + r ) // 2 root = TreeNode ( nums [ m ]) root . left = helper ( l , m - 1 ) root . right = helper ( m + 1 , r ) return root return helper ( 0 , len ( nums ) - 1 )","title":"108. Convert Sorted Array to Binary Search Tree"},{"location":"problems/0109/","text":"109. Convert Sorted List to Binary Search Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { if ( ! head ) return nullptr ; if ( ! head -> next ) return new TreeNode ( head -> val ); ListNode * mid = findMid ( head ); TreeNode * root = new TreeNode ( mid -> val ); root -> left = sortedListToBST ( head ); root -> right = sortedListToBST ( mid -> next ); return root ; } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public TreeNode sortedListToBST ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return new TreeNode ( head . val ); ListNode mid = findMid ( head ); TreeNode root = new TreeNode ( mid . val ); root . left = sortedListToBST ( head ); root . right = sortedListToBST ( mid . next ); return root ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def findMid ( head : ListNode ) -> ListNode : prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow if not head : return None if not head . next : return TreeNode ( head . val ) mid = findMid ( head ) root = TreeNode ( mid . val ) root . left = self . sortedListToBST ( head ) root . right = self . sortedListToBST ( mid . next ) return root","title":"109. Convert Sorted List to Binary Search Tree"},{"location":"problems/0109/#109-convert-sorted-list-to-binary-search-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { if ( ! head ) return nullptr ; if ( ! head -> next ) return new TreeNode ( head -> val ); ListNode * mid = findMid ( head ); TreeNode * root = new TreeNode ( mid -> val ); root -> left = sortedListToBST ( head ); root -> right = sortedListToBST ( mid -> next ); return root ; } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public TreeNode sortedListToBST ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return new TreeNode ( head . val ); ListNode mid = findMid ( head ); TreeNode root = new TreeNode ( mid . val ); root . left = sortedListToBST ( head ); root . right = sortedListToBST ( mid . next ); return root ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def findMid ( head : ListNode ) -> ListNode : prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow if not head : return None if not head . next : return TreeNode ( head . val ) mid = findMid ( head ) root = TreeNode ( mid . val ) root . left = self . sortedListToBST ( head ) root . right = self . sortedListToBST ( mid . next ) return root","title":"109. Convert Sorted List to Binary Search Tree"},{"location":"problems/0110/","text":"110. Balanced Binary Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isBalanced ( TreeNode root ) { if ( root == null ) return true ; return Math . abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 && isBalanced ( root . left ) && isBalanced ( root . right ); } private int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isBalanced ( self , root : TreeNode ) -> bool : def maxDepth ( root : TreeNode ) -> int : if not root : return 0 return 1 + max ( maxDepth ( root . left ), maxDepth ( root . right )) if not root : return True return abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and self . isBalanced ( root . right )","title":"110. Balanced Binary Tree"},{"location":"problems/0110/#110-balanced-binary-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isBalanced ( TreeNode root ) { if ( root == null ) return true ; return Math . abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 && isBalanced ( root . left ) && isBalanced ( root . right ); } private int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isBalanced ( self , root : TreeNode ) -> bool : def maxDepth ( root : TreeNode ) -> int : if not root : return 0 return 1 + max ( maxDepth ( root . left ), maxDepth ( root . right )) if not root : return True return abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and self . isBalanced ( root . right )","title":"110. Balanced Binary Tree"},{"location":"problems/0111/","text":"111. Minimum Depth of Binary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); if ( ! root -> left && ! root -> right ) return ans ; if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { TreeNode node = q . poll (); if ( node . left == null && node . right == null ) return ans ; if ( node . left != null ) q . offer ( node . left ); if ( node . right != null ) q . offer ( node . right ); } } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right )","title":"111. Minimum Depth of Binary Tree"},{"location":"problems/0111/#111-minimum-depth-of-binary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); if ( ! root -> left && ! root -> right ) return ans ; if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { TreeNode node = q . poll (); if ( node . left == null && node . right == null ) return ans ; if ( node . left != null ) q . offer ( node . left ); if ( node . right != null ) q . offer ( node . right ); } } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right )","title":"111. Minimum Depth of Binary Tree"},{"location":"problems/0112/","text":"112. Path Sum Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean hasPathSum ( TreeNode root , int sum ) { if ( root == null ) return false ; if ( root . val == sum && root . left == null && root . right == null ) return true ; return hasPathSum ( root . left , sum - root . val ) || hasPathSum ( root . right , sum - root . val ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val )","title":"112. Path Sum"},{"location":"problems/0112/#112-path-sum","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean hasPathSum ( TreeNode root , int sum ) { if ( root == null ) return false ; if ( root . val == sum && root . left == null && root . right == null ) return true ; return hasPathSum ( root . left , sum - root . val ) || hasPathSum ( root . right , sum - root . val ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val )","title":"112. Path Sum"},{"location":"problems/0113/","text":"113. Path Sum II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int sum ) { if ( ! root ) return ; if ( root -> val == sum && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val ); dfs ( root -> right , sum - root -> val ); path . pop_back (); }; dfs ( root , sum ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> pathSum ( TreeNode root , int sum ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( root , sum , new ArrayList <> (), ans ); return ans ; } private void dfs ( TreeNode root , int sum , List < Integer > path , List < List < Integer >> ans ) { if ( root == null ) return ; if ( root . val == sum && root . left == null && root . right == null ) { path . add ( root . val ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); return ; } path . add ( root . val ); dfs ( root . left , sum - root . val , path , ans ); dfs ( root . right , sum - root . val , path , ans ); path . remove ( path . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: def dfs ( root : TreeNode , sum : int , path : List [ int ]) -> None : if root is None : return if root . val == sum and root . left is None and root . right is None : ans . append ( path + [ root . val ]) return dfs ( root . left , sum - root . val , path + [ root . val ]) dfs ( root . right , sum - root . val , path + [ root . val ]) ans = [] dfs ( root , sum , []) return ans","title":"113. Path Sum II"},{"location":"problems/0113/#113-path-sum-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int sum ) { if ( ! root ) return ; if ( root -> val == sum && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val ); dfs ( root -> right , sum - root -> val ); path . pop_back (); }; dfs ( root , sum ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> pathSum ( TreeNode root , int sum ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( root , sum , new ArrayList <> (), ans ); return ans ; } private void dfs ( TreeNode root , int sum , List < Integer > path , List < List < Integer >> ans ) { if ( root == null ) return ; if ( root . val == sum && root . left == null && root . right == null ) { path . add ( root . val ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); return ; } path . add ( root . val ); dfs ( root . left , sum - root . val , path , ans ); dfs ( root . right , sum - root . val , path , ans ); path . remove ( path . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: def dfs ( root : TreeNode , sum : int , path : List [ int ]) -> None : if root is None : return if root . val == sum and root . left is None and root . right is None : ans . append ( path + [ root . val ]) return dfs ( root . left , sum - root . val , path + [ root . val ]) dfs ( root . right , sum - root . val , path + [ root . val ]) ans = [] dfs ( root , sum , []) return ans","title":"113. Path Sum II"},{"location":"problems/0114/","text":"114. Flatten Binary Tree to Linked List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); if ( ! stack . empty ()) root -> right = stack . top (); root -> left = nullptr ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void flatten ( TreeNode root ) { if ( root == null ) return ; Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); if ( root . right != null ) stack . push ( root . right ); if ( root . left != null ) stack . push ( root . left ); if ( ! stack . isEmpty ()) root . right = stack . peek (); root . left = null ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None","title":"114. Flatten Binary Tree to Linked List"},{"location":"problems/0114/#114-flatten-binary-tree-to-linked-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); if ( ! stack . empty ()) root -> right = stack . top (); root -> left = nullptr ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void flatten ( TreeNode root ) { if ( root == null ) return ; Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); if ( root . right != null ) stack . push ( root . right ); if ( root . left != null ) stack . push ( root . left ); if ( ! stack . isEmpty ()) root . right = stack . peek (); root . left = null ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None","title":"114. Flatten Binary Tree to Linked List"},{"location":"problems/0115/","text":"115. Distinct Subsequences Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int numDistinct ( String s , String t ) { final int m = s . length (); final int n = t . length (); long [][] dp = new long [ m + 1 ][ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] ; return ( int ) dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ] Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < long > dp ( n + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = n ; j >= 1 ; -- j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ j ] += dp [ j - 1 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int numDistinct ( String s , String t ) { final int m = s . length (); final int n = t . length (); long [] dp = new long [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = n ; j >= 1 ; -- j ) if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ j ] += dp [ j - 1 ] ; return ( int ) dp [ n ] ; } }","title":"115. Distinct Subsequences"},{"location":"problems/0115/#115-distinct-subsequences","text":"","title":"115. Distinct Subsequences"},{"location":"problems/0115/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int numDistinct ( String s , String t ) { final int m = s . length (); final int n = t . length (); long [][] dp = new long [ m + 1 ][ n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] ; return ( int ) dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ]","title":"Approach 1: 2D DP"},{"location":"problems/0115/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < long > dp ( n + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = n ; j >= 1 ; -- j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ j ] += dp [ j - 1 ]; return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int numDistinct ( String s , String t ) { final int m = s . length (); final int n = t . length (); long [] dp = new long [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = n ; j >= 1 ; -- j ) if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 )) dp [ j ] += dp [ j - 1 ] ; return ( int ) dp [ n ] ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0116/","text":"116. Populating Next Right Pointers in Each Node Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : nullptr ; node = node -> next ; } node = next ; } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public Node connect ( Node root ) { Node node = root ; while ( node != null && node . left != null ) { Node next = node . left ; while ( node != null ) { node . left . next = node . right ; node . right . next = node . next == null ? null : node . next . left ; node = node . next ; } node = next ; } return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : cached = node . left while node : node . left . next = node . right node . right . next = node . next . left if node . next else None node = node . next node = cached return root","title":"116. Populating Next Right Pointers in Each Node"},{"location":"problems/0116/#116-populating-next-right-pointers-in-each-node","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : nullptr ; node = node -> next ; } node = next ; } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public Node connect ( Node root ) { Node node = root ; while ( node != null && node . left != null ) { Node next = node . left ; while ( node != null ) { node . left . next = node . right ; node . right . next = node . next == null ? null : node . next . left ; node = node . next ; } node = next ; } return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : cached = node . left while node : node . left . next = node . right node . right . next = node . next . left if node . next else None node = node . next node = cached return root","title":"116. Populating Next Right Pointers in Each Node"},{"location":"problems/0117/","text":"117. Populating Next Right Pointers in Each Node II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * cache = new Node ; while ( node ) { Node * curr = cache ; while ( node ) { if ( node -> left ) { curr -> next = node -> left ; curr = curr -> next ; } if ( node -> right ) { curr -> next = node -> right ; curr = curr -> next ; } node = node -> next ; } node = cache -> next ; cache -> next = nullptr ; } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public Node connect ( Node root ) { Node node = root ; Node cache = new Node ( 0 ); while ( node != null ) { Node curr = cache ; while ( node != null ) { if ( node . left != null ) { curr . next = node . left ; curr = curr . next ; } if ( node . right != null ) { curr . next = node . right ; curr = curr . next ; } node = node . next ; } node = cache . next ; cache . next = null ; } return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root cached = Node ( 0 ) while node : curr = cached while node : if node . left : curr . next = node . left curr = curr . next if node . right : curr . next = node . right curr = curr . next node = node . next node = cached . next cached . next = None return root","title":"117. Populating Next Right Pointers in Each Node II"},{"location":"problems/0117/#117-populating-next-right-pointers-in-each-node-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * cache = new Node ; while ( node ) { Node * curr = cache ; while ( node ) { if ( node -> left ) { curr -> next = node -> left ; curr = curr -> next ; } if ( node -> right ) { curr -> next = node -> right ; curr = curr -> next ; } node = node -> next ; } node = cache -> next ; cache -> next = nullptr ; } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public Node connect ( Node root ) { Node node = root ; Node cache = new Node ( 0 ); while ( node != null ) { Node curr = cache ; while ( node != null ) { if ( node . left != null ) { curr . next = node . left ; curr = curr . next ; } if ( node . right != null ) { curr . next = node . right ; curr = curr . next ; } node = node . next ; } node = cache . next ; cache . next = null ; } return root ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root cached = Node ( 0 ) while node : curr = cached while node : if node . left : curr . next = node . left curr = curr . next if node . right : curr . next = node . right curr = curr . next node = node . next node = cached . next cached . next = None return root","title":"117. Populating Next Right Pointers in Each Node II"},{"location":"problems/0118/","text":"118. Pascal's Triangle Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 ; i < numRows ; ++ i ) { Integer [] temp = new Integer [ i + 1 ] ; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; ++ j ) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans","title":"118. Pascal's Triangle"},{"location":"problems/0118/#118-pascals-triangle","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 ; i < numRows ; ++ i ) { Integer [] temp = new Integer [ i + 1 ] ; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; ++ j ) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans","title":"118. Pascal's Triangle"},{"location":"problems/0119/","text":"119. Pascal's Triangle II Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ] ; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ] ; return Arrays . asList ( ans ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans","title":"119. Pascal's Triangle II"},{"location":"problems/0119/#119-pascals-triangle-ii","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ] ; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ] ; return Arrays . asList ( ans ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans","title":"119. Pascal's Triangle II"},{"location":"problems/0120/","text":"120. Triangle Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"120. Triangle"},{"location":"problems/0120/#120-triangle","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"120. Triangle"},{"location":"problems/0121/","text":"121. Best Time to Buy and Sell Stock Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne","title":"121. Best Time to Buy and Sell Stock"},{"location":"problems/0121/#121-best-time-to-buy-and-sell-stock","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne","title":"121. Best Time to Buy and Sell Stock"},{"location":"problems/0122/","text":"122. Best Time to Buy and Sell Stock II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell","title":"122. Best Time to Buy and Sell Stock II"},{"location":"problems/0122/#122-best-time-to-buy-and-sell-stock-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell","title":"122. Best Time to Buy and Sell Stock II"},{"location":"problems/0123/","text":"123. Best Time to Buy and Sell Stock III Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo","title":"123. Best Time to Buy and Sell Stock III"},{"location":"problems/0123/#123-best-time-to-buy-and-sell-stock-iii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( final int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo","title":"123. Best Time to Buy and Sell Stock III"},{"location":"problems/0124/","text":"124. Binary Tree Maximum Path Sum Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; maxPathSumDownFrom ( root , ans ); return ans ; } private : int maxPathSumDownFrom ( TreeNode * root , int & ans ) { if ( ! root ) return 0 ; const int l = max ( 0 , maxPathSumDownFrom ( root -> left , ans )); const int r = max ( 0 , maxPathSumDownFrom ( root -> right , ans )); ans = max ( ans , root -> val + l + r ); return root -> val + max ( l , r ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxPathSum ( TreeNode root ) { maxPathSumDownFrom ( root ); return ans ; } private int ans = Integer . MIN_VALUE ; private int maxPathSumDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; final int l = Math . max ( maxPathSumDownFrom ( root . left ), 0 ); final int r = Math . max ( maxPathSumDownFrom ( root . right ), 0 ); ans = Math . max ( ans , root . val + l + r ); return root . val + Math . max ( l , r ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxPathSum ( self , root : TreeNode ) -> int : def maxPathSumDownFrom ( root : TreeNode ) -> int : if not root : return 0 left = max ( maxPathSumDownFrom ( root . left ), 0 ) right = max ( maxPathSumDownFrom ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right ) self . ans = float ( '-inf' ) maxPathSumDownFrom ( root ) return self . ans","title":"124. Binary Tree Maximum Path Sum"},{"location":"problems/0124/#124-binary-tree-maximum-path-sum","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; maxPathSumDownFrom ( root , ans ); return ans ; } private : int maxPathSumDownFrom ( TreeNode * root , int & ans ) { if ( ! root ) return 0 ; const int l = max ( 0 , maxPathSumDownFrom ( root -> left , ans )); const int r = max ( 0 , maxPathSumDownFrom ( root -> right , ans )); ans = max ( ans , root -> val + l + r ); return root -> val + max ( l , r ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxPathSum ( TreeNode root ) { maxPathSumDownFrom ( root ); return ans ; } private int ans = Integer . MIN_VALUE ; private int maxPathSumDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; final int l = Math . max ( maxPathSumDownFrom ( root . left ), 0 ); final int r = Math . max ( maxPathSumDownFrom ( root . right ), 0 ); ans = Math . max ( ans , root . val + l + r ); return root . val + Math . max ( l , r ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxPathSum ( self , root : TreeNode ) -> int : def maxPathSumDownFrom ( root : TreeNode ) -> int : if not root : return 0 left = max ( maxPathSumDownFrom ( root . left ), 0 ) right = max ( maxPathSumDownFrom ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right ) self . ans = float ( '-inf' ) maxPathSumDownFrom ( root ) return self . ans","title":"124. Binary Tree Maximum Path Sum"},{"location":"problems/0125/","text":"125. Valid Palindrome Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isPalindrome ( String s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( l ))) ++ l ; while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( r ))) -- r ; if ( Character . toLowerCase ( s . charAt ( l )) != Character . toLowerCase ( s . charAt ( r ))) return false ; ++ l ; -- r ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True","title":"125. Valid Palindrome"},{"location":"problems/0125/#125-valid-palindrome","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isPalindrome ( String s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( l ))) ++ l ; while ( l < r && ! Character . isLetterOrDigit ( s . charAt ( r ))) -- r ; if ( Character . toLowerCase ( s . charAt ( l )) != Character . toLowerCase ( s . charAt ( r ))) return false ; ++ l ; -- r ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True","title":"125. Valid Palindrome"},{"location":"problems/0126/","text":"126. Word Ladder II Approach 1: BFS + DFS Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList| + |paths||word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); if ( ! wordSet . count ( endWord )) return {}; unordered_map < string , vector < string >> parentToChildren ; unordered_set < string > currentLevelWords { beginWord }; bool isFound = false ; while ( ! currentLevelWords . empty ()) { // remove words in current level for ( const string & word : currentLevelWords ) wordSet . erase ( word ); unordered_set < string > nextLevelWords ; // `parent` will be used as a key in `parentToChildren` for ( const string & parent : currentLevelWords ) { string child = parent ; // enumerate next level words for ( int i = 0 ; i < child . length (); ++ i ) { const char cache = child [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { child [ i ] = c ; if ( wordSet . count ( child )) { if ( child == endWord ) isFound = true ; nextLevelWords . insert ( child ); parentToChildren [ parent ]. push_back ( child ); } } child [ i ] = cache ; } } if ( isFound ) break ; currentLevelWords = move ( nextLevelWords ); } if ( ! isFound ) return {}; vector < vector < string >> ans ; vector < string > path { beginWord }; // construct the ans by `parentToChildren` function < void ( const string & ) > dfs = [ & ]( const string & word ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( ! parentToChildren . count ( word )) return ; for ( const string & child : parentToChildren [ word ]) { path . push_back ( child ); dfs ( child ); path . pop_back (); } }; dfs ( beginWord ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet <> ( wordList ); if ( ! wordSet . contains ( endWord )) return new ArrayList <> (); Map < String , List < String >> parentToChildren = new HashMap <> (); Set < String > currentLevelWords = new HashSet <> (); currentLevelWords . add ( beginWord ); boolean isFound = false ; while ( ! currentLevelWords . isEmpty ()) { // remove words in current level for ( final String word : currentLevelWords ) wordSet . remove ( word ); Set < String > nextLevelWords = new HashSet <> (); // `parent` will be used as a key in `parentToChildren` for ( final String parent : currentLevelWords ) { StringBuilder sb = new StringBuilder ( parent ); for ( int i = 0 ; i < sb . length (); ++ i ) { final char cache = sb . charAt ( i ); for ( char c = 'a' ; c <= 'z' ; ++ c ) { sb . setCharAt ( i , c ); final String child = sb . toString (); if ( wordSet . contains ( child )) { if ( child . equals ( endWord )) isFound = true ; nextLevelWords . add ( child ); parentToChildren . computeIfAbsent ( parent , k -> new ArrayList <> ()). add ( child ); } } sb . setCharAt ( i , cache ); } currentLevelWords = nextLevelWords ; } if ( isFound ) break ; } if ( ! isFound ) return new ArrayList <> (); List < List < String >> ans = new ArrayList <> (); List < String > path = new ArrayList <> ( Arrays . asList ( beginWord )); dfs ( parentToChildren , beginWord , endWord , path , ans ); return ans ; } // construct the ans by `parentToChildren` private void dfs ( Map < String , List < String >> parentToChildren , final String word , final String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <> ( path )); return ; } if ( ! parentToChildren . containsKey ( word )) return ; for ( final String child : parentToChildren . get ( word )) { path . add ( child ); dfs ( parentToChildren , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] wordList = set ( wordList ) if endWord not in wordList : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : wordList . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in wordList and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans Approach 2: Pure BFS Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList| + |paths||word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); queue < vector < string >> paths {{{ beginWord }}}; // {{\"hit\"}} while ( ! paths . empty ()) { unordered_set < string > currentLevelVisited ; for ( int i = paths . size (); i > 0 ; -- i ) { vector < string > path = paths . front (); paths . pop (); // {\"hit\"} string lastWord = path . back (); // \"hit\" for ( int i = 0 ; i < lastWord . length (); ++ i ) { char cache = lastWord [ i ]; // cache = 'i' for ( char c = 'a' ; c <= 'z' ; ++ c ) { lastWord [ i ] = c ; // \"hit\" -> \"hot\" (temporarily) if ( wordSet . count ( lastWord )) { // find \"hot\" in wordSet currentLevelVisited . insert ( lastWord ); // mark \"hot\" as visited vector < string > nextPath ( path ); nextPath . push_back ( lastWord ); // nextPath = {\"hit\", \"hot\"} if ( lastWord == endWord ) ans . push_back ( nextPath ); else paths . push ( nextPath ); } } lastWord [ i ] = cache ; // \"hot\" back to \"hit\" } } for ( const string & word : currentLevelVisited ) wordSet . erase ( word ); } return ans ; } };","title":"126. Word Ladder II"},{"location":"problems/0126/#126-word-ladder-ii","text":"","title":"126. Word Ladder II"},{"location":"problems/0126/#approach-1-bfs-dfs","text":"Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList| + |paths||word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); if ( ! wordSet . count ( endWord )) return {}; unordered_map < string , vector < string >> parentToChildren ; unordered_set < string > currentLevelWords { beginWord }; bool isFound = false ; while ( ! currentLevelWords . empty ()) { // remove words in current level for ( const string & word : currentLevelWords ) wordSet . erase ( word ); unordered_set < string > nextLevelWords ; // `parent` will be used as a key in `parentToChildren` for ( const string & parent : currentLevelWords ) { string child = parent ; // enumerate next level words for ( int i = 0 ; i < child . length (); ++ i ) { const char cache = child [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { child [ i ] = c ; if ( wordSet . count ( child )) { if ( child == endWord ) isFound = true ; nextLevelWords . insert ( child ); parentToChildren [ parent ]. push_back ( child ); } } child [ i ] = cache ; } } if ( isFound ) break ; currentLevelWords = move ( nextLevelWords ); } if ( ! isFound ) return {}; vector < vector < string >> ans ; vector < string > path { beginWord }; // construct the ans by `parentToChildren` function < void ( const string & ) > dfs = [ & ]( const string & word ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( ! parentToChildren . count ( word )) return ; for ( const string & child : parentToChildren [ word ]) { path . push_back ( child ); dfs ( child ); path . pop_back (); } }; dfs ( beginWord ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet <> ( wordList ); if ( ! wordSet . contains ( endWord )) return new ArrayList <> (); Map < String , List < String >> parentToChildren = new HashMap <> (); Set < String > currentLevelWords = new HashSet <> (); currentLevelWords . add ( beginWord ); boolean isFound = false ; while ( ! currentLevelWords . isEmpty ()) { // remove words in current level for ( final String word : currentLevelWords ) wordSet . remove ( word ); Set < String > nextLevelWords = new HashSet <> (); // `parent` will be used as a key in `parentToChildren` for ( final String parent : currentLevelWords ) { StringBuilder sb = new StringBuilder ( parent ); for ( int i = 0 ; i < sb . length (); ++ i ) { final char cache = sb . charAt ( i ); for ( char c = 'a' ; c <= 'z' ; ++ c ) { sb . setCharAt ( i , c ); final String child = sb . toString (); if ( wordSet . contains ( child )) { if ( child . equals ( endWord )) isFound = true ; nextLevelWords . add ( child ); parentToChildren . computeIfAbsent ( parent , k -> new ArrayList <> ()). add ( child ); } } sb . setCharAt ( i , cache ); } currentLevelWords = nextLevelWords ; } if ( isFound ) break ; } if ( ! isFound ) return new ArrayList <> (); List < List < String >> ans = new ArrayList <> (); List < String > path = new ArrayList <> ( Arrays . asList ( beginWord )); dfs ( parentToChildren , beginWord , endWord , path , ans ); return ans ; } // construct the ans by `parentToChildren` private void dfs ( Map < String , List < String >> parentToChildren , final String word , final String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <> ( path )); return ; } if ( ! parentToChildren . containsKey ( word )) return ; for ( final String child : parentToChildren . get ( word )) { path . add ( child ); dfs ( parentToChildren , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] wordList = set ( wordList ) if endWord not in wordList : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : wordList . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in wordList and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans","title":"Approach 1: BFS + DFS"},{"location":"problems/0126/#approach-2-pure-bfs","text":"Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList| + |paths||word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); queue < vector < string >> paths {{{ beginWord }}}; // {{\"hit\"}} while ( ! paths . empty ()) { unordered_set < string > currentLevelVisited ; for ( int i = paths . size (); i > 0 ; -- i ) { vector < string > path = paths . front (); paths . pop (); // {\"hit\"} string lastWord = path . back (); // \"hit\" for ( int i = 0 ; i < lastWord . length (); ++ i ) { char cache = lastWord [ i ]; // cache = 'i' for ( char c = 'a' ; c <= 'z' ; ++ c ) { lastWord [ i ] = c ; // \"hit\" -> \"hot\" (temporarily) if ( wordSet . count ( lastWord )) { // find \"hot\" in wordSet currentLevelVisited . insert ( lastWord ); // mark \"hot\" as visited vector < string > nextPath ( path ); nextPath . push_back ( lastWord ); // nextPath = {\"hit\", \"hot\"} if ( lastWord == endWord ) ans . push_back ( nextPath ); else paths . push ( nextPath ); } } lastWord [ i ] = cache ; // \"hot\" back to \"hit\" } } for ( const string & word : currentLevelVisited ) wordSet . erase ( word ); } return ans ; } };","title":"Approach 2: Pure BFS"},{"location":"problems/0127/","text":"127. Word Ladder Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); if ( ! wordSet . count ( endWord )) return 0 ; int ans = 0 ; queue < string > queue {{ beginWord }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { string word = queue . front (); queue . pop (); for ( int j = 0 ; j < word . length (); ++ j ) { const char cache = word [ j ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { word [ j ] = c ; if ( word == endWord ) return ans + 1 ; if ( wordSet . count ( word )) { wordSet . erase ( word ); queue . push ( word ); } } word [ j ] = cache ; } } } return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet <> ( wordList ); if ( ! wordSet . contains ( endWord )) return 0 ; int ans = 0 ; Queue < String > q = new LinkedList <> (); q . offer ( beginWord ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { StringBuilder sb = new StringBuilder ( q . poll ()); for ( int j = 0 ; j < sb . length (); ++ j ) { final char cache = sb . charAt ( j ); for ( char c = 'a' ; c <= 'z' ; ++ c ) { sb . setCharAt ( j , c ); final String word = sb . toString (); if ( word . equals ( endWord )) return ans + 1 ; if ( wordSet . contains ( word )) { wordSet . remove ( word ); q . offer ( word ); } } sb . setCharAt ( j , cache ); } } } return 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : wordList = set ( wordList ) if endWord not in wordList : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in wordList : continue wordList . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0","title":"127. Word Ladder"},{"location":"problems/0127/#127-word-ladder","text":"Time: $O(|wordList| \\cdot 26^{word_i})$ Space: $O(|wordList|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( begin ( wordList ), end ( wordList )); if ( ! wordSet . count ( endWord )) return 0 ; int ans = 0 ; queue < string > queue {{ beginWord }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { string word = queue . front (); queue . pop (); for ( int j = 0 ; j < word . length (); ++ j ) { const char cache = word [ j ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { word [ j ] = c ; if ( word == endWord ) return ans + 1 ; if ( wordSet . count ( word )) { wordSet . erase ( word ); queue . push ( word ); } } word [ j ] = cache ; } } } return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > wordSet = new HashSet <> ( wordList ); if ( ! wordSet . contains ( endWord )) return 0 ; int ans = 0 ; Queue < String > q = new LinkedList <> (); q . offer ( beginWord ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { StringBuilder sb = new StringBuilder ( q . poll ()); for ( int j = 0 ; j < sb . length (); ++ j ) { final char cache = sb . charAt ( j ); for ( char c = 'a' ; c <= 'z' ; ++ c ) { sb . setCharAt ( j , c ); final String word = sb . toString (); if ( word . equals ( endWord )) return ans + 1 ; if ( wordSet . contains ( word )) { wordSet . remove ( word ); q . offer ( word ); } } sb . setCharAt ( j , cache ); } } } return 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : wordList = set ( wordList ) if endWord not in wordList : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in wordList : continue wordList . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0","title":"127. Word Ladder"},{"location":"problems/0128/","text":"128. Longest Consecutive Sequence Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > seen { begin ( nums ), end ( nums )}; for ( long num : nums ) // the start num of a sequence if ( ! seen . count ( num - 1 )) { int length = 0 ; while ( seen . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <> (); for ( final int num : nums ) set . add ( num ); for ( int num : nums ) // the start num of a sequence if ( ! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++ )) ++ length ; ans = Math . max ( ans , length ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 numsSet = set ( nums ) for num in nums : if num - 1 not in numsSet : length = 0 while num in numsSet : num += 1 length += 1 ans = max ( ans , length ) return ans","title":"128. Longest Consecutive Sequence"},{"location":"problems/0128/#128-longest-consecutive-sequence","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > seen { begin ( nums ), end ( nums )}; for ( long num : nums ) // the start num of a sequence if ( ! seen . count ( num - 1 )) { int length = 0 ; while ( seen . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <> (); for ( final int num : nums ) set . add ( num ); for ( int num : nums ) // the start num of a sequence if ( ! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++ )) ++ length ; ans = Math . max ( ans , length ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 numsSet = set ( nums ) for num in nums : if num - 1 not in numsSet : length = 0 while num in numsSet : num += 1 length += 1 ans = max ( ans , length ) return ans","title":"128. Longest Consecutive Sequence"},{"location":"problems/0129/","text":"129. Sum Root to Leaf Numbers Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; dfs ( root , 0 , ans ); return ans ; } private : void dfs ( TreeNode * root , int path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans += path * 10 + root -> val ; return ; } dfs ( root -> left , path * 10 + root -> val , ans ); dfs ( root -> right , path * 10 + root -> val , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int sumNumbers ( TreeNode root ) { dfs ( root , 0 ); return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans += path * 10 + root . val ; return ; } dfs ( root . left , path * 10 + root . val ); dfs ( root . right , path * 10 + root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumNumbers ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += path * 10 + root . val return dfs ( root . left , path * 10 + root . val ) dfs ( root . right , path * 10 + root . val ) self . ans = 0 dfs ( root , 0 ) return self . ans","title":"129. Sum Root to Leaf Numbers"},{"location":"problems/0129/#129-sum-root-to-leaf-numbers","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; dfs ( root , 0 , ans ); return ans ; } private : void dfs ( TreeNode * root , int path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans += path * 10 + root -> val ; return ; } dfs ( root -> left , path * 10 + root -> val , ans ); dfs ( root -> right , path * 10 + root -> val , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int sumNumbers ( TreeNode root ) { dfs ( root , 0 ); return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans += path * 10 + root . val ; return ; } dfs ( root . left , path * 10 + root . val ); dfs ( root . right , path * 10 + root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumNumbers ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += path * 10 + root . val return dfs ( root . left , path * 10 + root . val ) dfs ( root . right , path * 10 + root . val ) self . ans = 0 dfs ( root , 0 ) return self . ans","title":"129. Sum Root to Leaf Numbers"},{"location":"problems/0130/","text":"130. Surrounded Regions Approach 1: BFS Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) if ( board [ i ][ j ] == 'O' ) { q . push ({ i , j }); board [ i ][ j ] = '*' ; } // mark grids that stretch from four sides with '*' while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] != 'O' ) continue ; q . push ({ x , y }); board [ x ][ y ] = '*' ; } } for ( vector < char >& row : board ) for ( char & c : row ) if ( c == '*' ) c = 'O' ; else if ( c == 'O' ) c = 'X' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> q = new LinkedList <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) if ( board [ i ][ j ] == 'O' ) { q . offer ( new int [] { i , j }); board [ i ][ j ] = '*' ; } // mark grids that stretch from four sides with '*' while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] != 'O' ) continue ; q . offer ( new int [] { x , y }); board [ x ][ y ] = '*' ; } } for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) if ( row [ i ] == '*' ) row [ i ] = 'O' ; else if ( row [ i ] == 'O' ) row [ i ] = 'X' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def solve ( self , board : List [ List [ str ]]) -> None : def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not board : return for i in range ( len ( board )): dfs ( i , 0 ) dfs ( i , len ( board [ 0 ]) - 1 ) for j in range ( 1 , len ( board [ 0 ]) - 1 ): dfs ( 0 , j ) dfs ( len ( board ) - 1 , j ) for row in board : for i , c in enumerate ( row ): row [ i ] = 'O' if c == '.' else 'X' Approach 2: DFS Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); // mark grids that stretch from four sides with '*' function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) dfs ( i , j ); for ( vector < char >& row : board ) for ( char & c : row ) if ( c == '*' ) c = 'O' ; else if ( c == 'O' ) c = 'X' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) dfs ( board , i , j ); for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) if ( row [ i ] == '*' ) row [ i ] = 'O' ; else if ( row [ i ] == 'O' ) row [ i ] = 'X' ; } // mark grids that stretch from four sides with '*' private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); } }","title":"130. Surrounded Regions"},{"location":"problems/0130/#130-surrounded-regions","text":"","title":"130. Surrounded Regions"},{"location":"problems/0130/#approach-1-bfs","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) if ( board [ i ][ j ] == 'O' ) { q . push ({ i , j }); board [ i ][ j ] = '*' ; } // mark grids that stretch from four sides with '*' while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] != 'O' ) continue ; q . push ({ x , y }); board [ x ][ y ] = '*' ; } } for ( vector < char >& row : board ) for ( char & c : row ) if ( c == '*' ) c = 'O' ; else if ( c == 'O' ) c = 'X' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> q = new LinkedList <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) if ( board [ i ][ j ] == 'O' ) { q . offer ( new int [] { i , j }); board [ i ][ j ] = '*' ; } // mark grids that stretch from four sides with '*' while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] != 'O' ) continue ; q . offer ( new int [] { x , y }); board [ x ][ y ] = '*' ; } } for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) if ( row [ i ] == '*' ) row [ i ] = 'O' ; else if ( row [ i ] == 'O' ) row [ i ] = 'X' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def solve ( self , board : List [ List [ str ]]) -> None : def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not board : return for i in range ( len ( board )): dfs ( i , 0 ) dfs ( i , len ( board [ 0 ]) - 1 ) for j in range ( 1 , len ( board [ 0 ]) - 1 ): dfs ( 0 , j ) dfs ( len ( board ) - 1 , j ) for row in board : for i , c in enumerate ( row ): row [ i ] = 'O' if c == '.' else 'X'","title":"Approach 1: BFS"},{"location":"problems/0130/#approach-2-dfs","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); // mark grids that stretch from four sides with '*' function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) dfs ( i , j ); for ( vector < char >& row : board ) for ( char & c : row ) if ( c == '*' ) c = 'O' ; else if ( c == 'O' ) c = 'X' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( i == 0 || i == m - 1 ) || ( j == 0 || j == n - 1 )) dfs ( board , i , j ); for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) if ( row [ i ] == '*' ) row [ i ] = 'O' ; else if ( row [ i ] == 'O' ) row [ i ] = 'X' ; } // mark grids that stretch from four sides with '*' private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); } }","title":"Approach 2: DFS"},{"location":"problems/0131/","text":"131. Palindrome Partitioning Time: $O(n2^n)$ Space: $O(n2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int start ) { if ( start == s . length ()) { ans . push_back ( path ); return ; } for ( int i = start ; i < s . length (); ++ i ) if ( isPalindrome ( s , start , i )) { path . push_back ( s . substr ( start , i - start + 1 )); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } private : bool isPalindrome ( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List < List < String >> partition ( String s ) { List < List < String >> ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int start , List < String > path , List < List < String >> ans ) { if ( start == s . length ()) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = start ; i < s . length (); ++ i ) if ( isPalindrome ( s , start , i )) { path . add ( s . substring ( start , i + 1 )); dfs ( s , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } private boolean isPalindrome ( final String s , int l , int r ) { while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ]","title":"131. Palindrome Partitioning"},{"location":"problems/0131/#131-palindrome-partitioning","text":"Time: $O(n2^n)$ Space: $O(n2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int start ) { if ( start == s . length ()) { ans . push_back ( path ); return ; } for ( int i = start ; i < s . length (); ++ i ) if ( isPalindrome ( s , start , i )) { path . push_back ( s . substr ( start , i - start + 1 )); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } private : bool isPalindrome ( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List < List < String >> partition ( String s ) { List < List < String >> ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int start , List < String > path , List < List < String >> ans ) { if ( start == s . length ()) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = start ; i < s . length (); ++ i ) if ( isPalindrome ( s , start , i )) { path . add ( s . substring ( start , i + 1 )); dfs ( s , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } private boolean isPalindrome ( final String s , int l , int r ) { while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ]","title":"131. Palindrome Partitioning"},{"location":"problems/0132/","text":"132. Palindrome Partitioning II Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int minCut ( string s ) { const int n = s . length (); // isPalindrome[i][j] := true if s[i..j] is a palindrome vector < vector < bool >> isPalindrome ( n , vector < bool > ( n , true )); // dp[i] := min cuts needed for a palindrome partitioning of s[0..i] vector < int > dp ( n , n ); for ( int l = 2 ; l <= n ; ++ l ) for ( int i = 0 , j = l - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s [ i ] == s [ j ] && isPalindrome [ i + 1 ][ j - 1 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ]) { dp [ i ] = 0 ; continue ; } // try all possible partitions for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ]) dp [ i ] = min ( dp [ i ], dp [ j ] + 1 ); } return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int minCut ( String s ) { final int n = s . length (); // isPalindrome[i][j] := true if s[i..j] is a palindrome boolean [][] isPalindrome = new boolean [ n ][ n ] ; for ( boolean [] row : isPalindrome ) Arrays . fill ( row , true ); // dp[i] := min cuts needed for a palindrome partitioning of s[0..i] int [] dp = new int [ n ] ; Arrays . fill ( dp , n ); for ( int l = 2 ; l <= n ; ++ l ) for ( int i = 0 , j = l - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s . charAt ( i ) == s . charAt ( j ) && isPalindrome [ i + 1 ][ j - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ] ) { dp [ i ] = 0 ; continue ; } // try all possible partitions for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ] ) dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ); } return dp [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): mini = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True mini = 0 if j == 0 else min ( mini , cut [ j - 1 ] + 1 ) cut [ i ] = mini return cut [ n - 1 ]","title":"132. Palindrome Partitioning II"},{"location":"problems/0132/#132-palindrome-partitioning-ii","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int minCut ( string s ) { const int n = s . length (); // isPalindrome[i][j] := true if s[i..j] is a palindrome vector < vector < bool >> isPalindrome ( n , vector < bool > ( n , true )); // dp[i] := min cuts needed for a palindrome partitioning of s[0..i] vector < int > dp ( n , n ); for ( int l = 2 ; l <= n ; ++ l ) for ( int i = 0 , j = l - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s [ i ] == s [ j ] && isPalindrome [ i + 1 ][ j - 1 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ]) { dp [ i ] = 0 ; continue ; } // try all possible partitions for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ]) dp [ i ] = min ( dp [ i ], dp [ j ] + 1 ); } return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int minCut ( String s ) { final int n = s . length (); // isPalindrome[i][j] := true if s[i..j] is a palindrome boolean [][] isPalindrome = new boolean [ n ][ n ] ; for ( boolean [] row : isPalindrome ) Arrays . fill ( row , true ); // dp[i] := min cuts needed for a palindrome partitioning of s[0..i] int [] dp = new int [ n ] ; Arrays . fill ( dp , n ); for ( int l = 2 ; l <= n ; ++ l ) for ( int i = 0 , j = l - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s . charAt ( i ) == s . charAt ( j ) && isPalindrome [ i + 1 ][ j - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ] ) { dp [ i ] = 0 ; continue ; } // try all possible partitions for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ] ) dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ); } return dp [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): mini = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True mini = 0 if j == 0 else min ( mini , cut [ j - 1 ] + 1 ) cut [ i ] = mini return cut [ n - 1 ]","title":"132. Palindrome Partitioning II"},{"location":"problems/0133/","text":"133. Clone Graph Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return nullptr ; if ( map . count ( node )) return map [ node ]; Node * newNode = new Node ( node -> val ); map [ node ] = newNode ; for ( Node * neighbor : node -> neighbors ) newNode -> neighbors . push_back ( cloneGraph ( neighbor )); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node cloneGraph ( Node node ) { if ( node == null ) return null ; if ( map . containsKey ( node )) return map . get ( node ); Node newNode = new Node ( node . val ); map . put ( node , newNode ); for ( Node neighbor : node . neighbors ) newNode . neighbors . add ( cloneGraph ( neighbor )); return newNode ; } private Map < Node , Node > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . lookup : return self . lookup [ node ] self . lookup [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . lookup [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . lookup [ node ] lookup = {}","title":"133. Clone Graph"},{"location":"problems/0133/#133-clone-graph","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return nullptr ; if ( map . count ( node )) return map [ node ]; Node * newNode = new Node ( node -> val ); map [ node ] = newNode ; for ( Node * neighbor : node -> neighbors ) newNode -> neighbors . push_back ( cloneGraph ( neighbor )); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node cloneGraph ( Node node ) { if ( node == null ) return null ; if ( map . containsKey ( node )) return map . get ( node ); Node newNode = new Node ( node . val ); map . put ( node , newNode ); for ( Node neighbor : node . neighbors ) newNode . neighbors . add ( cloneGraph ( neighbor )); return newNode ; } private Map < Node , Node > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . lookup : return self . lookup [ node ] self . lookup [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . lookup [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . lookup [ node ] lookup = {}","title":"133. Clone Graph"},{"location":"problems/0134/","text":"134. Gas Station Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { const int gasses = accumulate ( begin ( gas ), end ( gas ), 0 ); const int costs = accumulate ( begin ( cost ), end ( cost ), 0 ); if ( gasses - costs < 0 ) return -1 ; int ans = 0 ; int sum = 0 ; // try to start from each index for ( int i = 0 ; i < gas . size (); ++ i ) { sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; // start from next index } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int canCompleteCircuit ( int [] gas , int [] cost ) { final int gasses = Arrays . stream ( gas ). sum (); final int costs = Arrays . stream ( cost ). sum (); if ( gasses - costs < 0 ) return - 1 ; int ans = 0 ; int sum = 0 ; // try to start from each index for ( int i = 0 ; i < gas . length ; ++ i ) { sum += gas [ i ] - cost [ i ] ; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; // start from next index } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans","title":"134. Gas Station"},{"location":"problems/0134/#134-gas-station","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { const int gasses = accumulate ( begin ( gas ), end ( gas ), 0 ); const int costs = accumulate ( begin ( cost ), end ( cost ), 0 ); if ( gasses - costs < 0 ) return -1 ; int ans = 0 ; int sum = 0 ; // try to start from each index for ( int i = 0 ; i < gas . size (); ++ i ) { sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; // start from next index } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int canCompleteCircuit ( int [] gas , int [] cost ) { final int gasses = Arrays . stream ( gas ). sum (); final int costs = Arrays . stream ( cost ). sum (); if ( gasses - costs < 0 ) return - 1 ; int ans = 0 ; int sum = 0 ; // try to start from each index for ( int i = 0 ; i < gas . length ; ++ i ) { sum += gas [ i ] - cost [ i ] ; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; // start from next index } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans","title":"134. Gas Station"},{"location":"problems/0135/","text":"135. Candy Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int candy ( vector < int >& ratings ) { const int n = ratings . size (); int ans = 0 ; vector < int > l ( n , 1 ); vector < int > r ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ]) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ]) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += max ( l [ i ], r [ i ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int candy ( int [] ratings ) { final int n = ratings . length ; int ans = 0 ; int [] l = new int [ n ] ; int [] r = new int [ n ] ; Arrays . fill ( l , 1 ); Arrays . fill ( r , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ] ) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ] ) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += Math . max ( l [ i ] , r [ i ] ); return ans ; } }","title":"135. Candy"},{"location":"problems/0135/#135-candy","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int candy ( vector < int >& ratings ) { const int n = ratings . size (); int ans = 0 ; vector < int > l ( n , 1 ); vector < int > r ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ]) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ]) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += max ( l [ i ], r [ i ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int candy ( int [] ratings ) { final int n = ratings . length ; int ans = 0 ; int [] l = new int [ n ] ; int [] r = new int [ n ] ; Arrays . fill ( l , 1 ); Arrays . fill ( r , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ] ) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ] ) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += Math . max ( l [ i ] , r [ i ] ); return ans ; } }","title":"135. Candy"},{"location":"problems/0136/","text":"136. Single Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) ans ^= num ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( final int num : nums ) ans ^= num ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans","title":"136. Single Number"},{"location":"problems/0136/#136-single-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) ans ^= num ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( final int num : nums ) ans ^= num ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans","title":"136. Single Number"},{"location":"problems/0137/","text":"137. Single Number II Approach 1: Bit Time: $O(32n) = O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int sum = 0 ; for ( const int num : nums ) sum += ( num >> i ) & 1 ; sum %= 3 ; ans |= ( sum << i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int sum = 0 ; for ( final int num : nums ) sum += ( num >> i ) & 1 ; sum %= 3 ; ans |= ( sum << i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones Approach 2: Magic Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( const int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int singleNumber ( int [] nums ) { int ones = 0 ; int twos = 0 ; for ( final int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }","title":"137. Single Number II"},{"location":"problems/0137/#137-single-number-ii","text":"","title":"137. Single Number II"},{"location":"problems/0137/#approach-1-bit","text":"Time: $O(32n) = O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int sum = 0 ; for ( const int num : nums ) sum += ( num >> i ) & 1 ; sum %= 3 ; ans |= ( sum << i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int sum = 0 ; for ( final int num : nums ) sum += ( num >> i ) & 1 ; sum %= 3 ; ans |= ( sum << i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones","title":"Approach 1: Bit"},{"location":"problems/0137/#approach-2-magic","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( const int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int singleNumber ( int [] nums ) { int ones = 0 ; int twos = 0 ; for ( final int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }","title":"Approach 2: Magic"},{"location":"problems/0138/","text":"138. Copy List with Random Pointer Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; if ( map . count ( head )) return map [ head ]; Node * newNode = new Node ( head -> val ); map [ head ] = newNode ; newNode -> next = copyRandomList ( head -> next ); newNode -> random = copyRandomList ( head -> random ); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node copyRandomList ( Node head ) { if ( head == null ) return null ; if ( map . containsKey ( head )) return map . get ( head ); Node newNode = new Node ( head . val ); map . put ( head , newNode ); newNode . next = copyRandomList ( head . next ); newNode . random = copyRandomList ( head . random ); return newNode ; } private Map < Node , Node > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if head is None : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {}","title":"138. Copy List with Random Pointer"},{"location":"problems/0138/#138-copy-list-with-random-pointer","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; if ( map . count ( head )) return map [ head ]; Node * newNode = new Node ( head -> val ); map [ head ] = newNode ; newNode -> next = copyRandomList ( head -> next ); newNode -> random = copyRandomList ( head -> random ); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node copyRandomList ( Node head ) { if ( head == null ) return null ; if ( map . containsKey ( head )) return map . get ( head ); Node newNode = new Node ( head . val ); map . put ( head , newNode ); newNode . next = copyRandomList ( head . next ); newNode . random = copyRandomList ( head . random ); return newNode ; } private Map < Node , Node > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if head is None : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {}","title":"138. Copy List with Random Pointer"},{"location":"problems/0139/","text":"139. Word Break Approach 1: Bottom-up Time: $O(n^2)$ Space: $O(n + \\Sigma|wordDict_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { const int n = s . length (); unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; vector < bool > dp ( n + 1 ); // dp[i] := true if s[0..i) can be segmented dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . count ( s . substr ( j , i - j ))) { dp [ i ] = true ; break ; } return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { final int n = s . length (); Set < String > wordSet = new HashSet <> ( wordDict ); boolean [] dp = new boolean [ n + 1 ] ; // dp[i] := true if s[0..i) can be segmented dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . contains ( s . substring ( j , i ))) { dp [ i ] = true ; break ; } return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : def wordBreak ( s : str ) -> bool : if s in memo : return memo [ s ] if s in wordDict : memo [ s ] = True return True for i in range ( 1 , len ( s )): if s [: i ] in wordDict and wordBreak ( s [ i :]): memo [ s ] = True return True memo [ s ] = False return False memo = {} wordDict = set ( wordDict ) return wordBreak ( s ) Approach 2: Top-down Time: $O(n^2)$ Space: $O(n + \\Sigma|wordDict_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , bool > memo ; function < bool ( const string & ) > wordBreak = [ & ]( const string & s ) { if ( wordSet . count ( s )) return true ; if ( memo . count ( s )) return memo [ s ]; for ( int i = 1 ; i < s . length (); ++ i ) if ( wordSet . count ( s . substr ( 0 , i )) && wordBreak ( s . substr ( i ))) return memo [ s ] = true ; return memo [ s ] = false ; }; return wordBreak ( s ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); if ( wordSet . contains ( s )) { memo . put ( s , true ); return true ; } for ( int i = 1 ; i < s . length (); ++ i ) { final String prefix = s . substring ( 0 , i ); final String suffix = s . substring ( i ); if ( wordSet . contains ( prefix ) && wordBreak ( suffix , wordSet )) { memo . put ( s , true ); return true ; } } memo . put ( s , false ); return false ; } }","title":"139. Word Break"},{"location":"problems/0139/#139-word-break","text":"","title":"139. Word Break"},{"location":"problems/0139/#approach-1-bottom-up","text":"Time: $O(n^2)$ Space: $O(n + \\Sigma|wordDict_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { const int n = s . length (); unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; vector < bool > dp ( n + 1 ); // dp[i] := true if s[0..i) can be segmented dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . count ( s . substr ( j , i - j ))) { dp [ i ] = true ; break ; } return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { final int n = s . length (); Set < String > wordSet = new HashSet <> ( wordDict ); boolean [] dp = new boolean [ n + 1 ] ; // dp[i] := true if s[0..i) can be segmented dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . contains ( s . substring ( j , i ))) { dp [ i ] = true ; break ; } return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : def wordBreak ( s : str ) -> bool : if s in memo : return memo [ s ] if s in wordDict : memo [ s ] = True return True for i in range ( 1 , len ( s )): if s [: i ] in wordDict and wordBreak ( s [ i :]): memo [ s ] = True return True memo [ s ] = False return False memo = {} wordDict = set ( wordDict ) return wordBreak ( s )","title":"Approach 1: Bottom-up"},{"location":"problems/0139/#approach-2-top-down","text":"Time: $O(n^2)$ Space: $O(n + \\Sigma|wordDict_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , bool > memo ; function < bool ( const string & ) > wordBreak = [ & ]( const string & s ) { if ( wordSet . count ( s )) return true ; if ( memo . count ( s )) return memo [ s ]; for ( int i = 1 ; i < s . length (); ++ i ) if ( wordSet . count ( s . substr ( 0 , i )) && wordBreak ( s . substr ( i ))) return memo [ s ] = true ; return memo [ s ] = false ; }; return wordBreak ( s ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); if ( wordSet . contains ( s )) { memo . put ( s , true ); return true ; } for ( int i = 1 ; i < s . length (); ++ i ) { final String prefix = s . substring ( 0 , i ); final String suffix = s . substring ( i ); if ( wordSet . contains ( prefix ) && wordBreak ( suffix , wordSet )) { memo . put ( s , true ); return true ; } } memo . put ( s , false ); return false ; } }","title":"Approach 2: Top-down"},{"location":"problems/0140/","text":"140. Word Break II Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , vector < string >> memo ; function < vector < string > ( const string & s ) > wordBreak = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < string > ans ; // 1 <= prefix.length() < s.length() for ( int i = 1 ; i < s . length (); ++ i ) { const string & prefix = s . substr ( 0 , i ); if ( wordSet . count ( prefix )) for ( const string & word : wordBreak ( s . substr ( i ))) ans . push_back ( prefix + \" \" + word ); } // contains whole string, so don't add any space if ( wordSet . count ( s )) ans . push_back ( s ); return memo [ s ] = ans ; }; return wordBreak ( s ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , List < String >> memo = new HashMap <> (); private List < String > wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); List < String > ans = new ArrayList <> (); if ( wordSet . contains ( s )) ans . add ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { final String suffix = s . substring ( i ); if ( wordSet . contains ( suffix )) for ( final String word : wordBreak ( s . substring ( 0 , i ), wordSet )) ans . add ( word + \" \" + suffix ); } memo . put ( s , ans ); return ans ; } }","title":"140. Word Break II"},{"location":"problems/0140/#140-word-break-ii","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , vector < string >> memo ; function < vector < string > ( const string & s ) > wordBreak = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < string > ans ; // 1 <= prefix.length() < s.length() for ( int i = 1 ; i < s . length (); ++ i ) { const string & prefix = s . substr ( 0 , i ); if ( wordSet . count ( prefix )) for ( const string & word : wordBreak ( s . substr ( i ))) ans . push_back ( prefix + \" \" + word ); } // contains whole string, so don't add any space if ( wordSet . count ( s )) ans . push_back ( s ); return memo [ s ] = ans ; }; return wordBreak ( s ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , List < String >> memo = new HashMap <> (); private List < String > wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); List < String > ans = new ArrayList <> (); if ( wordSet . contains ( s )) ans . add ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { final String suffix = s . substring ( i ); if ( wordSet . contains ( suffix )) for ( final String word : wordBreak ( s . substring ( 0 , i ), wordSet )) ans . add ( word + \" \" + suffix ); } memo . put ( s , ans ); return ans ; } }","title":"140. Word Break II"},{"location":"problems/0141/","text":"141. Linked List Cycle Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False","title":"141. Linked List Cycle"},{"location":"problems/0141/#141-linked-list-cycle","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False","title":"141. Linked List Cycle"},{"location":"problems/0142/","text":"142. Linked List Cycle II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None","title":"142. Linked List Cycle II"},{"location":"problems/0142/#142-linked-list-cycle-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None","title":"142. Linked List Cycle II"},{"location":"problems/0143/","text":"143. Reorder List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution : def reorderList ( self , head : ListNode ) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed )","title":"143. Reorder List"},{"location":"problems/0143/#143-reorder-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution : def reorderList ( self , head : ListNode ) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed )","title":"143. Reorder List"},{"location":"problems/0144/","text":"144. Binary Tree Preorder Traversal Approach 1: Recursive Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; ans . push_back ( root -> val ); preorder ( root -> left ); preorder ( root -> right ); }; preorder ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > preorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); preorder ( root , ans ); return ans ; } private void preorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; ans . add ( root . val ); preorder ( root . left , ans ); preorder ( root . right , ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans Approach 2: Iterative Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < Integer > preorderTraversal ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); ans . add ( root . val ); if ( root . right != null ) stack . push ( root . right ); if ( root . left != null ) stack . push ( root . left ); } return ans ; } }","title":"144. Binary Tree Preorder Traversal"},{"location":"problems/0144/#144-binary-tree-preorder-traversal","text":"","title":"144. Binary Tree Preorder Traversal"},{"location":"problems/0144/#approach-1-recursive","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; ans . push_back ( root -> val ); preorder ( root -> left ); preorder ( root -> right ); }; preorder ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > preorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); preorder ( root , ans ); return ans ; } private void preorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; ans . add ( root . val ); preorder ( root . left , ans ); preorder ( root . right , ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans","title":"Approach 1: Recursive"},{"location":"problems/0144/#approach-2-iterative","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < Integer > preorderTraversal ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); ans . add ( root . val ); if ( root . right != null ) stack . push ( root . right ); if ( root . left != null ) stack . push ( root . left ); } return ans ; } }","title":"Approach 2: Iterative"},{"location":"problems/0145/","text":"145. Binary Tree Postorder Traversal Approach 1: Recursive Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * ) > postorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; postorder ( root -> left ); postorder ( root -> right ); ans . push_back ( root -> val ); }; postorder ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); postorder ( root , ans ); return ans ; } private void postorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; postorder ( root . left , ans ); postorder ( root . right , ans ); ans . add ( root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ] Approach 2: Iterative Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> left ) stack . push ( root -> left ); if ( root -> right ) stack . push ( root -> right ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < Integer > postorderTraversal ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); ans . add ( root . val ); if ( root . left != null ) stack . push ( root . left ); if ( root . right != null ) stack . push ( root . right ); } Collections . reverse ( ans ); return ans ; } }","title":"145. Binary Tree Postorder Traversal"},{"location":"problems/0145/#145-binary-tree-postorder-traversal","text":"","title":"145. Binary Tree Postorder Traversal"},{"location":"problems/0145/#approach-1-recursive","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * ) > postorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; postorder ( root -> left ); postorder ( root -> right ); ans . push_back ( root -> val ); }; postorder ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); postorder ( root , ans ); return ans ; } private void postorder ( TreeNode root , List < Integer > ans ) { if ( root == null ) return ; postorder ( root . left , ans ); postorder ( root . right , ans ); ans . add ( root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ]","title":"Approach 1: Recursive"},{"location":"problems/0145/#approach-2-iterative","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> left ) stack . push ( root -> left ); if ( root -> right ) stack . push ( root -> right ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < Integer > postorderTraversal ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); ans . add ( root . val ); if ( root . left != null ) stack . push ( root . left ); if ( root . right != null ) stack . push ( root . right ); } Collections . reverse ( ans ); return ans ; } }","title":"Approach 2: Iterative"},{"location":"problems/0146/","text":"146. LRU Cache Time: $O(1)$ Space: $O(capacity)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Node { int key ; int value ; }; class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! keyToIterator . count ( key )) return -1 ; const auto & it = keyToIterator [ key ]; cache . splice ( begin ( cache ), cache , it ); // move it to front return it -> value ; } void put ( int key , int value ) { if ( keyToIterator . count ( key )) { // no capacity issue, just update the value const auto & it = keyToIterator [ key ]; cache . splice ( begin ( cache ), cache , it ); // move it to front it -> value = value ; return ; } if ( cache . size () == capacity ) { // check the capacity const Node & lastNode = cache . back (); keyToIterator . erase ( lastNode . key ); // that's why we store key in `Node` cache . pop_back (); } cache . push_front ({ key , value }); keyToIterator [ key ] = begin ( cache ); } private : int capacity ; list < Node > cache ; unordered_map < int , list < Node >:: iterator > keyToIterator ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Node { public int key ; public int value ; public Node ( int key , int value ) { this . key = key ; this . value = value ; } } class LRUCache { public LRUCache ( int capacity ) { this . capacity = capacity ; } public int get ( int key ) { if ( ! keyToNode . containsKey ( key )) return - 1 ; Node node = keyToNode . get ( key ); cache . remove ( node ); cache . add ( node ); return node . value ; } public void put ( int key , int value ) { if ( keyToNode . containsKey ( key )) { keyToNode . get ( key ). value = value ; get ( key ); return ; } if ( cache . size () == capacity ) { Node lastNode = cache . iterator (). next (); cache . remove ( lastNode ); keyToNode . remove ( lastNode . key ); } Node node = new Node ( key , value ); cache . add ( node ); keyToNode . put ( key , node ); } private int capacity ; private Set < Node > cache = new LinkedHashSet <> (); private Map < Integer , Node > keyToNode = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Node : def __init__ ( self , key : int , value : int ): self . key = key self . value = value self . prev = None self . next = None class LRUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . dict = {} self . head = Node ( - 1 , - 1 ) self . tail = Node ( - 1 , - 1 ) self . join ( self . head , self . tail ) def get ( self , key : int ) -> int : if key not in self . dict : return - 1 node = self . dict [ key ] self . remove ( node ) self . moveToHead ( node ) return node . value def put ( self , key : int , value : int ) -> None : if key in self . dict : node = self . dict [ key ] node . value = value self . remove ( node ) self . moveToHead ( node ) return if len ( self . dict ) == self . capacity : lastNode = self . tail . prev del self . dict [ lastNode . key ] self . remove ( lastNode ) self . moveToHead ( Node ( key , value )) self . dict [ key ] = self . head . next def join ( self , node1 : Node , node2 : Node ): node1 . next = node2 node2 . prev = node1 def moveToHead ( self , node : Node ): self . join ( node , self . head . next ) self . join ( self . head , node ) def remove ( self , node : Node ): self . join ( node . prev , node . next )","title":"146. LRU Cache"},{"location":"problems/0146/#146-lru-cache","text":"Time: $O(1)$ Space: $O(capacity)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Node { int key ; int value ; }; class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! keyToIterator . count ( key )) return -1 ; const auto & it = keyToIterator [ key ]; cache . splice ( begin ( cache ), cache , it ); // move it to front return it -> value ; } void put ( int key , int value ) { if ( keyToIterator . count ( key )) { // no capacity issue, just update the value const auto & it = keyToIterator [ key ]; cache . splice ( begin ( cache ), cache , it ); // move it to front it -> value = value ; return ; } if ( cache . size () == capacity ) { // check the capacity const Node & lastNode = cache . back (); keyToIterator . erase ( lastNode . key ); // that's why we store key in `Node` cache . pop_back (); } cache . push_front ({ key , value }); keyToIterator [ key ] = begin ( cache ); } private : int capacity ; list < Node > cache ; unordered_map < int , list < Node >:: iterator > keyToIterator ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Node { public int key ; public int value ; public Node ( int key , int value ) { this . key = key ; this . value = value ; } } class LRUCache { public LRUCache ( int capacity ) { this . capacity = capacity ; } public int get ( int key ) { if ( ! keyToNode . containsKey ( key )) return - 1 ; Node node = keyToNode . get ( key ); cache . remove ( node ); cache . add ( node ); return node . value ; } public void put ( int key , int value ) { if ( keyToNode . containsKey ( key )) { keyToNode . get ( key ). value = value ; get ( key ); return ; } if ( cache . size () == capacity ) { Node lastNode = cache . iterator (). next (); cache . remove ( lastNode ); keyToNode . remove ( lastNode . key ); } Node node = new Node ( key , value ); cache . add ( node ); keyToNode . put ( key , node ); } private int capacity ; private Set < Node > cache = new LinkedHashSet <> (); private Map < Integer , Node > keyToNode = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Node : def __init__ ( self , key : int , value : int ): self . key = key self . value = value self . prev = None self . next = None class LRUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . dict = {} self . head = Node ( - 1 , - 1 ) self . tail = Node ( - 1 , - 1 ) self . join ( self . head , self . tail ) def get ( self , key : int ) -> int : if key not in self . dict : return - 1 node = self . dict [ key ] self . remove ( node ) self . moveToHead ( node ) return node . value def put ( self , key : int , value : int ) -> None : if key in self . dict : node = self . dict [ key ] node . value = value self . remove ( node ) self . moveToHead ( node ) return if len ( self . dict ) == self . capacity : lastNode = self . tail . prev del self . dict [ lastNode . key ] self . remove ( lastNode ) self . moveToHead ( Node ( key , value )) self . dict [ key ] = self . head . next def join ( self , node1 : Node , node2 : Node ): node1 . next = node2 node2 . prev = node1 def moveToHead ( self , node : Node ): self . join ( node , self . head . next ) self . join ( self . head , node ) def remove ( self , node : Node ): self . join ( node . prev , node . next )","title":"146. LRU Cache"},{"location":"problems/0147/","text":"147. Insertion Sort List Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * prev = & dummy ; // the last (largest) of the sorted list while ( head ) { // current inserting node ListNode * next = head -> next ; // cache next inserting node if ( prev -> val >= head -> val ) // `prev` >= current inserting node prev = & dummy ; // move `prev` to the front while ( prev -> next && prev -> next -> val < head -> val ) prev = prev -> next ; head -> next = prev -> next ; prev -> next = head ; head = next ; // update current inserting node } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode insertionSortList ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode prev = dummy ; // the last (largest) of the sorted list while ( head != null ) { // current inserting node ListNode next = head . next ; // cache next inserting node if ( prev . val >= head . val ) // `prev` >= current inserting node prev = dummy ; // move `prev` to the front while ( prev . next != null && prev . next . val < head . val ) prev = prev . next ; head . next = prev . next ; prev . next = head ; head = next ; // update current inserting node } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next","title":"147. Insertion Sort List"},{"location":"problems/0147/#147-insertion-sort-list","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * prev = & dummy ; // the last (largest) of the sorted list while ( head ) { // current inserting node ListNode * next = head -> next ; // cache next inserting node if ( prev -> val >= head -> val ) // `prev` >= current inserting node prev = & dummy ; // move `prev` to the front while ( prev -> next && prev -> next -> val < head -> val ) prev = prev -> next ; head -> next = prev -> next ; prev -> next = head ; head = next ; // update current inserting node } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public ListNode insertionSortList ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode prev = dummy ; // the last (largest) of the sorted list while ( head != null ) { // current inserting node ListNode next = head . next ; // cache next inserting node if ( prev . val >= head . val ) // `prev` >= current inserting node prev = dummy ; // move `prev` to the front while ( prev . next != null && prev . next . val < head . val ) prev = prev . next ; head . next = prev . next ; prev . next = head ; head = next ; // update current inserting node } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next","title":"147. Insertion Sort List"},{"location":"problems/0148/","text":"148. Sort List Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : ListNode * sortList ( ListNode * head ) { const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); auto [ mergedHead , mergedTail ] = merge ( l , r ); tail -> next = mergedHead ; tail = mergedTail ; } } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : nullptr ; if ( head ) head -> next = nullptr ; return rest ; } pair < ListNode * , ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public ListNode sortList ( ListNode head ) { final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode curr = dummy . next ; ListNode tail = dummy ; while ( curr != null ) { ListNode l = curr ; ListNode r = split ( l , k ); curr = split ( r , k ); ListNode [] merged = merge ( l , r ); tail . next = merged [ 0 ] ; tail = merged [ 1 ] ; } } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } private ListNode split ( ListNode head , int k ) { while ( -- k > 0 && head != null ) head = head . next ; ListNode rest = head == null ? null : head . next ; if ( head != null ) head . next = null ; return rest ; } private ListNode [] merge ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode tail = dummy ; while ( l1 != null && l2 != null ) { if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } tail . next = l1 ; l1 = l1 . next ; tail = tail . next ; } tail . next = l1 == null ? l2 : l1 ; while ( tail . next != null ) tail = tail . next ; return new ListNode [] { dummy . next , tail }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution : def sortList ( self , head : ListNode ) -> ListNode : def split ( head : ListNode , k : int ) -> ListNode : while k > 1 and head : head = head . next k -= 1 rest = head . next if head else None if head : head . next = None return rest def merge ( l1 : ListNode , l2 : ListNode ) -> tuple : dummy = ListNode ( 0 ) tail = dummy while l1 and l2 : if l1 . val > l2 . val : l1 , l2 = l2 , l1 tail . next = l1 l1 = l1 . next tail = tail . next tail . next = l1 if l1 else l2 while tail . next : tail = tail . next return dummy . next , tail length = 0 curr = head while curr : length += 1 curr = curr . next dummy = ListNode ( 0 ) dummy . next = head k = 1 while k < length : curr = dummy . next tail = dummy while curr : l = curr r = split ( l , k ) curr = split ( r , k ) mergedHead , mergedTail = merge ( l , r ) tail . next = mergedHead tail = mergedTail k *= 2 return dummy . next","title":"148. Sort List"},{"location":"problems/0148/#148-sort-list","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : ListNode * sortList ( ListNode * head ) { const int length = getLength ( head ); ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); auto [ mergedHead , mergedTail ] = merge ( l , r ); tail -> next = mergedHead ; tail = mergedTail ; } } return dummy . next ; } private : int getLength ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; return length ; } ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : nullptr ; if ( head ) head -> next = nullptr ; return rest ; } pair < ListNode * , ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public ListNode sortList ( ListNode head ) { final int length = getLength ( head ); ListNode dummy = new ListNode ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode curr = dummy . next ; ListNode tail = dummy ; while ( curr != null ) { ListNode l = curr ; ListNode r = split ( l , k ); curr = split ( r , k ); ListNode [] merged = merge ( l , r ); tail . next = merged [ 0 ] ; tail = merged [ 1 ] ; } } return dummy . next ; } private int getLength ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; return length ; } private ListNode split ( ListNode head , int k ) { while ( -- k > 0 && head != null ) head = head . next ; ListNode rest = head == null ? null : head . next ; if ( head != null ) head . next = null ; return rest ; } private ListNode [] merge ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode tail = dummy ; while ( l1 != null && l2 != null ) { if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } tail . next = l1 ; l1 = l1 . next ; tail = tail . next ; } tail . next = l1 == null ? l2 : l1 ; while ( tail . next != null ) tail = tail . next ; return new ListNode [] { dummy . next , tail }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution : def sortList ( self , head : ListNode ) -> ListNode : def split ( head : ListNode , k : int ) -> ListNode : while k > 1 and head : head = head . next k -= 1 rest = head . next if head else None if head : head . next = None return rest def merge ( l1 : ListNode , l2 : ListNode ) -> tuple : dummy = ListNode ( 0 ) tail = dummy while l1 and l2 : if l1 . val > l2 . val : l1 , l2 = l2 , l1 tail . next = l1 l1 = l1 . next tail = tail . next tail . next = l1 if l1 else l2 while tail . next : tail = tail . next return dummy . next , tail length = 0 curr = head while curr : length += 1 curr = curr . next dummy = ListNode ( 0 ) dummy . next = head k = 1 while k < length : curr = dummy . next tail = dummy while curr : l = curr r = split ( l , k ) curr = split ( r , k ) mergedHead , mergedTail = merge ( l , r ) tail . next = mergedHead tail = mergedTail k *= 2 return dummy . next","title":"148. Sort List"},{"location":"problems/0149/","text":"149. Max Points on a Line Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { unordered_map < pair < int , int > , int , pairHash > slopeCount ; const vector < int > p1 { points [ i ]}; int samePoints = 1 ; int maxPoints = 0 ; // maximum number of points with the same slope for ( int j = i + 1 ; j < points . size (); ++ j ) { const vector < int > p2 { points [ j ]}; if ( p1 == p2 ) ++ samePoints ; else maxPoints = max ( maxPoints , ++ slopeCount [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( const vector < int >& p1 , const vector < int >& p2 ) { const int dx = p2 [ 0 ] - p1 [ 0 ]; const int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; if ( dy == 0 ) return { p1 [ 1 ], 0 }; const int d = __gcd ( dx , dy ); return { dx / d , dy / d }; } struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int maxPoints ( int [][] points ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; ++ i ) { Map < Pair < Integer , Integer > , Integer > slopeCount = new HashMap <> (); final int [] p1 = points [ i ] ; int samePoints = 1 ; int maxPoints = 0 ; // maximum number of points with the same slope for ( int j = i + 1 ; j < points . length ; ++ j ) { final int [] p2 = points [ j ] ; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ] ) ++ samePoints ; else { final Pair < Integer , Integer > slope = getSlope ( p1 , p2 ); slopeCount . put ( slope , slopeCount . getOrDefault ( slope , 0 ) + 1 ); maxPoints = Math . max ( maxPoints , slopeCount . get ( slope )); } } ans = Math . max ( ans , samePoints + maxPoints ); } return ans ; } private Pair < Integer , Integer > getSlope ( int [] p1 , int [] p2 ) { final int dx = p2 [ 0 ] - p1 [ 0 ] ; final int dy = p2 [ 1 ] - p1 [ 1 ] ; if ( dx == 0 ) return new Pair <> ( 0 , p1 [ 0 ] ); if ( dy == 0 ) return new Pair <> ( p1 [ 1 ] , 0 ); final int d = gcd ( dx , dy ); return new Pair <> ( dx / d , dy / d ); } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from fractions import gcd class Solution : def maxPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i , p1 in enumerate ( points ): count = collections . defaultdict ( int ) samePoints = 1 maxPoints = 0 for j in range ( i + 1 , len ( points )): p2 = points [ j ] if p1 == p2 : samePoints += 1 else : slope = self . getSlope ( p1 , p2 ) count [ slope ] += 1 maxPoints = max ( maxPoints , count [ slope ]) ans = max ( ans , samePoints + maxPoints ) return ans def getSlope ( self , p1 : List [ int ], p2 : List [ int ]) -> tuple : dx = p2 [ 0 ] - p1 [ 0 ] dy = p2 [ 1 ] - p1 [ 1 ] if dx == 0 : return ( 0 , p1 [ 0 ]) if dy == 0 : return ( p1 [ 1 ], 0 ) d = gcd ( dx , dy ) return ( dx // d , dy // d )","title":"149. Max Points on a Line"},{"location":"problems/0149/#149-max-points-on-a-line","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { unordered_map < pair < int , int > , int , pairHash > slopeCount ; const vector < int > p1 { points [ i ]}; int samePoints = 1 ; int maxPoints = 0 ; // maximum number of points with the same slope for ( int j = i + 1 ; j < points . size (); ++ j ) { const vector < int > p2 { points [ j ]}; if ( p1 == p2 ) ++ samePoints ; else maxPoints = max ( maxPoints , ++ slopeCount [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( const vector < int >& p1 , const vector < int >& p2 ) { const int dx = p2 [ 0 ] - p1 [ 0 ]; const int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; if ( dy == 0 ) return { p1 [ 1 ], 0 }; const int d = __gcd ( dx , dy ); return { dx / d , dy / d }; } struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int maxPoints ( int [][] points ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; ++ i ) { Map < Pair < Integer , Integer > , Integer > slopeCount = new HashMap <> (); final int [] p1 = points [ i ] ; int samePoints = 1 ; int maxPoints = 0 ; // maximum number of points with the same slope for ( int j = i + 1 ; j < points . length ; ++ j ) { final int [] p2 = points [ j ] ; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ] ) ++ samePoints ; else { final Pair < Integer , Integer > slope = getSlope ( p1 , p2 ); slopeCount . put ( slope , slopeCount . getOrDefault ( slope , 0 ) + 1 ); maxPoints = Math . max ( maxPoints , slopeCount . get ( slope )); } } ans = Math . max ( ans , samePoints + maxPoints ); } return ans ; } private Pair < Integer , Integer > getSlope ( int [] p1 , int [] p2 ) { final int dx = p2 [ 0 ] - p1 [ 0 ] ; final int dy = p2 [ 1 ] - p1 [ 1 ] ; if ( dx == 0 ) return new Pair <> ( 0 , p1 [ 0 ] ); if ( dy == 0 ) return new Pair <> ( p1 [ 1 ] , 0 ); final int d = gcd ( dx , dy ); return new Pair <> ( dx / d , dy / d ); } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from fractions import gcd class Solution : def maxPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i , p1 in enumerate ( points ): count = collections . defaultdict ( int ) samePoints = 1 maxPoints = 0 for j in range ( i + 1 , len ( points )): p2 = points [ j ] if p1 == p2 : samePoints += 1 else : slope = self . getSlope ( p1 , p2 ) count [ slope ] += 1 maxPoints = max ( maxPoints , count [ slope ]) ans = max ( ans , samePoints + maxPoints ) return ans def getSlope ( self , p1 : List [ int ], p2 : List [ int ]) -> tuple : dx = p2 [ 0 ] - p1 [ 0 ] dy = p2 [ 1 ] - p1 [ 1 ] if dx == 0 : return ( 0 , p1 [ 0 ]) if dy == 0 : return ( p1 [ 1 ], 0 ) d = gcd ( dx , dy ) return ( dx // d , dy // d )","title":"149. Max Points on a Line"},{"location":"problems/0150/","text":"150. Evaluate Reverse Polish Notation Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; const unordered_map < string , function < int ( int , int ) >> op { { \"+\" , plus < int > ()}, { \"-\" , minus < int > ()}, { \"*\" , multiplies < int > ()}, { \"/\" , divides < int > ()}}; for ( const string & token : tokens ) if ( op . count ( token )) { const int b = stack . top (); stack . pop (); const int a = stack . top (); stack . pop (); stack . push ( op . at ( token )( a , b )); } else { stack . push ( stoi ( token )); } return stack . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int evalRPN ( String [] tokens ) { Stack < Integer > stack = new Stack < Integer > (); for ( final String token : tokens ) switch ( token ) { case \"+\" : stack . push ( stack . pop () + stack . pop ()); break ; case \"-\" : stack . push ( - stack . pop () + stack . pop ()); break ; case \"*\" : stack . push ( stack . pop () * stack . pop ()); break ; case \"/\" : final int b = stack . pop (); final int a = stack . pop (); stack . push ( a / b ); break ; default : stack . push ( Integer . valueOf ( token )); } return stack . peek (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] operators = { \"+\" : lambda a , b : a + b , \"-\" : lambda a , b : a - b , \"*\" : lambda a , b : a * b , \"/\" : lambda a , b : int ( a / b ), } for token in tokens : if token in operators : b = stack . pop () a = stack . pop () stack . append ( operators [ token ]( a , b )) else : stack . append ( int ( token )) return stack [ 0 ]","title":"150. Evaluate Reverse Polish Notation"},{"location":"problems/0150/#150-evaluate-reverse-polish-notation","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; const unordered_map < string , function < int ( int , int ) >> op { { \"+\" , plus < int > ()}, { \"-\" , minus < int > ()}, { \"*\" , multiplies < int > ()}, { \"/\" , divides < int > ()}}; for ( const string & token : tokens ) if ( op . count ( token )) { const int b = stack . top (); stack . pop (); const int a = stack . top (); stack . pop (); stack . push ( op . at ( token )( a , b )); } else { stack . push ( stoi ( token )); } return stack . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int evalRPN ( String [] tokens ) { Stack < Integer > stack = new Stack < Integer > (); for ( final String token : tokens ) switch ( token ) { case \"+\" : stack . push ( stack . pop () + stack . pop ()); break ; case \"-\" : stack . push ( - stack . pop () + stack . pop ()); break ; case \"*\" : stack . push ( stack . pop () * stack . pop ()); break ; case \"/\" : final int b = stack . pop (); final int a = stack . pop (); stack . push ( a / b ); break ; default : stack . push ( Integer . valueOf ( token )); } return stack . peek (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] operators = { \"+\" : lambda a , b : a + b , \"-\" : lambda a , b : a - b , \"*\" : lambda a , b : a * b , \"/\" : lambda a , b : int ( a / b ), } for token in tokens : if token in operators : b = stack . pop () a = stack . pop () stack . append ( operators [ token ]( a , b )) else : stack . append ( int ( token )) return stack [ 0 ]","title":"150. Evaluate Reverse Polish Notation"},{"location":"problems/0151/","text":"151. Reverse Words in a String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : string reverseWords ( string s ) { reverse ( begin ( s ), end ( s )); // reverse the whole string reverseWords ( s , s . length ()); // reverse each word return cleanSpaces ( s , s . length ()); // clean up spaces } private : void reverseWords ( string & s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) ++ i ; // skip spaces while ( j < i || j < n && s [ j ] != ' ' ) ++ j ; // skip non spaces reverse ( begin ( s ) + i , begin ( s ) + j ); // reverse the word } } // trim leading, trailing, and middle spaces string cleanSpaces ( string & s , int n ) { int i = 0 ; int j = 0 ; while ( j < n ) { while ( j < n && s [ j ] == ' ' ) ++ j ; // skip spaces while ( j < n && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; // keep non spaces while ( j < n && s [ j ] == ' ' ) ++ j ; // skip spaces if ( j < n ) s [ i ++ ] = ' ' ; // keep only one space } return s . substr ( 0 , i ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public String reverseWords ( String s ) { StringBuilder sb = new StringBuilder ( s ). reverse (); // reverse the whole string reverseWords ( sb , sb . length ()); // reverse each word return cleanSpaces ( sb , sb . length ()); // clean up spaces } private void reverseWords ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && sb . charAt ( i ) == ' ' ) // skip spaces ++ i ; while ( j < i || j < n && sb . charAt ( j ) != ' ' ) // skip non spaces ++ j ; reverse ( sb , i , j - 1 ); // reverse the word } } // trim leading, trailing, and middle spaces private String cleanSpaces ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( j < n ) { while ( j < n && sb . charAt ( j ) == ' ' ) // skip spaces ++ j ; while ( j < n && sb . charAt ( j ) != ' ' ) // keep non spaces sb . setCharAt ( i ++ , sb . charAt ( j ++ )); while ( j < n && sb . charAt ( j ) == ' ' ) // skip spaces ++ j ; if ( j < n ) // keep only one space sb . setCharAt ( i ++ , ' ' ); } return sb . substring ( 0 , i ). toString (); } private void reverse ( StringBuilder sb , int l , int r ) { while ( l < r ) { final char temp = sb . charAt ( l ); sb . setCharAt ( l ++ , sb . charAt ( r )); sb . setCharAt ( r -- , temp ); } } } Python 1 2 3 class Solution : def reverseWords ( self , s : str ) -> str : return ' ' . join ( reversed ( s . split ()))","title":"151. Reverse Words in a String"},{"location":"problems/0151/#151-reverse-words-in-a-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : string reverseWords ( string s ) { reverse ( begin ( s ), end ( s )); // reverse the whole string reverseWords ( s , s . length ()); // reverse each word return cleanSpaces ( s , s . length ()); // clean up spaces } private : void reverseWords ( string & s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) ++ i ; // skip spaces while ( j < i || j < n && s [ j ] != ' ' ) ++ j ; // skip non spaces reverse ( begin ( s ) + i , begin ( s ) + j ); // reverse the word } } // trim leading, trailing, and middle spaces string cleanSpaces ( string & s , int n ) { int i = 0 ; int j = 0 ; while ( j < n ) { while ( j < n && s [ j ] == ' ' ) ++ j ; // skip spaces while ( j < n && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; // keep non spaces while ( j < n && s [ j ] == ' ' ) ++ j ; // skip spaces if ( j < n ) s [ i ++ ] = ' ' ; // keep only one space } return s . substr ( 0 , i ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public String reverseWords ( String s ) { StringBuilder sb = new StringBuilder ( s ). reverse (); // reverse the whole string reverseWords ( sb , sb . length ()); // reverse each word return cleanSpaces ( sb , sb . length ()); // clean up spaces } private void reverseWords ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && sb . charAt ( i ) == ' ' ) // skip spaces ++ i ; while ( j < i || j < n && sb . charAt ( j ) != ' ' ) // skip non spaces ++ j ; reverse ( sb , i , j - 1 ); // reverse the word } } // trim leading, trailing, and middle spaces private String cleanSpaces ( StringBuilder sb , int n ) { int i = 0 ; int j = 0 ; while ( j < n ) { while ( j < n && sb . charAt ( j ) == ' ' ) // skip spaces ++ j ; while ( j < n && sb . charAt ( j ) != ' ' ) // keep non spaces sb . setCharAt ( i ++ , sb . charAt ( j ++ )); while ( j < n && sb . charAt ( j ) == ' ' ) // skip spaces ++ j ; if ( j < n ) // keep only one space sb . setCharAt ( i ++ , ' ' ); } return sb . substring ( 0 , i ). toString (); } private void reverse ( StringBuilder sb , int l , int r ) { while ( l < r ) { final char temp = sb . charAt ( l ); sb . setCharAt ( l ++ , sb . charAt ( r )); sb . setCharAt ( r -- , temp ); } } } Python 1 2 3 class Solution : def reverseWords ( self , s : str ) -> str : return ' ' . join ( reversed ( s . split ()))","title":"151. Reverse Words in a String"},{"location":"problems/0152/","text":"152. Maximum Product Subarray Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int dpMin = nums [ 0 ]; // min so far int dpMax = nums [ 0 ]; // max so far for ( int i = 1 ; i < nums . size (); ++ i ) { const int num = nums [ i ]; const int prevMin = dpMin ; // dpMin[i - 1] const int prevMax = dpMax ; // dpMax[i - 1] if ( num < 0 ) { dpMin = min ( prevMax * num , num ); dpMax = max ( prevMin * num , num ); } else { dpMin = min ( prevMin * num , num ); dpMax = max ( prevMax * num , num ); } ans = max ( ans , dpMax ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ] ; int dpMin = nums [ 0 ] ; // min so far int dpMax = nums [ 0 ] ; // max so far for ( int i = 1 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; final int prevMin = dpMin ; // dpMin[i - 1] final int prevMax = dpMax ; // dpMax[i - 1] if ( num < 0 ) { dpMin = Math . min ( prevMax * num , num ); dpMax = Math . max ( prevMin * num , num ); } else { dpMin = Math . min ( prevMin * num , num ); dpMax = Math . max ( prevMax * num , num ); } ans = Math . max ( ans , dpMax ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): mini = prevMin * nums [ i ] maxi = prevMax * nums [ i ] prevMin = min ( nums [ i ], mini , maxi ) prevMax = max ( nums [ i ], mini , maxi ) ans = max ( ans , prevMax ) return ans","title":"152. Maximum Product Subarray"},{"location":"problems/0152/#152-maximum-product-subarray","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int dpMin = nums [ 0 ]; // min so far int dpMax = nums [ 0 ]; // max so far for ( int i = 1 ; i < nums . size (); ++ i ) { const int num = nums [ i ]; const int prevMin = dpMin ; // dpMin[i - 1] const int prevMax = dpMax ; // dpMax[i - 1] if ( num < 0 ) { dpMin = min ( prevMax * num , num ); dpMax = max ( prevMin * num , num ); } else { dpMin = min ( prevMin * num , num ); dpMax = max ( prevMax * num , num ); } ans = max ( ans , dpMax ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ] ; int dpMin = nums [ 0 ] ; // min so far int dpMax = nums [ 0 ] ; // max so far for ( int i = 1 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; final int prevMin = dpMin ; // dpMin[i - 1] final int prevMax = dpMax ; // dpMax[i - 1] if ( num < 0 ) { dpMin = Math . min ( prevMax * num , num ); dpMax = Math . max ( prevMin * num , num ); } else { dpMin = Math . min ( prevMin * num , num ); dpMax = Math . max ( prevMax * num , num ); } ans = Math . max ( ans , dpMax ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): mini = prevMin * nums [ i ] maxi = prevMax * nums [ i ] prevMin = min ( nums [ i ], mini , maxi ) prevMax = max ( nums [ i ], mini , maxi ) ans = max ( ans , prevMax ) return ans","title":"152. Maximum Product Subarray"},{"location":"problems/0153/","text":"153. Find Minimum in Rotated Sorted Array Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"153. Find Minimum in Rotated Sorted Array"},{"location":"problems/0153/#153-find-minimum-in-rotated-sorted-array","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"153. Find Minimum in Rotated Sorted Array"},{"location":"problems/0154/","text":"154. Find Minimum in Rotated Sorted Array II Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ] ) -- r ; else if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"154. Find Minimum in Rotated Sorted Array II"},{"location":"problems/0154/#154-find-minimum-in-rotated-sorted-array-ii","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ] ) -- r ; else if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"154. Find Minimum in Rotated Sorted Array II"},{"location":"problems/0155/","text":"155. Min Stack Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MinStack { public : void push ( int x ) { if ( stack . empty ()) stack . push ({ x , x }); else stack . push ({ x , min ( x , stack . top (). second )}); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : stack < pair < int , int >> stack ; // {x, min} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MinStack { public void push ( int x ) { if ( stack . isEmpty ()) stack . push ( new int [] { x , x }); else stack . push ( new int [] { x , Math . min ( x , stack . peek () [ 1 ] ) }); } public void pop () { stack . pop (); } public int top () { return stack . peek () [ 0 ] ; } public int getMin () { return stack . peek () [ 1 ] ; } private Stack < int []> stack = new Stack <> (); // {x, min} } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : mini = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , mini ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ]","title":"155. Min Stack"},{"location":"problems/0155/#155-min-stack","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MinStack { public : void push ( int x ) { if ( stack . empty ()) stack . push ({ x , x }); else stack . push ({ x , min ( x , stack . top (). second )}); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : stack < pair < int , int >> stack ; // {x, min} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MinStack { public void push ( int x ) { if ( stack . isEmpty ()) stack . push ( new int [] { x , x }); else stack . push ( new int [] { x , Math . min ( x , stack . peek () [ 1 ] ) }); } public void pop () { stack . pop (); } public int top () { return stack . peek () [ 0 ] ; } public int getMin () { return stack . peek () [ 1 ] ; } private Stack < int []> stack = new Stack <> (); // {x, min} } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : mini = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , mini ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ]","title":"155. Min Stack"},{"location":"problems/0156/","text":"156. Binary Tree Upside Down \ud83d\udd12 Approach 1: Recursive Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { if ( ! root || ! root -> left ) return root ; TreeNode * newRoot = upsideDownBinaryTree ( root -> left ); root -> left -> left = root -> right ; // 2's left = 3 (root's right) root -> left -> right = root ; // 2's right = 1 (root) root -> left = nullptr ; root -> right = nullptr ; return newRoot ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public TreeNode upsideDownBinaryTree ( TreeNode root ) { if ( root == null || root . left == null ) return root ; TreeNode newRoot = upsideDownBinaryTree ( root . left ); root . left . left = root . right ; // 2's left = 3 (root's right) root . left . right = root ; // 2's right = 1 (root) root . left = null ; root . right = null ; return newRoot ; } } Approach 2: Iterative Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { TreeNode * prevRoot = nullptr ; TreeNode * prevRightChild = nullptr ; while ( root ) { TreeNode * nextRoot = root -> left ; // cache next root root -> left = prevRightChild ; prevRightChild = root -> right ; root -> right = prevRoot ; prevRoot = root ; // record previous root root = nextRoot ; // update root } return prevRoot ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode upsideDownBinaryTree ( TreeNode root ) { TreeNode prevRoot = null ; TreeNode prevRightChild = null ; while ( root != null ) { TreeNode nextRoot = root . left ; // cache next root root . left = prevRightChild ; prevRightChild = root . right ; root . right = prevRoot ; prevRoot = root ; // record previous root root = nextRoot ; // update root } return prevRoot ; } }","title":"156. Binary Tree Upside Down"},{"location":"problems/0156/#156-binary-tree-upside-down","text":"","title":"156. Binary Tree Upside Down \ud83d\udd12"},{"location":"problems/0156/#approach-1-recursive","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { if ( ! root || ! root -> left ) return root ; TreeNode * newRoot = upsideDownBinaryTree ( root -> left ); root -> left -> left = root -> right ; // 2's left = 3 (root's right) root -> left -> right = root ; // 2's right = 1 (root) root -> left = nullptr ; root -> right = nullptr ; return newRoot ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public TreeNode upsideDownBinaryTree ( TreeNode root ) { if ( root == null || root . left == null ) return root ; TreeNode newRoot = upsideDownBinaryTree ( root . left ); root . left . left = root . right ; // 2's left = 3 (root's right) root . left . right = root ; // 2's right = 1 (root) root . left = null ; root . right = null ; return newRoot ; } }","title":"Approach 1: Recursive"},{"location":"problems/0156/#approach-2-iterative","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { TreeNode * prevRoot = nullptr ; TreeNode * prevRightChild = nullptr ; while ( root ) { TreeNode * nextRoot = root -> left ; // cache next root root -> left = prevRightChild ; prevRightChild = root -> right ; root -> right = prevRoot ; prevRoot = root ; // record previous root root = nextRoot ; // update root } return prevRoot ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public TreeNode upsideDownBinaryTree ( TreeNode root ) { TreeNode prevRoot = null ; TreeNode prevRightChild = null ; while ( root != null ) { TreeNode nextRoot = root . left ; // cache next root root . left = prevRightChild ; prevRightChild = root . right ; root . right = prevRoot ; prevRoot = root ; // record previous root root = nextRoot ; // update root } return prevRoot ; } }","title":"Approach 2: Iterative"},{"location":"problems/0157/","text":"157. Read N Characters Given Read4 \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * The read4 API is defined in the parent class Reader4. * int read4(char *buf4); */ class Solution { public : /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read ( char * buf , int n ) { char * buf4 = new char [ 4 ]; // dynamic buffer int i = 0 ; // point to buf while ( true ) { const int n4 = read4 ( buf4 ); // will return [0..4] for ( int i4 = 0 ; i4 < n4 && i < n ; ++ i4 ) buf [ i ++ ] = buf4 [ i4 ]; if ( n4 == 0 || i == n ) return i ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * The read4 API is defined in the parent class Reader4. * int read4(char[] buf4); */ public class Solution extends Reader4 { /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ public int read ( char [] buf , int n ) { char [] buf4 = new char [ 4 ] ; // dynamic buffer int i = 0 ; // point to buf while ( true ) { final int n4 = read4 ( buf4 ); // will return [0..4] for ( int i4 = 0 ; i4 < n4 && i < n ; ++ i4 ) buf [ i ++] = buf4 [ i4 ] ; if ( n4 == 0 || i == n ) return i ; } } }","title":"157. Read N Characters Given Read4"},{"location":"problems/0157/#157-read-n-characters-given-read4","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * The read4 API is defined in the parent class Reader4. * int read4(char *buf4); */ class Solution { public : /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read ( char * buf , int n ) { char * buf4 = new char [ 4 ]; // dynamic buffer int i = 0 ; // point to buf while ( true ) { const int n4 = read4 ( buf4 ); // will return [0..4] for ( int i4 = 0 ; i4 < n4 && i < n ; ++ i4 ) buf [ i ++ ] = buf4 [ i4 ]; if ( n4 == 0 || i == n ) return i ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * The read4 API is defined in the parent class Reader4. * int read4(char[] buf4); */ public class Solution extends Reader4 { /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ public int read ( char [] buf , int n ) { char [] buf4 = new char [ 4 ] ; // dynamic buffer int i = 0 ; // point to buf while ( true ) { final int n4 = read4 ( buf4 ); // will return [0..4] for ( int i4 = 0 ; i4 < n4 && i < n ; ++ i4 ) buf [ i ++] = buf4 [ i4 ] ; if ( n4 == 0 || i == n ) return i ; } } }","title":"157. Read N Characters Given Read4 \ud83d\udd12"},{"location":"problems/0158/","text":"158. Read N Characters Given Read4 II - Call multiple times \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * The read4 API is defined in the parent class Reader4. * int read4(char *buf4); */ class Solution { public : /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read ( char * buf , int n ) { int i = 0 ; // buf's pointer while ( i < n ) { if ( i4 == n4 ) { // all characters in buf4 are consumed i4 = 0 ; // reset buf4's pointer n4 = read4 ( buf4 ); // read 4 (or less) chars from file to buf4 if ( n4 == 0 ) // reach the EOF break ; } buf [ i ++ ] = buf4 [ i4 ++ ]; } return i ; } private : char * buf4 = new char [ 4 ]; int i4 = 0 ; // buf4's pointer int n4 = 0 ; // buf4's size }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * The read4 API is defined in the parent class Reader4. * int read4(char[] buf4); */ public class Solution extends Reader4 { /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ public int read ( char [] buf , int n ) { int i = 0 ; // point to buf while ( i < n ) { if ( i4 >= n4 ) { i4 = 0 ; n4 = read4 ( buf4 ); if ( n4 == 0 ) break ; } buf [ i ++] = buf4 [ i4 ++] ; } return i ; } private char [] buf4 = new char [ 4 ] ; private int i4 = 0 ; // point to buf4 private int n4 = 0 ; // size of buf4 }","title":"158. Read N Characters Given Read4 II - Call multiple times"},{"location":"problems/0158/#158-read-n-characters-given-read4-ii-call-multiple-times","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * The read4 API is defined in the parent class Reader4. * int read4(char *buf4); */ class Solution { public : /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ int read ( char * buf , int n ) { int i = 0 ; // buf's pointer while ( i < n ) { if ( i4 == n4 ) { // all characters in buf4 are consumed i4 = 0 ; // reset buf4's pointer n4 = read4 ( buf4 ); // read 4 (or less) chars from file to buf4 if ( n4 == 0 ) // reach the EOF break ; } buf [ i ++ ] = buf4 [ i4 ++ ]; } return i ; } private : char * buf4 = new char [ 4 ]; int i4 = 0 ; // buf4's pointer int n4 = 0 ; // buf4's size }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * The read4 API is defined in the parent class Reader4. * int read4(char[] buf4); */ public class Solution extends Reader4 { /** * @param buf Destination buffer * @param n Number of characters to read * @return The number of actual characters read */ public int read ( char [] buf , int n ) { int i = 0 ; // point to buf while ( i < n ) { if ( i4 >= n4 ) { i4 = 0 ; n4 = read4 ( buf4 ); if ( n4 == 0 ) break ; } buf [ i ++] = buf4 [ i4 ++] ; } return i ; } private char [] buf4 = new char [ 4 ] ; private int i4 = 0 ; // point to buf4 private int n4 = 0 ; // size of buf4 }","title":"158. Read N Characters Given Read4 II - Call multiple times \ud83d\udd12"},{"location":"problems/0159/","text":"159. Longest Substring with At Most Two Distinct Characters \ud83d\udd12 Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int lengthOfLongestSubstringTwoDistinct ( string s ) { int ans = 0 ; int distinct = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s [ r ]] == 1 ) ++ distinct ; while ( distinct == 3 ) if ( -- count [ s [ l ++ ]] == 0 ) -- distinct ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int lengthOfLongestSubstringTwoDistinct ( String s ) { int ans = 0 ; int distinct = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) ++ distinct ; while ( distinct == 3 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) -- distinct ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"159. Longest Substring with At Most Two Distinct Characters"},{"location":"problems/0159/#159-longest-substring-with-at-most-two-distinct-characters","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int lengthOfLongestSubstringTwoDistinct ( string s ) { int ans = 0 ; int distinct = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s [ r ]] == 1 ) ++ distinct ; while ( distinct == 3 ) if ( -- count [ s [ l ++ ]] == 0 ) -- distinct ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int lengthOfLongestSubstringTwoDistinct ( String s ) { int ans = 0 ; int distinct = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) ++ distinct ; while ( distinct == 3 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) -- distinct ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"159. Longest Substring with At Most Two Distinct Characters \ud83d\udd12"},{"location":"problems/0160/","text":"160. Intersection of Two Linked Lists Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a","title":"160. Intersection of Two Linked Lists"},{"location":"problems/0160/#160-intersection-of-two-linked-lists","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a","title":"160. Intersection of Two Linked Lists"},{"location":"problems/0161/","text":"161. One Edit Distance \ud83d\udd12 Time: $O(\\min(|s|, |t|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isOneEditDistance ( string s , string t ) { const int m = s . length (); const int n = t . length (); if ( m > n ) // make sure len(s) <= len(t) return isOneEditDistance ( t , s ); for ( int i = 0 ; i < m ; ++ i ) if ( s [ i ] != t [ i ]) { if ( m == n ) return s . substr ( i + 1 ) == t . substr ( i + 1 ); // replace s[i] with t[i] return s . substr ( i ) == t . substr ( i + 1 ); // delete t[i] } return m + 1 == n ; // delete t[-1] } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isOneEditDistance ( String s , String t ) { final int m = s . length (); final int n = t . length (); if ( m > n ) // make sure len(s) <= len(t) return isOneEditDistance ( t , s ); for ( int i = 0 ; i < m ; ++ i ) if ( s . charAt ( i ) != t . charAt ( i )) { if ( m == n ) return s . substring ( i + 1 ). equals ( t . substring ( i + 1 )); // replace s[i] with t[i] return s . substring ( i ). equals ( t . substring ( i + 1 )); // delete t[i] } return m + 1 == n ; // delete t[-1] } }","title":"161. One Edit Distance"},{"location":"problems/0161/#161-one-edit-distance","text":"Time: $O(\\min(|s|, |t|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isOneEditDistance ( string s , string t ) { const int m = s . length (); const int n = t . length (); if ( m > n ) // make sure len(s) <= len(t) return isOneEditDistance ( t , s ); for ( int i = 0 ; i < m ; ++ i ) if ( s [ i ] != t [ i ]) { if ( m == n ) return s . substr ( i + 1 ) == t . substr ( i + 1 ); // replace s[i] with t[i] return s . substr ( i ) == t . substr ( i + 1 ); // delete t[i] } return m + 1 == n ; // delete t[-1] } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isOneEditDistance ( String s , String t ) { final int m = s . length (); final int n = t . length (); if ( m > n ) // make sure len(s) <= len(t) return isOneEditDistance ( t , s ); for ( int i = 0 ; i < m ; ++ i ) if ( s . charAt ( i ) != t . charAt ( i )) { if ( m == n ) return s . substring ( i + 1 ). equals ( t . substring ( i + 1 )); // replace s[i] with t[i] return s . substring ( i ). equals ( t . substring ( i + 1 )); // delete t[i] } return m + 1 == n ; // delete t[-1] } }","title":"161. One Edit Distance \ud83d\udd12"},{"location":"problems/0162/","text":"162. Find Peak Element Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; // find the first index l s.t. nums[l] >= nums[l + 1] while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ m + 1 ]) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; // find the first index l s.t. nums[l] >= nums[l + 1] while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ m + 1 ] ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l","title":"162. Find Peak Element"},{"location":"problems/0162/#162-find-peak-element","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; // find the first index l s.t. nums[l] >= nums[l + 1] while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ m + 1 ]) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; // find the first index l s.t. nums[l] >= nums[l + 1] while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ m + 1 ] ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l","title":"162. Find Peak Element"},{"location":"problems/0163/","text":"163. Missing Ranges \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > findMissingRanges ( vector < int >& nums , int lower , int upper ) { vector < string > ans ; if ( nums . empty ()) { ans . push_back ( getRange ( lower , upper )); return ans ; } if ( nums . front () > lower ) ans . push_back ( getRange ( lower , nums . front () - 1 )); for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ] + 1 ) ans . push_back ( getRange ( nums [ i - 1 ] + 1 , nums [ i ] - 1 )); if ( nums . back () < upper ) ans . push_back ( getRange ( nums . back () + 1 , upper )); return ans ; } private : string getRange ( int lo , int hi ) { if ( lo == hi ) return to_string ( lo ); return to_string ( lo ) + \"->\" + to_string ( hi ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > findMissingRanges ( int [] nums , int lower , int upper ) { List < String > ans = new ArrayList <> (); if ( nums . length == 0 ) { ans . add ( getRange ( lower , upper )); return ans ; } if ( nums [ 0 ] > lower ) ans . add ( getRange ( lower , nums [ 0 ] - 1 )); for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] > nums [ i - 1 ] + 1 ) ans . add ( getRange ( nums [ i - 1 ] + 1 , nums [ i ] - 1 )); if ( nums [ nums . length - 1 ] < upper ) ans . add ( getRange ( nums [ nums . length - 1 ] + 1 , upper )); return ans ; } private String getRange ( int lo , int hi ) { if ( lo == hi ) return String . valueOf ( lo ); return lo + \"->\" + hi ; } }","title":"163. Missing Ranges"},{"location":"problems/0163/#163-missing-ranges","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > findMissingRanges ( vector < int >& nums , int lower , int upper ) { vector < string > ans ; if ( nums . empty ()) { ans . push_back ( getRange ( lower , upper )); return ans ; } if ( nums . front () > lower ) ans . push_back ( getRange ( lower , nums . front () - 1 )); for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ] + 1 ) ans . push_back ( getRange ( nums [ i - 1 ] + 1 , nums [ i ] - 1 )); if ( nums . back () < upper ) ans . push_back ( getRange ( nums . back () + 1 , upper )); return ans ; } private : string getRange ( int lo , int hi ) { if ( lo == hi ) return to_string ( lo ); return to_string ( lo ) + \"->\" + to_string ( hi ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > findMissingRanges ( int [] nums , int lower , int upper ) { List < String > ans = new ArrayList <> (); if ( nums . length == 0 ) { ans . add ( getRange ( lower , upper )); return ans ; } if ( nums [ 0 ] > lower ) ans . add ( getRange ( lower , nums [ 0 ] - 1 )); for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] > nums [ i - 1 ] + 1 ) ans . add ( getRange ( nums [ i - 1 ] + 1 , nums [ i ] - 1 )); if ( nums [ nums . length - 1 ] < upper ) ans . add ( getRange ( nums [ nums . length - 1 ] + 1 , upper )); return ans ; } private String getRange ( int lo , int hi ) { if ( lo == hi ) return String . valueOf ( lo ); return lo + \"->\" + hi ; } }","title":"163. Missing Ranges \ud83d\udd12"},{"location":"problems/0164/","text":"164. Maximum Gap Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Bucket { int min ; int max ; }; class Solution { public : int maximumGap ( vector < int >& nums ) { if ( nums . size () < 2 ) return 0 ; const int mini = * min_element ( begin ( nums ), end ( nums )); const int maxi = * max_element ( begin ( nums ), end ( nums )); if ( mini == maxi ) return 0 ; const int gap = ceil (( maxi - mini ) / ( double )( nums . size () - 1 )); const int bucketSize = ( maxi - mini ) / gap + 1 ; vector < Bucket > buckets ( bucketSize , { INT_MAX , INT_MIN }); for ( const int num : nums ) { const int i = ( num - mini ) / gap ; buckets [ i ]. min = min ( buckets [ i ]. min , num ); buckets [ i ]. max = max ( buckets [ i ]. max , num ); } int ans = 0 ; int prevMax = mini ; for ( const Bucket & bucket : buckets ) { if ( bucket . min == INT_MAX ) continue ; // empty bucket ans = max ( ans , bucket . min - prevMax ); prevMax = bucket . max ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Bucket { public int min ; public int max ; public Bucket ( int min , int max ) { this . min = min ; this . max = max ; } } class Solution { public int maximumGap ( int [] nums ) { if ( nums . length < 2 ) return 0 ; final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); if ( min == max ) return 0 ; final int gap = ( int ) Math . ceil (( double ) ( max - min ) / ( nums . length - 1 )); final int bucketsLength = ( max - min ) / gap + 1 ; Bucket [] buckets = new Bucket [ bucketsLength ] ; for ( int i = 0 ; i < buckets . length ; ++ i ) buckets [ i ] = new Bucket ( Integer . MAX_VALUE , Integer . MIN_VALUE ); for ( final int num : nums ) { final int i = ( num - min ) / gap ; buckets [ i ] . min = Math . min ( buckets [ i ] . min , num ); buckets [ i ] . max = Math . max ( buckets [ i ] . max , num ); } int ans = 0 ; int prevMax = min ; for ( final Bucket bucket : buckets ) { if ( bucket . min == Integer . MAX_VALUE ) // empty bucket continue ; ans = Math . max ( ans , bucket . min - prevMax ); prevMax = bucket . max ; } return ans ; } }","title":"164. Maximum Gap"},{"location":"problems/0164/#164-maximum-gap","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Bucket { int min ; int max ; }; class Solution { public : int maximumGap ( vector < int >& nums ) { if ( nums . size () < 2 ) return 0 ; const int mini = * min_element ( begin ( nums ), end ( nums )); const int maxi = * max_element ( begin ( nums ), end ( nums )); if ( mini == maxi ) return 0 ; const int gap = ceil (( maxi - mini ) / ( double )( nums . size () - 1 )); const int bucketSize = ( maxi - mini ) / gap + 1 ; vector < Bucket > buckets ( bucketSize , { INT_MAX , INT_MIN }); for ( const int num : nums ) { const int i = ( num - mini ) / gap ; buckets [ i ]. min = min ( buckets [ i ]. min , num ); buckets [ i ]. max = max ( buckets [ i ]. max , num ); } int ans = 0 ; int prevMax = mini ; for ( const Bucket & bucket : buckets ) { if ( bucket . min == INT_MAX ) continue ; // empty bucket ans = max ( ans , bucket . min - prevMax ); prevMax = bucket . max ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Bucket { public int min ; public int max ; public Bucket ( int min , int max ) { this . min = min ; this . max = max ; } } class Solution { public int maximumGap ( int [] nums ) { if ( nums . length < 2 ) return 0 ; final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); if ( min == max ) return 0 ; final int gap = ( int ) Math . ceil (( double ) ( max - min ) / ( nums . length - 1 )); final int bucketsLength = ( max - min ) / gap + 1 ; Bucket [] buckets = new Bucket [ bucketsLength ] ; for ( int i = 0 ; i < buckets . length ; ++ i ) buckets [ i ] = new Bucket ( Integer . MAX_VALUE , Integer . MIN_VALUE ); for ( final int num : nums ) { final int i = ( num - min ) / gap ; buckets [ i ] . min = Math . min ( buckets [ i ] . min , num ); buckets [ i ] . max = Math . max ( buckets [ i ] . max , num ); } int ans = 0 ; int prevMax = min ; for ( final Bucket bucket : buckets ) { if ( bucket . min == Integer . MAX_VALUE ) // empty bucket continue ; ans = Math . max ( ans , bucket . min - prevMax ); prevMax = bucket . max ; } return ans ; } }","title":"164. Maximum Gap"},{"location":"problems/0165/","text":"165. Compare Version Numbers Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char dotChar ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return -1 ; if ( num1 > num2 ) return 1 ; iss1 >> dotChar ; iss2 >> dotChar ; num1 = 0 ; num2 = 0 ; } return 0 ; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int compareVersion ( String version1 , String version2 ) { final String [] levels1 = version1 . split ( \"\\\\.\" ); final String [] levels2 = version2 . split ( \"\\\\.\" ); final int length = Math . max ( levels1 . length , levels2 . length ); for ( int i = 0 ; i < length ; ++ i ) { final Integer v1 = i < levels1 . length ? Integer . parseInt ( levels1 [ i ] ) : 0 ; final Integer v2 = i < levels2 . length ? Integer . parseInt ( levels2 [ i ] ) : 0 ; final int compare = v1 . compareTo ( v2 ); if ( compare != 0 ) return compare ; } return 0 ; } }","title":"165. Compare Version Numbers"},{"location":"problems/0165/#165-compare-version-numbers","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char dotChar ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return -1 ; if ( num1 > num2 ) return 1 ; iss1 >> dotChar ; iss2 >> dotChar ; num1 = 0 ; num2 = 0 ; } return 0 ; }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int compareVersion ( String version1 , String version2 ) { final String [] levels1 = version1 . split ( \"\\\\.\" ); final String [] levels2 = version2 . split ( \"\\\\.\" ); final int length = Math . max ( levels1 . length , levels2 . length ); for ( int i = 0 ; i < length ; ++ i ) { final Integer v1 = i < levels1 . length ? Integer . parseInt ( levels1 [ i ] ) : 0 ; final Integer v2 = i < levels2 . length ? Integer . parseInt ( levels2 [ i ] ) : 0 ; final int compare = v1 . compareTo ( v2 ); if ( compare != 0 ) return compare ; } return 0 ; } }","title":"165. Compare Version Numbers"},{"location":"problems/0166/","text":"166. Fraction to Recurring Decimal Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = labs ( numerator ); long d = labs ( denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > seen ; for ( long r = n % d ; r ; r %= d ) { if ( seen . count ( r )) { ans . insert ( seen [ r ], 1 , '(' ); ans += ')' ; break ; } seen [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public String fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; StringBuilder sb = new StringBuilder (); if ( numerator < 0 ^ denominator < 0 ) sb . append ( \"-\" ); long n = Math . abs (( long ) numerator ); long d = Math . abs (( long ) denominator ); sb . append ( n / d ); if ( n % d == 0 ) return sb . toString (); sb . append ( \".\" ); Map < Long , Integer > seen = new HashMap <> (); for ( long r = n % d ; r > 0 ; r %= d ) { if ( seen . containsKey ( r )) { sb . insert ( seen . get ( r ), \"(\" ); sb . append ( \")\" ); break ; } seen . put ( r , sb . length ()); r *= 10 ; sb . append ( r / d ); } return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fractionToDecimal ( self , numerator : int , denominator : int ) -> str : if numerator == 0 : return \"0\" ans = \"\" if ( numerator < 0 ) ^ ( denominator < 0 ): ans += \"-\" numerator = abs ( numerator ) denominator = abs ( denominator ) ans += str ( numerator // denominator ) if numerator % denominator == 0 : return ans ans += \".\" dict = {} remainder = numerator % denominator while remainder : if remainder in dict : ans = ans [: dict [ remainder ]] + '(' + ans [ dict [ remainder ]:] + ')' break dict [ remainder ] = len ( ans ) remainder *= 10 ans += str ( remainder // denominator ) remainder %= denominator return ans","title":"166. Fraction to Recurring Decimal"},{"location":"problems/0166/#166-fraction-to-recurring-decimal","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = labs ( numerator ); long d = labs ( denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > seen ; for ( long r = n % d ; r ; r %= d ) { if ( seen . count ( r )) { ans . insert ( seen [ r ], 1 , '(' ); ans += ')' ; break ; } seen [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public String fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; StringBuilder sb = new StringBuilder (); if ( numerator < 0 ^ denominator < 0 ) sb . append ( \"-\" ); long n = Math . abs (( long ) numerator ); long d = Math . abs (( long ) denominator ); sb . append ( n / d ); if ( n % d == 0 ) return sb . toString (); sb . append ( \".\" ); Map < Long , Integer > seen = new HashMap <> (); for ( long r = n % d ; r > 0 ; r %= d ) { if ( seen . containsKey ( r )) { sb . insert ( seen . get ( r ), \"(\" ); sb . append ( \")\" ); break ; } seen . put ( r , sb . length ()); r *= 10 ; sb . append ( r / d ); } return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fractionToDecimal ( self , numerator : int , denominator : int ) -> str : if numerator == 0 : return \"0\" ans = \"\" if ( numerator < 0 ) ^ ( denominator < 0 ): ans += \"-\" numerator = abs ( numerator ) denominator = abs ( denominator ) ans += str ( numerator // denominator ) if numerator % denominator == 0 : return ans ans += \".\" dict = {} remainder = numerator % denominator while remainder : if remainder in dict : ans = ans [: dict [ remainder ]] + '(' + ans [ dict [ remainder ]:] + ')' break dict [ remainder ] = len ( ans ) remainder *= 10 ans += str ( remainder // denominator ) remainder %= denominator return ans","title":"166. Fraction to Recurring Decimal"},{"location":"problems/0167/","text":"167. Two Sum II - Input array is sorted Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return { l + 1 , r + 1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return new int [] { l + 1 , r + 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1","title":"167. Two Sum II - Input array is sorted"},{"location":"problems/0167/#167-two-sum-ii-input-array-is-sorted","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return { l + 1 , r + 1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return new int [] { l + 1 , r + 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1","title":"167. Two Sum II - Input array is sorted"},{"location":"problems/0168/","text":"168. Excel Sheet Column Title Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; Java 1 2 3 4 5 class Solution { public String convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char ) ( 'A' + (( n - 1 ) % 26 )); } } Python 1 2 3 class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\"","title":"168. Excel Sheet Column Title"},{"location":"problems/0168/#168-excel-sheet-column-title","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; Java 1 2 3 4 5 class Solution { public String convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char ) ( 'A' + (( n - 1 ) % 26 )); } } Python 1 2 3 class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\"","title":"168. Excel Sheet Column Title"},{"location":"problems/0169/","text":"169. Majority Element Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( const int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : -1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( final int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans","title":"169. Majority Element"},{"location":"problems/0169/#169-majority-element","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( const int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : -1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( final int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans","title":"169. Majority Element"},{"location":"problems/0170/","text":"170. Two Sum III - Data structure design \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class TwoSum { public : void add ( int number ) { ++ count [ number ]; } bool find ( int value ) { for ( const auto & [ key , freq ] : count ) { const int remain = value - key ; if ( key == remain && freq > 1 ) return true ; if ( key != remain && count . count ( remain )) return true ; } return false ; } private : unordered_map < int , int > count ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TwoSum { public void add ( int number ) { count . put ( number , count . getOrDefault ( number , 0 ) + 1 ); } public boolean find ( int value ) { for ( final Map . Entry < Integer , Integer > entry : count . entrySet ()) { final int key = entry . getKey (); final int remain = value - key ; if ( key == remain && entry . getValue () > 1 ) return true ; if ( key != remain && count . containsKey ( remain )) return true ; } return false ; } private HashMap < Integer , Integer > count = new HashMap <> (); }","title":"170. Two Sum III - Data structure design"},{"location":"problems/0170/#170-two-sum-iii-data-structure-design","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class TwoSum { public : void add ( int number ) { ++ count [ number ]; } bool find ( int value ) { for ( const auto & [ key , freq ] : count ) { const int remain = value - key ; if ( key == remain && freq > 1 ) return true ; if ( key != remain && count . count ( remain )) return true ; } return false ; } private : unordered_map < int , int > count ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class TwoSum { public void add ( int number ) { count . put ( number , count . getOrDefault ( number , 0 ) + 1 ); } public boolean find ( int value ) { for ( final Map . Entry < Integer , Integer > entry : count . entrySet ()) { final int key = entry . getKey (); final int remain = value - key ; if ( key == remain && entry . getValue () > 1 ) return true ; if ( key != remain && count . containsKey ( remain )) return true ; } return false ; } private HashMap < Integer , Integer > count = new HashMap <> (); }","title":"170. Two Sum III - Data structure design \ud83d\udd12"},{"location":"problems/0171/","text":"171. Excel Sheet Column Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( begin ( s ), end ( s ), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int titleToNumber ( String s ) { int ans = 0 ; for ( final char c : s . toCharArray ()) ans = ans * 26 + c - '@' ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def titleToNumber ( self , s : str ) -> int : ans = 0 for c in s : ans = ans * 26 + ord ( c ) - ord ( '@' ) return ans","title":"171. Excel Sheet Column Number"},{"location":"problems/0171/#171-excel-sheet-column-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( begin ( s ), end ( s ), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int titleToNumber ( String s ) { int ans = 0 ; for ( final char c : s . toCharArray ()) ans = ans * 26 + c - '@' ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def titleToNumber ( self , s : str ) -> int : ans = 0 for c in s : ans = ans * 26 + ord ( c ) - ord ( '@' ) return ans","title":"171. Excel Sheet Column Number"},{"location":"problems/0172/","text":"172. Factorial Trailing Zeroes Time: $O(\\log_5 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; Java 1 2 3 4 5 class Solution { public int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } } Python 1 2 3 class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 )","title":"172. Factorial Trailing Zeroes"},{"location":"problems/0172/#172-factorial-trailing-zeroes","text":"Time: $O(\\log_5 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; Java 1 2 3 4 5 class Solution { public int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } } Python 1 2 3 class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 )","title":"172. Factorial Trailing Zeroes"},{"location":"problems/0173/","text":"173. Binary Search Tree Iterator Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BSTIterator { public : BSTIterator ( TreeNode * root ) { pushLeftsUntilNull ( root ); } /** @return the next smallest number */ int next () { TreeNode * root = stack . top (); stack . pop (); pushLeftsUntilNull ( root -> right ); return root -> val ; } /** @return whether we have a next smallest number */ bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; void pushLeftsUntilNull ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class BSTIterator { public BSTIterator ( TreeNode root ) { while ( root != null ) { stack . push ( root ); root = root . left ; } } public int next () { TreeNode node = stack . pop (); final int ans = node . val ; node = node . right ; while ( node != null ) { stack . push ( node ); node = node . left ; } return ans ; } public boolean hasNext () { return ! stack . isEmpty (); } private Stack < TreeNode > stack = new Stack <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left","title":"173. Binary Search Tree Iterator"},{"location":"problems/0173/#173-binary-search-tree-iterator","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BSTIterator { public : BSTIterator ( TreeNode * root ) { pushLeftsUntilNull ( root ); } /** @return the next smallest number */ int next () { TreeNode * root = stack . top (); stack . pop (); pushLeftsUntilNull ( root -> right ); return root -> val ; } /** @return whether we have a next smallest number */ bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; void pushLeftsUntilNull ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class BSTIterator { public BSTIterator ( TreeNode root ) { while ( root != null ) { stack . push ( root ); root = root . left ; } } public int next () { TreeNode node = stack . pop (); final int ans = node . val ; node = node . right ; while ( node != null ) { stack . push ( node ); node = node . left ; } return ans ; } public boolean hasNext () { return ! stack . isEmpty (); } private Stack < TreeNode > stack = new Stack <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left","title":"173. Binary Search Tree Iterator"},{"location":"problems/0174/","text":"174. Dungeon Game Time: $O(mn)$ Space: $O(mn) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]; dp [ i ][ j ] = max ( dp [ i ][ j ], 1 ); } return dp [ 0 ][ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int calculateMinimumHP ( int [][] dungeon ) { final int m = dungeon . length ; final int n = dungeon [ 0 ] . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i ][ j + 1 ] ) - dungeon [ i ][ j ] ; dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , 1 ); } return dp [ 0 ][ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [ float ( 'inf' )] * ( n + 1 ) dp [ n - 1 ] = 1 for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: dp [ j ] = min ( dp [ j ], dp [ j + 1 ]) - dungeon [ i ][ j ] dp [ j ] = max ( dp [ j ], 1 ) return dp [ 0 ]","title":"174. Dungeon Game"},{"location":"problems/0174/#174-dungeon-game","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]; dp [ i ][ j ] = max ( dp [ i ][ j ], 1 ); } return dp [ 0 ][ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int calculateMinimumHP ( int [][] dungeon ) { final int m = dungeon . length ; final int n = dungeon [ 0 ] . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i ][ j + 1 ] ) - dungeon [ i ][ j ] ; dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , 1 ); } return dp [ 0 ][ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [ float ( 'inf' )] * ( n + 1 ) dp [ n - 1 ] = 1 for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: dp [ j ] = min ( dp [ j ], dp [ j + 1 ]) - dungeon [ i ][ j ] dp [ j ] = max ( dp [ j ], 1 ) return dp [ 0 ]","title":"174. Dungeon Game"},{"location":"problems/0175/","text":"175. Combine Two Tables","title":"175. Combine Two Tables"},{"location":"problems/0175/#175-combine-two-tables","text":"","title":"175. Combine Two Tables"},{"location":"problems/0176/","text":"176. Second Highest Salary","title":"176. Second Highest Salary"},{"location":"problems/0176/#176-second-highest-salary","text":"","title":"176. Second Highest Salary"},{"location":"problems/0177/","text":"177. Nth Highest Salary","title":"177. Nth Highest Salary"},{"location":"problems/0177/#177-nth-highest-salary","text":"","title":"177. Nth Highest Salary"},{"location":"problems/0178/","text":"178. Rank Scores","title":"178. Rank Scores"},{"location":"problems/0178/#178-rank-scores","text":"","title":"178. Rank Scores"},{"location":"problems/0179/","text":"179. Largest Number Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( begin ( nums ), end ( nums ), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( const int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public String largestNumber ( int [] nums ) { StringBuilder sb = new StringBuilder (); String [] strings = new String [ nums . length ] ; for ( int i = 0 ; i < nums . length ; ++ i ) strings [ i ] = String . valueOf ( nums [ i ] ); Arrays . sort ( strings , ( a , b ) -> ( b + a ). compareTo ( a + b )); for ( final String s : strings ) sb . append ( s ); return sb . charAt ( 0 ) == '0' ? \"0\" : sb . toString (); } }","title":"179. Largest Number"},{"location":"problems/0179/#179-largest-number","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( begin ( nums ), end ( nums ), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( const int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public String largestNumber ( int [] nums ) { StringBuilder sb = new StringBuilder (); String [] strings = new String [ nums . length ] ; for ( int i = 0 ; i < nums . length ; ++ i ) strings [ i ] = String . valueOf ( nums [ i ] ); Arrays . sort ( strings , ( a , b ) -> ( b + a ). compareTo ( a + b )); for ( final String s : strings ) sb . append ( s ); return sb . charAt ( 0 ) == '0' ? \"0\" : sb . toString (); } }","title":"179. Largest Number"},{"location":"problems/0180/","text":"180. Consecutive Numbers","title":"180. Consecutive Numbers"},{"location":"problems/0180/#180-consecutive-numbers","text":"","title":"180. Consecutive Numbers"},{"location":"problems/0181/","text":"181. Employees Earning More Than Their Managers","title":"181. Employees Earning More Than Their Managers"},{"location":"problems/0181/#181-employees-earning-more-than-their-managers","text":"","title":"181. Employees Earning More Than Their Managers"},{"location":"problems/0182/","text":"182. Duplicate Emails","title":"182. Duplicate Emails"},{"location":"problems/0182/#182-duplicate-emails","text":"","title":"182. Duplicate Emails"},{"location":"problems/0183/","text":"183. Customers Who Never Order","title":"183. Customers Who Never Order"},{"location":"problems/0183/#183-customers-who-never-order","text":"","title":"183. Customers Who Never Order"},{"location":"problems/0184/","text":"184. Department Highest Salary","title":"184. Department Highest Salary"},{"location":"problems/0184/#184-department-highest-salary","text":"","title":"184. Department Highest Salary"},{"location":"problems/0185/","text":"185. Department Top Three Salaries","title":"185. Department Top Three Salaries"},{"location":"problems/0185/#185-department-top-three-salaries","text":"","title":"185. Department Top Three Salaries"},{"location":"problems/0186/","text":"186. Reverse Words in a String II \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : void reverseWords ( vector < char >& s ) { reverse ( begin ( s ), end ( s )); // reverse the whole string reverseWords ( s , s . size ()); // reverse each word } private : void reverseWords ( vector < char >& s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) ++ i ; // skip spaces while ( j < i || j < n && s [ j ] != ' ' ) ++ j ; // skip non spaces reverse ( begin ( s ) + i , begin ( s ) + j ); // reverse the word } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public void reverseWords ( char [] s ) { reverse ( s , 0 , s . length - 1 ); // reverse the whole string reverseWords ( s , s . length ); // reverse each word } private void reverse ( char [] s , int l , int r ) { while ( l < r ) { final char c = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = c ; } } private void reverseWords ( char [] s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) // skip spaces ++ i ; while ( j < i || j < n && s [ j ] != ' ' ) // skip non spaces ++ j ; reverse ( s , i , j - 1 ); // reverse the word } } }","title":"186. Reverse Words in a String II"},{"location":"problems/0186/#186-reverse-words-in-a-string-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : void reverseWords ( vector < char >& s ) { reverse ( begin ( s ), end ( s )); // reverse the whole string reverseWords ( s , s . size ()); // reverse each word } private : void reverseWords ( vector < char >& s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) ++ i ; // skip spaces while ( j < i || j < n && s [ j ] != ' ' ) ++ j ; // skip non spaces reverse ( begin ( s ) + i , begin ( s ) + j ); // reverse the word } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public void reverseWords ( char [] s ) { reverse ( s , 0 , s . length - 1 ); // reverse the whole string reverseWords ( s , s . length ); // reverse each word } private void reverse ( char [] s , int l , int r ) { while ( l < r ) { final char c = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = c ; } } private void reverseWords ( char [] s , int n ) { int i = 0 ; int j = 0 ; while ( i < n ) { while ( i < j || i < n && s [ i ] == ' ' ) // skip spaces ++ i ; while ( j < i || j < n && s [ j ] != ' ' ) // skip non spaces ++ j ; reverse ( s , i , j - 1 ); // reverse the word } } }","title":"186. Reverse Words in a String II \ud83d\udd12"},{"location":"problems/0187/","text":"187. Repeated DNA Sequences Time: $O(10n)$ Space: $O(10n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { unordered_set < string > ans ; unordered_set < string_view > seen ; const string_view sv ( s ); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { if ( seen . count ( sv . substr ( i , 10 ))) ans . insert ( s . substr ( i , 10 )); seen . insert ( sv . substr ( i , 10 )); } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public List < String > findRepeatedDnaSequences ( String s ) { Set < String > ans = new HashSet <> (); Set < String > seen = new HashSet <> (); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { final String seq = s . substring ( i , i + 10 ); if ( seen . contains ( seq )) ans . add ( seq ); seen . add ( seq ); } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () seen = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in seen : ans . add ( seq ) seen . add ( seq ) return list ( ans )","title":"187. Repeated DNA Sequences"},{"location":"problems/0187/#187-repeated-dna-sequences","text":"Time: $O(10n)$ Space: $O(10n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { unordered_set < string > ans ; unordered_set < string_view > seen ; const string_view sv ( s ); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { if ( seen . count ( sv . substr ( i , 10 ))) ans . insert ( s . substr ( i , 10 )); seen . insert ( sv . substr ( i , 10 )); } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public List < String > findRepeatedDnaSequences ( String s ) { Set < String > ans = new HashSet <> (); Set < String > seen = new HashSet <> (); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { final String seq = s . substring ( i , i + 10 ); if ( seen . contains ( seq )) ans . add ( seq ); seen . add ( seq ); } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () seen = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in seen : ans . add ( seq ) seen . add ( seq ) return list ( ans )","title":"187. Repeated DNA Sequences"},{"location":"problems/0188/","text":"188. Best Time to Buy and Sell Stock IV Time: $O(nk)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( const int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ] ; int [] hold = new int [ k + 1 ] ; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( final int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = Math . max ( sell [ i ] , hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ] , sell [ i - 1 ] - price ); } return sell [ k ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ]","title":"188. Best Time to Buy and Sell Stock IV"},{"location":"problems/0188/#188-best-time-to-buy-and-sell-stock-iv","text":"Time: $O(nk)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( const int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( final int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ] ; int [] hold = new int [ k + 1 ] ; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( final int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = Math . max ( sell [ i ] , hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ] , sell [ i - 1 ] - price ); } return sell [ k ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ]","title":"188. Best Time to Buy and Sell Stock IV"},{"location":"problems/0189/","text":"189. Rotate Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int l , int r ) { final int temp = nums [ l ] ; nums [ l ] = nums [ r ] ; nums [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1","title":"189. Rotate Array"},{"location":"problems/0189/#189-rotate-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int l , int r ) { final int temp = nums [ l ] ; nums [ l ] = nums [ r ] ; nums [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1","title":"189. Rotate Array"},{"location":"problems/0190/","text":"190. Reverse Bits Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 public class Solution { // you need treat n as an unsigned value public int reverseBits ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ((( n >> i ) & 1 ) == 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } }","title":"190. Reverse Bits"},{"location":"problems/0190/#190-reverse-bits","text":"Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : uint32_t reverseBits ( uint32_t n ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 public class Solution { // you need treat n as an unsigned value public int reverseBits ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ((( n >> i ) & 1 ) == 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } }","title":"190. Reverse Bits"},{"location":"problems/0191/","text":"191. Number of 1 Bits Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 public class Solution { // you need to treat n as an unsigned value public int hammingWeight ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ((( n >> i ) & 1 ) == 1 ) ++ ans ; return ans ; } }","title":"191. Number of 1 Bits"},{"location":"problems/0191/#191-number-of-1-bits","text":"Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 public class Solution { // you need to treat n as an unsigned value public int hammingWeight ( int n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ((( n >> i ) & 1 ) == 1 ) ++ ans ; return ans ; } }","title":"191. Number of 1 Bits"},{"location":"problems/0192/","text":"192. Word Frequency","title":"192. Word Frequency"},{"location":"problems/0192/#192-word-frequency","text":"","title":"192. Word Frequency"},{"location":"problems/0193/","text":"193. Valid Phone Numbers","title":"193. Valid Phone Numbers"},{"location":"problems/0193/#193-valid-phone-numbers","text":"","title":"193. Valid Phone Numbers"},{"location":"problems/0194/","text":"194. Transpose File","title":"194. Transpose File"},{"location":"problems/0194/#194-transpose-file","text":"","title":"194. Transpose File"},{"location":"problems/0195/","text":"195. Tenth Line","title":"195. Tenth Line"},{"location":"problems/0195/#195-tenth-line","text":"","title":"195. Tenth Line"},{"location":"problems/0196/","text":"196. Delete Duplicate Emails","title":"196. Delete Duplicate Emails"},{"location":"problems/0196/#196-delete-duplicate-emails","text":"","title":"196. Delete Duplicate Emails"},{"location":"problems/0197/","text":"197. Rising Temperature","title":"197. Rising Temperature"},{"location":"problems/0197/#197-rising-temperature","text":"","title":"197. Rising Temperature"},{"location":"problems/0198/","text":"198. House Robber Approach 1: 1D DP Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; // dp[i] := max money of robbing nums[0..i] vector < int > dp ( nums . size ()); dp [ 0 ] = nums [ 0 ]; dp [ 1 ] = max ( nums [ 0 ], nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + nums [ i ]); return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int rob ( int [] nums ) { final int n = nums . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return nums [ 0 ] ; // dp[i] := max money of robbing nums[0..i] int [] dp = new int [ n ] ; dp [ 0 ] = nums [ 0 ] ; dp [ 1 ] = Math . max ( nums [ 0 ] , nums [ 1 ] ); for ( int i = 2 ; i < n ; ++ i ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + nums [ i ] ); return dp [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1 Approach 2: $O(1)$ DP Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( const int num : nums ) { const int dp = max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int rob ( int [] nums ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( final int num : nums ) { final int dp = Math . max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }","title":"198. House Robber"},{"location":"problems/0198/#198-house-robber","text":"","title":"198. House Robber"},{"location":"problems/0198/#approach-1-1d-dp","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; // dp[i] := max money of robbing nums[0..i] vector < int > dp ( nums . size ()); dp [ 0 ] = nums [ 0 ]; dp [ 1 ] = max ( nums [ 0 ], nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) dp [ i ] = max ( dp [ i - 1 ], dp [ i - 2 ] + nums [ i ]); return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int rob ( int [] nums ) { final int n = nums . length ; if ( n == 0 ) return 0 ; if ( n == 1 ) return nums [ 0 ] ; // dp[i] := max money of robbing nums[0..i] int [] dp = new int [ n ] ; dp [ 0 ] = nums [ 0 ] ; dp [ 1 ] = Math . max ( nums [ 0 ] , nums [ 1 ] ); for ( int i = 2 ; i < n ; ++ i ) dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ i - 2 ] + nums [ i ] ); return dp [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1","title":"Approach 1: 1D DP"},{"location":"problems/0198/#approach-2-o1-dp","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( const int num : nums ) { const int dp = max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int rob ( int [] nums ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( final int num : nums ) { final int dp = Math . max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } }","title":"Approach 2: $O(1)$ DP"},{"location":"problems/0199/","text":"199. Binary Tree Right Side View Approach 1: BFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { const int size = q . size (); for ( int i = 0 ; i < size ; ++ i ) { root = q . front (), q . pop (); if ( i == size - 1 ) ans . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < Integer > rightSideView ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { final int size = q . size (); for ( int i = 0 ; i < size ; ++ i ) { root = q . poll (); if ( i == size - 1 ) ans . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } } return ans ; } } Approach 2: DFS Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int depth ) { if ( ! root ) return ; if ( depth == ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , depth + 1 ); dfs ( root -> left , depth + 1 ); }; dfs ( root , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > rightSideView ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); dfs ( root , 0 , ans ); return ans ; } private void dfs ( TreeNode root , int depth , List < Integer > ans ) { if ( root == null ) return ; if ( depth == ans . size ()) ans . add ( root . val ); dfs ( root . right , depth + 1 , ans ); dfs ( root . left , depth + 1 , ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , depth : int ) -> None : if not root : return if depth == len ( ans ): ans . append ( root . val ) dfs ( root . right , depth + 1 ) dfs ( root . left , depth + 1 ) ans = [] dfs ( root , 0 ) return ans","title":"199. Binary Tree Right Side View"},{"location":"problems/0199/#199-binary-tree-right-side-view","text":"","title":"199. Binary Tree Right Side View"},{"location":"problems/0199/#approach-1-bfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { const int size = q . size (); for ( int i = 0 ; i < size ; ++ i ) { root = q . front (), q . pop (); if ( i == size - 1 ) ans . push_back ( root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < Integer > rightSideView ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { final int size = q . size (); for ( int i = 0 ; i < size ; ++ i ) { root = q . poll (); if ( i == size - 1 ) ans . add ( root . val ); if ( root . left != null ) q . offer ( root . left ); if ( root . right != null ) q . offer ( root . right ); } } return ans ; } }","title":"Approach 1: BFS"},{"location":"problems/0199/#approach-2-dfs","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int depth ) { if ( ! root ) return ; if ( depth == ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , depth + 1 ); dfs ( root -> left , depth + 1 ); }; dfs ( root , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > rightSideView ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); dfs ( root , 0 , ans ); return ans ; } private void dfs ( TreeNode root , int depth , List < Integer > ans ) { if ( root == null ) return ; if ( depth == ans . size ()) ans . add ( root . val ); dfs ( root . right , depth + 1 , ans ); dfs ( root . left , depth + 1 , ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , depth : int ) -> None : if not root : return if depth == len ( ans ): ans . append ( root . val ) dfs ( root . right , depth + 1 ) dfs ( root . left , depth + 1 ) ans = [] dfs ( root , 0 ) return ans","title":"Approach 2: DFS"},{"location":"problems/0200/","text":"200. Number of Islands Approach 1: BFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; auto bfs = [ & ]( int r , int c ) { queue < pair < int , int >> q {{{ r , c }}}; grid [ r ][ c ] = '2' ; // mark '2' as visited while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != '1' ) continue ; q . push ({ x , y }); grid [ x ][ y ] = '2' ; // mark '2' as visited } } }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { bfs ( i , j ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == '1' ) { bfs ( grid , i , j ); ++ ans ; } return ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( char [][] grid , int r , int c ) { Queue < int []> q = new LinkedList <> (); q . offer ( new int [] { r , c }); grid [ r ][ c ] = '2' ; // mark '2' as visited while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == grid . length || y < 0 || y == grid [ 0 ] . length ) continue ; if ( grid [ x ][ y ] != '1' ) continue ; q . offer ( new int [] { x , y }); grid [ x ][ y ] = '2' ; // mark '2' as visited } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans Approach 2: DFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( grid [ i ][ j ] != '1' ) return ; grid [ i ][ j ] = '2' ; // mark '2' as visited dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; int ans = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { dfs ( i , j ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == '1' ) { dfs ( grid , i , j ); ++ ans ; } return ans ; } private void dfs ( char [][] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ][ j ] != '1' ) return ; grid [ i ][ j ] = '2' ; // mark '2' as visited dfs ( grid , i + 1 , j ); dfs ( grid , i - 1 , j ); dfs ( grid , i , j + 1 ); dfs ( grid , i , j - 1 ); } }","title":"200. Number of Islands"},{"location":"problems/0200/#200-number-of-islands","text":"","title":"200. Number of Islands"},{"location":"problems/0200/#approach-1-bfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; auto bfs = [ & ]( int r , int c ) { queue < pair < int , int >> q {{{ r , c }}}; grid [ r ][ c ] = '2' ; // mark '2' as visited while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != '1' ) continue ; q . push ({ x , y }); grid [ x ][ y ] = '2' ; // mark '2' as visited } } }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { bfs ( i , j ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == '1' ) { bfs ( grid , i , j ); ++ ans ; } return ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( char [][] grid , int r , int c ) { Queue < int []> q = new LinkedList <> (); q . offer ( new int [] { r , c }); grid [ r ][ c ] = '2' ; // mark '2' as visited while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == grid . length || y < 0 || y == grid [ 0 ] . length ) continue ; if ( grid [ x ][ y ] != '1' ) continue ; q . offer ( new int [] { x , y }); grid [ x ][ y ] = '2' ; // mark '2' as visited } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans","title":"Approach 1: BFS"},{"location":"problems/0200/#approach-2-dfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( grid [ i ][ j ] != '1' ) return ; grid [ i ][ j ] = '2' ; // mark '2' as visited dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; int ans = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { dfs ( i , j ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == '1' ) { dfs ( grid , i , j ); ++ ans ; } return ans ; } private void dfs ( char [][] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return ; if ( grid [ i ][ j ] != '1' ) return ; grid [ i ][ j ] = '2' ; // mark '2' as visited dfs ( grid , i + 1 , j ); dfs ( grid , i - 1 , j ); dfs ( grid , i , j + 1 ); dfs ( grid , i , j - 1 ); } }","title":"Approach 2: DFS"},{"location":"problems/0201/","text":"201. Bitwise AND of Numbers Range Time: $O(32) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } } Python 1 2 3 class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m","title":"201. Bitwise AND of Numbers Range"},{"location":"problems/0201/#201-bitwise-and-of-numbers-range","text":"Time: $O(32) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } } Python 1 2 3 class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m","title":"201. Bitwise AND of Numbers Range"},{"location":"problems/0202/","text":"202. Happy Number Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isHappy ( int n ) { auto helper = [ & ]( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; }; int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } private int helper ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isHappy ( self , n : int ) -> bool : def helper ( n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum slow = helper ( n ) fast = helper ( helper ( n )) while slow != fast : slow = helper ( slow ) fast = helper ( helper ( fast )) return slow == 1","title":"202. Happy Number"},{"location":"problems/0202/#202-happy-number","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isHappy ( int n ) { auto helper = [ & ]( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; }; int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } private int helper ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isHappy ( self , n : int ) -> bool : def helper ( n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum slow = helper ( n ) fast = helper ( helper ( n )) while slow != fast : slow = helper ( slow ) fast = helper ( helper ( fast )) return slow == 1","title":"202. Happy Number"},{"location":"problems/0203/","text":"203. Remove Linked List Elements Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for (; head ; head = head -> next ) if ( head -> val != val ) { prev -> next = head ; prev = prev -> next ; } prev -> next = nullptr ; return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public ListNode removeElements ( ListNode head , int val ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for (; head != null ; head = head . next ) if ( head . val != val ) { prev . next = head ; prev = prev . next ; } prev . next = null ; return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : if head . val != val : prev . next = head prev = prev . next head = head . next prev . next = None return dummy . next","title":"203. Remove Linked List Elements"},{"location":"problems/0203/#203-remove-linked-list-elements","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for (; head ; head = head -> next ) if ( head -> val != val ) { prev -> next = head ; prev = prev -> next ; } prev -> next = nullptr ; return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public ListNode removeElements ( ListNode head , int val ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for (; head != null ; head = head . next ) if ( head . val != val ) { prev . next = head ; prev = prev . next ; } prev . next = null ; return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : if head . val != val : prev . next = head prev = prev . next head = head . next prev . next = None return dummy . next","title":"203. Remove Linked List Elements"},{"location":"problems/0204/","text":"204. Count Primes Time: $O(n\\log\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return false ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; int ans = 0 ; boolean [] prime = new boolean [ n ] ; Arrays . fill ( prime , 2 , n , true ); for ( int i = 0 ; i < Math . sqrt ( n ); ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; for ( final boolean p : prime ) if ( p ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ False ] * 2 + [ True ] * ( n - 2 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n , i ): isPrime [ j ] = False return sum ( isPrime )","title":"204. Count Primes"},{"location":"problems/0204/#204-count-primes","text":"Time: $O(n\\log\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return false ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; int ans = 0 ; boolean [] prime = new boolean [ n ] ; Arrays . fill ( prime , 2 , n , true ); for ( int i = 0 ; i < Math . sqrt ( n ); ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; for ( final boolean p : prime ) if ( p ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ False ] * 2 + [ True ] * ( n - 2 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n , i ): isPrime [ j ] = False return sum ( isPrime )","title":"204. Count Primes"},{"location":"problems/0205/","text":"205. Isomorphic Strings Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) return false ; charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) return false ; return true ; } } Python 1 2 3 class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )]","title":"205. Isomorphic Strings"},{"location":"problems/0205/#205-isomorphic-strings","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) return false ; charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > charToIndex_s = new HashMap <> (); Map < Character , Integer > charToIndex_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) if ( charToIndex_s . put ( s . charAt ( i ), i ) != charToIndex_t . put ( t . charAt ( i ), i )) return false ; return true ; } } Python 1 2 3 class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )]","title":"205. Isomorphic Strings"},{"location":"problems/0206/","text":"206. Reverse Linked List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev","title":"206. Reverse Linked List"},{"location":"problems/0206/#206-reverse-linked-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev","title":"206. Reverse Linked List"},{"location":"problems/0207/","text":"207. Course Schedule Time: $O(n^2) \\to O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { const enum State { INIT , VISITING , VISITED }; vector < vector < int >> graph ( numCourses ); vector < State > state ( numCourses ); for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int i ) { if ( state [ i ] == VISITING ) return true ; if ( state [ i ] == VISITED ) return false ; state [ i ] = VISITING ; for ( const int neighbor : graph [ i ]) if ( hasCycle ( neighbor )) return true ; state [ i ] = VISITED ; return false ; }; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i )) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < Integer >[] graph = new List [ numCourses ] ; State [] state = new State [ numCourses ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i , graph , state )) return false ; return true ; } private enum State { INIT , VISITING , VISITED } private boolean hasCycle ( int i , List < Integer >[] graph , State [] state ) { if ( state [ i ] == State . VISITING ) return true ; if ( state [ i ] == State . VISITED ) return false ; state [ i ] = State . VISITING ; for ( final int neighbor : graph [ i ] ) if ( hasCycle ( neighbor , graph , state )) return true ; state [ i ] = State . VISITED ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 return False graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return False return True","title":"207. Course Schedule"},{"location":"problems/0207/#207-course-schedule","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { const enum State { INIT , VISITING , VISITED }; vector < vector < int >> graph ( numCourses ); vector < State > state ( numCourses ); for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int i ) { if ( state [ i ] == VISITING ) return true ; if ( state [ i ] == VISITED ) return false ; state [ i ] = VISITING ; for ( const int neighbor : graph [ i ]) if ( hasCycle ( neighbor )) return true ; state [ i ] = VISITED ; return false ; }; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i )) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < Integer >[] graph = new List [ numCourses ] ; State [] state = new State [ numCourses ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i , graph , state )) return false ; return true ; } private enum State { INIT , VISITING , VISITED } private boolean hasCycle ( int i , List < Integer >[] graph , State [] state ) { if ( state [ i ] == State . VISITING ) return true ; if ( state [ i ] == State . VISITED ) return false ; state [ i ] = State . VISITING ; for ( final int neighbor : graph [ i ] ) if ( hasCycle ( neighbor , graph , state )) return true ; state [ i ] = State . VISITED ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 return False graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return False return True","title":"207. Course Schedule"},{"location":"problems/0208/","text":"208. Implement Trie (Prefix Tree) Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class Trie { public : void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( const string & prefix ) { return find ( prefix ); } private : TrieNode root ; TrieNode * find ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { if ( ! node -> children [ c - 'a' ]) return nullptr ; node = node -> children [ c - 'a' ]; } return node ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class Trie { public void insert ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) return null ; node = node . children [ c - 'a' ] ; } return node ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix : str ) -> dict : node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node","title":"208. Implement Trie (Prefix Tree)"},{"location":"problems/0208/#208-implement-trie-prefix-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class Trie { public : void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( const string & prefix ) { return find ( prefix ); } private : TrieNode root ; TrieNode * find ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { if ( ! node -> children [ c - 'a' ]) return nullptr ; node = node -> children [ c - 'a' ]; } return node ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class Trie { public void insert ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) return null ; node = node . children [ c - 'a' ] ; } return node ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix : str ) -> dict : node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node","title":"208. Implement Trie (Prefix Tree)"},{"location":"problems/0209/","text":"209. Minimum Size Subarray Sum Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { sum += nums [ r ]; while ( sum >= s ) { ans = min ( ans , r - l + 1 ); sum -= nums [ l ++ ]; } } return ans < INT_MAX ? ans : 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { sum += nums [ r ] ; while ( sum >= s ) { ans = Math . min ( ans , r - l + 1 ); sum -= nums [ l ++] ; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0","title":"209. Minimum Size Subarray Sum"},{"location":"problems/0209/#209-minimum-size-subarray-sum","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { sum += nums [ r ]; while ( sum >= s ) { ans = min ( ans , r - l + 1 ); sum -= nums [ l ++ ]; } } return ans < INT_MAX ? ans : 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { sum += nums [ r ] ; while ( sum >= s ) { ans = Math . min ( ans , r - l + 1 ); sum -= nums [ l ++] ; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0","title":"209. Minimum Size Subarray Sum"},{"location":"problems/0210/","text":"210. Course Schedule II Approach 1: DFS Time: $O(n^2) \\to O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { const enum State { INIT , VISITING , VISITED }; vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < State > state ( numCourses ); for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int i ) { if ( state [ i ] == VISITING ) return true ; if ( state [ i ] == VISITED ) return false ; state [ i ] = VISITING ; for ( const int neighbor : graph [ i ]) if ( hasCycle ( neighbor )) return true ; state [ i ] = VISITED ; ans . push_back ( i ); return false ; }; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i )) return {}; reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int [] findOrder ( int numCourses , int [][] prerequisites ) { Deque < Integer > ans = new ArrayDeque <> (); List < Integer >[] graph = new List [ numCourses ] ; State [] state = new State [ numCourses ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i , graph , state , ans )) return new int [] {}; return ans . stream (). mapToInt ( i -> i ). toArray (); } private enum State { INIT , VISITING , VISITED } private boolean hasCycle ( int i , List < Integer >[] graph , State [] state , Deque < Integer > ans ) { if ( state [ i ] == State . VISITING ) return true ; if ( state [ i ] == State . VISITED ) return false ; state [ i ] = State . VISITING ; for ( final int neighbor : graph [ i ] ) if ( hasCycle ( neighbor , graph , state , ans )) return true ; state [ i ] = State . VISITED ; ans . addFirst ( i ); return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findOrder ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> List [ int ]: def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 ans . append ( course ) return False ans = [] graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return [] return ans [:: - 1 ] Approach 2: Topology Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < int > inDegree ( numCourses ); vector < vector < int >> graph ( numCourses ); // build graph for ( const vector < int >& p : prerequisites ) { const int out = p [ 1 ]; const int in = p [ 0 ]; graph [ out ]. push_back ( in ); ++ inDegree [ in ]; } // topology queue < int > q ; for ( int i = 0 ; i < numCourses ; ++ i ) if ( inDegree [ i ] == 0 ) q . push ( i ); while ( ! q . empty ()) { const int out = q . front (); q . pop (); ans . push_back ( out ); for ( const int in : graph [ out ]) if ( -- inDegree [ in ] == 0 ) q . push ( in ); } return ans . size () == numCourses ? ans : vector < int > (); } };","title":"210. Course Schedule II"},{"location":"problems/0210/#210-course-schedule-ii","text":"","title":"210. Course Schedule II"},{"location":"problems/0210/#approach-1-dfs","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { const enum State { INIT , VISITING , VISITED }; vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < State > state ( numCourses ); for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int i ) { if ( state [ i ] == VISITING ) return true ; if ( state [ i ] == VISITED ) return false ; state [ i ] = VISITING ; for ( const int neighbor : graph [ i ]) if ( hasCycle ( neighbor )) return true ; state [ i ] = VISITED ; ans . push_back ( i ); return false ; }; for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i )) return {}; reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int [] findOrder ( int numCourses , int [][] prerequisites ) { Deque < Integer > ans = new ArrayDeque <> (); List < Integer >[] graph = new List [ numCourses ] ; State [] state = new State [ numCourses ] ; for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int i = 0 ; i < numCourses ; ++ i ) if ( hasCycle ( i , graph , state , ans )) return new int [] {}; return ans . stream (). mapToInt ( i -> i ). toArray (); } private enum State { INIT , VISITING , VISITED } private boolean hasCycle ( int i , List < Integer >[] graph , State [] state , Deque < Integer > ans ) { if ( state [ i ] == State . VISITING ) return true ; if ( state [ i ] == State . VISITED ) return false ; state [ i ] = State . VISITING ; for ( final int neighbor : graph [ i ] ) if ( hasCycle ( neighbor , graph , state , ans )) return true ; state [ i ] = State . VISITED ; ans . addFirst ( i ); return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findOrder ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> List [ int ]: def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 ans . append ( course ) return False ans = [] graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return [] return ans [:: - 1 ]","title":"Approach 1: DFS"},{"location":"problems/0210/#approach-2-topology","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < int > inDegree ( numCourses ); vector < vector < int >> graph ( numCourses ); // build graph for ( const vector < int >& p : prerequisites ) { const int out = p [ 1 ]; const int in = p [ 0 ]; graph [ out ]. push_back ( in ); ++ inDegree [ in ]; } // topology queue < int > q ; for ( int i = 0 ; i < numCourses ; ++ i ) if ( inDegree [ i ] == 0 ) q . push ( i ); while ( ! q . empty ()) { const int out = q . front (); q . pop (); ans . push_back ( out ); for ( const int in : graph [ out ]) if ( -- inDegree [ in ] == 0 ) q . push ( in ); } return ans . size () == numCourses ? ans : vector < int > (); } };","title":"Approach 2: Topology"},{"location":"problems/0211/","text":"211. Add and Search Word - Data structure design Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class WordDictionary { public : void addWord ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { return dfs ( word , 0 , & root ); } private : TrieNode root ; bool dfs ( const string & word , int s , TrieNode * node ) { if ( s == word . length ()) return node -> isWord ; if ( word [ s ] != '.' ) { TrieNode * next = node -> children [ word [ s ] - 'a' ]; return next ? dfs ( word , s + 1 , next ) : false ; } // word[s] == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , s + 1 , node -> children [ i ])) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int s , TrieNode node ) { if ( s == word . length ()) return node . isWord ; if ( word . charAt ( s ) != '.' ) { TrieNode next = node . children [ word . charAt ( s ) - 'a' ] ; return next == null ? false : dfs ( word , s + 1 , next ); } // word.charAt(s) == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null && dfs ( word , s + 1 , node . children [ i ] )) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False","title":"211. Add and Search Word - Data structure design"},{"location":"problems/0211/#211-add-and-search-word-data-structure-design","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class WordDictionary { public : void addWord ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { return dfs ( word , 0 , & root ); } private : TrieNode root ; bool dfs ( const string & word , int s , TrieNode * node ) { if ( s == word . length ()) return node -> isWord ; if ( word [ s ] != '.' ) { TrieNode * next = node -> children [ word [ s ] - 'a' ]; return next ? dfs ( word , s + 1 , next ) : false ; } // word[s] == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , s + 1 , node -> children [ i ])) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public boolean isWord = false ; } class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int s , TrieNode node ) { if ( s == word . length ()) return node . isWord ; if ( word . charAt ( s ) != '.' ) { TrieNode next = node . children [ word . charAt ( s ) - 'a' ] ; return next == null ? false : dfs ( word , s + 1 , next ); } // word.charAt(s) == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null && dfs ( word , s + 1 , node . children [ i ] )) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False","title":"211. Add and Search Word - Data structure design"},{"location":"problems/0212/","text":"212. Word Search II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { const int m = board . size (); const int n = board [ 0 ]. size (); vector < string > ans ; for ( const string & word : words ) insert ( word ); function < void ( int , int , TrieNode * ) > dfs = [ & ]( int i , int j , TrieNode * node ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] == '*' ) return ; const char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( i + 1 , j , next ); dfs ( i - 1 , j , next ); dfs ( i , j + 1 , next ); dfs ( i , j - 1 , next ); board [ i ][ j ] = c ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dfs ( i , j , & root ); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public String word ; } class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( final String word : words ) insert ( word ); List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) dfs ( board , i , j , root , ans ); return ans ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] == '*' ) return ; final char c = board [ i ][ j ] ; TrieNode next = node . children [ ( int ) ( c - 'a' ) ] ; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans","title":"212. Word Search II"},{"location":"problems/0212/#212-word-search-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { const int m = board . size (); const int n = board [ 0 ]. size (); vector < string > ans ; for ( const string & word : words ) insert ( word ); function < void ( int , int , TrieNode * ) > dfs = [ & ]( int i , int j , TrieNode * node ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] == '*' ) return ; const char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( i + 1 , j , next ); dfs ( i - 1 , j , next ); dfs ( i , j + 1 , next ); dfs ( i , j - 1 , next ); board [ i ][ j ] = c ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dfs ( i , j , & root ); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public String word ; } class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( final String word : words ) insert ( word ); List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) dfs ( board , i , j , root , ans ); return ans ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { if ( node . children [ c - 'a' ] == null ) node . children [ c - 'a' ] = new TrieNode (); node = node . children [ c - 'a' ] ; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] == '*' ) return ; final char c = board [ i ][ j ] ; TrieNode next = node . children [ ( int ) ( c - 'a' ) ] ; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans","title":"212. Word Search II"},{"location":"problems/0213/","text":"213. House Robber II Time: $O(n)$ Space: $O(n) \\to O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; auto rob = [ & ]( int l , int r ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( int i = l ; i <= r ; ++ i ) { const int dp = max ( prev1 , prev2 + nums [ i ]); prev2 = prev1 ; prev1 = dp ; } return prev1 ; }; return max ( rob ( 0 , nums . size () - 2 ), rob ( 1 , nums . size () - 1 )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int rob ( int [] nums ) { if ( nums . length == 0 ) return 0 ; if ( nums . length == 1 ) return nums [ 0 ] ; return Math . max ( rob ( nums , 0 , nums . length - 2 ), rob ( nums , 1 , nums . length - 1 )); } private int rob ( final int [] nums , int l , int r ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( int i = l ; i <= r ; ++ i ) { final int dp = Math . max ( prev1 , prev2 + nums [ i ] ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 ))","title":"213. House Robber II"},{"location":"problems/0213/#213-house-robber-ii","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; auto rob = [ & ]( int l , int r ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( int i = l ; i <= r ; ++ i ) { const int dp = max ( prev1 , prev2 + nums [ i ]); prev2 = prev1 ; prev1 = dp ; } return prev1 ; }; return max ( rob ( 0 , nums . size () - 2 ), rob ( 1 , nums . size () - 1 )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int rob ( int [] nums ) { if ( nums . length == 0 ) return 0 ; if ( nums . length == 1 ) return nums [ 0 ] ; return Math . max ( rob ( nums , 0 , nums . length - 2 ), rob ( nums , 1 , nums . length - 1 )); } private int rob ( final int [] nums , int l , int r ) { int prev1 = 0 ; // dp[i - 1] int prev2 = 0 ; // dp[i - 2] for ( int i = l ; i <= r ; ++ i ) { final int dp = Math . max ( prev1 , prev2 + nums [ i ] ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 ))","title":"213. House Robber II"},{"location":"problems/0214/","text":"214. Shortest Palindrome Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string shortestPalindrome ( string s ) { string t = s ; reverse ( begin ( t ), end ( t )); const string_view sv_s ( s ); const string_view sv_t ( t ); for ( int i = 0 ; i < s . length (); ++ i ) if ( sv_s . substr ( 0 , s . length () - i ) == sv_t . substr ( i )) return t . substr ( 0 , i ) + s ; return t + s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public String shortestPalindrome ( String s ) { final String t = new StringBuilder ( s ). reverse (). toString (); for ( int i = 0 ; i < t . length (); ++ i ) if ( s . startsWith ( t . substring ( i ))) return t . substring ( 0 , i ) + s ; return t + s ; } }","title":"214. Shortest Palindrome"},{"location":"problems/0214/#214-shortest-palindrome","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string shortestPalindrome ( string s ) { string t = s ; reverse ( begin ( t ), end ( t )); const string_view sv_s ( s ); const string_view sv_t ( t ); for ( int i = 0 ; i < s . length (); ++ i ) if ( sv_s . substr ( 0 , s . length () - i ) == sv_t . substr ( i )) return t . substr ( 0 , i ) + s ; return t + s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public String shortestPalindrome ( String s ) { final String t = new StringBuilder ( s ). reverse (). toString (); for ( int i = 0 ; i < t . length (); ++ i ) if ( s . startsWith ( t . substring ( i ))) return t . substring ( 0 , i ) + s ; return t + s ; } }","title":"214. Shortest Palindrome"},{"location":"problems/0215/","text":"215. Kth Largest Element in an Array Approach 1: Heap Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater <>> pq ; for ( const int num : nums ) { pq . push ( num ); if ( pq . size () > k ) pq . pop (); } return pq . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findKthLargest ( int [] nums , int k ) { PriorityQueue < Integer > pq = new PriorityQueue <> (( a , b ) -> a - b ); // min-heap for ( final int num : nums ) { pq . offer ( num ); while ( pq . size () > k ) pq . poll (); } return pq . peek (); } } Approach 2: Quick Select Time: $O(n) \\to O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { return quickSelect ( nums , 0 , nums . size () - 1 , k ); } private : int quickSelect ( vector < int >& nums , int left , int right , int k ) { int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ]) // nums[right] := the pivot swap ( nums [ l ++ ], nums [ i ]); swap ( nums [ l ], nums [ right ]); const int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ]; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int findKthLargest ( int [] nums , int k ) { return quickSelect ( nums , 0 , nums . length - 1 , k ); } private int quickSelect ( int [] nums , int left , int right , int k ) { int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ] ) // nums[right] := the pivot swap ( nums , l ++ , i ); swap ( nums , l , right ); final int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ] ; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } Approach 3: Quick Select with random pivot Time: $O(n)$ (average) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { return quickSelect ( nums , 0 , nums . size () - 1 , k ); } private : int quickSelect ( vector < int >& nums , int left , int right , int k ) { const int randIndex = rand () % ( right - left + 1 ) + left ; swap ( nums [ right ], nums [ randIndex ]); int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ]) // nums[right] := the pivot swap ( nums [ l ++ ], nums [ i ]); swap ( nums [ l ], nums [ right ]); const int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ]; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int findKthLargest ( int [] nums , int k ) { return quickSelect ( nums , 0 , nums . length - 1 , k ); } private int quickSelect ( int [] nums , int left , int right , int k ) { final int randIndex = new Random (). nextInt ( right - left + 1 ) + left ; swap ( nums , right , randIndex ); int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ] ) // nums[right] := the pivot swap ( nums , l ++ , i ); swap ( nums , l , right ); final int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ] ; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"215. Kth Largest Element in an Array"},{"location":"problems/0215/#215-kth-largest-element-in-an-array","text":"","title":"215. Kth Largest Element in an Array"},{"location":"problems/0215/#approach-1-heap","text":"Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater <>> pq ; for ( const int num : nums ) { pq . push ( num ); if ( pq . size () > k ) pq . pop (); } return pq . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findKthLargest ( int [] nums , int k ) { PriorityQueue < Integer > pq = new PriorityQueue <> (( a , b ) -> a - b ); // min-heap for ( final int num : nums ) { pq . offer ( num ); while ( pq . size () > k ) pq . poll (); } return pq . peek (); } }","title":"Approach 1: Heap"},{"location":"problems/0215/#approach-2-quick-select","text":"Time: $O(n) \\to O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { return quickSelect ( nums , 0 , nums . size () - 1 , k ); } private : int quickSelect ( vector < int >& nums , int left , int right , int k ) { int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ]) // nums[right] := the pivot swap ( nums [ l ++ ], nums [ i ]); swap ( nums [ l ], nums [ right ]); const int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ]; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int findKthLargest ( int [] nums , int k ) { return quickSelect ( nums , 0 , nums . length - 1 , k ); } private int quickSelect ( int [] nums , int left , int right , int k ) { int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ] ) // nums[right] := the pivot swap ( nums , l ++ , i ); swap ( nums , l , right ); final int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ] ; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"Approach 2: Quick Select"},{"location":"problems/0215/#approach-3-quick-select-with-random-pivot","text":"Time: $O(n)$ (average) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { return quickSelect ( nums , 0 , nums . size () - 1 , k ); } private : int quickSelect ( vector < int >& nums , int left , int right , int k ) { const int randIndex = rand () % ( right - left + 1 ) + left ; swap ( nums [ right ], nums [ randIndex ]); int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ]) // nums[right] := the pivot swap ( nums [ l ++ ], nums [ i ]); swap ( nums [ l ], nums [ right ]); const int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ]; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int findKthLargest ( int [] nums , int k ) { return quickSelect ( nums , 0 , nums . length - 1 , k ); } private int quickSelect ( int [] nums , int left , int right , int k ) { final int randIndex = new Random (). nextInt ( right - left + 1 ) + left ; swap ( nums , right , randIndex ); int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( nums [ i ] >= nums [ right ] ) // nums[right] := the pivot swap ( nums , l ++ , i ); swap ( nums , l , right ); final int count = l - left + 1 ; // # of nums >= pivot if ( count == k ) return nums [ l ] ; if ( count > k ) return quickSelect ( nums , left , l - 1 , k ); return quickSelect ( nums , l + 1 , right , k - count ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"Approach 3: Quick Select with random pivot"},{"location":"problems/0216/","text":"216. Combination Sum III Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int , int ) > dfs = [ & ]( int k , int n , int s ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n <= 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 ); path . pop_back (); } }; dfs ( k , n , 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( k , n , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans","title":"216. Combination Sum III"},{"location":"problems/0216/#216-combination-sum-iii","text":"Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int , int ) > dfs = [ & ]( int k , int n , int s ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n <= 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 ); path . pop_back (); } }; dfs ( k , n , 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( k , n , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans","title":"216. Combination Sum III"},{"location":"problems/0217/","text":"217. Contains Duplicate Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . insert ( num ). second ) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) if ( ! seen . add ( num )) return true ; return false ; } } Python 1 2 3 class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums ))","title":"217. Contains Duplicate"},{"location":"problems/0217/#217-contains-duplicate","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . insert ( num ). second ) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) if ( ! seen . add ( num )) return true ; return false ; } } Python 1 2 3 class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums ))","title":"217. Contains Duplicate"},{"location":"problems/0218/","text":"218. The Skyline Problem Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; // {{Li, Hi} | {Ri, -Hi}} for ( const vector < int >& b : buildings ) { events . push_back ({ b [ 0 ], b [ 2 ]}); events . push_back ({ b [ 1 ], - b [ 2 ]}); // minus to indicate leaving } sort ( begin ( events ), end ( events ), []( const vector < int >& a , const vector < int >& b ) { // same entering, sort from higher to lower // same leaving, sort from lower to higher return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& event : events ) { const int x = event [ 0 ]; const int h = abs ( event [ 1 ]); const int isEntering = event [ 1 ] > 0 ; if ( isEntering ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * rbegin ( set ); } };","title":"218. The Skyline Problem"},{"location":"problems/0218/#218-the-skyline-problem","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; // {{Li, Hi} | {Ri, -Hi}} for ( const vector < int >& b : buildings ) { events . push_back ({ b [ 0 ], b [ 2 ]}); events . push_back ({ b [ 1 ], - b [ 2 ]}); // minus to indicate leaving } sort ( begin ( events ), end ( events ), []( const vector < int >& a , const vector < int >& b ) { // same entering, sort from higher to lower // same leaving, sort from lower to higher return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& event : events ) { const int x = event [ 0 ]; const int h = abs ( event [ 1 ]); const int isEntering = event [ 1 ] > 0 ; if ( isEntering ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * rbegin ( set ); } };","title":"218. The Skyline Problem"},{"location":"problems/0219/","text":"219. Contains Duplicate II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > seen ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! seen . insert ( nums [ i ]). second ) return true ; if ( i >= k ) seen . erase ( nums [ i - k ]); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( ! seen . add ( nums [ i ] )) return true ; if ( i >= k ) seen . remove ( nums [ i - k ] ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : seen = set () for i , num in enumerate ( nums ): if i > k : seen . remove ( nums [ i - k - 1 ]) if num in seen : return True seen . add ( num ) return False","title":"219. Contains Duplicate II"},{"location":"problems/0219/#219-contains-duplicate-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > seen ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! seen . insert ( nums [ i ]). second ) return true ; if ( i >= k ) seen . erase ( nums [ i - k ]); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( ! seen . add ( nums [ i ] )) return true ; if ( i >= k ) seen . remove ( nums [ i - k ] ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : seen = set () for i , num in enumerate ( nums ): if i > k : seen . remove ( nums [ i - k - 1 ]) if num in seen : return True seen . add ( num ) return False","title":"219. Contains Duplicate II"},{"location":"problems/0220/","text":"220. Contains Duplicate III Approach 1: Ordered Set Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { set < long > window ; for ( int i = 0 ; i < nums . size (); ++ i ) { const auto it = window . lower_bound (( long ) nums [ i ] - t ); if ( it != cend ( window ) && * it - nums [ i ] <= t ) return true ; window . insert ( nums [ i ]); if ( i >= k ) window . erase ( nums [ i - k ]); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean containsNearbyAlmostDuplicate ( int [] nums , int k , int t ) { TreeSet < Long > set = new TreeSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final long num = ( long ) nums [ i ] ; final Long ceiling = set . ceiling ( num ); // the smallest num >= nums[i] if ( ceiling != null && ceiling - num <= t ) return true ; final Long floor = set . floor ( num ); // the largest num <= nums[i] if ( floor != null && num - floor <= t ) return true ; set . add ( num ); if ( i >= k ) set . remove (( long ) nums [ i - k ] ); } return false ; } } Approach 2: Bucket Time: $O(n)$ Space: $O((\\max(nums) - \\min(nums)) / t) \\to O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { if ( nums . empty () || k <= 0 || t < 0 ) return false ; const long min = * min_element ( begin ( nums ), end ( nums )); const long diff = ( long ) t + 1 ; // in case of t = 0 // use long because corner case INT_MAX - (-1) will overflow unordered_map < long , long > bucket ; for ( int i = 0 ; i < nums . size (); ++ i ) { const long num = nums [ i ]; const long key = getKey ( num , min , diff ); if ( bucket . count ( key )) // current bucket return true ; if ( bucket . count ( key - 1 ) && abs ( bucket [ key - 1 ] - num ) < diff ) // left bucket return true ; if ( bucket . count ( key + 1 ) && abs ( bucket [ key + 1 ] - num ) < diff ) // right bucket return true ; bucket [ key ] = num ; if ( i >= k ) bucket . erase ( getKey ( nums [ i - k ], min , diff )); } return false ; } private : int getKey ( long num , long min , long diff ) { return ( num - min ) / diff ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean containsNearbyAlmostDuplicate ( int [] nums , int k , int t ) { if ( nums . length == 0 || k <= 0 || t < 0 ) return false ; final long min = Arrays . stream ( nums ). min (). getAsInt (); final long diff = ( long ) t + 1 ; // in case of t = 0 // use Long because of corner case Integer.MAX_VALUE - (-1) will overflow HashMap < Long , Long > bucket = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final long num = ( long ) nums [ i ] ; final long key = getKey ( nums [ i ] , min , diff ); if ( bucket . containsKey ( key )) // current bucket return true ; if ( bucket . containsKey ( key - 1 ) && Math . abs ( bucket . get ( key - 1 ) - num ) < diff ) // left adjacent bucket return true ; if ( bucket . containsKey ( key + 1 ) && Math . abs ( bucket . get ( key + 1 ) - num ) < diff ) // right adjacent bucket return true ; bucket . put ( key , num ); if ( i >= k ) bucket . remove ( getKey ( nums [ i - k ] , min , diff )); } return false ; } private long getKey ( int num , long min , long diff ) { return (( long ) num - min ) / diff ; } }","title":"220. Contains Duplicate III"},{"location":"problems/0220/#220-contains-duplicate-iii","text":"","title":"220. Contains Duplicate III"},{"location":"problems/0220/#approach-1-ordered-set","text":"Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { set < long > window ; for ( int i = 0 ; i < nums . size (); ++ i ) { const auto it = window . lower_bound (( long ) nums [ i ] - t ); if ( it != cend ( window ) && * it - nums [ i ] <= t ) return true ; window . insert ( nums [ i ]); if ( i >= k ) window . erase ( nums [ i - k ]); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean containsNearbyAlmostDuplicate ( int [] nums , int k , int t ) { TreeSet < Long > set = new TreeSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final long num = ( long ) nums [ i ] ; final Long ceiling = set . ceiling ( num ); // the smallest num >= nums[i] if ( ceiling != null && ceiling - num <= t ) return true ; final Long floor = set . floor ( num ); // the largest num <= nums[i] if ( floor != null && num - floor <= t ) return true ; set . add ( num ); if ( i >= k ) set . remove (( long ) nums [ i - k ] ); } return false ; } }","title":"Approach 1: Ordered Set"},{"location":"problems/0220/#approach-2-bucket","text":"Time: $O(n)$ Space: $O((\\max(nums) - \\min(nums)) / t) \\to O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { if ( nums . empty () || k <= 0 || t < 0 ) return false ; const long min = * min_element ( begin ( nums ), end ( nums )); const long diff = ( long ) t + 1 ; // in case of t = 0 // use long because corner case INT_MAX - (-1) will overflow unordered_map < long , long > bucket ; for ( int i = 0 ; i < nums . size (); ++ i ) { const long num = nums [ i ]; const long key = getKey ( num , min , diff ); if ( bucket . count ( key )) // current bucket return true ; if ( bucket . count ( key - 1 ) && abs ( bucket [ key - 1 ] - num ) < diff ) // left bucket return true ; if ( bucket . count ( key + 1 ) && abs ( bucket [ key + 1 ] - num ) < diff ) // right bucket return true ; bucket [ key ] = num ; if ( i >= k ) bucket . erase ( getKey ( nums [ i - k ], min , diff )); } return false ; } private : int getKey ( long num , long min , long diff ) { return ( num - min ) / diff ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean containsNearbyAlmostDuplicate ( int [] nums , int k , int t ) { if ( nums . length == 0 || k <= 0 || t < 0 ) return false ; final long min = Arrays . stream ( nums ). min (). getAsInt (); final long diff = ( long ) t + 1 ; // in case of t = 0 // use Long because of corner case Integer.MAX_VALUE - (-1) will overflow HashMap < Long , Long > bucket = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final long num = ( long ) nums [ i ] ; final long key = getKey ( nums [ i ] , min , diff ); if ( bucket . containsKey ( key )) // current bucket return true ; if ( bucket . containsKey ( key - 1 ) && Math . abs ( bucket . get ( key - 1 ) - num ) < diff ) // left adjacent bucket return true ; if ( bucket . containsKey ( key + 1 ) && Math . abs ( bucket . get ( key + 1 ) - num ) < diff ) // right adjacent bucket return true ; bucket . put ( key , num ); if ( i >= k ) bucket . remove ( getKey ( nums [ i - k ] , min , diff )); } return false ; } private long getKey ( int num , long min , long diff ) { return (( long ) num - min ) / diff ; } }","title":"Approach 2: Bucket"},{"location":"problems/0221/","text":"221. Maximal Square Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < vector < int >> dp ( m , vector < int > ( n )); int maxLength = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ i ][ j ]); } return maxLength * maxLength ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int [][] dp = new int [ m ][ n ] ; int maxLength = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j - 1 ] , Math . min ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] )) + 1 ; maxLength = Math . max ( maxLength , dp [ i ][ j ] ); } return maxLength * maxLength ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 dp = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] maxLength = 0 for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ i ][ j ] = 1 if matrix [ i ][ j ] == '1' else 0 else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ], dp [ i - 1 ] [ j ], dp [ i ][ j - 1 ]) + 1 maxLength = max ( maxLength , dp [ i ][ j ]) return maxLength * maxLength Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int maxLength = 0 ; int prev = 0 ; // dp[i - 1][j - 1] for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { const int cache = dp [ j ]; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = min ({ prev , dp [ j ], dp [ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ j ]); prev = cache ; } return maxLength * maxLength ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int [] dp = new int [ n ] ; int maxLength = 0 ; int prev = 0 ; // dp[i - 1][j - 1] for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { final int cache = dp [ j ] ; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = Math . min ( prev , Math . min ( dp [ j ] , dp [ j - 1 ] )) + 1 ; maxLength = Math . max ( maxLength , dp [ j ] ); prev = cache ; } return maxLength * maxLength ; } }","title":"221. Maximal Square"},{"location":"problems/0221/#221-maximal-square","text":"","title":"221. Maximal Square"},{"location":"problems/0221/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < vector < int >> dp ( m , vector < int > ( n )); int maxLength = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ i ][ j ]); } return maxLength * maxLength ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int [][] dp = new int [ m ][ n ] ; int maxLength = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j - 1 ] , Math . min ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] )) + 1 ; maxLength = Math . max ( maxLength , dp [ i ][ j ] ); } return maxLength * maxLength ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 dp = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] maxLength = 0 for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ i ][ j ] = 1 if matrix [ i ][ j ] == '1' else 0 else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ], dp [ i - 1 ] [ j ], dp [ i ][ j - 1 ]) + 1 maxLength = max ( maxLength , dp [ i ][ j ]) return maxLength * maxLength","title":"Approach 1: 2D DP"},{"location":"problems/0221/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int maxLength = 0 ; int prev = 0 ; // dp[i - 1][j - 1] for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { const int cache = dp [ j ]; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = min ({ prev , dp [ j ], dp [ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ j ]); prev = cache ; } return maxLength * maxLength ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int [] dp = new int [ n ] ; int maxLength = 0 ; int prev = 0 ; // dp[i - 1][j - 1] for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { final int cache = dp [ j ] ; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = Math . min ( prev , Math . min ( dp [ j ] , dp [ j - 1 ] )) + 1 ; maxLength = Math . max ( maxLength , dp [ j ] ); prev = cache ; } return maxLength * maxLength ; } }","title":"Approach 2: 1D DP"},{"location":"problems/0222/","text":"222. Count Complete Tree Nodes Time: $O(\\log^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; TreeNode * l = root ; TreeNode * r = root ; int heightL = 0 ; int heightR = 0 ; while ( l ) { ++ heightL ; l = l -> left ; } while ( r ) { ++ heightR ; r = r -> right ; } if ( heightL == heightR ) // root is a complete tree return pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; TreeNode l = root ; TreeNode r = root ; int heightL = 0 ; int heightR = 0 ; while ( l != null ) { ++ heightL ; l = l . left ; } while ( r != null ) { ++ heightR ; r = r . right ; } if ( heightL == heightR ) // root is a complete tree return ( int ) Math . pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans","title":"222. Count Complete Tree Nodes"},{"location":"problems/0222/#222-count-complete-tree-nodes","text":"Time: $O(\\log^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; TreeNode * l = root ; TreeNode * r = root ; int heightL = 0 ; int heightR = 0 ; while ( l ) { ++ heightL ; l = l -> left ; } while ( r ) { ++ heightR ; r = r -> right ; } if ( heightL == heightR ) // root is a complete tree return pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; TreeNode l = root ; TreeNode r = root ; int heightL = 0 ; int heightR = 0 ; while ( l != null ) { ++ heightL ; l = l . left ; } while ( r != null ) { ++ heightR ; r = r . right ; } if ( heightL == heightR ) // root is a complete tree return ( int ) Math . pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans","title":"222. Count Complete Tree Nodes"},{"location":"problems/0223/","text":"223. Rectangle Area Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { const long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; const long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ; } }; Java 1 2 3 4 5 6 7 8 class Solution { public int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { final long x = Math . max ( A , E ) < Math . min ( C , G ) ? ( Math . min ( C , G ) - Math . max ( A , E )) : 0 ; final long y = Math . max ( B , F ) < Math . min ( D , H ) ? ( Math . min ( D , H ) - Math . max ( B , F )) : 0 ; return ( int ) (( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ); } } Python 1 2 3 4 5 6 class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y","title":"223. Rectangle Area"},{"location":"problems/0223/#223-rectangle-area","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { const long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; const long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ; } }; Java 1 2 3 4 5 6 7 8 class Solution { public int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { final long x = Math . max ( A , E ) < Math . min ( C , G ) ? ( Math . min ( C , G ) - Math . max ( A , E )) : 0 ; final long y = Math . max ( B , F ) < Math . min ( D , H ) ? ( Math . min ( D , H ) - Math . max ( B , F )) : 0 ; return ( int ) (( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ); } } Python 1 2 3 4 5 6 class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y","title":"223. Rectangle Area"},{"location":"problems/0224/","text":"224. Basic Calculator Approach 1: Stack Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; stack < int > stack {{ sign }}; // stack.top(): current env's sign for ( const char c : s ) if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '(' ) stack . push ( sign ); else if ( c == ' ) ' ) stack . pop (); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = ( c == '+' ? 1 : -1 ) * stack . top (); num = 0 ; } return ans + sign * num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; Stack < Integer > stack = new Stack <> (); // stack.peek(): current env's sign stack . push ( sign ); for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '(' ) stack . push ( sign ); else if ( c == ')' ) stack . pop (); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = ( c == '+' ? 1 : - 1 ) * stack . peek (); num = 0 ; } return ans + sign * num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def calculate ( self , s : str ) -> int : ans = 0 num = 0 sign = 1 stack = [ sign ] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : ans += sign * num sign = stack [ - 1 ] * ( 1 if c == '+' else - 1 ) num = 0 elif c == '(' : stack . append ( sign ) elif c == ')' : stack . pop () return ans + sign * num Approach 2: Similar to 772. Basic Calculator III Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int calculate ( string s ) { stack < int > nums ; // stores nums stack < char > ops ; // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . pop (); // remove '(' } else { // c == '+' || c == '-' while ( ! ops . empty () && ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : int calculate ( char op , int b , int a ) { return op == '+' ? a + b : a - b ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } int pop ( stack < int >& nums ) { const int num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' while ( ! ops . isEmpty () && ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { return op == '+' ? a + b : a - b ; } }","title":"224. Basic Calculator"},{"location":"problems/0224/#224-basic-calculator","text":"","title":"224. Basic Calculator"},{"location":"problems/0224/#approach-1-stack","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; stack < int > stack {{ sign }}; // stack.top(): current env's sign for ( const char c : s ) if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '(' ) stack . push ( sign ); else if ( c == ' ) ' ) stack . pop (); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = ( c == '+' ? 1 : -1 ) * stack . top (); num = 0 ; } return ans + sign * num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; Stack < Integer > stack = new Stack <> (); // stack.peek(): current env's sign stack . push ( sign ); for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '(' ) stack . push ( sign ); else if ( c == ')' ) stack . pop (); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = ( c == '+' ? 1 : - 1 ) * stack . peek (); num = 0 ; } return ans + sign * num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def calculate ( self , s : str ) -> int : ans = 0 num = 0 sign = 1 stack = [ sign ] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : ans += sign * num sign = stack [ - 1 ] * ( 1 if c == '+' else - 1 ) num = 0 elif c == '(' : stack . append ( sign ) elif c == ')' : stack . pop () return ans + sign * num","title":"Approach 1: Stack"},{"location":"problems/0224/#approach-2-similar-to-772-basic-calculator-iii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int calculate ( string s ) { stack < int > nums ; // stores nums stack < char > ops ; // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . pop (); // remove '(' } else { // c == '+' || c == '-' while ( ! ops . empty () && ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : int calculate ( char op , int b , int a ) { return op == '+' ? a + b : a - b ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } int pop ( stack < int >& nums ) { const int num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' while ( ! ops . isEmpty () && ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { return op == '+' ? a + b : a - b ; } }","title":"Approach 2: Similar to 772. Basic Calculator III"},{"location":"problems/0225/","text":"225. Implement Stack using Queues Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyStack { public : void push ( int x ) { q . push ( x ); for ( int i = 0 ; i < q . size () - 1 ; ++ i ) { q . push ( q . front ()); q . pop (); } } int pop () { const int val = q . front (); q . pop (); return val ; } int top () { return q . front (); } bool empty () { return q . empty (); } private : queue < int > q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyStack { public void push ( int x ) { q . offer ( x ); for ( int i = 0 ; i < q . size () - 1 ; ++ i ) q . offer ( q . poll ()); } public int pop () { return q . poll (); } public int top () { return q . peek (); } public boolean empty () { return q . isEmpty (); } private Queue < Integer > q = new LinkedList <> (); }","title":"225. Implement Stack using Queues"},{"location":"problems/0225/#225-implement-stack-using-queues","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyStack { public : void push ( int x ) { q . push ( x ); for ( int i = 0 ; i < q . size () - 1 ; ++ i ) { q . push ( q . front ()); q . pop (); } } int pop () { const int val = q . front (); q . pop (); return val ; } int top () { return q . front (); } bool empty () { return q . empty (); } private : queue < int > q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyStack { public void push ( int x ) { q . offer ( x ); for ( int i = 0 ; i < q . size () - 1 ; ++ i ) q . offer ( q . poll ()); } public int pop () { return q . poll (); } public int top () { return q . peek (); } public boolean empty () { return q . isEmpty (); } private Queue < Integer > q = new LinkedList <> (); }","title":"225. Implement Stack using Queues"},{"location":"problems/0226/","text":"226. Invert Binary Tree Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; TreeNode * const left = root -> left ; TreeNode * const right = root -> right ; root -> left = invertTree ( right ); root -> right = invertTree ( left ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public TreeNode invertTree ( TreeNode root ) { if ( root == null ) return null ; final TreeNode left = root . left ; final TreeNode right = root . right ; root . left = invertTree ( right ); root . right = invertTree ( left ); return root ; } }","title":"226. Invert Binary Tree"},{"location":"problems/0226/#226-invert-binary-tree","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; TreeNode * const left = root -> left ; TreeNode * const right = root -> right ; root -> left = invertTree ( right ); root -> right = invertTree ( left ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public TreeNode invertTree ( TreeNode root ) { if ( root == null ) return null ; final TreeNode left = root . left ; final TreeNode right = root . right ; root . left = invertTree ( right ); root . right = invertTree ( left ); return root ; } }","title":"226. Invert Binary Tree"},{"location":"problems/0227/","text":"227. Basic Calculator II Approach 1: Stack Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : int calculate ( string s ) { int num = 0 ; char sign = '+' ; vector < int > stack ; for ( const char c : s + '+' ) if ( isdigit ( c )) { num = num * 10 + ( c - '0' ); } else if ( isSign ( c )) { switch ( sign ) { case '+' : stack . push_back ( num ); break ; case '-' : stack . push_back ( - num ); break ; case '*' : num = stack . back () * num ; stack . pop_back (); stack . push_back ( num ); break ; default : num = stack . back () / num ; stack . pop_back (); stack . push_back ( num ); } num = 0 ; sign = c ; } return accumulate ( begin ( stack ), end ( stack ), 0 ); } private : bool isSign ( const char c ) { return c == '+' || c == '-' || c == '*' || c == '/' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; Stack < Integer > stack = new Stack <> (); for ( final char c : ( s + \"+\" ). toCharArray ()) if ( Character . isDigit ( c )) { num = num * 10 + ( c - '0' ); } else if ( isSign ( c )) { switch ( sign ) { case '+' : stack . push ( num ); break ; case '-' : stack . push ( - num ); break ; case '*' : stack . push ( stack . pop () * num ); break ; default : stack . push ( stack . pop () / num ); break ; } num = 0 ; sign = c ; } while ( ! stack . isEmpty ()) ans += stack . pop (); return ans ; } private boolean isSign ( final char c ) { return c == '+' || c == '-' || c == '*' || c == '/' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def calculate ( self , s : str ) -> int : num = 0 sign = '+' stack = [] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + int ( c ) if not c . isdigit () and c != ' ' or i == len ( s ) - 1 : if sign == '+' : stack . append ( num ) elif sign == '-' : stack . append ( - num ) elif sign == '*' : stack . append ( stack . pop () * num ) else : if stack [ - 1 ] < 0 : stack . append ( math . ceil ( stack . pop () / num )) else : stack . append ( stack . pop () // num ) num = 0 sign = c return sum ( stack ) Approach 2: Similar to 772. Basic Calculator III Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public : int calculate ( string s ) { stack < int > nums ; // stores nums stack < char > ops ; // stores operators for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . empty () && compare ( ops . top (), c )) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw ; } // return true if priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } int pop ( stack < int >& nums ) { const int num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw new IllegalArgumentException (); } // return true if priority(op1) >= priority(op2) private boolean compare ( char op1 , char op2 ) { return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"227. Basic Calculator II"},{"location":"problems/0227/#227-basic-calculator-ii","text":"","title":"227. Basic Calculator II"},{"location":"problems/0227/#approach-1-stack","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : int calculate ( string s ) { int num = 0 ; char sign = '+' ; vector < int > stack ; for ( const char c : s + '+' ) if ( isdigit ( c )) { num = num * 10 + ( c - '0' ); } else if ( isSign ( c )) { switch ( sign ) { case '+' : stack . push_back ( num ); break ; case '-' : stack . push_back ( - num ); break ; case '*' : num = stack . back () * num ; stack . pop_back (); stack . push_back ( num ); break ; default : num = stack . back () / num ; stack . pop_back (); stack . push_back ( num ); } num = 0 ; sign = c ; } return accumulate ( begin ( stack ), end ( stack ), 0 ); } private : bool isSign ( const char c ) { return c == '+' || c == '-' || c == '*' || c == '/' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; Stack < Integer > stack = new Stack <> (); for ( final char c : ( s + \"+\" ). toCharArray ()) if ( Character . isDigit ( c )) { num = num * 10 + ( c - '0' ); } else if ( isSign ( c )) { switch ( sign ) { case '+' : stack . push ( num ); break ; case '-' : stack . push ( - num ); break ; case '*' : stack . push ( stack . pop () * num ); break ; default : stack . push ( stack . pop () / num ); break ; } num = 0 ; sign = c ; } while ( ! stack . isEmpty ()) ans += stack . pop (); return ans ; } private boolean isSign ( final char c ) { return c == '+' || c == '-' || c == '*' || c == '/' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def calculate ( self , s : str ) -> int : num = 0 sign = '+' stack = [] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + int ( c ) if not c . isdigit () and c != ' ' or i == len ( s ) - 1 : if sign == '+' : stack . append ( num ) elif sign == '-' : stack . append ( - num ) elif sign == '*' : stack . append ( stack . pop () * num ) else : if stack [ - 1 ] < 0 : stack . append ( math . ceil ( stack . pop () / num )) else : stack . append ( stack . pop () // num ) num = 0 sign = c return sum ( stack )","title":"Approach 1: Stack"},{"location":"problems/0227/#approach-2-similar-to-772-basic-calculator-iii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public : int calculate ( string s ) { stack < int > nums ; // stores nums stack < char > ops ; // stores operators for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . empty () && compare ( ops . top (), c )) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw ; } // return true if priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } int pop ( stack < int >& nums ) { const int num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw new IllegalArgumentException (); } // return true if priority(op1) >= priority(op2) private boolean compare ( char op1 , char op2 ) { return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"Approach 2: Similar to 772. Basic Calculator III"},{"location":"problems/0228/","text":"228. Summary Ranges Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int begin = nums [ i ]; while ( i + 1 < nums . size () && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; const int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final int begin = nums [ i ] ; while ( i + 1 < nums . length && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; final int end = nums [ i ] ; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans","title":"228. Summary Ranges"},{"location":"problems/0228/#228-summary-ranges","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int begin = nums [ i ]; while ( i + 1 < nums . size () && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; const int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final int begin = nums [ i ] ; while ( i + 1 < nums . length && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; final int end = nums [ i ] ; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans","title":"228. Summary Ranges"},{"location":"problems/0229/","text":"229. Majority Element II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int candidate1 = 0 ; int candidate2 = 1 ; // any number different from candidate1 int countSoFar1 = 0 ; // # of candidate1 so far int countSoFar2 = 0 ; // # of candidate2 so far for ( const int num : nums ) if ( num == candidate1 ) { ++ countSoFar1 ; } else if ( num == candidate2 ) { ++ countSoFar2 ; } else if ( countSoFar1 == 0 ) { // assign new candidate candidate1 = num ; ++ countSoFar1 ; } else if ( countSoFar2 == 0 ) { // assign new candidate candidate2 = num ; ++ countSoFar2 ; } else { // meet a new number, so pair out previous counts -- countSoFar1 ; -- countSoFar2 ; } const int count1 = count ( begin ( nums ), end ( nums ), candidate1 ); const int count2 = count ( begin ( nums ), end ( nums ), candidate2 ); if ( count1 > nums . size () / 3 ) ans . push_back ( candidate1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( candidate2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <> (); int candidate1 = 0 ; int candidate2 = 1 ; // any number different from candidate1 int countSoFar1 = 0 ; // # of candidate1 so far int countSoFar2 = 0 ; // # of candidate2 so far for ( final int num : nums ) if ( num == candidate1 ) { ++ countSoFar1 ; } else if ( num == candidate2 ) { ++ countSoFar2 ; } else if ( countSoFar1 == 0 ) { // assign new candidate candidate1 = num ; ++ countSoFar1 ; } else if ( countSoFar2 == 0 ) { // assign new candidate candidate2 = num ; ++ countSoFar2 ; } else { // meet a new number, so pair out previous counts -- countSoFar1 ; -- countSoFar2 ; } int count1 = 0 ; int count2 = 0 ; for ( final int num : nums ) if ( num == candidate1 ) ++ count1 ; else if ( num == candidate2 ) ++ count2 ; if ( count1 > nums . length / 3 ) ans . add ( candidate1 ); if ( count2 > nums . length / 3 ) ans . add ( candidate2 ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ]","title":"229. Majority Element II"},{"location":"problems/0229/#229-majority-element-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int candidate1 = 0 ; int candidate2 = 1 ; // any number different from candidate1 int countSoFar1 = 0 ; // # of candidate1 so far int countSoFar2 = 0 ; // # of candidate2 so far for ( const int num : nums ) if ( num == candidate1 ) { ++ countSoFar1 ; } else if ( num == candidate2 ) { ++ countSoFar2 ; } else if ( countSoFar1 == 0 ) { // assign new candidate candidate1 = num ; ++ countSoFar1 ; } else if ( countSoFar2 == 0 ) { // assign new candidate candidate2 = num ; ++ countSoFar2 ; } else { // meet a new number, so pair out previous counts -- countSoFar1 ; -- countSoFar2 ; } const int count1 = count ( begin ( nums ), end ( nums ), candidate1 ); const int count2 = count ( begin ( nums ), end ( nums ), candidate2 ); if ( count1 > nums . size () / 3 ) ans . push_back ( candidate1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( candidate2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <> (); int candidate1 = 0 ; int candidate2 = 1 ; // any number different from candidate1 int countSoFar1 = 0 ; // # of candidate1 so far int countSoFar2 = 0 ; // # of candidate2 so far for ( final int num : nums ) if ( num == candidate1 ) { ++ countSoFar1 ; } else if ( num == candidate2 ) { ++ countSoFar2 ; } else if ( countSoFar1 == 0 ) { // assign new candidate candidate1 = num ; ++ countSoFar1 ; } else if ( countSoFar2 == 0 ) { // assign new candidate candidate2 = num ; ++ countSoFar2 ; } else { // meet a new number, so pair out previous counts -- countSoFar1 ; -- countSoFar2 ; } int count1 = 0 ; int count2 = 0 ; for ( final int num : nums ) if ( num == candidate1 ) ++ count1 ; else if ( num == candidate2 ) ++ count2 ; if ( count1 > nums . length / 3 ) ans . add ( candidate1 ); if ( count2 > nums . length / 3 ) ans . add ( candidate2 ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ]","title":"229. Majority Element II"},{"location":"problems/0230/","text":"230. Kth Smallest Element in a BST Approach 1: Binary Search Time: $O(n^2)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { const int leftCount = countNodes ( root -> left ); if ( leftCount == k - 1 ) return root -> val ; if ( leftCount >= k ) return kthSmallest ( root -> left , k ); return kthSmallest ( root -> right , k - 1 - leftCount ); // leftCount < k } private : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int kthSmallest ( TreeNode root , int k ) { final int leftCount = countNodes ( root . left ); if ( leftCount == k - 1 ) return root . val ; if ( leftCount >= k ) return kthSmallest ( root . left , k ); return kthSmallest ( root . right , k - 1 - leftCount ); // leftCount < k } private int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ] Approach 2: Inorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { stack < TreeNode *> stack ; while ( root ) { stack . push ( root ); root = root -> left ; } for ( int i = 0 ; i < k - 1 ; ++ i ) { root = stack . top (), stack . pop (); root = root -> right ; while ( root ) { stack . push ( root ); root = root -> left ; } } return stack . top () -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int kthSmallest ( TreeNode root , int k ) { Stack < TreeNode > stack = new Stack <> (); while ( root != null ) { stack . push ( root ); root = root . left ; } for ( int i = 0 ; i < k - 1 ; ++ i ) { root = stack . pop (); root = root . right ; while ( root != null ) { stack . push ( root ); root = root . left ; } } return stack . peek (). val ; } } Approach 3: Stack Time: $O(n)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); nums . push_back ( root -> val ); inorder ( root -> right ); }; inorder ( root ); return nums [ k - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int kthSmallest ( TreeNode root , int k ) { List < Integer > nums = new ArrayList <> (); inorder ( root , nums ); return nums . get ( k - 1 ); } private void inorder ( TreeNode root , List < Integer > nums ) { if ( root == null ) return ; inorder ( root . left , nums ); nums . add ( root . val ); inorder ( root . right , nums ); } }","title":"230. Kth Smallest Element in a BST"},{"location":"problems/0230/#230-kth-smallest-element-in-a-bst","text":"","title":"230. Kth Smallest Element in a BST"},{"location":"problems/0230/#approach-1-binary-search","text":"Time: $O(n^2)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { const int leftCount = countNodes ( root -> left ); if ( leftCount == k - 1 ) return root -> val ; if ( leftCount >= k ) return kthSmallest ( root -> left , k ); return kthSmallest ( root -> right , k - 1 - leftCount ); // leftCount < k } private : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int kthSmallest ( TreeNode root , int k ) { final int leftCount = countNodes ( root . left ); if ( leftCount == k - 1 ) return root . val ; if ( leftCount >= k ) return kthSmallest ( root . left , k ); return kthSmallest ( root . right , k - 1 - leftCount ); // leftCount < k } private int countNodes ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + countNodes ( root . left ) + countNodes ( root . right ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ]","title":"Approach 1: Binary Search"},{"location":"problems/0230/#approach-2-inorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { stack < TreeNode *> stack ; while ( root ) { stack . push ( root ); root = root -> left ; } for ( int i = 0 ; i < k - 1 ; ++ i ) { root = stack . top (), stack . pop (); root = root -> right ; while ( root ) { stack . push ( root ); root = root -> left ; } } return stack . top () -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int kthSmallest ( TreeNode root , int k ) { Stack < TreeNode > stack = new Stack <> (); while ( root != null ) { stack . push ( root ); root = root . left ; } for ( int i = 0 ; i < k - 1 ; ++ i ) { root = stack . pop (); root = root . right ; while ( root != null ) { stack . push ( root ); root = root . left ; } } return stack . peek (). val ; } }","title":"Approach 2: Inorder Traversal"},{"location":"problems/0230/#approach-3-stack","text":"Time: $O(n)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); nums . push_back ( root -> val ); inorder ( root -> right ); }; inorder ( root ); return nums [ k - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int kthSmallest ( TreeNode root , int k ) { List < Integer > nums = new ArrayList <> (); inorder ( root , nums ); return nums . get ( k - 1 ); } private void inorder ( TreeNode root , List < Integer > nums ) { if ( root == null ) return ; inorder ( root . left , nums ); nums . add ( root . val ); inorder ( root . right , nums ); } }","title":"Approach 3: Stack"},{"location":"problems/0231/","text":"231. Power of Two Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool isPowerOfTwo ( int n ) { return n < 0 ? false : __builtin_popcountll ( n ) == 1 ; } }; Java 1 2 3 4 5 class Solution { public boolean isPowerOfTwo ( int n ) { return n < 0 ? false : Integer . bitCount ( n ) == 1 ; } } Python 1 2 3 class Solution : def isPowerOfTwo ( self , n : int ) -> bool : return False if n < 0 else bin ( n ) . count ( '1' ) == 1","title":"231. Power of Two"},{"location":"problems/0231/#231-power-of-two","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool isPowerOfTwo ( int n ) { return n < 0 ? false : __builtin_popcountll ( n ) == 1 ; } }; Java 1 2 3 4 5 class Solution { public boolean isPowerOfTwo ( int n ) { return n < 0 ? false : Integer . bitCount ( n ) == 1 ; } } Python 1 2 3 class Solution : def isPowerOfTwo ( self , n : int ) -> bool : return False if n < 0 else bin ( n ) . count ( '1' ) == 1","title":"231. Power of Two"},{"location":"problems/0232/","text":"232. Implement Queue using Stacks Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyQueue { public : void push ( int x ) { input . push ( x ); } int pop () { peek (); const int val = output . top (); output . pop (); return val ; } int peek () { if ( output . empty ()) while ( ! input . empty ()) output . push ( input . top ()), input . pop (); return output . top (); } bool empty () { return input . empty () && output . empty (); } private : stack < int > input ; stack < int > output ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyQueue { public void push ( int x ) { input . push ( x ); } public int pop () { peek (); return output . pop (); } public int peek () { if ( output . isEmpty ()) while ( ! input . isEmpty ()) output . push ( input . pop ()); return output . peek (); } public boolean empty () { return input . isEmpty () && output . isEmpty (); } private Stack < Integer > input = new Stack <> (); private Stack < Integer > output = new Stack <> (); }","title":"232. Implement Queue using Stacks"},{"location":"problems/0232/#232-implement-queue-using-stacks","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyQueue { public : void push ( int x ) { input . push ( x ); } int pop () { peek (); const int val = output . top (); output . pop (); return val ; } int peek () { if ( output . empty ()) while ( ! input . empty ()) output . push ( input . top ()), input . pop (); return output . top (); } bool empty () { return input . empty () && output . empty (); } private : stack < int > input ; stack < int > output ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyQueue { public void push ( int x ) { input . push ( x ); } public int pop () { peek (); return output . pop (); } public int peek () { if ( output . isEmpty ()) while ( ! input . isEmpty ()) output . push ( input . pop ()); return output . peek (); } public boolean empty () { return input . isEmpty () && output . isEmpty (); } private Stack < Integer > input = new Stack <> (); private Stack < Integer > output = new Stack <> (); }","title":"232. Implement Queue using Stacks"},{"location":"problems/0233/","text":"233. Number of Digit One Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { const int prefix = n / ( i * 10 ); const int suffix = n % i ; const int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { final int prefix = ( int ) ( n / ( i * 10 )); final int suffix = ( int ) ( n % i ); final int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countDigitOne ( self , n : int ) -> int : if n < 0 : return 0 ans = 0 i = 1 num = n while i <= n : prefix = n // ( i * 10 ) suffix = n % i currentDigit = num % 10 ans += prefix * i if currentDigit > 1 : ans += i elif currentDigit == 1 : ans += suffix + 1 i *= 10 num //= 10 return ans","title":"233. Number of Digit One"},{"location":"problems/0233/#233-number-of-digit-one","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { const int prefix = n / ( i * 10 ); const int suffix = n % i ; const int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { final int prefix = ( int ) ( n / ( i * 10 )); final int suffix = ( int ) ( n % i ); final int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countDigitOne ( self , n : int ) -> int : if n < 0 : return 0 ans = 0 i = 1 num = n while i <= n : prefix = n // ( i * 10 ) suffix = n % i currentDigit = num % 10 ans += prefix * i if currentDigit > 1 : ans += i elif currentDigit == 1 : ans += suffix + 1 i *= 10 num //= 10 return ans","title":"233. Number of Digit One"},{"location":"problems/0234/","text":"234. Palindrome Linked List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) slow = slow . next ; slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) return false ; slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True","title":"234. Palindrome Linked List"},{"location":"problems/0234/#234-palindrome-linked-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; while ( head ) { ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) slow = slow . next ; slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) return false ; slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; while ( head != null ) { ListNode next = head . next ; head . next = prev ; prev = head ; head = next ; } return prev ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True","title":"234. Palindrome Linked List"},{"location":"problems/0235/","text":"235. Lowest Common Ancestor of a Binary Search Tree Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root -> val > max ( p -> val , q -> val )) return lowestCommonAncestor ( root -> left , p , q ); if ( root -> val < min ( p -> val , q -> val )) return lowestCommonAncestor ( root -> right , p , q ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root . val > Math . max ( p . val , q . val )) return lowestCommonAncestor ( root . left , p , q ); if ( root . val < Math . min ( p . val , q . val )) return lowestCommonAncestor ( root . right , p , q ); return root ; } }","title":"235. Lowest Common Ancestor of a Binary Search Tree"},{"location":"problems/0235/#235-lowest-common-ancestor-of-a-binary-search-tree","text":"Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root -> val > max ( p -> val , q -> val )) return lowestCommonAncestor ( root -> left , p , q ); if ( root -> val < min ( p -> val , q -> val )) return lowestCommonAncestor ( root -> right , p , q ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root . val > Math . max ( p . val , q . val )) return lowestCommonAncestor ( root . left , p , q ); if ( root . val < Math . min ( p . val , q . val )) return lowestCommonAncestor ( root . right , p , q ); return root ; } }","title":"235. Lowest Common Ancestor of a Binary Search Tree"},{"location":"problems/0236/","text":"236. Lowest Common Ancestor of a Binary Tree Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * const left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * const right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; // both left and right are not nullptr } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root == null || root == p || root == q ) return root ; final TreeNode left = lowestCommonAncestor ( root . left , p , q ); final TreeNode right = lowestCommonAncestor ( root . right , p , q ); if ( left == null ) return right ; if ( right == null ) return left ; return root ; // both left and right are not null } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root","title":"236. Lowest Common Ancestor of a Binary Tree"},{"location":"problems/0236/#236-lowest-common-ancestor-of-a-binary-tree","text":"Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * const left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * const right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; // both left and right are not nullptr } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { if ( root == null || root == p || root == q ) return root ; final TreeNode left = lowestCommonAncestor ( root . left , p , q ); final TreeNode right = lowestCommonAncestor ( root . right , p , q ); if ( left == null ) return right ; if ( right == null ) return left ; return root ; // both left and right are not null } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root","title":"236. Lowest Common Ancestor of a Binary Tree"},{"location":"problems/0237/","text":"237. Delete Node in a Linked List Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; Java 1 2 3 4 5 6 class Solution { public void deleteNode ( ListNode node ) { node . val = node . next . val ; node . next = node . next . next ; } } Python 1 2 3 4 class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next","title":"237. Delete Node in a Linked List"},{"location":"problems/0237/#237-delete-node-in-a-linked-list","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; Java 1 2 3 4 5 6 class Solution { public void deleteNode ( ListNode node ) { node . val = node . next . val ; node . next = node . next . next ; } } Python 1 2 3 4 class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next","title":"237. Delete Node in a Linked List"},{"location":"problems/0238/","text":"238. Product of Array Except Self Approach 1: $O(n)$ space Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n ); // can also use nums as the ans array vector < int > prefix ( n , 1 ); // prefix product vector < int > suffix ( n , 1 ); // suffix product for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ]; for ( int i = n - 2 ; i >= 0 ; -- i ) suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ]; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] * suffix [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] productExceptSelf ( int [] nums ) { final int n = nums . length ; int [] ans = new int [ n ] ; // can also use nums as the ans array int [] prefix = new int [ n ] ; // prefix product int [] suffix = new int [ n ] ; // suffix product prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ] ; suffix [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] * suffix [ i ] ; return ans ; } } Approach 2: $O(1)$ space Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n , 1 ); // use ans as the prefix product array for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; int suffix = 1 ; // suffix product for ( int i = n - 1 ; i >= 0 ; -- i ) { ans [ i ] *= suffix ; suffix *= nums [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] productExceptSelf ( int [] nums ) { final int n = nums . length ; int [] ans = new int [ n ] ; ans [ 0 ] = 1 ; // use ans as the prefix product array for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; int suffix = 1 ; // suffix product for ( int i = n - 1 ; i >= 0 ; -- i ) { ans [ i ] *= suffix ; suffix *= nums [ i ] ; } return ans ; } }","title":"238. Product of Array Except Self"},{"location":"problems/0238/#238-product-of-array-except-self","text":"","title":"238. Product of Array Except Self"},{"location":"problems/0238/#approach-1-on-space","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n ); // can also use nums as the ans array vector < int > prefix ( n , 1 ); // prefix product vector < int > suffix ( n , 1 ); // suffix product for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ]; for ( int i = n - 2 ; i >= 0 ; -- i ) suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ]; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] * suffix [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] productExceptSelf ( int [] nums ) { final int n = nums . length ; int [] ans = new int [ n ] ; // can also use nums as the ans array int [] prefix = new int [ n ] ; // prefix product int [] suffix = new int [ n ] ; // suffix product prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] * nums [ i - 1 ] ; suffix [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) suffix [ i ] = suffix [ i + 1 ] * nums [ i + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = prefix [ i ] * suffix [ i ] ; return ans ; } }","title":"Approach 1: $O(n)$ space"},{"location":"problems/0238/#approach-2-o1-space","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n , 1 ); // use ans as the prefix product array for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; int suffix = 1 ; // suffix product for ( int i = n - 1 ; i >= 0 ; -- i ) { ans [ i ] *= suffix ; suffix *= nums [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] productExceptSelf ( int [] nums ) { final int n = nums . length ; int [] ans = new int [ n ] ; ans [ 0 ] = 1 ; // use ans as the prefix product array for ( int i = 1 ; i < n ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; int suffix = 1 ; // suffix product for ( int i = n - 1 ; i >= 0 ; -- i ) { ans [ i ] *= suffix ; suffix *= nums [ i ] ; } return ans ; } }","title":"Approach 2: $O(1)$ space"},{"location":"problems/0239/","text":"239. Sliding Window Maximum Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > q ; // max queue for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! q . empty () && q . back () < nums [ i ]) q . pop_back (); q . push_back ( nums [ i ]); if ( i >= k && nums [ i - k ] == q . front ()) // out of bound q . pop_front (); if ( i >= k - 1 ) ans . push_back ( q . front ()); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] maxSlidingWindow ( int [] nums , int k ) { int [] ans = new int [ nums . length - k + 1 ] ; Deque < Integer > q = new ArrayDeque <> (); // max queue for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! q . isEmpty () && q . peekLast () < nums [ i ] ) q . removeLast (); q . offerLast ( nums [ i ] ); if ( i >= k && nums [ i - k ] == q . peekFirst ()) // out of bound q . removeFirst (); if ( i >= k - 1 ) ans [ i - k + 1 ] = q . peekFirst (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] decreasingQueue = collections . deque () for i , num in enumerate ( nums ): while decreasingQueue and num > decreasingQueue [ - 1 ]: decreasingQueue . pop () decreasingQueue . append ( num ) if i >= k - 1 : ans . append ( decreasingQueue [ 0 ]) if nums [ i - k + 1 ] == decreasingQueue [ 0 ]: decreasingQueue . popleft () return ans","title":"239. Sliding Window Maximum"},{"location":"problems/0239/#239-sliding-window-maximum","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > q ; // max queue for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! q . empty () && q . back () < nums [ i ]) q . pop_back (); q . push_back ( nums [ i ]); if ( i >= k && nums [ i - k ] == q . front ()) // out of bound q . pop_front (); if ( i >= k - 1 ) ans . push_back ( q . front ()); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] maxSlidingWindow ( int [] nums , int k ) { int [] ans = new int [ nums . length - k + 1 ] ; Deque < Integer > q = new ArrayDeque <> (); // max queue for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! q . isEmpty () && q . peekLast () < nums [ i ] ) q . removeLast (); q . offerLast ( nums [ i ] ); if ( i >= k && nums [ i - k ] == q . peekFirst ()) // out of bound q . removeFirst (); if ( i >= k - 1 ) ans [ i - k + 1 ] = q . peekFirst (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] decreasingQueue = collections . deque () for i , num in enumerate ( nums ): while decreasingQueue and num > decreasingQueue [ - 1 ]: decreasingQueue . pop () decreasingQueue . append ( num ) if i >= k - 1 : ans . append ( decreasingQueue [ 0 ]) if nums [ i - k + 1 ] == decreasingQueue [ 0 ]: decreasingQueue . popleft () return ans","title":"239. Sliding Window Maximum"},{"location":"problems/0240/","text":"240. Search a 2D Matrix II Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; if ( matrix [ r ][ c ] > target ) -- c ; else ++ r ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; int r = 0 ; int c = matrix [ 0 ] . length - 1 ; while ( r <= matrix . length && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; if ( matrix [ r ][ c ] > target ) -- c ; else ++ r ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"240. Search a 2D Matrix II"},{"location":"problems/0240/#240-search-a-2d-matrix-ii","text":"Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; if ( matrix [ r ][ c ] > target ) -- c ; else ++ r ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; int r = 0 ; int c = matrix [ 0 ] . length - 1 ; while ( r <= matrix . length && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; if ( matrix [ r ][ c ] > target ) -- c ; else ++ r ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"240. Search a 2D Matrix II"},{"location":"problems/0241/","text":"241. Different Ways to Add Parentheses Time: $O(2^n \\to n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > diffWaysToCompute ( string input ) { unordered_map < string , vector < int >> memo ; function < vector < int > ( const string & s ) > ways = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < int > ans ; for ( int i = 0 ; i < s . length (); ++ i ) if ( ispunct ( s [ i ])) for ( const int a : ways ( s . substr ( 0 , i ))) for ( const int b : ways ( s . substr ( i + 1 ))) if ( s [ i ] == '+' ) ans . push_back ( a + b ); else if ( s [ i ] == '-' ) ans . push_back ( a - b ); else ans . push_back ( a * b ); if ( ans . empty ()) // single number return memo [ s ] = { stoi ( s )}; return memo [ s ] = ans ; }; return ways ( input ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < Integer > diffWaysToCompute ( String input ) { Map < String , List < Integer >> memo = new HashMap <> (); return ways ( input , memo ); } private List < Integer > ways ( final String s , Map < String , List < Integer >> memo ) { if ( memo . containsKey ( s )) return memo . get ( s ); List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < s . length (); ++ i ) if ( ! Character . isDigit ( s . charAt ( i ))) for ( final int a : ways ( s . substring ( 0 , i ), memo )) for ( final int b : ways ( s . substring ( i + 1 ), memo )) if ( s . charAt ( i ) == '+' ) ans . add ( a + b ); else if ( s . charAt ( i ) == '-' ) ans . add ( a - b ); else ans . add ( a * b ); if ( ans . isEmpty ()) { memo . put ( s , Arrays . asList ( Integer . parseInt ( s ))); return memo . get ( s ); } memo . put ( s , ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )]","title":"241. Different Ways to Add Parentheses"},{"location":"problems/0241/#241-different-ways-to-add-parentheses","text":"Time: $O(2^n \\to n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > diffWaysToCompute ( string input ) { unordered_map < string , vector < int >> memo ; function < vector < int > ( const string & s ) > ways = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < int > ans ; for ( int i = 0 ; i < s . length (); ++ i ) if ( ispunct ( s [ i ])) for ( const int a : ways ( s . substr ( 0 , i ))) for ( const int b : ways ( s . substr ( i + 1 ))) if ( s [ i ] == '+' ) ans . push_back ( a + b ); else if ( s [ i ] == '-' ) ans . push_back ( a - b ); else ans . push_back ( a * b ); if ( ans . empty ()) // single number return memo [ s ] = { stoi ( s )}; return memo [ s ] = ans ; }; return ways ( input ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < Integer > diffWaysToCompute ( String input ) { Map < String , List < Integer >> memo = new HashMap <> (); return ways ( input , memo ); } private List < Integer > ways ( final String s , Map < String , List < Integer >> memo ) { if ( memo . containsKey ( s )) return memo . get ( s ); List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < s . length (); ++ i ) if ( ! Character . isDigit ( s . charAt ( i ))) for ( final int a : ways ( s . substring ( 0 , i ), memo )) for ( final int b : ways ( s . substring ( i + 1 ), memo )) if ( s . charAt ( i ) == '+' ) ans . add ( a + b ); else if ( s . charAt ( i ) == '-' ) ans . add ( a - b ); else ans . add ( a * b ); if ( ans . isEmpty ()) { memo . put ( s , Arrays . asList ( Integer . parseInt ( s ))); return memo . get ( s ); } memo . put ( s , ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )]","title":"241. Different Ways to Add Parentheses"},{"location":"problems/0242/","text":"242. Valid Anagram Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : t ) if ( -- count [ c ] < 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isAnagram ( String s , String t ) { if ( s . length () != t . length ()) return false ; int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : t . toCharArray ()) if ( -- count [ c ] < 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True","title":"242. Valid Anagram"},{"location":"problems/0242/#242-valid-anagram","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : t ) if ( -- count [ c ] < 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isAnagram ( String s , String t ) { if ( s . length () != t . length ()) return false ; int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : t . toCharArray ()) if ( -- count [ c ] < 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True","title":"242. Valid Anagram"},{"location":"problems/0243/","text":"243. Shortest Word Distance \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int shortestDistance ( vector < string >& words , string word1 , string word2 ) { int ans = words . size (); int index1 = -1 ; // words[index1] == word1 int index2 = -1 ; // words[index2] == word2 for ( int i = 0 ; i < words . size (); ++ i ) { if ( words [ i ] == word1 ) { index1 = i ; if ( index2 != -1 ) ans = min ( ans , index1 - index2 ); } if ( words [ i ] == word2 ) { index2 = i ; if ( index1 != -1 ) ans = min ( ans , index2 - index1 ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int shortestDistance ( String [] words , String word1 , String word2 ) { int ans = words . length ; int index1 = - 1 ; // words[index1] == word1 int index2 = - 1 ; // words[index2] == word2 for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 )) { index1 = i ; if ( index2 != - 1 ) ans = Math . min ( ans , index1 - index2 ); } if ( words [ i ] . equals ( word2 )) { index2 = i ; if ( index1 != - 1 ) ans = Math . min ( ans , index2 - index1 ); } } return ans ; } }","title":"243. Shortest Word Distance"},{"location":"problems/0243/#243-shortest-word-distance","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int shortestDistance ( vector < string >& words , string word1 , string word2 ) { int ans = words . size (); int index1 = -1 ; // words[index1] == word1 int index2 = -1 ; // words[index2] == word2 for ( int i = 0 ; i < words . size (); ++ i ) { if ( words [ i ] == word1 ) { index1 = i ; if ( index2 != -1 ) ans = min ( ans , index1 - index2 ); } if ( words [ i ] == word2 ) { index2 = i ; if ( index1 != -1 ) ans = min ( ans , index2 - index1 ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int shortestDistance ( String [] words , String word1 , String word2 ) { int ans = words . length ; int index1 = - 1 ; // words[index1] == word1 int index2 = - 1 ; // words[index2] == word2 for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 )) { index1 = i ; if ( index2 != - 1 ) ans = Math . min ( ans , index1 - index2 ); } if ( words [ i ] . equals ( word2 )) { index2 = i ; if ( index1 != - 1 ) ans = Math . min ( ans , index2 - index1 ); } } return ans ; } }","title":"243. Shortest Word Distance \ud83d\udd12"},{"location":"problems/0244/","text":"244. Shortest Word Distance II \ud83d\udd12 Time: $O(m + n)$ Space: $O(|words|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WordDistance { public : WordDistance ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) wordToIndices [ words [ i ]]. push_back ( i ); } int shortest ( string word1 , string word2 ) { int ans = INT_MAX ; const vector < int > indices1 = wordToIndices [ word1 ]; const vector < int > indices2 = wordToIndices [ word2 ]; for ( int i = 0 , j = 0 ; i < indices1 . size () && j < indices2 . size ();) { ans = min ( ans , abs ( indices1 [ i ] - indices2 [ j ])); if ( indices1 [ i ] < indices2 [ j ]) ++ i ; else ++ j ; } return ans ; } private : unordered_map < string , vector < int >> wordToIndices ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WordDistance { public WordDistance ( String [] words ) { for ( int i = 0 ; i < words . length ; ++ i ) { wordToIndices . putIfAbsent ( words [ i ] , new ArrayList <> ()); wordToIndices . get ( words [ i ] ). add ( i ); } } public int shortest ( String word1 , String word2 ) { int ans = Integer . MAX_VALUE ; final List < Integer > indices1 = wordToIndices . get ( word1 ); final List < Integer > indices2 = wordToIndices . get ( word2 ); for ( int i = 0 , j = 0 ; i < indices1 . size () && j < indices2 . size ();) { ans = Math . min ( ans , Math . abs ( indices1 . get ( i ) - indices2 . get ( j ))); if ( indices1 . get ( i ) < indices2 . get ( j )) ++ i ; else ++ j ; } return ans ; } private Map < String , List < Integer >> wordToIndices = new HashMap <> (); }","title":"244. Shortest Word Distance II"},{"location":"problems/0244/#244-shortest-word-distance-ii","text":"Time: $O(m + n)$ Space: $O(|words|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WordDistance { public : WordDistance ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) wordToIndices [ words [ i ]]. push_back ( i ); } int shortest ( string word1 , string word2 ) { int ans = INT_MAX ; const vector < int > indices1 = wordToIndices [ word1 ]; const vector < int > indices2 = wordToIndices [ word2 ]; for ( int i = 0 , j = 0 ; i < indices1 . size () && j < indices2 . size ();) { ans = min ( ans , abs ( indices1 [ i ] - indices2 [ j ])); if ( indices1 [ i ] < indices2 [ j ]) ++ i ; else ++ j ; } return ans ; } private : unordered_map < string , vector < int >> wordToIndices ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class WordDistance { public WordDistance ( String [] words ) { for ( int i = 0 ; i < words . length ; ++ i ) { wordToIndices . putIfAbsent ( words [ i ] , new ArrayList <> ()); wordToIndices . get ( words [ i ] ). add ( i ); } } public int shortest ( String word1 , String word2 ) { int ans = Integer . MAX_VALUE ; final List < Integer > indices1 = wordToIndices . get ( word1 ); final List < Integer > indices2 = wordToIndices . get ( word2 ); for ( int i = 0 , j = 0 ; i < indices1 . size () && j < indices2 . size ();) { ans = Math . min ( ans , Math . abs ( indices1 . get ( i ) - indices2 . get ( j ))); if ( indices1 . get ( i ) < indices2 . get ( j )) ++ i ; else ++ j ; } return ans ; } private Map < String , List < Integer >> wordToIndices = new HashMap <> (); }","title":"244. Shortest Word Distance II \ud83d\udd12"},{"location":"problems/0245/","text":"245. Shortest Word Distance III \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int shortestWordDistance ( vector < string >& words , string word1 , string word2 ) { int ans = INT_MAX ; int index1 = words . size (); // if word1 == word2, index1 is the newest index int index2 = - words . size (); // if word1 == word2, index2 is the previous index const bool isSame = word1 == word2 ; for ( int i = 0 ; i < words . size (); ++ i ) { if ( words [ i ] == word1 ) { if ( isSame ) index2 = index1 ; index1 = i ; } else if ( words [ i ] == word2 ) { index2 = i ; } ans = min ( ans , abs ( index1 - index2 )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int shortestWordDistance ( String [] words , String word1 , String word2 ) { int ans = Integer . MAX_VALUE ; int index1 = words . length ; // if word1 == word2, index1 is the newest index int index2 = - words . length ; // if word1 == word2, index2 is the previous index final boolean isSame = word1 . equals ( word2 ); for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 )) { if ( isSame ) index2 = index1 ; index1 = i ; } else if ( words [ i ] . equals ( word2 )) { index2 = i ; } ans = Math . min ( ans , Math . abs ( index1 - index2 )); } return ans ; } }","title":"245. Shortest Word Distance III"},{"location":"problems/0245/#245-shortest-word-distance-iii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int shortestWordDistance ( vector < string >& words , string word1 , string word2 ) { int ans = INT_MAX ; int index1 = words . size (); // if word1 == word2, index1 is the newest index int index2 = - words . size (); // if word1 == word2, index2 is the previous index const bool isSame = word1 == word2 ; for ( int i = 0 ; i < words . size (); ++ i ) { if ( words [ i ] == word1 ) { if ( isSame ) index2 = index1 ; index1 = i ; } else if ( words [ i ] == word2 ) { index2 = i ; } ans = min ( ans , abs ( index1 - index2 )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int shortestWordDistance ( String [] words , String word1 , String word2 ) { int ans = Integer . MAX_VALUE ; int index1 = words . length ; // if word1 == word2, index1 is the newest index int index2 = - words . length ; // if word1 == word2, index2 is the previous index final boolean isSame = word1 . equals ( word2 ); for ( int i = 0 ; i < words . length ; ++ i ) { if ( words [ i ] . equals ( word1 )) { if ( isSame ) index2 = index1 ; index1 = i ; } else if ( words [ i ] . equals ( word2 )) { index2 = i ; } ans = Math . min ( ans , Math . abs ( index1 - index2 )); } return ans ; } }","title":"245. Shortest Word Distance III \ud83d\udd12"},{"location":"problems/0246/","text":"246. Strobogrammatic Number \ud83d\udd12 Time: $O(n)$ Space: $O(10) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool isStrobogrammatic ( string num ) { vector < char > rotated { '0' , '1' , 'n' , 'n' , 'n' , 'n' , '9' , 'n' , '8' , '6' }; for ( int i = 0 ; i < num . length (); ++ i ) if ( rotated [ num [ i ] - '0' ] != num [ num . length () - 1 - i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean isStrobogrammatic ( String num ) { int [] rotated = new int [] { '0' , '1' , 'n' , 'n' , 'n' , 'n' , '9' , 'n' , '8' , '6' }; for ( int i = 0 ; i < num . length (); ++ i ) if ( rotated [ num . charAt ( i ) - '0' ] != num . charAt ( num . length () - 1 - i )) return false ; return true ; } }","title":"246. Strobogrammatic Number"},{"location":"problems/0246/#246-strobogrammatic-number","text":"Time: $O(n)$ Space: $O(10) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool isStrobogrammatic ( string num ) { vector < char > rotated { '0' , '1' , 'n' , 'n' , 'n' , 'n' , '9' , 'n' , '8' , '6' }; for ( int i = 0 ; i < num . length (); ++ i ) if ( rotated [ num [ i ] - '0' ] != num [ num . length () - 1 - i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean isStrobogrammatic ( String num ) { int [] rotated = new int [] { '0' , '1' , 'n' , 'n' , 'n' , 'n' , '9' , 'n' , '8' , '6' }; for ( int i = 0 ; i < num . length (); ++ i ) if ( rotated [ num . charAt ( i ) - '0' ] != num . charAt ( num . length () - 1 - i )) return false ; return true ; } }","title":"246. Strobogrammatic Number \ud83d\udd12"},{"location":"problems/0247/","text":"247. Strobogrammatic Number II \ud83d\udd12 Time: $O(5^n)$ Space: $O(|ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < string > findStrobogrammatic ( int n ) { return helper ( n , n ); } private : vector < string > helper ( int n , int k ) { if ( n == 0 ) return { \"\" }; if ( n == 1 ) return { \"0\" , \"1\" , \"8\" }; vector < string > ans ; for ( const string inner : helper ( n - 2 , k )) { if ( n < k ) ans . push_back ( \"0\" + inner + \"0\" ); ans . push_back ( \"1\" + inner + \"1\" ); ans . push_back ( \"6\" + inner + \"9\" ); ans . push_back ( \"8\" + inner + \"8\" ); ans . push_back ( \"9\" + inner + \"6\" ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < String > findStrobogrammatic ( int n ) { return helper ( n , n ); } private List < String > helper ( int n , int k ) { if ( n == 0 ) return new ArrayList <> ( Arrays . asList ( \"\" )); if ( n == 1 ) return new ArrayList <> ( Arrays . asList ( \"0\" , \"1\" , \"8\" )); List < String > ans = new ArrayList <> (); for ( final String inner : helper ( n - 2 , k )) { if ( n < k ) ans . add ( \"0\" + inner + \"0\" ); ans . add ( \"1\" + inner + \"1\" ); ans . add ( \"6\" + inner + \"9\" ); ans . add ( \"8\" + inner + \"8\" ); ans . add ( \"9\" + inner + \"6\" ); } return ans ; } }","title":"247. Strobogrammatic Number II"},{"location":"problems/0247/#247-strobogrammatic-number-ii","text":"Time: $O(5^n)$ Space: $O(|ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < string > findStrobogrammatic ( int n ) { return helper ( n , n ); } private : vector < string > helper ( int n , int k ) { if ( n == 0 ) return { \"\" }; if ( n == 1 ) return { \"0\" , \"1\" , \"8\" }; vector < string > ans ; for ( const string inner : helper ( n - 2 , k )) { if ( n < k ) ans . push_back ( \"0\" + inner + \"0\" ); ans . push_back ( \"1\" + inner + \"1\" ); ans . push_back ( \"6\" + inner + \"9\" ); ans . push_back ( \"8\" + inner + \"8\" ); ans . push_back ( \"9\" + inner + \"6\" ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < String > findStrobogrammatic ( int n ) { return helper ( n , n ); } private List < String > helper ( int n , int k ) { if ( n == 0 ) return new ArrayList <> ( Arrays . asList ( \"\" )); if ( n == 1 ) return new ArrayList <> ( Arrays . asList ( \"0\" , \"1\" , \"8\" )); List < String > ans = new ArrayList <> (); for ( final String inner : helper ( n - 2 , k )) { if ( n < k ) ans . add ( \"0\" + inner + \"0\" ); ans . add ( \"1\" + inner + \"1\" ); ans . add ( \"6\" + inner + \"9\" ); ans . add ( \"8\" + inner + \"8\" ); ans . add ( \"9\" + inner + \"6\" ); } return ans ; } }","title":"247. Strobogrammatic Number II \ud83d\udd12"},{"location":"problems/0248/","text":"248. Strobogrammatic Number III \ud83d\udd12","title":"248. Strobogrammatic Number III"},{"location":"problems/0248/#248-strobogrammatic-number-iii","text":"","title":"248. Strobogrammatic Number III \ud83d\udd12"},{"location":"problems/0249/","text":"249. Group Shifted Strings \ud83d\udd12 Time: $O(\\Sigma|strings_i|)$ Space: $O(\\Sigma|strings_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < string >> groupStrings ( vector < string >& strings ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> keyToStrings ; for ( const string & s : strings ) keyToStrings [ getKey ( s )]. push_back ( s ); for ( const auto & [ _ , strings ] : keyToStrings ) ans . push_back ( strings ); return ans ; } private : // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1 string getKey ( const string & s ) { string key ; for ( int i = 1 ; i < s . length (); ++ i ) { const int diff = ( s [ i ] - s [ i - 1 ] + 26 ) % 26 ; key += to_string ( diff ) + \",\" ; } return key ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < String >> groupStrings ( String [] strings ) { Map < String , List < String >> keyToStrings = new HashMap <> (); for ( final String s : strings ) keyToStrings . computeIfAbsent ( getKey ( s ), k -> new ArrayList <> ()). add ( s ); return new ArrayList <> ( keyToStrings . values ()); } // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1 private String getKey ( final String s ) { StringBuilder sb = new StringBuilder (); for ( int i = 1 ; i < s . length (); ++ i ) { final int diff = ( s . charAt ( i ) - s . charAt ( i - 1 ) + 26 ) % 26 ; sb . append ( diff ). append ( \",\" ); } return sb . toString (); } }","title":"249. Group Shifted Strings"},{"location":"problems/0249/#249-group-shifted-strings","text":"Time: $O(\\Sigma|strings_i|)$ Space: $O(\\Sigma|strings_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < string >> groupStrings ( vector < string >& strings ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> keyToStrings ; for ( const string & s : strings ) keyToStrings [ getKey ( s )]. push_back ( s ); for ( const auto & [ _ , strings ] : keyToStrings ) ans . push_back ( strings ); return ans ; } private : // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1 string getKey ( const string & s ) { string key ; for ( int i = 1 ; i < s . length (); ++ i ) { const int diff = ( s [ i ] - s [ i - 1 ] + 26 ) % 26 ; key += to_string ( diff ) + \",\" ; } return key ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < String >> groupStrings ( String [] strings ) { Map < String , List < String >> keyToStrings = new HashMap <> (); for ( final String s : strings ) keyToStrings . computeIfAbsent ( getKey ( s ), k -> new ArrayList <> ()). add ( s ); return new ArrayList <> ( keyToStrings . values ()); } // \"abc\" -> \"11\" because diff(a, b) = 1 and diff(b, c) = 1 private String getKey ( final String s ) { StringBuilder sb = new StringBuilder (); for ( int i = 1 ; i < s . length (); ++ i ) { final int diff = ( s . charAt ( i ) - s . charAt ( i - 1 ) + 26 ) % 26 ; sb . append ( diff ). append ( \",\" ); } return sb . toString (); } }","title":"249. Group Shifted Strings \ud83d\udd12"},{"location":"problems/0250/","text":"250. Count Univalue Subtrees \ud83d\udd12 Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { int ans = 0 ; function < bool ( TreeNode * , int ) > isUnival = [ & ]( TreeNode * root , int val ) { if ( ! root ) return true ; if ( isUnival ( root -> left , root -> val ) & isUnival ( root -> right , root -> val )) { ++ ans ; return root -> val == val ; } return false ; }; isUnival ( root , INT_MAX ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int countUnivalSubtrees ( TreeNode root ) { isUnival ( root , Integer . MAX_VALUE ); return ans ; } private int ans = 0 ; private boolean isUnival ( TreeNode root , int val ) { if ( root == null ) return true ; if ( isUnival ( root . left , root . val ) & isUnival ( root . right , root . val )) { ++ ans ; return root . val == val ; } return false ; } }","title":"250. Count Univalue Subtrees"},{"location":"problems/0250/#250-count-univalue-subtrees","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { int ans = 0 ; function < bool ( TreeNode * , int ) > isUnival = [ & ]( TreeNode * root , int val ) { if ( ! root ) return true ; if ( isUnival ( root -> left , root -> val ) & isUnival ( root -> right , root -> val )) { ++ ans ; return root -> val == val ; } return false ; }; isUnival ( root , INT_MAX ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int countUnivalSubtrees ( TreeNode root ) { isUnival ( root , Integer . MAX_VALUE ); return ans ; } private int ans = 0 ; private boolean isUnival ( TreeNode root , int val ) { if ( root == null ) return true ; if ( isUnival ( root . left , root . val ) & isUnival ( root . right , root . val )) { ++ ans ; return root . val == val ; } return false ; } }","title":"250. Count Univalue Subtrees \ud83d\udd12"},{"location":"problems/0251/","text":"251. Flatten 2D Vector \ud83d\udd12 Approach 1: Straightforward Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Vector2D { public : Vector2D ( vector < vector < int >>& v ) { for ( const vector < int >& arr : v ) for ( const int a : arr ) vec . push_back ( a ); } int next () { return vec [ i ++ ]; } bool hasNext () { return i < vec . size (); } private : vector < int > vec ; int i = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Vector2D { public Vector2D ( int [][] v ) { for ( final int [] arr : v ) for ( final int a : arr ) vec . add ( a ); } public int next () { return vec . get ( i ++ ); } public boolean hasNext () { return i < vec . size (); } private List < Integer > vec = new ArrayList <> (); private int i = 0 ; } Approach 2: Iterator Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Vector2D { public : Vector2D ( vector < vector < int >>& v ) { i = begin ( v ); iEnd = end ( v ); } int next () { moveIterator (); return ( * i )[ j ++ ]; } bool hasNext () { moveIterator (); return i != iEnd ; } private : // (*i)[j] := current pointed value vector < vector < int >>:: iterator i , iEnd ; int j = 0 ; void moveIterator () { while ( i != iEnd && j == ( * i ). size ()) ++ i , j = 0 ; } };","title":"251. Flatten 2D Vector"},{"location":"problems/0251/#251-flatten-2d-vector","text":"","title":"251. Flatten 2D Vector \ud83d\udd12"},{"location":"problems/0251/#approach-1-straightforward","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Vector2D { public : Vector2D ( vector < vector < int >>& v ) { for ( const vector < int >& arr : v ) for ( const int a : arr ) vec . push_back ( a ); } int next () { return vec [ i ++ ]; } bool hasNext () { return i < vec . size (); } private : vector < int > vec ; int i = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Vector2D { public Vector2D ( int [][] v ) { for ( final int [] arr : v ) for ( final int a : arr ) vec . add ( a ); } public int next () { return vec . get ( i ++ ); } public boolean hasNext () { return i < vec . size (); } private List < Integer > vec = new ArrayList <> (); private int i = 0 ; }","title":"Approach 1: Straightforward"},{"location":"problems/0251/#approach-2-iterator","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Vector2D { public : Vector2D ( vector < vector < int >>& v ) { i = begin ( v ); iEnd = end ( v ); } int next () { moveIterator (); return ( * i )[ j ++ ]; } bool hasNext () { moveIterator (); return i != iEnd ; } private : // (*i)[j] := current pointed value vector < vector < int >>:: iterator i , iEnd ; int j = 0 ; void moveIterator () { while ( i != iEnd && j == ( * i ). size ()) ++ i , j = 0 ; } };","title":"Approach 2: Iterator"},{"location":"problems/0252/","text":"252. Meeting Rooms \ud83d\udd12 Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool canAttendMeetings ( vector < vector < int >>& intervals ) { sort ( begin ( intervals ), end ( intervals )); for ( int i = 1 ; i < intervals . size (); ++ i ) if ( intervals [ i - 1 ][ 1 ] > intervals [ i ][ 0 ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canAttendMeetings ( int [][] intervals ) { Arrays . sort ( intervals , ( a , b ) -> a [ 0 ] - b [ 0 ] ); for ( int i = 1 ; i < intervals . length ; ++ i ) if ( intervals [ i - 1 ][ 1 ] > intervals [ i ][ 0 ] ) return false ; return true ; } }","title":"252. Meeting Rooms"},{"location":"problems/0252/#252-meeting-rooms","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool canAttendMeetings ( vector < vector < int >>& intervals ) { sort ( begin ( intervals ), end ( intervals )); for ( int i = 1 ; i < intervals . size (); ++ i ) if ( intervals [ i - 1 ][ 1 ] > intervals [ i ][ 0 ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canAttendMeetings ( int [][] intervals ) { Arrays . sort ( intervals , ( a , b ) -> a [ 0 ] - b [ 0 ] ); for ( int i = 1 ; i < intervals . length ; ++ i ) if ( intervals [ i - 1 ][ 1 ] > intervals [ i ][ 0 ] ) return false ; return true ; } }","title":"252. Meeting Rooms \ud83d\udd12"},{"location":"problems/0253/","text":"253. Meeting Rooms II \ud83d\udd12 Approach 1: Heap Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { if ( intervals . empty ()) return 0 ; auto compare = []( const vector < int >& a , const vector < int >& b ) { return a [ 1 ] > b [ 1 ]; }; priority_queue < vector < int > , vector < vector < int >> , decltype ( compare ) > pq ( compare ); sort ( begin ( intervals ), end ( intervals )); pq . push ( intervals [ 0 ]); for ( int i = 1 ; i < intervals . size (); ++ i ) { const vector < int >& interval = intervals [ i ]; vector < int > earliestAvailable = pq . top (); pq . pop (); if ( intervals [ i ][ 0 ] >= earliestAvailable [ 1 ]) earliestAvailable [ 1 ] = interval [ 1 ]; else pq . push ( interval ); pq . push ( earliestAvailable ); } return pq . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minMeetingRooms ( int [][] intervals ) { if ( intervals . length == 0 ) return 0 ; PriorityQueue < int []> pq = new PriorityQueue <> (( a , b ) -> a [ 1 ] - b [ 1 ] ); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] )); pq . offer ( intervals [ 0 ] ); for ( int i = 1 ; i < intervals . length ; ++ i ) { final int [] interval = intervals [ i ] ; int [] earliestAvailable = pq . poll (); if ( interval [ 0 ] >= earliestAvailable [ 1 ] ) earliestAvailable [ 1 ] = interval [ 1 ] ; else pq . offer ( interval ); pq . offer ( earliestAvailable ); } return pq . size (); } } Approach 2: Sort Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { const int n = intervals . size (); int ans = 0 ; vector < int > starts ; vector < int > ends ; for ( const vector < int >& interval : intervals ) { starts . push_back ( interval [ 0 ]); ends . push_back ( interval [ 1 ]); } sort ( begin ( starts ), end ( starts )); sort ( begin ( ends ), end ( ends )); for ( int i = 0 , j = 0 ; i < n ; ++ i ) if ( starts [ i ] < ends [ j ]) ++ ans ; else ++ j ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minMeetingRooms ( int [][] intervals ) { final int n = intervals . length ; int ans = 0 ; int [] starts = new int [ n ] ; int [] ends = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { starts [ i ] = intervals [ i ][ 0 ] ; ends [ i ] = intervals [ i ][ 1 ] ; } Arrays . sort ( starts ); Arrays . sort ( ends ); // j points to ends for ( int i = 0 , j = 0 ; i < n ; ++ i ) if ( starts [ i ] < ends [ j ] ) ++ ans ; else ++ j ; return ans ; } }","title":"253. Meeting Rooms II"},{"location":"problems/0253/#253-meeting-rooms-ii","text":"","title":"253. Meeting Rooms II \ud83d\udd12"},{"location":"problems/0253/#approach-1-heap","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { if ( intervals . empty ()) return 0 ; auto compare = []( const vector < int >& a , const vector < int >& b ) { return a [ 1 ] > b [ 1 ]; }; priority_queue < vector < int > , vector < vector < int >> , decltype ( compare ) > pq ( compare ); sort ( begin ( intervals ), end ( intervals )); pq . push ( intervals [ 0 ]); for ( int i = 1 ; i < intervals . size (); ++ i ) { const vector < int >& interval = intervals [ i ]; vector < int > earliestAvailable = pq . top (); pq . pop (); if ( intervals [ i ][ 0 ] >= earliestAvailable [ 1 ]) earliestAvailable [ 1 ] = interval [ 1 ]; else pq . push ( interval ); pq . push ( earliestAvailable ); } return pq . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minMeetingRooms ( int [][] intervals ) { if ( intervals . length == 0 ) return 0 ; PriorityQueue < int []> pq = new PriorityQueue <> (( a , b ) -> a [ 1 ] - b [ 1 ] ); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ] )); pq . offer ( intervals [ 0 ] ); for ( int i = 1 ; i < intervals . length ; ++ i ) { final int [] interval = intervals [ i ] ; int [] earliestAvailable = pq . poll (); if ( interval [ 0 ] >= earliestAvailable [ 1 ] ) earliestAvailable [ 1 ] = interval [ 1 ] ; else pq . offer ( interval ); pq . offer ( earliestAvailable ); } return pq . size (); } }","title":"Approach 1: Heap"},{"location":"problems/0253/#approach-2-sort","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { const int n = intervals . size (); int ans = 0 ; vector < int > starts ; vector < int > ends ; for ( const vector < int >& interval : intervals ) { starts . push_back ( interval [ 0 ]); ends . push_back ( interval [ 1 ]); } sort ( begin ( starts ), end ( starts )); sort ( begin ( ends ), end ( ends )); for ( int i = 0 , j = 0 ; i < n ; ++ i ) if ( starts [ i ] < ends [ j ]) ++ ans ; else ++ j ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minMeetingRooms ( int [][] intervals ) { final int n = intervals . length ; int ans = 0 ; int [] starts = new int [ n ] ; int [] ends = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { starts [ i ] = intervals [ i ][ 0 ] ; ends [ i ] = intervals [ i ][ 1 ] ; } Arrays . sort ( starts ); Arrays . sort ( ends ); // j points to ends for ( int i = 0 , j = 0 ; i < n ; ++ i ) if ( starts [ i ] < ends [ j ] ) ++ ans ; else ++ j ; return ans ; } }","title":"Approach 2: Sort"},{"location":"problems/0254/","text":"254. Factor Combinations \ud83d\udd12 Time: $O(n\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> getFactors ( int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int n , int s ) { if ( n <= 1 ) { if ( path . size () > 1 ) ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) if ( n % i == 0 ) { path . push_back ( i ); dfs ( n / i , i ); path . pop_back (); } }; dfs ( n , 2 ); // the smallest factor is 2 return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> getFactors ( int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( n , 2 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( n == 1 ) { if ( path . size () > 1 ) ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i <= n ; ++ i ) if ( n % i == 0 ) { path . add ( i ); dfs ( n / i , i , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"254. Factor Combinations"},{"location":"problems/0254/#254-factor-combinations","text":"Time: $O(n\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> getFactors ( int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int n , int s ) { if ( n <= 1 ) { if ( path . size () > 1 ) ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) if ( n % i == 0 ) { path . push_back ( i ); dfs ( n / i , i ); path . pop_back (); } }; dfs ( n , 2 ); // the smallest factor is 2 return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> getFactors ( int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( n , 2 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( n == 1 ) { if ( path . size () > 1 ) ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i <= n ; ++ i ) if ( n % i == 0 ) { path . add ( i ); dfs ( n / i , i , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"254. Factor Combinations \ud83d\udd12"},{"location":"problems/0255/","text":"255. Verify Preorder Sequence in Binary Search Tree \ud83d\udd12 Approach 1: Backtracking Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int i = 0 ; function < void ( int , int ) > dfs = [ & ]( int min , int max ) { if ( i >= preorder . size () || preorder [ i ] < min || preorder [ i ] > max ) return ; const int val = preorder [ i ++ ]; dfs ( min , val ); dfs ( val , max ); }; dfs ( INT_MIN , INT_MAX ); return i == preorder . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean verifyPreorder ( int [] preorder ) { dfs ( preorder , Integer . MIN_VALUE , Integer . MAX_VALUE ); return i == preorder . length ; } private int i = 0 ; private void dfs ( int [] preorder , int min , int max ) { if ( i >= preorder . length || preorder [ i ] < min || preorder [ i ] > max ) return ; final int val = preorder [ i ++] ; dfs ( preorder , min , val ); dfs ( preorder , val , max ); } } Approach 2: Stack Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int low = INT_MIN ; stack < int > stack ; for ( const int p : preorder ) { if ( p < low ) return false ; while ( ! stack . empty () && stack . top () < p ) low = stack . top (), stack . pop (); stack . push ( p ); } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean verifyPreorder ( int [] preorder ) { int low = Integer . MIN_VALUE ; Stack < Integer > stack = new Stack <> (); for ( final int p : preorder ) { if ( p < low ) return false ; while ( ! stack . isEmpty () && stack . peek () < p ) low = stack . pop (); stack . push ( p ); } return true ; } } Approach 3: Abuse original array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int low = INT_MIN ; int i = -1 ; for ( const int p : preorder ) { if ( p < low ) return false ; while ( i >= 0 && preorder [ i ] < p ) low = preorder [ i -- ]; preorder [ ++ i ] = p ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean verifyPreorder ( int [] preorder ) { int low = Integer . MIN_VALUE ; int i = - 1 ; for ( final int p : preorder ) { if ( p < low ) return false ; while ( i >= 0 && preorder [ i ] < p ) low = preorder [ i --] ; preorder [++ i ] = p ; } return true ; } }","title":"255. Verify Preorder Sequence in Binary Search Tree"},{"location":"problems/0255/#255-verify-preorder-sequence-in-binary-search-tree","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree \ud83d\udd12"},{"location":"problems/0255/#approach-1-backtracking","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int i = 0 ; function < void ( int , int ) > dfs = [ & ]( int min , int max ) { if ( i >= preorder . size () || preorder [ i ] < min || preorder [ i ] > max ) return ; const int val = preorder [ i ++ ]; dfs ( min , val ); dfs ( val , max ); }; dfs ( INT_MIN , INT_MAX ); return i == preorder . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean verifyPreorder ( int [] preorder ) { dfs ( preorder , Integer . MIN_VALUE , Integer . MAX_VALUE ); return i == preorder . length ; } private int i = 0 ; private void dfs ( int [] preorder , int min , int max ) { if ( i >= preorder . length || preorder [ i ] < min || preorder [ i ] > max ) return ; final int val = preorder [ i ++] ; dfs ( preorder , min , val ); dfs ( preorder , val , max ); } }","title":"Approach 1: Backtracking"},{"location":"problems/0255/#approach-2-stack","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int low = INT_MIN ; stack < int > stack ; for ( const int p : preorder ) { if ( p < low ) return false ; while ( ! stack . empty () && stack . top () < p ) low = stack . top (), stack . pop (); stack . push ( p ); } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean verifyPreorder ( int [] preorder ) { int low = Integer . MIN_VALUE ; Stack < Integer > stack = new Stack <> (); for ( final int p : preorder ) { if ( p < low ) return false ; while ( ! stack . isEmpty () && stack . peek () < p ) low = stack . pop (); stack . push ( p ); } return true ; } }","title":"Approach 2: Stack"},{"location":"problems/0255/#approach-3-abuse-original-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool verifyPreorder ( vector < int >& preorder ) { int low = INT_MIN ; int i = -1 ; for ( const int p : preorder ) { if ( p < low ) return false ; while ( i >= 0 && preorder [ i ] < p ) low = preorder [ i -- ]; preorder [ ++ i ] = p ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean verifyPreorder ( int [] preorder ) { int low = Integer . MIN_VALUE ; int i = - 1 ; for ( final int p : preorder ) { if ( p < low ) return false ; while ( i >= 0 && preorder [ i ] < p ) low = preorder [ i --] ; preorder [++ i ] = p ; } return true ; } }","title":"Approach 3: Abuse original array"},{"location":"problems/0256/","text":"256. Paint House \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minCost ( vector < vector < int >>& costs ) { if ( costs . empty ()) return 0 ; for ( int i = 1 ; i < costs . size (); ++ i ) { costs [ i ][ 0 ] += min ( costs [ i - 1 ][ 1 ], costs [ i - 1 ][ 2 ]); costs [ i ][ 1 ] += min ( costs [ i - 1 ][ 0 ], costs [ i - 1 ][ 2 ]); costs [ i ][ 2 ] += min ( costs [ i - 1 ][ 0 ], costs [ i - 1 ][ 1 ]); } return * min_element ( begin ( costs . back ()), end ( costs . back ())); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minCost ( int [][] costs ) { final int n = costs . length ; if ( n == 0 ) return 0 ; for ( int i = 1 ; i < n ; ++ i ) { costs [ i ][ 0 ] += Math . min ( costs [ i - 1 ][ 1 ] , costs [ i - 1 ][ 2 ] ); costs [ i ][ 1 ] += Math . min ( costs [ i - 1 ][ 0 ] , costs [ i - 1 ][ 2 ] ); costs [ i ][ 2 ] += Math . min ( costs [ i - 1 ][ 0 ] , costs [ i - 1 ][ 1 ] ); } return Math . min ( costs [ n - 1 ][ 0 ] , Math . min ( costs [ n - 1 ][ 1 ] , costs [ n - 1 ][ 2 ] )); } }","title":"256. Paint House"},{"location":"problems/0256/#256-paint-house","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minCost ( vector < vector < int >>& costs ) { if ( costs . empty ()) return 0 ; for ( int i = 1 ; i < costs . size (); ++ i ) { costs [ i ][ 0 ] += min ( costs [ i - 1 ][ 1 ], costs [ i - 1 ][ 2 ]); costs [ i ][ 1 ] += min ( costs [ i - 1 ][ 0 ], costs [ i - 1 ][ 2 ]); costs [ i ][ 2 ] += min ( costs [ i - 1 ][ 0 ], costs [ i - 1 ][ 1 ]); } return * min_element ( begin ( costs . back ()), end ( costs . back ())); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minCost ( int [][] costs ) { final int n = costs . length ; if ( n == 0 ) return 0 ; for ( int i = 1 ; i < n ; ++ i ) { costs [ i ][ 0 ] += Math . min ( costs [ i - 1 ][ 1 ] , costs [ i - 1 ][ 2 ] ); costs [ i ][ 1 ] += Math . min ( costs [ i - 1 ][ 0 ] , costs [ i - 1 ][ 2 ] ); costs [ i ][ 2 ] += Math . min ( costs [ i - 1 ][ 0 ] , costs [ i - 1 ][ 1 ] ); } return Math . min ( costs [ n - 1 ][ 0 ] , Math . min ( costs [ n - 1 ][ 1 ] , costs [ n - 1 ][ 2 ] )); } }","title":"256. Paint House \ud83d\udd12"},{"location":"problems/0257/","text":"257. Binary Tree Paths Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < string > ans ; function < void ( TreeNode * , const string & ) > dfs = [ & ]( TreeNode * root , const string & path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans . push_back ( path + to_string ( root -> val )); return ; } dfs ( root -> left , path + to_string ( root -> val ) + \"->\" ); dfs ( root -> right , path + to_string ( root -> val ) + \"->\" ); }; dfs ( root , \"\" ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < String > binaryTreePaths ( TreeNode root ) { List < String > ans = new ArrayList <> (); dfs ( root , new StringBuilder (), ans ); return ans ; } private void dfs ( TreeNode root , StringBuilder path , List < String > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( path . append ( root . val ). toString ()); return ; } final int length = path . length (); dfs ( root . left , path . append ( root . val ). append ( \"->\" ), ans ); path . setLength ( length ); dfs ( root . right , path . append ( root . val ). append ( \"->\" ), ans ); path . setLength ( length ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def binaryTreePaths ( self , root : TreeNode ) -> List [ str ]: def dfs ( root : TreeNode , path : str ) -> None : if not root : return if not root . left and not root . right : ans . append ( path + str ( root . val )) return dfs ( root . left , path + str ( root . val ) + '->' ) dfs ( root . right , path + str ( root . val ) + '->' ) ans = [] dfs ( root , '' ) return ans","title":"257. Binary Tree Paths"},{"location":"problems/0257/#257-binary-tree-paths","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < string > ans ; function < void ( TreeNode * , const string & ) > dfs = [ & ]( TreeNode * root , const string & path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans . push_back ( path + to_string ( root -> val )); return ; } dfs ( root -> left , path + to_string ( root -> val ) + \"->\" ); dfs ( root -> right , path + to_string ( root -> val ) + \"->\" ); }; dfs ( root , \"\" ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < String > binaryTreePaths ( TreeNode root ) { List < String > ans = new ArrayList <> (); dfs ( root , new StringBuilder (), ans ); return ans ; } private void dfs ( TreeNode root , StringBuilder path , List < String > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( path . append ( root . val ). toString ()); return ; } final int length = path . length (); dfs ( root . left , path . append ( root . val ). append ( \"->\" ), ans ); path . setLength ( length ); dfs ( root . right , path . append ( root . val ). append ( \"->\" ), ans ); path . setLength ( length ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def binaryTreePaths ( self , root : TreeNode ) -> List [ str ]: def dfs ( root : TreeNode , path : str ) -> None : if not root : return if not root . left and not root . right : ans . append ( path + str ( root . val )) return dfs ( root . left , path + str ( root . val ) + '->' ) dfs ( root . right , path + str ( root . val ) + '->' ) ans = [] dfs ( root , '' ) return ans","title":"257. Binary Tree Paths"},{"location":"problems/0258/","text":"258. Add Digits Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } }; Java 1 2 3 4 5 class Solution { public int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } } Python 1 2 3 class Solution : def addDigits ( self , num : int ) -> int : return 0 if num == 0 else 1 + ( num - 1 ) % 9","title":"258. Add Digits"},{"location":"problems/0258/#258-add-digits","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } }; Java 1 2 3 4 5 class Solution { public int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } } Python 1 2 3 class Solution : def addDigits ( self , num : int ) -> int : return 0 if num == 0 else 1 + ( num - 1 ) % 9","title":"258. Add Digits"},{"location":"problems/0259/","text":"259. 3Sum Smaller \ud83d\udd12 Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int threeSumSmaller ( vector < int >& nums , int target ) { if ( nums . size () < 3 ) return 0 ; int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) if ( nums [ i ] + nums [ l ] + nums [ r ] < target ) { // (nums[i], nums[l], nums[r]) // (nums[i], nums[l], nums[r - 1]) // ..., // (nums[i], nums[l], nums[l + 1]) ans += r - l ; ++ l ; } else { -- r ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int threeSumSmaller ( int [] nums , int target ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) if ( nums [ i ] + nums [ l ] + nums [ r ] < target ) { // (nums[i], nums[l], nums[r]) // (nums[i], nums[l], nums[r - 1]) // ..., // (nums[i], nums[l], nums[l + 1]) ans += r - l ; ++ l ; } else { -- r ; } } return ans ; } }","title":"259. 3Sum Smaller"},{"location":"problems/0259/#259-3sum-smaller","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int threeSumSmaller ( vector < int >& nums , int target ) { if ( nums . size () < 3 ) return 0 ; int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) if ( nums [ i ] + nums [ l ] + nums [ r ] < target ) { // (nums[i], nums[l], nums[r]) // (nums[i], nums[l], nums[r - 1]) // ..., // (nums[i], nums[l], nums[l + 1]) ans += r - l ; ++ l ; } else { -- r ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int threeSumSmaller ( int [] nums , int target ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) if ( nums [ i ] + nums [ l ] + nums [ r ] < target ) { // (nums[i], nums[l], nums[r]) // (nums[i], nums[l], nums[r - 1]) // ..., // (nums[i], nums[l], nums[l + 1]) ans += r - l ; ++ l ; } else { -- r ; } } return ans ; } }","title":"259. 3Sum Smaller \ud83d\udd12"},{"location":"problems/0260/","text":"260. Single Number III Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { const int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor <> ()); const int lowbit = xors & - xors ; vector < int > ans ( 2 ); // seperate nums into two groups by the lowbit for ( const int num : nums ) if ( num & lowbit ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] singleNumber ( int [] nums ) { int xors = 0 ; for ( final int num : nums ) xors ^= num ; final int lowbit = xors & - xors ; int [] ans = new int [ 2 ] ; for ( final int num : nums ) if (( num & lowbit ) > 0 ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"260. Single Number III"},{"location":"problems/0260/#260-single-number-iii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { const int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor <> ()); const int lowbit = xors & - xors ; vector < int > ans ( 2 ); // seperate nums into two groups by the lowbit for ( const int num : nums ) if ( num & lowbit ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] singleNumber ( int [] nums ) { int xors = 0 ; for ( final int num : nums ) xors ^= num ; final int lowbit = xors & - xors ; int [] ans = new int [ 2 ] ; for ( final int num : nums ) if (( num & lowbit ) > 0 ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"260. Single Number III"},{"location":"problems/0261/","text":"261. Graph Valid Tree \ud83d\udd12 Approach 1: BFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool validTree ( int n , vector < vector < int >>& edges ) { if ( n == 0 || edges . size () != n - 1 ) return false ; vector < vector < int >> graph ( n ); queue < int > q {{ 0 }}; unordered_set < int > seen ; seen . insert ( 0 ); for ( const vector < int > edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } while ( ! q . empty ()) { const int node = q . front (); q . pop (); for ( const int neighbor : graph [ node ]) if ( ! seen . count ( neighbor )) { q . push ( neighbor ); seen . insert ( neighbor ); } } return seen . size () == n ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean validTree ( int n , int [][] edges ) { if ( n == 0 || edges . length != n - 1 ) return false ; List < Integer >[] graph = new List [ n ] ; Queue < Integer > q = new LinkedList <> (); Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } q . offer ( 0 ); seen . add ( 0 ); while ( ! q . isEmpty ()) { final int node = q . poll (); for ( final int neighbor : graph [ node ] ) if ( ! seen . contains ( neighbor )) { q . offer ( neighbor ); seen . add ( neighbor ); } } return seen . size () == n ; } } Approach 2: UF Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : bool validTree ( int n , vector < vector < int >>& edges ) { if ( n == 0 || edges . size () != n - 1 ) return false ; UF uf ( n ); unordered_set < int > parents ; for ( const vector < int >& edge : edges ) uf . union_ ( edge [ 0 ], edge [ 1 ]); for ( int i = 0 ; i < n ; ++ i ) parents . insert ( uf . find ( i )); return parents . size () == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public boolean validTree ( int n , int [][] edges ) { if ( n == 0 || edges . length != n - 1 ) return false ; UF uf = new UF ( n ); Set < Integer > parents = new HashSet <> (); for ( final int [] edge : edges ) uf . union ( edge [ 0 ] , edge [ 1 ] ); for ( int i = 0 ; i < n ; ++ i ) parents . add ( uf . find ( i )); return parents . size () == 1 ; } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } private int [] rank ; private int [] parent ; }","title":"261. Graph Valid Tree"},{"location":"problems/0261/#261-graph-valid-tree","text":"","title":"261. Graph Valid Tree \ud83d\udd12"},{"location":"problems/0261/#approach-1-bfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool validTree ( int n , vector < vector < int >>& edges ) { if ( n == 0 || edges . size () != n - 1 ) return false ; vector < vector < int >> graph ( n ); queue < int > q {{ 0 }}; unordered_set < int > seen ; seen . insert ( 0 ); for ( const vector < int > edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } while ( ! q . empty ()) { const int node = q . front (); q . pop (); for ( const int neighbor : graph [ node ]) if ( ! seen . count ( neighbor )) { q . push ( neighbor ); seen . insert ( neighbor ); } } return seen . size () == n ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean validTree ( int n , int [][] edges ) { if ( n == 0 || edges . length != n - 1 ) return false ; List < Integer >[] graph = new List [ n ] ; Queue < Integer > q = new LinkedList <> (); Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } q . offer ( 0 ); seen . add ( 0 ); while ( ! q . isEmpty ()) { final int node = q . poll (); for ( final int neighbor : graph [ node ] ) if ( ! seen . contains ( neighbor )) { q . offer ( neighbor ); seen . add ( neighbor ); } } return seen . size () == n ; } }","title":"Approach 1: BFS"},{"location":"problems/0261/#approach-2-uf","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : bool validTree ( int n , vector < vector < int >>& edges ) { if ( n == 0 || edges . size () != n - 1 ) return false ; UF uf ( n ); unordered_set < int > parents ; for ( const vector < int >& edge : edges ) uf . union_ ( edge [ 0 ], edge [ 1 ]); for ( int i = 0 ; i < n ; ++ i ) parents . insert ( uf . find ( i )); return parents . size () == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public boolean validTree ( int n , int [][] edges ) { if ( n == 0 || edges . length != n - 1 ) return false ; UF uf = new UF ( n ); Set < Integer > parents = new HashSet <> (); for ( final int [] edge : edges ) uf . union ( edge [ 0 ] , edge [ 1 ] ); for ( int i = 0 ; i < n ; ++ i ) parents . add ( uf . find ( i )); return parents . size () == 1 ; } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } private int [] rank ; private int [] parent ; }","title":"Approach 2: UF"},{"location":"problems/0262/","text":"262. Trips and Users","title":"262. Trips and Users"},{"location":"problems/0262/#262-trips-and-users","text":"","title":"262. Trips and Users"},{"location":"problems/0263/","text":"263. Ugly Number Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; for ( const int prime : { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isUgly ( int num ) { if ( num == 0 ) return false ; for ( final int prime : new int [] { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for prime in 2 , 3 , 5 : while num % prime == 0 : num //= prime return num == 1","title":"263. Ugly Number"},{"location":"problems/0263/#263-ugly-number","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; for ( const int prime : { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean isUgly ( int num ) { if ( num == 0 ) return false ; for ( final int prime : new int [] { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for prime in 2 , 3 , 5 : while num % prime == 0 : num //= prime return num == 1","title":"263. Ugly Number"},{"location":"problems/0264/","text":"264. Ugly Number II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > uglyNums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { const int next2 = uglyNums [ i2 ] * 2 ; const int next3 = uglyNums [ i3 ] * 3 ; const int next5 = uglyNums [ i5 ] * 5 ; const int next = min ({ next2 , next3 , next5 }); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . push_back ( next ); } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int nthUglyNumber ( int n ) { List < Integer > uglyNums = new ArrayList <> (); uglyNums . add ( 1 ); int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { final int next2 = uglyNums . get ( i2 ) * 2 ; final int next3 = uglyNums . get ( i3 ) * 3 ; final int next5 = uglyNums . get ( i5 ) * 5 ; final int next = Math . min ( next2 , Math . min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . add ( next ); } return uglyNums . get ( uglyNums . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ]","title":"264. Ugly Number II"},{"location":"problems/0264/#264-ugly-number-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > uglyNums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { const int next2 = uglyNums [ i2 ] * 2 ; const int next3 = uglyNums [ i3 ] * 3 ; const int next5 = uglyNums [ i5 ] * 5 ; const int next = min ({ next2 , next3 , next5 }); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . push_back ( next ); } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int nthUglyNumber ( int n ) { List < Integer > uglyNums = new ArrayList <> (); uglyNums . add ( 1 ); int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { final int next2 = uglyNums . get ( i2 ) * 2 ; final int next3 = uglyNums . get ( i3 ) * 3 ; final int next5 = uglyNums . get ( i5 ) * 5 ; final int next = Math . min ( next2 , Math . min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . add ( next ); } return uglyNums . get ( uglyNums . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ]","title":"264. Ugly Number II"},{"location":"problems/0265/","text":"265. Paint House II \ud83d\udd12 Time: $O(nk)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int minCostII ( vector < vector < int >>& costs ) { if ( costs . empty ()) return 0 ; int prevIndex = -1 ; // the previous minimum index int prevMin1 = 0 ; // minimum cost so far int prevMin2 = 0 ; // 2nd minimum cost so far for ( const vector < int >& cost : costs ) { // O(n) int index = -1 ; // the painted index s.t. achieve the minimum cost after painting current house int min1 = INT_MAX ; // the minimum cost after painting current house int min2 = INT_MAX ; // the 2nd minimum cost after painting current house for ( int i = 0 ; i < cost . size (); ++ i ) { // O(k) const int theCost = cost [ i ] + ( i == prevIndex ? prevMin2 : prevMin1 ); if ( theCost < min1 ) { index = i ; min2 = min1 ; min1 = theCost ; } else if ( theCost < min2 ) { // min1 <= theCost < min2 min2 = theCost ; } } prevIndex = index ; prevMin1 = min1 ; prevMin2 = min2 ; } return prevMin1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int minCostII ( int [][] costs ) { if ( costs . length == 0 ) return 0 ; int prevIndex = - 1 ; // the previous minimum index int prevMin1 = 0 ; // minimum cost so far int prevMin2 = 0 ; // 2nd minimum cost so far for ( final int [] cost : costs ) { // O(n) int index = - 1 ; // the painted index s.t. achieve the minimum cost after painting current house int min1 = Integer . MAX_VALUE ; // the minimum cost after painting current house int min2 = Integer . MAX_VALUE ; // the 2nd minimum cost after painting current house for ( int i = 0 ; i < cost . length ; ++ i ) { // O(k) final int theCost = cost [ i ] + ( i == prevIndex ? prevMin2 : prevMin1 ); if ( theCost < min1 ) { index = i ; min2 = min1 ; min1 = theCost ; } else if ( theCost < min2 ) { // min1 <= theCost < min2 min2 = theCost ; } } prevIndex = index ; prevMin1 = min1 ; prevMin2 = min2 ; } return prevMin1 ; } }","title":"265. Paint House II"},{"location":"problems/0265/#265-paint-house-ii","text":"Time: $O(nk)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int minCostII ( vector < vector < int >>& costs ) { if ( costs . empty ()) return 0 ; int prevIndex = -1 ; // the previous minimum index int prevMin1 = 0 ; // minimum cost so far int prevMin2 = 0 ; // 2nd minimum cost so far for ( const vector < int >& cost : costs ) { // O(n) int index = -1 ; // the painted index s.t. achieve the minimum cost after painting current house int min1 = INT_MAX ; // the minimum cost after painting current house int min2 = INT_MAX ; // the 2nd minimum cost after painting current house for ( int i = 0 ; i < cost . size (); ++ i ) { // O(k) const int theCost = cost [ i ] + ( i == prevIndex ? prevMin2 : prevMin1 ); if ( theCost < min1 ) { index = i ; min2 = min1 ; min1 = theCost ; } else if ( theCost < min2 ) { // min1 <= theCost < min2 min2 = theCost ; } } prevIndex = index ; prevMin1 = min1 ; prevMin2 = min2 ; } return prevMin1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int minCostII ( int [][] costs ) { if ( costs . length == 0 ) return 0 ; int prevIndex = - 1 ; // the previous minimum index int prevMin1 = 0 ; // minimum cost so far int prevMin2 = 0 ; // 2nd minimum cost so far for ( final int [] cost : costs ) { // O(n) int index = - 1 ; // the painted index s.t. achieve the minimum cost after painting current house int min1 = Integer . MAX_VALUE ; // the minimum cost after painting current house int min2 = Integer . MAX_VALUE ; // the 2nd minimum cost after painting current house for ( int i = 0 ; i < cost . length ; ++ i ) { // O(k) final int theCost = cost [ i ] + ( i == prevIndex ? prevMin2 : prevMin1 ); if ( theCost < min1 ) { index = i ; min2 = min1 ; min1 = theCost ; } else if ( theCost < min2 ) { // min1 <= theCost < min2 min2 = theCost ; } } prevIndex = index ; prevMin1 = min1 ; prevMin2 = min2 ; } return prevMin1 ; } }","title":"265. Paint House II \ud83d\udd12"},{"location":"problems/0266/","text":"266. Palindrome Permutation \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool canPermutePalindrome ( string s ) { unordered_set < char > seen ; for ( const char c : s ) if ( ! seen . insert ( c ). second ) seen . erase ( c ); return seen . size () <= 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canPermutePalindrome ( String s ) { Set < Character > seen = new HashSet <> (); for ( final char c : s . toCharArray ()) if ( ! seen . add ( c )) seen . remove ( c ); return seen . size () <= 1 ; } }","title":"266. Palindrome Permutation"},{"location":"problems/0266/#266-palindrome-permutation","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool canPermutePalindrome ( string s ) { unordered_set < char > seen ; for ( const char c : s ) if ( ! seen . insert ( c ). second ) seen . erase ( c ); return seen . size () <= 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canPermutePalindrome ( String s ) { Set < Character > seen = new HashSet <> (); for ( final char c : s . toCharArray ()) if ( ! seen . add ( c )) seen . remove ( c ); return seen . size () <= 1 ; } }","title":"266. Palindrome Permutation \ud83d\udd12"},{"location":"problems/0267/","text":"267. Palindrome Permutation II \ud83d\udd12 Time: $O(n^n)$ Space: $O(|ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < string > generatePalindromes ( string s ) { int odd = 0 ; unordered_map < char , int > count ; for ( const char c : s ) ++ count [ c ]; for ( const auto & [ _ , value ] : count ) if ( value & 1 ) ++ odd ; if ( odd > 1 ) return {}; vector < string > ans ; string path ; vector < char > candidates ; string mid ; for ( const auto & [ key , value ] : count ) { if ( value & 1 ) mid += key ; for ( int i = 0 ; i < value / 2 ; ++ i ) candidates . push_back ( key ); } vector < bool > used ( candidates . size ()); function < void () > dfs = [ & ]() { if ( path . length () == candidates . size ()) { string secondHalf = path ; reverse ( begin ( secondHalf ), end ( secondHalf )); ans . push_back ( path + mid + secondHalf ); return ; } for ( int i = 0 ; i < candidates . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && candidates [ i ] == candidates [ i - 1 ] && ! used [ i ]) continue ; used [ i ] = true ; path . push_back ( candidates [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public List < String > generatePalindromes ( String s ) { int odd = 0 ; Map < Character , Integer > count = new HashMap <> (); // get character occurrence for ( final char c : s . toCharArray ()) count . put ( c , count . getOrDefault ( c , 0 ) + 1 ); // count odd one for ( Map . Entry < Character , Integer > entry : count . entrySet ()) if ( entry . getValue () % 2 == 1 ) ++ odd ; // can't form any palindrome if ( odd > 1 ) return new ArrayList <> (); List < String > ans = new ArrayList <> (); List < Character > candidates = new ArrayList <> (); StringBuilder mid = new StringBuilder (); // get mid and candidates characters for ( Map . Entry < Character , Integer > entry : count . entrySet ()) { final char key = entry . getKey (); final int value = entry . getValue (); if ( value % 2 == 1 ) mid . append ( key ); for ( int i = 0 ; i < value / 2 ; ++ i ) candidates . add ( key ); } // backtracking to generate our ans (strings) dfs ( candidates , mid , new boolean [ candidates . size () ] , new StringBuilder (), ans ); return ans ; } // generate all unique palindromes from candidates private void dfs ( List < Character > candidates , StringBuilder mid , boolean [] used , StringBuilder path , List < String > ans ) { if ( path . length () == candidates . size ()) { ans . add ( path . toString () + mid + path . reverse (). toString ()); path . reverse (); return ; } for ( int i = 0 ; i < candidates . size (); ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && candidates . get ( i ) == candidates . get ( i - 1 ) && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . append ( candidates . get ( i )); dfs ( candidates , mid , used , path , ans ); path . deleteCharAt ( path . length () - 1 ); used [ i ] = false ; } } }","title":"267. Palindrome Permutation II"},{"location":"problems/0267/#267-palindrome-permutation-ii","text":"Time: $O(n^n)$ Space: $O(|ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < string > generatePalindromes ( string s ) { int odd = 0 ; unordered_map < char , int > count ; for ( const char c : s ) ++ count [ c ]; for ( const auto & [ _ , value ] : count ) if ( value & 1 ) ++ odd ; if ( odd > 1 ) return {}; vector < string > ans ; string path ; vector < char > candidates ; string mid ; for ( const auto & [ key , value ] : count ) { if ( value & 1 ) mid += key ; for ( int i = 0 ; i < value / 2 ; ++ i ) candidates . push_back ( key ); } vector < bool > used ( candidates . size ()); function < void () > dfs = [ & ]() { if ( path . length () == candidates . size ()) { string secondHalf = path ; reverse ( begin ( secondHalf ), end ( secondHalf )); ans . push_back ( path + mid + secondHalf ); return ; } for ( int i = 0 ; i < candidates . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && candidates [ i ] == candidates [ i - 1 ] && ! used [ i ]) continue ; used [ i ] = true ; path . push_back ( candidates [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public List < String > generatePalindromes ( String s ) { int odd = 0 ; Map < Character , Integer > count = new HashMap <> (); // get character occurrence for ( final char c : s . toCharArray ()) count . put ( c , count . getOrDefault ( c , 0 ) + 1 ); // count odd one for ( Map . Entry < Character , Integer > entry : count . entrySet ()) if ( entry . getValue () % 2 == 1 ) ++ odd ; // can't form any palindrome if ( odd > 1 ) return new ArrayList <> (); List < String > ans = new ArrayList <> (); List < Character > candidates = new ArrayList <> (); StringBuilder mid = new StringBuilder (); // get mid and candidates characters for ( Map . Entry < Character , Integer > entry : count . entrySet ()) { final char key = entry . getKey (); final int value = entry . getValue (); if ( value % 2 == 1 ) mid . append ( key ); for ( int i = 0 ; i < value / 2 ; ++ i ) candidates . add ( key ); } // backtracking to generate our ans (strings) dfs ( candidates , mid , new boolean [ candidates . size () ] , new StringBuilder (), ans ); return ans ; } // generate all unique palindromes from candidates private void dfs ( List < Character > candidates , StringBuilder mid , boolean [] used , StringBuilder path , List < String > ans ) { if ( path . length () == candidates . size ()) { ans . add ( path . toString () + mid + path . reverse (). toString ()); path . reverse (); return ; } for ( int i = 0 ; i < candidates . size (); ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && candidates . get ( i ) == candidates . get ( i - 1 ) && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . append ( candidates . get ( i )); dfs ( candidates , mid , used , path , ans ); path . deleteCharAt ( path . length () - 1 ); used [ i ] = false ; } } }","title":"267. Palindrome Permutation II \ud83d\udd12"},{"location":"problems/0268/","text":"268. Missing Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; ++ i ) ans ^= i ^ nums [ i ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans","title":"268. Missing Number"},{"location":"problems/0268/#268-missing-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; ++ i ) ans ^= i ^ nums [ i ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans","title":"268. Missing Number"},{"location":"problems/0269/","text":"269. Alien Dictionary \ud83d\udd12 Time: $O(26 + |words| - 1)$ Space: $O(26 + |words| - 1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution { public : string alienOrder ( vector < string >& words ) { vector < int > inDegree ( 26 ); unordered_map < char , unordered_set < char >> graph ; buildGraph ( graph , words , inDegree ); return bfs ( graph , inDegree ); } private : void buildGraph ( unordered_map < char , unordered_set < char >>& graph , const vector < string >& words , vector < int >& inDegree ) { // create node for each character in each word for ( const string & word : words ) for ( const char c : word ) if ( ! graph . count ( c )) graph [ c ] = unordered_set < char > (); for ( int i = 1 ; i < words . size (); ++ i ) { const string & first = words [ i - 1 ]; const string & second = words [ i ]; const int length = min ( first . length (), second . length ()); for ( int j = 0 ; j < length ; ++ j ) { const char out = first [ j ]; const char in = second [ j ]; if ( out != in ) { if ( ! graph [ out ]. count ( in )) { graph [ out ]. insert ( in ); ++ inDegree [ in - 'a' ]; } break ; // later characters' order are meaningless } // first = \"ab\", second = \"a\" -> invalid if ( j == length - 1 && first . length () > second . length ()) { graph . clear (); return ; } } } } string bfs ( unordered_map < char , unordered_set < char >>& graph , vector < int >& inDegree ) { string s ; queue < char > q ; for ( const auto & [ c , _ ] : graph ) if ( inDegree [ c - 'a' ] == 0 ) q . push ( c ); while ( ! q . empty ()) { const char out = q . front (); q . pop (); s += out ; for ( const char in : graph [ out ]) if ( -- inDegree [ in - 'a' ] == 0 ) q . push ( in ); } // words = [\"z\", \"x\", \"y\", \"x\"] return s . length () == graph . size () ? s : \"\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public String alienOrder ( String [] words ) { int [] inDegree = new int [ 26 ] ; Map < Character , Set < Character >> graph = new HashMap <> (); buildGraph ( words , inDegree , graph ); return bfs ( inDegree , graph ); } private void buildGraph ( final String [] words , int [] inDegree , Map < Character , Set < Character >> graph ) { // create node for each character in each word for ( final String word : words ) for ( final char c : word . toCharArray ()) graph . putIfAbsent ( c , new HashSet <> ()); for ( int i = 1 ; i < words . length ; ++ i ) { final String first = words [ i - 1 ] ; final String second = words [ i ] ; final int length = Math . min ( first . length (), second . length ()); for ( int j = 0 ; j < length ; ++ j ) { final char out = first . charAt ( j ); final char in = second . charAt ( j ); if ( out != in ) { if ( ! graph . get ( out ). contains ( in )) { graph . get ( out ). add ( in ); ++ inDegree [ in - 'a' ] ; } break ; // later characters' order are meaningless } // first = \"ab\", second = \"a\" -> invalid if ( j == length - 1 && first . length () > second . length ()) { graph . clear (); return ; } } } } private String bfs ( int [] inDegree , Map < Character , Set < Character >> graph ) { StringBuilder sb = new StringBuilder (); Queue < Character > q = new LinkedList <> (); for ( final char c : graph . keySet ()) if ( inDegree [ c - 'a' ] == 0 ) q . offer ( c ); while ( ! q . isEmpty ()) { final char out = q . poll (); sb . append ( out ); for ( final char in : graph . get ( out )) if ( -- inDegree [ in - 'a' ] == 0 ) q . offer ( in ); } return sb . length () == graph . size () ? sb . toString () : \"\" ; } }","title":"269. Alien Dictionary"},{"location":"problems/0269/#269-alien-dictionary","text":"Time: $O(26 + |words| - 1)$ Space: $O(26 + |words| - 1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution { public : string alienOrder ( vector < string >& words ) { vector < int > inDegree ( 26 ); unordered_map < char , unordered_set < char >> graph ; buildGraph ( graph , words , inDegree ); return bfs ( graph , inDegree ); } private : void buildGraph ( unordered_map < char , unordered_set < char >>& graph , const vector < string >& words , vector < int >& inDegree ) { // create node for each character in each word for ( const string & word : words ) for ( const char c : word ) if ( ! graph . count ( c )) graph [ c ] = unordered_set < char > (); for ( int i = 1 ; i < words . size (); ++ i ) { const string & first = words [ i - 1 ]; const string & second = words [ i ]; const int length = min ( first . length (), second . length ()); for ( int j = 0 ; j < length ; ++ j ) { const char out = first [ j ]; const char in = second [ j ]; if ( out != in ) { if ( ! graph [ out ]. count ( in )) { graph [ out ]. insert ( in ); ++ inDegree [ in - 'a' ]; } break ; // later characters' order are meaningless } // first = \"ab\", second = \"a\" -> invalid if ( j == length - 1 && first . length () > second . length ()) { graph . clear (); return ; } } } } string bfs ( unordered_map < char , unordered_set < char >>& graph , vector < int >& inDegree ) { string s ; queue < char > q ; for ( const auto & [ c , _ ] : graph ) if ( inDegree [ c - 'a' ] == 0 ) q . push ( c ); while ( ! q . empty ()) { const char out = q . front (); q . pop (); s += out ; for ( const char in : graph [ out ]) if ( -- inDegree [ in - 'a' ] == 0 ) q . push ( in ); } // words = [\"z\", \"x\", \"y\", \"x\"] return s . length () == graph . size () ? s : \"\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public String alienOrder ( String [] words ) { int [] inDegree = new int [ 26 ] ; Map < Character , Set < Character >> graph = new HashMap <> (); buildGraph ( words , inDegree , graph ); return bfs ( inDegree , graph ); } private void buildGraph ( final String [] words , int [] inDegree , Map < Character , Set < Character >> graph ) { // create node for each character in each word for ( final String word : words ) for ( final char c : word . toCharArray ()) graph . putIfAbsent ( c , new HashSet <> ()); for ( int i = 1 ; i < words . length ; ++ i ) { final String first = words [ i - 1 ] ; final String second = words [ i ] ; final int length = Math . min ( first . length (), second . length ()); for ( int j = 0 ; j < length ; ++ j ) { final char out = first . charAt ( j ); final char in = second . charAt ( j ); if ( out != in ) { if ( ! graph . get ( out ). contains ( in )) { graph . get ( out ). add ( in ); ++ inDegree [ in - 'a' ] ; } break ; // later characters' order are meaningless } // first = \"ab\", second = \"a\" -> invalid if ( j == length - 1 && first . length () > second . length ()) { graph . clear (); return ; } } } } private String bfs ( int [] inDegree , Map < Character , Set < Character >> graph ) { StringBuilder sb = new StringBuilder (); Queue < Character > q = new LinkedList <> (); for ( final char c : graph . keySet ()) if ( inDegree [ c - 'a' ] == 0 ) q . offer ( c ); while ( ! q . isEmpty ()) { final char out = q . poll (); sb . append ( out ); for ( final char in : graph . get ( out )) if ( -- inDegree [ in - 'a' ] == 0 ) q . offer ( in ); } return sb . length () == graph . size () ? sb . toString () : \"\" ; } }","title":"269. Alien Dictionary \ud83d\udd12"},{"location":"problems/0270/","text":"270. Closest Binary Search Tree Value \ud83d\udd12 Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int closestValue ( TreeNode * root , double target ) { // if target < root->val, search left subtree if ( target < root -> val && root -> left ) { const int left = closestValue ( root -> left , target ); if ( abs ( left - target ) < abs ( root -> val - target )) return left ; } // if target > root->val, search right subtree if ( target > root -> val && root -> right ) { const int right = closestValue ( root -> right , target ); if ( abs ( right - target ) < abs ( root -> val - target )) return right ; } return root -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int closestValue ( TreeNode root , double target ) { // if target < root.val, search left subtree if ( target < root . val && root . left != null ) { final int left = closestValue ( root . left , target ); if ( Math . abs ( left - target ) < Math . abs ( root . val - target )) return left ; } // if target > root.val, search right subtree if ( target > root . val && root . right != null ) { final int right = closestValue ( root . right , target ); if ( Math . abs ( right - target ) < Math . abs ( root . val - target )) return right ; } return root . val ; } }","title":"270. Closest Binary Search Tree Value"},{"location":"problems/0270/#270-closest-binary-search-tree-value","text":"Time: $O(h)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int closestValue ( TreeNode * root , double target ) { // if target < root->val, search left subtree if ( target < root -> val && root -> left ) { const int left = closestValue ( root -> left , target ); if ( abs ( left - target ) < abs ( root -> val - target )) return left ; } // if target > root->val, search right subtree if ( target > root -> val && root -> right ) { const int right = closestValue ( root -> right , target ); if ( abs ( right - target ) < abs ( root -> val - target )) return right ; } return root -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int closestValue ( TreeNode root , double target ) { // if target < root.val, search left subtree if ( target < root . val && root . left != null ) { final int left = closestValue ( root . left , target ); if ( Math . abs ( left - target ) < Math . abs ( root . val - target )) return left ; } // if target > root.val, search right subtree if ( target > root . val && root . right != null ) { final int right = closestValue ( root . right , target ); if ( Math . abs ( right - target ) < Math . abs ( root . val - target )) return right ; } return root . val ; } }","title":"270. Closest Binary Search Tree Value \ud83d\udd12"},{"location":"problems/0271/","text":"271. Encode and Decode Strings \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Codec { public : // Encodes a list of strings to a single string. string encode ( vector < string >& strs ) { string encoded ; for ( const string & s : strs ) encoded += to_string ( s . length ()) + '/' + s ; return encoded ; } // Decodes a single string to a list of strings. vector < string > decode ( string s ) { vector < string > decoded ; for ( int i = 0 ; i < s . length ();) { const int slash = s . find ( '/' , i ); const int length = stoi ( s . substr ( i , slash - i )); i = slash + length + 1 ; decoded . push_back ( s . substr ( slash + 1 , i - slash - 1 )); } return decoded ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Codec { // Encodes a list of strings to a single string. public String encode ( List < String > strs ) { StringBuilder encoded = new StringBuilder (); for ( final String s : strs ) encoded . append ( s . length ()). append ( '/' ). append ( s ); return encoded . toString (); } // Decodes a single string to a list of strings. public List < String > decode ( String s ) { List < String > decoded = new ArrayList <> (); for ( int i = 0 ; i < s . length ();) { final int slash = s . indexOf ( '/' , i ); final int length = Integer . parseInt ( s . substring ( i , slash )); i = slash + length + 1 ; decoded . add ( s . substring ( slash + 1 , i )); } return decoded ; } }","title":"271. Encode and Decode Strings"},{"location":"problems/0271/#271-encode-and-decode-strings","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Codec { public : // Encodes a list of strings to a single string. string encode ( vector < string >& strs ) { string encoded ; for ( const string & s : strs ) encoded += to_string ( s . length ()) + '/' + s ; return encoded ; } // Decodes a single string to a list of strings. vector < string > decode ( string s ) { vector < string > decoded ; for ( int i = 0 ; i < s . length ();) { const int slash = s . find ( '/' , i ); const int length = stoi ( s . substr ( i , slash - i )); i = slash + length + 1 ; decoded . push_back ( s . substr ( slash + 1 , i - slash - 1 )); } return decoded ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Codec { // Encodes a list of strings to a single string. public String encode ( List < String > strs ) { StringBuilder encoded = new StringBuilder (); for ( final String s : strs ) encoded . append ( s . length ()). append ( '/' ). append ( s ); return encoded . toString (); } // Decodes a single string to a list of strings. public List < String > decode ( String s ) { List < String > decoded = new ArrayList <> (); for ( int i = 0 ; i < s . length ();) { final int slash = s . indexOf ( '/' , i ); final int length = Integer . parseInt ( s . substring ( i , slash )); i = slash + length + 1 ; decoded . add ( s . substring ( slash + 1 , i )); } return decoded ; } }","title":"271. Encode and Decode Strings \ud83d\udd12"},{"location":"problems/0272/","text":"272. Closest Binary Search Tree Value II \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > closestKValues ( TreeNode * root , double target , int k ) { deque < int > q ; inorder ( root , q ); while ( q . size () > k ) if ( abs ( q . front () - target ) > abs ( q . back () - target )) q . pop_front (); else q . pop_back (); return { begin ( q ), end ( q )}; } private : void inorder ( TreeNode * root , deque < int >& q ) { if ( ! root ) return ; inorder ( root -> left , q ); q . push_back ( root -> val ); inorder ( root -> right , q ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < Integer > closestKValues ( TreeNode root , double target , int k ) { Deque < Integer > q = new ArrayDeque <> (); inorder ( root , q ); while ( q . size () > k ) if ( Math . abs ( q . peekFirst () - target ) > Math . abs ( q . peekLast () - target )) q . pollFirst (); else q . pollLast (); return new ArrayList <> ( q ); } private void inorder ( TreeNode root , Deque < Integer > q ) { if ( root == null ) return ; inorder ( root . left , q ); q . addLast ( root . val ); inorder ( root . right , q ); } }","title":"272. Closest Binary Search Tree Value II"},{"location":"problems/0272/#272-closest-binary-search-tree-value-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > closestKValues ( TreeNode * root , double target , int k ) { deque < int > q ; inorder ( root , q ); while ( q . size () > k ) if ( abs ( q . front () - target ) > abs ( q . back () - target )) q . pop_front (); else q . pop_back (); return { begin ( q ), end ( q )}; } private : void inorder ( TreeNode * root , deque < int >& q ) { if ( ! root ) return ; inorder ( root -> left , q ); q . push_back ( root -> val ); inorder ( root -> right , q ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < Integer > closestKValues ( TreeNode root , double target , int k ) { Deque < Integer > q = new ArrayDeque <> (); inorder ( root , q ); while ( q . size () > k ) if ( Math . abs ( q . peekFirst () - target ) > Math . abs ( q . peekLast () - target )) q . pollFirst (); else q . pollLast (); return new ArrayList <> ( q ); } private void inorder ( TreeNode root , Deque < Integer > q ) { if ( root == null ) return ; inorder ( root . left , q ); q . addLast ( root . val ); inorder ( root . right , q ); } }","title":"272. Closest Binary Search Tree Value II \ud83d\udd12"},{"location":"problems/0273/","text":"273. Integer to English Words Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string numberToWords ( int num ) { if ( num == 0 ) return \"Zero\" ; return helper ( num ); } private : const vector < string > belowTwenty { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; const vector < string > tens { \"\" , \"\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string helper ( int num ) { string s ; if ( num < 20 ) s = belowTwenty . at ( num ); else if ( num < 100 ) s = tens . at ( num / 10 ) + \" \" + belowTwenty . at ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); trim ( s ); return s ; } void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private final String [] belowTwenty = { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; private final String [] tens = { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; private String helper ( int num ) { StringBuilder s = new StringBuilder (); if ( num < 20 ) s . append ( belowTwenty [ num ] ); else if ( num < 100 ) s . append ( tens [ num / 10 ] ). append ( \" \" ). append ( belowTwenty [ num % 10 ] ); else if ( num < 1000 ) s . append ( helper ( num / 100 )). append ( \" Hundred \" ). append ( helper ( num % 100 )); else if ( num < 1000000 ) s . append ( helper ( num / 1000 )). append ( \" Thousand \" ). append ( helper ( num % 1000 )); else if ( num < 1000000000 ) s . append ( helper ( num / 1000000 )). append ( \" Million \" ). append ( helper ( num % 1000000 )); else s . append ( helper ( num / 1000000000 )). append ( \" Billion \" ). append ( helper ( num % 1000000000 )); return s . toString (). trim (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numberToWords ( self , num : int ) -> str : def helper ( num : int ) -> str : if num < 20 : s = belowTwenty [ num ] elif num < 100 : s = tens [ num // 10 ] + \" \" + helper ( num % 10 ) elif num < 1000 : s = helper ( num // 100 ) + \" Hundred \" + helper ( num % 100 ) elif num < 1000000 : s = helper ( num // 1000 ) + \" Thousand \" + helper ( num % 1000 ) elif num < 1000000000 : s = helper ( num // 1000000 ) + \" Million \" + \\ helper ( num % 1000000 ) else : s = helper ( num // 1000000000 ) + \" Billion \" + \\ helper ( num % 1000000000 ) return s . strip () belowTwenty = [ \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" ] tens = [ \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" ] if num == 0 : return \"Zero\" return helper ( num )","title":"273. Integer to English Words"},{"location":"problems/0273/#273-integer-to-english-words","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string numberToWords ( int num ) { if ( num == 0 ) return \"Zero\" ; return helper ( num ); } private : const vector < string > belowTwenty { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; const vector < string > tens { \"\" , \"\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string helper ( int num ) { string s ; if ( num < 20 ) s = belowTwenty . at ( num ); else if ( num < 100 ) s = tens . at ( num / 10 ) + \" \" + belowTwenty . at ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); trim ( s ); return s ; } void trim ( string & s ) { s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private final String [] belowTwenty = { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; private final String [] tens = { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; private String helper ( int num ) { StringBuilder s = new StringBuilder (); if ( num < 20 ) s . append ( belowTwenty [ num ] ); else if ( num < 100 ) s . append ( tens [ num / 10 ] ). append ( \" \" ). append ( belowTwenty [ num % 10 ] ); else if ( num < 1000 ) s . append ( helper ( num / 100 )). append ( \" Hundred \" ). append ( helper ( num % 100 )); else if ( num < 1000000 ) s . append ( helper ( num / 1000 )). append ( \" Thousand \" ). append ( helper ( num % 1000 )); else if ( num < 1000000000 ) s . append ( helper ( num / 1000000 )). append ( \" Million \" ). append ( helper ( num % 1000000 )); else s . append ( helper ( num / 1000000000 )). append ( \" Billion \" ). append ( helper ( num % 1000000000 )); return s . toString (). trim (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numberToWords ( self , num : int ) -> str : def helper ( num : int ) -> str : if num < 20 : s = belowTwenty [ num ] elif num < 100 : s = tens [ num // 10 ] + \" \" + helper ( num % 10 ) elif num < 1000 : s = helper ( num // 100 ) + \" Hundred \" + helper ( num % 100 ) elif num < 1000000 : s = helper ( num // 1000 ) + \" Thousand \" + helper ( num % 1000 ) elif num < 1000000000 : s = helper ( num // 1000000 ) + \" Million \" + \\ helper ( num % 1000000 ) else : s = helper ( num // 1000000000 ) + \" Billion \" + \\ helper ( num % 1000000000 ) return s . strip () belowTwenty = [ \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" ] tens = [ \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" ] if num == 0 : return \"Zero\" return helper ( num )","title":"273. Integer to English Words"},{"location":"problems/0274/","text":"274. H-Index Approach 1: Bucket Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); int accumulate = 0 ; vector < int > count ( n + 1 ); for ( const int citation : citations ) ++ count [ min ( citation , n )]; // to find the largeset h-index, loop from back to front // i is the candidate h-index for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ]; if ( accumulate >= i ) return i ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; int accumulate = 0 ; int [] count = new int [ n + 1 ] ; for ( final int citation : citations ) ++ count [ Math . min ( citation , n ) ] ; // to find the largeset h-index, loop from back to front // i is the candidate h-index for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ] ; if ( accumulate >= i ) return i ; } throw new IllegalArgumentException (); } } Approach 2: Sort Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); sort ( begin ( citations ), end ( citations )); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; Arrays . sort ( citations ); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def hIndex ( self , citations : List [ int ]) -> int : n = len ( citations ) citations . sort () for i , citation in enumerate ( citations ): if citation >= n - i : return n - i return 0","title":"274. H-Index"},{"location":"problems/0274/#274-h-index","text":"","title":"274. H-Index"},{"location":"problems/0274/#approach-1-bucket","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); int accumulate = 0 ; vector < int > count ( n + 1 ); for ( const int citation : citations ) ++ count [ min ( citation , n )]; // to find the largeset h-index, loop from back to front // i is the candidate h-index for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ]; if ( accumulate >= i ) return i ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; int accumulate = 0 ; int [] count = new int [ n + 1 ] ; for ( final int citation : citations ) ++ count [ Math . min ( citation , n ) ] ; // to find the largeset h-index, loop from back to front // i is the candidate h-index for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ] ; if ( accumulate >= i ) return i ; } throw new IllegalArgumentException (); } }","title":"Approach 1: Bucket"},{"location":"problems/0274/#approach-2-sort","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); sort ( begin ( citations ), end ( citations )); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; Arrays . sort ( citations ); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def hIndex ( self , citations : List [ int ]) -> int : n = len ( citations ) citations . sort () for i , citation in enumerate ( citations ): if citation >= n - i : return n - i return 0","title":"Approach 2: Sort"},{"location":"problems/0275/","text":"275. H-Index II Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . size () - m ) r = m ; else l = m + 1 ; } return citations . size () - l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int hIndex ( int [] citations ) { int l = 0 ; int r = citations . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . length - m ) r = m ; else l = m + 1 ; } return citations . length - l ; } }","title":"275. H-Index II"},{"location":"problems/0275/#275-h-index-ii","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . size () - m ) r = m ; else l = m + 1 ; } return citations . size () - l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int hIndex ( int [] citations ) { int l = 0 ; int r = citations . length ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . length - m ) r = m ; else l = m + 1 ; } return citations . length - l ; } }","title":"275. H-Index II"},{"location":"problems/0276/","text":"276. Paint Fence \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return k ; if ( n == 2 ) return k * k ; // dp[i] := # of ways to paint n posts with k colors vector < int > dp ( n + 1 ); dp [ 0 ] = 0 ; dp [ 1 ] = k ; dp [ 2 ] = k * k ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ]) * ( k - 1 ); return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return k ; if ( n == 2 ) return k * k ; // dp[i] := # of ways to paint n posts with k colors int [] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = k ; dp [ 2 ] = k * k ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) * ( k - 1 ); return dp [ n ] ; } }","title":"276. Paint Fence"},{"location":"problems/0276/#276-paint-fence","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return k ; if ( n == 2 ) return k * k ; // dp[i] := # of ways to paint n posts with k colors vector < int > dp ( n + 1 ); dp [ 0 ] = 0 ; dp [ 1 ] = k ; dp [ 2 ] = k * k ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ]) * ( k - 1 ); return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numWays ( int n , int k ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return k ; if ( n == 2 ) return k * k ; // dp[i] := # of ways to paint n posts with k colors int [] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = k ; dp [ 2 ] = k * k ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] ) * ( k - 1 ); return dp [ n ] ; } }","title":"276. Paint Fence \ud83d\udd12"},{"location":"problems/0277/","text":"277. Find the Celebrity \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findCelebrity ( int n ) { int candidate = 0 ; // everyone knows the celebrity for ( int i = 1 ; i < n ; ++ i ) if ( knows ( candidate , i )) candidate = i ; // candidate knows nobody and everyone knows the celebrity for ( int i = 0 ; i < n ; ++ i ) { if ( i < candidate && knows ( candidate , i ) || ! knows ( i , candidate )) return -1 ; if ( i > candidate && ! knows ( i , candidate )) return -1 ; } return candidate ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Solution extends Relation { public int findCelebrity ( int n ) { int candidate = 0 ; // everyone knows the celebrity for ( int i = 1 ; i < n ; ++ i ) if ( knows ( candidate , i )) candidate = i ; // candidate knows nobody and everyone knows the celebrity for ( int i = 0 ; i < n ; ++ i ) { if ( i < candidate && knows ( candidate , i ) || ! knows ( i , candidate )) return - 1 ; if ( i > candidate && ! knows ( i , candidate )) return - 1 ; } return candidate ; } }","title":"277. Find the Celebrity"},{"location":"problems/0277/#277-find-the-celebrity","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findCelebrity ( int n ) { int candidate = 0 ; // everyone knows the celebrity for ( int i = 1 ; i < n ; ++ i ) if ( knows ( candidate , i )) candidate = i ; // candidate knows nobody and everyone knows the celebrity for ( int i = 0 ; i < n ; ++ i ) { if ( i < candidate && knows ( candidate , i ) || ! knows ( i , candidate )) return -1 ; if ( i > candidate && ! knows ( i , candidate )) return -1 ; } return candidate ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Solution extends Relation { public int findCelebrity ( int n ) { int candidate = 0 ; // everyone knows the celebrity for ( int i = 1 ; i < n ; ++ i ) if ( knows ( candidate , i )) candidate = i ; // candidate knows nobody and everyone knows the celebrity for ( int i = 0 ; i < n ; ++ i ) { if ( i < candidate && knows ( candidate , i ) || ! knows ( i , candidate )) return - 1 ; if ( i > candidate && ! knows ( i , candidate )) return - 1 ; } return candidate ; } }","title":"277. Find the Celebrity \ud83d\udd12"},{"location":"problems/0278/","text":"278. First Bad Version Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Solution extends VersionControl { public int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l","title":"278. First Bad Version"},{"location":"problems/0278/#278-first-bad-version","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Solution extends VersionControl { public int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l","title":"278. First Bad Version"},{"location":"problems/0279/","text":"279. Perfect Squares Time: $O(\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numSquares ( int n ) { vector < int > dp ( n + 1 , n ); // 1^2 x n dp [ 0 ] = 0 ; // no way dp [ 1 ] = 1 ; // 1^2 for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ); return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numSquares ( int n ) { int [] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n ); // 1^2 x n dp [ 0 ] = 0 ; // no way dp [ 1 ] = 1 ; // 1^2 for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j * j ] + 1 ); return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSquares ( self , n : int ) -> int : dp = [ n ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ): j = 1 while j * j <= i : dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ) j += 1 return dp [ n ]","title":"279. Perfect Squares"},{"location":"problems/0279/#279-perfect-squares","text":"Time: $O(\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numSquares ( int n ) { vector < int > dp ( n + 1 , n ); // 1^2 x n dp [ 0 ] = 0 ; // no way dp [ 1 ] = 1 ; // 1^2 for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ); return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numSquares ( int n ) { int [] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n ); // 1^2 x n dp [ 0 ] = 0 ; // no way dp [ 1 ] = 1 ; // 1^2 for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j * j ] + 1 ); return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSquares ( self , n : int ) -> int : dp = [ n ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ): j = 1 while j * j <= i : dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ) j += 1 return dp [ n ]","title":"279. Perfect Squares"},{"location":"problems/0280/","text":"280. Wiggle Sort \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : void wiggleSort ( vector < int >& nums ) { // 1. if i is even, then nums[i] <= nums[i - 1] // 2. if i is odd, then nums[i] >= nums[i - 1] for ( int i = 1 ; i < nums . size (); ++ i ) if (( ! ( i & 1 ) && nums [ i ] > nums [ i - 1 ]) || (( i & 1 ) && nums [ i ] < nums [ i - 1 ])) swap ( nums [ i ], nums [ i - 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void wiggleSort ( int [] nums ) { // 1. if i is even, then nums[i] <= nums[i - 1] // 2. if i is odd, then nums[i] >= nums[i - 1] for ( int i = 1 ; i < nums . length ; ++ i ) if (( i % 2 == 0 && nums [ i ] > nums [ i - 1 ] ) || ( i % 2 == 1 && nums [ i ] < nums [ i - 1 ] )) swap ( nums , i , i - 1 ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"280. Wiggle Sort"},{"location":"problems/0280/#280-wiggle-sort","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : void wiggleSort ( vector < int >& nums ) { // 1. if i is even, then nums[i] <= nums[i - 1] // 2. if i is odd, then nums[i] >= nums[i - 1] for ( int i = 1 ; i < nums . size (); ++ i ) if (( ! ( i & 1 ) && nums [ i ] > nums [ i - 1 ]) || (( i & 1 ) && nums [ i ] < nums [ i - 1 ])) swap ( nums [ i ], nums [ i - 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void wiggleSort ( int [] nums ) { // 1. if i is even, then nums[i] <= nums[i - 1] // 2. if i is odd, then nums[i] >= nums[i - 1] for ( int i = 1 ; i < nums . length ; ++ i ) if (( i % 2 == 0 && nums [ i ] > nums [ i - 1 ] ) || ( i % 2 == 1 && nums [ i ] < nums [ i - 1 ] )) swap ( nums , i , i - 1 ); } private void swap ( int [] nums , int i , int j ) { final int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"280. Wiggle Sort \ud83d\udd12"},{"location":"problems/0281/","text":"281. Zigzag Iterator \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ZigzagIterator { public : ZigzagIterator ( vector < int >& v1 , vector < int >& v2 ) { if ( ! v1 . empty ()) q . push ({ begin ( v1 ), end ( v1 )}); if ( ! v2 . empty ()) q . push ({ begin ( v2 ), end ( v2 )}); } int next () { const auto [ it , endIt ] = q . front (); q . pop (); if ( it + 1 != endIt ) q . push ({ it + 1 , endIt }); return * it ; } bool hasNext () { return ! q . empty (); } private : // {{ it, endIt }} queue < pair < vector < int >:: iterator , vector < int >:: iterator >> q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ZigzagIterator { public ZigzagIterator ( List < Integer > v1 , List < Integer > v2 ) { if ( ! v1 . isEmpty ()) q . offer ( v1 . iterator ()); if ( ! v2 . isEmpty ()) q . offer ( v2 . iterator ()); } public int next () { final Iterator it = q . poll (); final int next = ( int ) it . next (); if ( it . hasNext ()) q . offer ( it ); return next ; } public boolean hasNext () { return ! q . isEmpty (); } private Queue < Iterator > q = new LinkedList <> (); }","title":"281. Zigzag Iterator"},{"location":"problems/0281/#281-zigzag-iterator","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ZigzagIterator { public : ZigzagIterator ( vector < int >& v1 , vector < int >& v2 ) { if ( ! v1 . empty ()) q . push ({ begin ( v1 ), end ( v1 )}); if ( ! v2 . empty ()) q . push ({ begin ( v2 ), end ( v2 )}); } int next () { const auto [ it , endIt ] = q . front (); q . pop (); if ( it + 1 != endIt ) q . push ({ it + 1 , endIt }); return * it ; } bool hasNext () { return ! q . empty (); } private : // {{ it, endIt }} queue < pair < vector < int >:: iterator , vector < int >:: iterator >> q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ZigzagIterator { public ZigzagIterator ( List < Integer > v1 , List < Integer > v2 ) { if ( ! v1 . isEmpty ()) q . offer ( v1 . iterator ()); if ( ! v2 . isEmpty ()) q . offer ( v2 . iterator ()); } public int next () { final Iterator it = q . poll (); final int next = ( int ) it . next (); if ( it . hasNext ()) q . offer ( it ); return next ; } public boolean hasNext () { return ! q . isEmpty (); } private Queue < Iterator > q = new LinkedList <> (); }","title":"281. Zigzag Iterator \ud83d\udd12"},{"location":"problems/0282/","text":"282. Expression Add Operators Time: $O(n4^{n - 1})$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < string > addOperators ( string num , int target ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; // start index, prev value, current evaluated value function < void ( int , long , long ) > dfs = [ & ]( int s , long prev , long eval ) { if ( s == num . length ()) { if ( eval == target ) ans . push_back ( join ( path )); return ; } for ( int i = s ; i < num . length (); ++ i ) { if ( i > s && num [ s ] == '0' ) break ; const string & str = num . substr ( s , i - s + 1 ); const long curr = stol ( str ); if ( s == 0 ) { // first num path . push_back ( str ); dfs ( i + 1 , curr , curr ); path . pop_back (); } else { for ( const string & op : { \"+\" , \"-\" , \"*\" }) { path . push_back ( op + str ); if ( op == \"+\" ) dfs ( i + 1 , curr , eval + curr ); else if ( op == \"-\" ) dfs ( i + 1 , - curr , eval - curr ); else dfs ( i + 1 , prev * curr , eval - prev + prev * curr ); path . pop_back (); } } } }; dfs ( 0 , 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < String > addOperators ( String num , int target ) { List < String > ans = new ArrayList <> (); dfs ( num , target , 0 , 0 , 0 , new StringBuilder (), ans ); return ans ; } private void dfs ( String num , int target , int s , long prev , long eval , StringBuilder path , List < String > ans ) { if ( s == num . length ()) { if ( eval == target ) ans . add ( path . toString ()); return ; } for ( int i = s ; i < num . length (); ++ i ) { if ( i > s && num . charAt ( s ) == '0' ) break ; final long curr = Long . parseLong ( num . substring ( s , i + 1 )); final int length = path . length (); if ( s == 0 ) { // first num dfs ( num , target , i + 1 , curr , curr , path . append ( curr ), ans ); path . setLength ( length ); } else { dfs ( num , target , i + 1 , curr , eval + curr , path . append ( \"+\" ). append ( curr ), ans ); path . setLength ( length ); dfs ( num , target , i + 1 , - curr , eval - curr , path . append ( \"-\" ). append ( curr ), ans ); path . setLength ( length ); dfs ( num , target , i + 1 , prev * curr , eval - prev + prev * curr , path . append ( \"*\" ). append ( curr ), ans ); path . setLength ( length ); } } } }","title":"282. Expression Add Operators"},{"location":"problems/0282/#282-expression-add-operators","text":"Time: $O(n4^{n - 1})$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < string > addOperators ( string num , int target ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; // start index, prev value, current evaluated value function < void ( int , long , long ) > dfs = [ & ]( int s , long prev , long eval ) { if ( s == num . length ()) { if ( eval == target ) ans . push_back ( join ( path )); return ; } for ( int i = s ; i < num . length (); ++ i ) { if ( i > s && num [ s ] == '0' ) break ; const string & str = num . substr ( s , i - s + 1 ); const long curr = stol ( str ); if ( s == 0 ) { // first num path . push_back ( str ); dfs ( i + 1 , curr , curr ); path . pop_back (); } else { for ( const string & op : { \"+\" , \"-\" , \"*\" }) { path . push_back ( op + str ); if ( op == \"+\" ) dfs ( i + 1 , curr , eval + curr ); else if ( op == \"-\" ) dfs ( i + 1 , - curr , eval - curr ); else dfs ( i + 1 , prev * curr , eval - prev + prev * curr ); path . pop_back (); } } } }; dfs ( 0 , 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < String > addOperators ( String num , int target ) { List < String > ans = new ArrayList <> (); dfs ( num , target , 0 , 0 , 0 , new StringBuilder (), ans ); return ans ; } private void dfs ( String num , int target , int s , long prev , long eval , StringBuilder path , List < String > ans ) { if ( s == num . length ()) { if ( eval == target ) ans . add ( path . toString ()); return ; } for ( int i = s ; i < num . length (); ++ i ) { if ( i > s && num . charAt ( s ) == '0' ) break ; final long curr = Long . parseLong ( num . substring ( s , i + 1 )); final int length = path . length (); if ( s == 0 ) { // first num dfs ( num , target , i + 1 , curr , curr , path . append ( curr ), ans ); path . setLength ( length ); } else { dfs ( num , target , i + 1 , curr , eval + curr , path . append ( \"+\" ). append ( curr ), ans ); path . setLength ( length ); dfs ( num , target , i + 1 , - curr , eval - curr , path . append ( \"-\" ). append ( curr ), ans ); path . setLength ( length ); dfs ( num , target , i + 1 , prev * curr , eval - prev + prev * curr , path . append ( \"*\" ). append ( curr ), ans ); path . setLength ( length ); } } } }","title":"282. Expression Add Operators"},{"location":"problems/0283/","text":"283. Move Zeroes Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void moveZeroes ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( num != 0 ) nums [ i ++ ] = num ; for (; i < nums . size (); ++ i ) nums [ i ] = 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public void moveZeroes ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( num != 0 ) nums [ i ++] = num ; for (; i < nums . length ; ++ i ) nums [ i ] = 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0","title":"283. Move Zeroes"},{"location":"problems/0283/#283-move-zeroes","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void moveZeroes ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( num != 0 ) nums [ i ++ ] = num ; for (; i < nums . size (); ++ i ) nums [ i ] = 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public void moveZeroes ( int [] nums ) { int i = 0 ; for ( final int num : nums ) if ( num != 0 ) nums [ i ++] = num ; for (; i < nums . length ; ++ i ) nums [ i ] = 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0","title":"283. Move Zeroes"},{"location":"problems/0284/","text":"284. Peeking Iterator Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class PeekingIterator : public Iterator { public : PeekingIterator ( const vector < int >& nums ) : Iterator ( nums ) {} // Returns the next element in the iteration without advancing the iterator. int peek () { // Iterator(*this) makes a copy of current iterator, then call next on the // copied iterator to get the next value without affecting current iterator return Iterator ( * this ). next (); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next () { return Iterator :: next (); } bool hasNext () const { return Iterator :: hasNext (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class PeekingIterator implements Iterator < Integer > { public PeekingIterator ( Iterator < Integer > iterator ) { this . iterator = iterator ; if ( iterator . hasNext ()) next = iterator . next (); } // Returns the next element in the iteration without advancing the iterator. public Integer peek () { return next ; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next () { Integer next = this . next ; this . next = iterator . hasNext () ? iterator . next () : null ; return next ; } @Override public boolean hasNext () { return next != null ; } private Integer next = null ; private Iterator < Integer > iterator ; }","title":"284. Peeking Iterator"},{"location":"problems/0284/#284-peeking-iterator","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class PeekingIterator : public Iterator { public : PeekingIterator ( const vector < int >& nums ) : Iterator ( nums ) {} // Returns the next element in the iteration without advancing the iterator. int peek () { // Iterator(*this) makes a copy of current iterator, then call next on the // copied iterator to get the next value without affecting current iterator return Iterator ( * this ). next (); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. int next () { return Iterator :: next (); } bool hasNext () const { return Iterator :: hasNext (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class PeekingIterator implements Iterator < Integer > { public PeekingIterator ( Iterator < Integer > iterator ) { this . iterator = iterator ; if ( iterator . hasNext ()) next = iterator . next (); } // Returns the next element in the iteration without advancing the iterator. public Integer peek () { return next ; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next () { Integer next = this . next ; this . next = iterator . hasNext () ? iterator . next () : null ; return next ; } @Override public boolean hasNext () { return next != null ; } private Integer next = null ; private Iterator < Integer > iterator ; }","title":"284. Peeking Iterator"},{"location":"problems/0285/","text":"285. Inorder Successor in BST \ud83d\udd12 Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { if ( ! root ) return nullptr ; if ( root -> val <= p -> val ) return inorderSuccessor ( root -> right , p ); TreeNode * left = inorderSuccessor ( root -> left , p ); return left ? left : root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public TreeNode inorderSuccessor ( TreeNode root , TreeNode p ) { if ( root == null ) return null ; if ( root . val <= p . val ) return inorderSuccessor ( root . right , p ); TreeNode left = inorderSuccessor ( root . left , p ); return left == null ? root : left ; } }","title":"285. Inorder Successor in BST"},{"location":"problems/0285/#285-inorder-successor-in-bst","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { if ( ! root ) return nullptr ; if ( root -> val <= p -> val ) return inorderSuccessor ( root -> right , p ); TreeNode * left = inorderSuccessor ( root -> left , p ); return left ? left : root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public TreeNode inorderSuccessor ( TreeNode root , TreeNode p ) { if ( root == null ) return null ; if ( root . val <= p . val ) return inorderSuccessor ( root . right , p ); TreeNode left = inorderSuccessor ( root . left , p ); return left == null ? root : left ; } }","title":"285. Inorder Successor in BST \ud83d\udd12"},{"location":"problems/0286/","text":"286. Walls and Gates \ud83d\udd12 Approach 1: BFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void wallsAndGates ( vector < vector < int >>& rooms ) { if ( rooms . empty ()) return ; const int m = rooms . size (); const int n = rooms [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) q . push ({ i , j }); while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( rooms [ x ][ y ] != INT_MAX ) continue ; rooms [ x ][ y ] = rooms [ i ][ j ] + 1 ; q . push ({ x , y }); } } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public void wallsAndGates ( int [][] rooms ) { if ( rooms . length == 0 ) return ; final int m = rooms . length ; final int n = rooms [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> q = new LinkedList <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) q . offer ( new int [] { i , j }); while ( ! q . isEmpty ()) { final int [] p = q . poll (); final int i = p [ 0 ] ; final int j = p [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( rooms [ x ][ y ] != Integer . MAX_VALUE ) continue ; rooms [ x ][ y ] = rooms [ i ][ j ] + 1 ; q . offer ( new int [] { x , y }); } } } } Approach 2: DFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : void wallsAndGates ( vector < vector < int >>& rooms ) { if ( rooms . empty ()) return ; const int m = rooms . size (); const int n = rooms [ 0 ]. size (); function < void ( int , int , int ) > dfs = [ & ]( int i , int j , int distance ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( rooms [ i ][ j ] < distance ) return ; rooms [ i ][ j ] = distance ; dfs ( i + 1 , j , distance + 1 ); dfs ( i - 1 , j , distance + 1 ); dfs ( i , j + 1 , distance + 1 ); dfs ( i , j - 1 , distance + 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) dfs ( i , j , 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public void wallsAndGates ( int [][] rooms ) { for ( int i = 0 ; i < rooms . length ; ++ i ) for ( int j = 0 ; j < rooms [ 0 ] . length ; ++ j ) if ( rooms [ i ][ j ] == 0 ) dfs ( rooms , i , j , 0 ); } private void dfs ( int [][] rooms , int i , int j , int distance ) { if ( i < 0 || i == rooms . length || j < 0 || j == rooms [ 0 ] . length ) return ; if ( rooms [ i ][ j ] < distance ) return ; rooms [ i ][ j ] = distance ; dfs ( rooms , i + 1 , j , distance + 1 ); dfs ( rooms , i - 1 , j , distance + 1 ); dfs ( rooms , i , j + 1 , distance + 1 ); dfs ( rooms , i , j - 1 , distance + 1 ); } }","title":"286. Walls and Gates"},{"location":"problems/0286/#286-walls-and-gates","text":"","title":"286. Walls and Gates \ud83d\udd12"},{"location":"problems/0286/#approach-1-bfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void wallsAndGates ( vector < vector < int >>& rooms ) { if ( rooms . empty ()) return ; const int m = rooms . size (); const int n = rooms [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) q . push ({ i , j }); while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( rooms [ x ][ y ] != INT_MAX ) continue ; rooms [ x ][ y ] = rooms [ i ][ j ] + 1 ; q . push ({ x , y }); } } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public void wallsAndGates ( int [][] rooms ) { if ( rooms . length == 0 ) return ; final int m = rooms . length ; final int n = rooms [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> q = new LinkedList <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) q . offer ( new int [] { i , j }); while ( ! q . isEmpty ()) { final int [] p = q . poll (); final int i = p [ 0 ] ; final int j = p [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( rooms [ x ][ y ] != Integer . MAX_VALUE ) continue ; rooms [ x ][ y ] = rooms [ i ][ j ] + 1 ; q . offer ( new int [] { x , y }); } } } }","title":"Approach 1: BFS"},{"location":"problems/0286/#approach-2-dfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : void wallsAndGates ( vector < vector < int >>& rooms ) { if ( rooms . empty ()) return ; const int m = rooms . size (); const int n = rooms [ 0 ]. size (); function < void ( int , int , int ) > dfs = [ & ]( int i , int j , int distance ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( rooms [ i ][ j ] < distance ) return ; rooms [ i ][ j ] = distance ; dfs ( i + 1 , j , distance + 1 ); dfs ( i - 1 , j , distance + 1 ); dfs ( i , j + 1 , distance + 1 ); dfs ( i , j - 1 , distance + 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( rooms [ i ][ j ] == 0 ) dfs ( i , j , 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public void wallsAndGates ( int [][] rooms ) { for ( int i = 0 ; i < rooms . length ; ++ i ) for ( int j = 0 ; j < rooms [ 0 ] . length ; ++ j ) if ( rooms [ i ][ j ] == 0 ) dfs ( rooms , i , j , 0 ); } private void dfs ( int [][] rooms , int i , int j , int distance ) { if ( i < 0 || i == rooms . length || j < 0 || j == rooms [ 0 ] . length ) return ; if ( rooms [ i ][ j ] < distance ) return ; rooms [ i ][ j ] = distance ; dfs ( rooms , i + 1 , j , distance + 1 ); dfs ( rooms , i - 1 , j , distance + 1 ); dfs ( rooms , i , j + 1 , distance + 1 ); dfs ( rooms , i , j - 1 , distance + 1 ); } }","title":"Approach 2: DFS"},{"location":"problems/0287/","text":"287. Find the Duplicate Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]] ; int fast = nums [ nums [ nums [ 0 ]]] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ nums [ fast ]] ; } slow = nums [ 0 ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ fast ] ; } return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow","title":"287. Find the Duplicate Number"},{"location":"problems/0287/#287-find-the-duplicate-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]] ; int fast = nums [ nums [ nums [ 0 ]]] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ nums [ fast ]] ; } slow = nums [ 0 ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ fast ] ; } return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow","title":"287. Find the Duplicate Number"},{"location":"problems/0288/","text":"288. Unique Word Abbreviation \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ValidWordAbbr { public : ValidWordAbbr ( vector < string >& dictionary ) { for ( const string & word : dictionary ) if ( word . length () > 2 ) { const string abbrev = getAbbrev ( word ); if ( abbrevToWord . count ( abbrev )) { if ( abbrevToWord [ abbrev ] != word ) abbrevToWord [ abbrev ] = \"\" ; // mark as \"\" (is not unique) } else { abbrevToWord [ abbrev ] = word ; } } } bool isUnique ( string word ) { if ( word . length () <= 2 ) return true ; const string abbrev = getAbbrev ( word ); return ! abbrevToWord . count ( abbrev ) || abbrevToWord [ abbrev ] == word ; } private : unordered_map < string , string > abbrevToWord ; string getAbbrev ( const string & word ) { const int innerLength = word . length () - 2 ; return word [ 0 ] + to_string ( innerLength ) + word . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ValidWordAbbr { public ValidWordAbbr ( String [] dictionary ) { for ( final String word : dictionary ) if ( word . length () > 2 ) { final String abbrev = getAbbrev ( word ); if ( abbrevToWord . containsKey ( abbrev )) { if ( ! abbrevToWord . get ( abbrev ). equals ( word )) abbrevToWord . put ( abbrev , \"\" ); // mark as \"\" (is not unique) } else { abbrevToWord . put ( abbrev , word ); } } } public boolean isUnique ( String word ) { if ( word . length () <= 2 ) return true ; final String abbrev = getAbbrev ( word ); return ! abbrevToWord . containsKey ( abbrev ) || abbrevToWord . get ( abbrev ). equals ( word ); } private Map < String , String > abbrevToWord = new HashMap <> (); private String getAbbrev ( final String word ) { final int innerLength = word . length () - 2 ; return word . charAt ( 0 ) + String . valueOf ( innerLength ) + word . charAt ( word . length () - 1 ); } }","title":"288. Unique Word Abbreviation"},{"location":"problems/0288/#288-unique-word-abbreviation","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class ValidWordAbbr { public : ValidWordAbbr ( vector < string >& dictionary ) { for ( const string & word : dictionary ) if ( word . length () > 2 ) { const string abbrev = getAbbrev ( word ); if ( abbrevToWord . count ( abbrev )) { if ( abbrevToWord [ abbrev ] != word ) abbrevToWord [ abbrev ] = \"\" ; // mark as \"\" (is not unique) } else { abbrevToWord [ abbrev ] = word ; } } } bool isUnique ( string word ) { if ( word . length () <= 2 ) return true ; const string abbrev = getAbbrev ( word ); return ! abbrevToWord . count ( abbrev ) || abbrevToWord [ abbrev ] == word ; } private : unordered_map < string , string > abbrevToWord ; string getAbbrev ( const string & word ) { const int innerLength = word . length () - 2 ; return word [ 0 ] + to_string ( innerLength ) + word . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class ValidWordAbbr { public ValidWordAbbr ( String [] dictionary ) { for ( final String word : dictionary ) if ( word . length () > 2 ) { final String abbrev = getAbbrev ( word ); if ( abbrevToWord . containsKey ( abbrev )) { if ( ! abbrevToWord . get ( abbrev ). equals ( word )) abbrevToWord . put ( abbrev , \"\" ); // mark as \"\" (is not unique) } else { abbrevToWord . put ( abbrev , word ); } } } public boolean isUnique ( String word ) { if ( word . length () <= 2 ) return true ; final String abbrev = getAbbrev ( word ); return ! abbrevToWord . containsKey ( abbrev ) || abbrevToWord . get ( abbrev ). equals ( word ); } private Map < String , String > abbrevToWord = new HashMap <> (); private String getAbbrev ( final String word ) { final int innerLength = word . length () - 2 ; return word . charAt ( 0 ) + String . valueOf ( innerLength ) + word . charAt ( word . length () - 1 ); } }","title":"288. Unique Word Abbreviation \ud83d\udd12"},{"location":"problems/0289/","text":"289. Game of Life Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; // any live cell with 2 or 3 live neighbors lives on to the next generation if ( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) board [ i ][ j ] |= 0b10 ; // any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction if ( board [ i ][ j ] == 0 && ones == 3 ) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; // any live cell with 2 or 3 live neighbors lives on to the next generation if ( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) board [ i ][ j ] |= 0b10 ; // any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction if ( board [ i ][ j ] == 0 && ones == 3 ) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1","title":"289. Game of Life"},{"location":"problems/0289/#289-game-of-life","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; // any live cell with 2 or 3 live neighbors lives on to the next generation if ( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) board [ i ][ j ] |= 0b10 ; // any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction if ( board [ i ][ j ] == 0 && ones == 3 ) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; // any live cell with 2 or 3 live neighbors lives on to the next generation if ( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) board [ i ][ j ] |= 0b10 ; // any dead cell with exactly 3 live neighbors becomes a live cell, as if by reproduction if ( board [ i ][ j ] == 0 && ones == 3 ) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1","title":"289. Game of Life"},{"location":"problems/0290/","text":"290. Word Pattern Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool wordPattern ( string pattern , string str ) { const int n = pattern . length (); istringstream iss ( str ); vector < int > charToIndex ( 128 ); unordered_map < string , int > stringToIndex ; int i = 0 ; for ( string word ; iss >> word ; ++ i ) { if ( i == n ) // out of bound return false ; if ( charToIndex [ pattern [ i ]] != stringToIndex [ word ]) return false ; charToIndex [ pattern [ i ]] = i + 1 ; stringToIndex [ word ] = i + 1 ; } return i == n ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean wordPattern ( String pattern , String str ) { String [] words = str . split ( \" \" ); if ( words . length != pattern . length ()) return false ; Map < Character , Integer > charToIndex = new HashMap <> (); Map < String , Integer > stringToIndex = new HashMap <> (); for ( Integer i = 0 ; i < pattern . length (); ++ i ) if ( charToIndex . put ( pattern . charAt ( i ), i ) != stringToIndex . put ( words [ i ] , i )) return false ; return true ; } } Python 1 2 3 4 class Solution : def wordPattern ( self , pattern : str , str : str ) -> bool : t = str . split () return [ * map ( pattern . index , pattern )] == [ * map ( t . index , t )]","title":"290. Word Pattern"},{"location":"problems/0290/#290-word-pattern","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool wordPattern ( string pattern , string str ) { const int n = pattern . length (); istringstream iss ( str ); vector < int > charToIndex ( 128 ); unordered_map < string , int > stringToIndex ; int i = 0 ; for ( string word ; iss >> word ; ++ i ) { if ( i == n ) // out of bound return false ; if ( charToIndex [ pattern [ i ]] != stringToIndex [ word ]) return false ; charToIndex [ pattern [ i ]] = i + 1 ; stringToIndex [ word ] = i + 1 ; } return i == n ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean wordPattern ( String pattern , String str ) { String [] words = str . split ( \" \" ); if ( words . length != pattern . length ()) return false ; Map < Character , Integer > charToIndex = new HashMap <> (); Map < String , Integer > stringToIndex = new HashMap <> (); for ( Integer i = 0 ; i < pattern . length (); ++ i ) if ( charToIndex . put ( pattern . charAt ( i ), i ) != stringToIndex . put ( words [ i ] , i )) return false ; return true ; } } Python 1 2 3 4 class Solution : def wordPattern ( self , pattern : str , str : str ) -> bool : t = str . split () return [ * map ( pattern . index , pattern )] == [ * map ( t . index , t )]","title":"290. Word Pattern"},{"location":"problems/0291/","text":"291. Word Pattern II \ud83d\udd12","title":"291. Word Pattern II"},{"location":"problems/0291/#291-word-pattern-ii","text":"","title":"291. Word Pattern II \ud83d\udd12"},{"location":"problems/0292/","text":"292. Nim Game Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool canWinNim ( int n ) { return n % 4 != 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean canWinNim ( int n ) { return n % 4 != 0 ; } }","title":"292. Nim Game"},{"location":"problems/0292/#292-nim-game","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool canWinNim ( int n ) { return n % 4 != 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean canWinNim ( int n ) { return n % 4 != 0 ; } }","title":"292. Nim Game"},{"location":"problems/0293/","text":"293. Flip Game \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < string > generatePossibleNextMoves ( string s ) { vector < string > ans ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == '+' && s [ i + 1 ] == '+' ) ans . push_back ( s . substr ( 0 , i ) + \"--\" + s . substr ( i + 2 )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public List < String > generatePossibleNextMoves ( String s ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == '+' && s . charAt ( i + 1 ) == '+' ) { StringBuilder sb = new StringBuilder ( s ); sb . setCharAt ( i , '-' ); sb . setCharAt ( i + 1 , '-' ); ans . add ( sb . toString ()); } return ans ; } }","title":"293. Flip Game"},{"location":"problems/0293/#293-flip-game","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < string > generatePossibleNextMoves ( string s ) { vector < string > ans ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == '+' && s [ i + 1 ] == '+' ) ans . push_back ( s . substr ( 0 , i ) + \"--\" + s . substr ( i + 2 )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public List < String > generatePossibleNextMoves ( String s ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == '+' && s . charAt ( i + 1 ) == '+' ) { StringBuilder sb = new StringBuilder ( s ); sb . setCharAt ( i , '-' ); sb . setCharAt ( i + 1 , '-' ); ans . add ( sb . toString ()); } return ans ; } }","title":"293. Flip Game \ud83d\udd12"},{"location":"problems/0294/","text":"294. Flip Game II \ud83d\udd12 Time: $O(3^{n / 2})$ Space: $O(3^{n / 2})$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool canWin ( string s ) { if ( memo . count ( s )) return memo [ s ]; // if any of s.substr(i, 2) == \"++\" and // your friend can't win after changing s.substr(i, 2) to \"--\" (or \"-\"), // then you can win for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == '+' && s [ i + 1 ] == '+' && ! canWin ( s . substr ( 0 , i ) + '-' + s . substr ( i + 2 ))) return memo [ s ] = true ; return memo [ s ] = false ; } private : unordered_map < string , bool > memo ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean canWin ( String s ) { if ( memo . containsKey ( s )) memo . get ( s ); // if any of s.substring(i, i + 2) == \"++\" and // your friend can't win after changing s.substring(i, i + 2) to \"--\" (or \"-\"), // then you can win for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == '+' && s . charAt ( i + 1 ) == '+' && ! canWin ( s . substring ( 0 , i ) + \"-\" + s . substring ( i + 2 ))) { memo . put ( s , true ); return true ; } memo . put ( s , false ); return false ; } private Map < String , Boolean > memo = new HashMap <> (); }","title":"294. Flip Game II"},{"location":"problems/0294/#294-flip-game-ii","text":"Time: $O(3^{n / 2})$ Space: $O(3^{n / 2})$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool canWin ( string s ) { if ( memo . count ( s )) return memo [ s ]; // if any of s.substr(i, 2) == \"++\" and // your friend can't win after changing s.substr(i, 2) to \"--\" (or \"-\"), // then you can win for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == '+' && s [ i + 1 ] == '+' && ! canWin ( s . substr ( 0 , i ) + '-' + s . substr ( i + 2 ))) return memo [ s ] = true ; return memo [ s ] = false ; } private : unordered_map < string , bool > memo ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean canWin ( String s ) { if ( memo . containsKey ( s )) memo . get ( s ); // if any of s.substring(i, i + 2) == \"++\" and // your friend can't win after changing s.substring(i, i + 2) to \"--\" (or \"-\"), // then you can win for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == '+' && s . charAt ( i + 1 ) == '+' && ! canWin ( s . substring ( 0 , i ) + \"-\" + s . substring ( i + 2 ))) { memo . put ( s , true ); return true ; } memo . put ( s , false ); return false ; } private Map < String , Boolean > memo = new HashMap <> (); }","title":"294. Flip Game II \ud83d\udd12"},{"location":"problems/0295/","text":"295. Find Median from Data Stream Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MedianFinder { public : void addNum ( int num ) { if ( l . empty () || num <= l . top ()) l . push ( num ); else r . push ( num ); // balance two heaps s.t. |l| >= |r| and |l| - |r| <= 1 if ( l . size () < r . size ()) l . push ( r . top ()), r . pop (); else if ( l . size () - r . size () > 1 ) r . push ( l . top ()), l . pop (); } double findMedian () { if ( l . size () == r . size ()) return ( l . top () + r . top ()) / 2.0 ; return l . top (); } private : priority_queue < int > l ; // max-heap priority_queue < int , vector < int > , greater <>> r ; // min-heap }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MedianFinder { public void addNum ( int num ) { if ( l . isEmpty () || num <= l . peek ()) l . offer ( num ); else r . offer ( num ); // balance two heaps s.t. |l| >= |r| and |l| - |r| <= 1 if ( l . size () < r . size ()) l . offer ( r . poll ()); else if ( l . size () - r . size () > 1 ) r . offer ( l . poll ()); } public double findMedian () { if ( l . size () == r . size ()) return ( double ) ( l . peek () + r . peek ()) / 2.0 ; return ( double ) l . peek (); } private PriorityQueue < Integer > l = new PriorityQueue <> ( Collections . reverseOrder ()); // max-heap private PriorityQueue < Integer > r = new PriorityQueue <> (); // min-heap }","title":"295. Find Median from Data Stream"},{"location":"problems/0295/#295-find-median-from-data-stream","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MedianFinder { public : void addNum ( int num ) { if ( l . empty () || num <= l . top ()) l . push ( num ); else r . push ( num ); // balance two heaps s.t. |l| >= |r| and |l| - |r| <= 1 if ( l . size () < r . size ()) l . push ( r . top ()), r . pop (); else if ( l . size () - r . size () > 1 ) r . push ( l . top ()), l . pop (); } double findMedian () { if ( l . size () == r . size ()) return ( l . top () + r . top ()) / 2.0 ; return l . top (); } private : priority_queue < int > l ; // max-heap priority_queue < int , vector < int > , greater <>> r ; // min-heap }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MedianFinder { public void addNum ( int num ) { if ( l . isEmpty () || num <= l . peek ()) l . offer ( num ); else r . offer ( num ); // balance two heaps s.t. |l| >= |r| and |l| - |r| <= 1 if ( l . size () < r . size ()) l . offer ( r . poll ()); else if ( l . size () - r . size () > 1 ) r . offer ( l . poll ()); } public double findMedian () { if ( l . size () == r . size ()) return ( double ) ( l . peek () + r . peek ()) / 2.0 ; return ( double ) l . peek (); } private PriorityQueue < Integer > l = new PriorityQueue <> ( Collections . reverseOrder ()); // max-heap private PriorityQueue < Integer > r = new PriorityQueue <> (); // min-heap }","title":"295. Find Median from Data Stream"},{"location":"problems/0296/","text":"296. Best Meeting Point \ud83d\udd12 Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int minTotalDistance ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < int > I ; // i indices s.t. grid[i][j] == 1 vector < int > J ; // j indices s.t. grid[i][j] == 1 for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ]) I . push_back ( i ); for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ][ j ]) J . push_back ( j ); // sum(i - median(I)) + sum(j - median(J)) return minTotalDistance ( I ) + minTotalDistance ( J ); } private : int minTotalDistance ( const vector < int >& grid ) { int sum = 0 ; int i = 0 ; int j = grid . size () - 1 ; while ( i < j ) sum += grid [ j -- ] - grid [ i ++ ]; return sum ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int minTotalDistance ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < Integer > I = new ArrayList <> (); // i indices s.t. grid[i][j] == 1 List < Integer > J = new ArrayList <> (); // j indices s.t. grid[i][j] == 1 for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) I . add ( i ); for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ][ j ] == 1 ) J . add ( j ); // sum(i - median(I)) + sum(j - median(J)) return minTotalDistance ( I ) + minTotalDistance ( J ); } private int minTotalDistance ( List < Integer > grid ) { int sum = 0 ; int i = 0 ; int j = grid . size () - 1 ; while ( i < j ) sum += grid . get ( j -- ) - grid . get ( i ++ ); return sum ; } }","title":"296. Best Meeting Point"},{"location":"problems/0296/#296-best-meeting-point","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int minTotalDistance ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < int > I ; // i indices s.t. grid[i][j] == 1 vector < int > J ; // j indices s.t. grid[i][j] == 1 for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ]) I . push_back ( i ); for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ][ j ]) J . push_back ( j ); // sum(i - median(I)) + sum(j - median(J)) return minTotalDistance ( I ) + minTotalDistance ( J ); } private : int minTotalDistance ( const vector < int >& grid ) { int sum = 0 ; int i = 0 ; int j = grid . size () - 1 ; while ( i < j ) sum += grid [ j -- ] - grid [ i ++ ]; return sum ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int minTotalDistance ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < Integer > I = new ArrayList <> (); // i indices s.t. grid[i][j] == 1 List < Integer > J = new ArrayList <> (); // j indices s.t. grid[i][j] == 1 for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) I . add ( i ); for ( int j = 0 ; j < n ; ++ j ) for ( int i = 0 ; i < m ; ++ i ) if ( grid [ i ][ j ] == 1 ) J . add ( j ); // sum(i - median(I)) + sum(j - median(J)) return minTotalDistance ( I ) + minTotalDistance ( J ); } private int minTotalDistance ( List < Integer > grid ) { int sum = 0 ; int i = 0 ; int j = grid . size () - 1 ; while ( i < j ) sum += grid . get ( j -- ) - grid . get ( i ++ ); return sum ; } }","title":"296. Best Meeting Point \ud83d\udd12"},{"location":"problems/0297/","text":"297. Serialize and Deserialize Binary Tree Approach 1: BFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { root = q . front (), q . pop (); if ( ! root ) { s += \"n \" ; continue ; } s += to_string ( root -> val ) + \" \" ; q . push ( root -> left ); q . push ( root -> right ); } return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string word ; iss >> word ; TreeNode * root = new TreeNode ( stoi ( word )); queue < TreeNode *> q {{ root }}; while ( iss >> word ) { TreeNode * parent = q . front (); q . pop (); if ( word != \"n\" ) { TreeNode * left = new TreeNode ( stoi ( word )); parent -> left = left ; q . push ( left ); } iss >> word ; if ( word != \"n\" ) { TreeNode * right = new TreeNode ( stoi ( word )); parent -> right = right ; q . push ( right ); } } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { root = q . poll (); if ( root == null ) { sb . append ( \"n\" ). append ( \" \" ); continue ; } sb . append ( root . val ). append ( \" \" ); q . offer ( root . left ); q . offer ( root . right ); } return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; final String [] vals = data . split ( \" \" ); TreeNode root = new TreeNode ( Integer . parseInt ( vals [ 0 ] )); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { TreeNode parent = q . poll (); if ( ! vals [ i ] . equals ( \"n\" )) { TreeNode left = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . left = left ; q . offer ( left ); } if ( ! vals [++ i ] . equals ( \"n\" )) { TreeNode right = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . right = right ; q . offer ( right ); } } return root ; } } Approach 2: DFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { string s ; function < void ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) { if ( ! root ) { s += \"n \" ; return ; } s += to_string ( root -> val ) + \" \" ; preorder ( root -> left ); preorder ( root -> right ); }; preorder ( root ); return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { istringstream iss ( data ); queue < string > q ; for ( string s ; iss >> s ;) q . push ( s ); function < TreeNode * () > preorder = [ & ]() -> TreeNode * { const string s = q . front (); q . pop (); if ( s == \"n\" ) return nullptr ; TreeNode * root = new TreeNode ( stoi ( s )); root -> left = preorder (); root -> right = preorder (); return root ; }; return preorder (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { StringBuilder sb = new StringBuilder (); preorder ( root , sb ); return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { final String [] vals = data . split ( \" \" ); Queue < String > q = new LinkedList <> (); for ( final String val : vals ) q . offer ( val ); return preorder ( q ); } private void preorder ( TreeNode root , StringBuilder sb ) { if ( root == null ) { sb . append ( \"n\" ). append ( \" \" ); return ; } sb . append ( root . val ). append ( \" \" ); preorder ( root . left , sb ); preorder ( root . right , sb ); } private TreeNode preorder ( Queue < String > q ) { final String s = q . poll (); if ( s . equals ( \"n\" )) return null ; TreeNode root = new TreeNode ( Integer . parseInt ( s )); root . left = preorder ( q ); root . right = preorder ( q ); return root ; } }","title":"297. Serialize and Deserialize Binary Tree"},{"location":"problems/0297/#297-serialize-and-deserialize-binary-tree","text":"","title":"297. Serialize and Deserialize Binary Tree"},{"location":"problems/0297/#approach-1-bfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { root = q . front (), q . pop (); if ( ! root ) { s += \"n \" ; continue ; } s += to_string ( root -> val ) + \" \" ; q . push ( root -> left ); q . push ( root -> right ); } return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string word ; iss >> word ; TreeNode * root = new TreeNode ( stoi ( word )); queue < TreeNode *> q {{ root }}; while ( iss >> word ) { TreeNode * parent = q . front (); q . pop (); if ( word != \"n\" ) { TreeNode * left = new TreeNode ( stoi ( word )); parent -> left = left ; q . push ( left ); } iss >> word ; if ( word != \"n\" ) { TreeNode * right = new TreeNode ( stoi ( word )); parent -> right = right ; q . push ( right ); } } return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { root = q . poll (); if ( root == null ) { sb . append ( \"n\" ). append ( \" \" ); continue ; } sb . append ( root . val ). append ( \" \" ); q . offer ( root . left ); q . offer ( root . right ); } return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; final String [] vals = data . split ( \" \" ); TreeNode root = new TreeNode ( Integer . parseInt ( vals [ 0 ] )); Queue < TreeNode > q = new LinkedList <> (); q . offer ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { TreeNode parent = q . poll (); if ( ! vals [ i ] . equals ( \"n\" )) { TreeNode left = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . left = left ; q . offer ( left ); } if ( ! vals [++ i ] . equals ( \"n\" )) { TreeNode right = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . right = right ; q . offer ( right ); } } return root ; } }","title":"Approach 1: BFS"},{"location":"problems/0297/#approach-2-dfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Codec { public : // Encodes a tree to a single string. string serialize ( TreeNode * root ) { string s ; function < void ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) { if ( ! root ) { s += \"n \" ; return ; } s += to_string ( root -> val ) + \" \" ; preorder ( root -> left ); preorder ( root -> right ); }; preorder ( root ); return s ; } // Decodes your encoded data to tree. TreeNode * deserialize ( string data ) { istringstream iss ( data ); queue < string > q ; for ( string s ; iss >> s ;) q . push ( s ); function < TreeNode * () > preorder = [ & ]() -> TreeNode * { const string s = q . front (); q . pop (); if ( s == \"n\" ) return nullptr ; TreeNode * root = new TreeNode ( stoi ( s )); root -> left = preorder (); root -> right = preorder (); return root ; }; return preorder (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { StringBuilder sb = new StringBuilder (); preorder ( root , sb ); return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { final String [] vals = data . split ( \" \" ); Queue < String > q = new LinkedList <> (); for ( final String val : vals ) q . offer ( val ); return preorder ( q ); } private void preorder ( TreeNode root , StringBuilder sb ) { if ( root == null ) { sb . append ( \"n\" ). append ( \" \" ); return ; } sb . append ( root . val ). append ( \" \" ); preorder ( root . left , sb ); preorder ( root . right , sb ); } private TreeNode preorder ( Queue < String > q ) { final String s = q . poll (); if ( s . equals ( \"n\" )) return null ; TreeNode root = new TreeNode ( Integer . parseInt ( s )); root . left = preorder ( q ); root . right = preorder ( q ); return root ; } }","title":"Approach 2: DFS"},{"location":"problems/0298/","text":"298. Binary Tree Longest Consecutive Sequence \ud83d\udd12 Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int longestConsecutive ( TreeNode * root ) { if ( ! root ) return 0 ; return dfs ( root , root -> val , 0 , 0 ); } private : int dfs ( TreeNode * root , int target , int length , int maxLength ) { if ( ! root ) return maxLength ; if ( root -> val == target ) maxLength = max ( maxLength , ++ length ); else length = 1 ; return max ( dfs ( root -> left , root -> val + 1 , length , maxLength ), dfs ( root -> right , root -> val + 1 , length , maxLength )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestConsecutive ( TreeNode root ) { if ( root == null ) return 0 ; return dfs ( root , - 1 , 0 , 1 ); } private int dfs ( TreeNode root , int target , int length , int max ) { if ( root == null ) return max ; if ( root . val == target ) max = Math . max ( max , ++ length ); else length = 1 ; return Math . max ( dfs ( root . left , root . val + 1 , length , max ), dfs ( root . right , root . val + 1 , length , max )); } }","title":"298. Binary Tree Longest Consecutive Sequence"},{"location":"problems/0298/#298-binary-tree-longest-consecutive-sequence","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int longestConsecutive ( TreeNode * root ) { if ( ! root ) return 0 ; return dfs ( root , root -> val , 0 , 0 ); } private : int dfs ( TreeNode * root , int target , int length , int maxLength ) { if ( ! root ) return maxLength ; if ( root -> val == target ) maxLength = max ( maxLength , ++ length ); else length = 1 ; return max ( dfs ( root -> left , root -> val + 1 , length , maxLength ), dfs ( root -> right , root -> val + 1 , length , maxLength )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestConsecutive ( TreeNode root ) { if ( root == null ) return 0 ; return dfs ( root , - 1 , 0 , 1 ); } private int dfs ( TreeNode root , int target , int length , int max ) { if ( root == null ) return max ; if ( root . val == target ) max = Math . max ( max , ++ length ); else length = 1 ; return Math . max ( dfs ( root . left , root . val + 1 , length , max ), dfs ( root . right , root . val + 1 , length , max )); } }","title":"298. Binary Tree Longest Consecutive Sequence \ud83d\udd12"},{"location":"problems/0299/","text":"299. Bulls and Cows Time: $O(n)$ Space: $O(10)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secret , string guess ) { int A = 0 ; int B = 0 ; vector < int > count1 ( 10 ); vector < int > count2 ( 10 ); for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret [ i ] == guess [ i ]) ++ A ; else { ++ count1 [ secret [ i ] - '0' ]; ++ count2 [ guess [ i ] - '0' ]; } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( count1 [ i ], count2 [ i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String getHint ( String secret , String guess ) { int A = 0 ; int B = 0 ; int [] count1 = new int [ 10 ] ; int [] count2 = new int [ 10 ] ; for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret . charAt ( i ) == guess . charAt ( i )) ++ A ; else { ++ count1 [ secret . charAt ( i ) - '0' ] ; ++ count2 [ guess . charAt ( i ) - '0' ] ; } for ( int i = 0 ; i <= 9 ; ++ i ) B += Math . min ( count1 [ i ] , count2 [ i ] ); return String . valueOf ( A ) + \"A\" + String . valueOf ( B ) + \"B\" ; } } Python 1 2 3 4 5 class Solution : def getHint ( self , secret : str , guess : str ) -> str : bulls = sum ( map ( operator . eq , secret , guess )) bovine = sum ( min ( secret . count ( x ), guess . count ( x )) for x in set ( guess )) return ' %d A %d B' % ( bulls , bovine - bulls )","title":"299. Bulls and Cows"},{"location":"problems/0299/#299-bulls-and-cows","text":"Time: $O(n)$ Space: $O(10)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secret , string guess ) { int A = 0 ; int B = 0 ; vector < int > count1 ( 10 ); vector < int > count2 ( 10 ); for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret [ i ] == guess [ i ]) ++ A ; else { ++ count1 [ secret [ i ] - '0' ]; ++ count2 [ guess [ i ] - '0' ]; } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( count1 [ i ], count2 [ i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String getHint ( String secret , String guess ) { int A = 0 ; int B = 0 ; int [] count1 = new int [ 10 ] ; int [] count2 = new int [ 10 ] ; for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret . charAt ( i ) == guess . charAt ( i )) ++ A ; else { ++ count1 [ secret . charAt ( i ) - '0' ] ; ++ count2 [ guess . charAt ( i ) - '0' ] ; } for ( int i = 0 ; i <= 9 ; ++ i ) B += Math . min ( count1 [ i ] , count2 [ i ] ); return String . valueOf ( A ) + \"A\" + String . valueOf ( B ) + \"B\" ; } } Python 1 2 3 4 5 class Solution : def getHint ( self , secret : str , guess : str ) -> str : bulls = sum ( map ( operator . eq , secret , guess )) bovine = sum ( min ( secret . count ( x ), guess . count ( x )) for x in set ( guess )) return ' %d A %d B' % ( bulls , bovine - bulls )","title":"299. Bulls and Cows"},{"location":"problems/0300/","text":"300. Longest Increasing Subsequence Approach 1: 2D DP Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLIS ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; vector < int > dp ( nums . size (), 1 ); for ( int i = 1 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int lengthOfLIS ( int [] nums ) { if ( nums . length == 0 ) return 0 ; // dp[i] := LIS ending at nums[i] int [] dp = new int [ nums . length ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < nums . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ); return Arrays . stream ( dp ). max (). getAsInt (); } } Approach 2: Binary Search Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int ans = 0 ; // dp[i] := the minimum tail of all increasing subseqs with length i + 1 // it's easy to see that dp must be an increasing array vector < int > dp ( nums . size ()); for ( const int num : nums ) { int l = 0 ; int r = ans ; // find the first index l in dp[0..ans) s.t. dp[l] >= num while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < num ) l = m + 1 ; else r = m ; } dp [ l ] = num ; // if didn't find any number in dp[0..ans) that is >= num, it means we // can append num in the current increasing subsequence if ( l == ans ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int lengthOfLIS ( int [] nums ) { int ans = 0 ; // dp[i] := the minimum tail of all increasing subseqs with length i + 1 // it's easy to see that dp must be an increasing array int [] dp = new int [ nums . length ] ; for ( final int num : nums ) { // find the first index i in dp[0..ans) s.t. dp[i] >= num int i = Arrays . binarySearch ( dp , 0 , ans , num ); // i = -(insertion point) - 1 // insertion point = -(i + 1) if ( i < 0 ) i = - ( i + 1 ); dp [ i ] = num ; // if didn't find any number in dp[0..ans) that is >= num, it means we // can append num in the current increasing subsequence if ( i == ans ) ++ ans ; } return ans ; } }","title":"300. Longest Increasing Subsequence"},{"location":"problems/0300/#300-longest-increasing-subsequence","text":"","title":"300. Longest Increasing Subsequence"},{"location":"problems/0300/#approach-1-2d-dp","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLIS ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; vector < int > dp ( nums . size (), 1 ); for ( int i = 1 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); return * max_element ( begin ( dp ), end ( dp )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int lengthOfLIS ( int [] nums ) { if ( nums . length == 0 ) return 0 ; // dp[i] := LIS ending at nums[i] int [] dp = new int [ nums . length ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < nums . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ); return Arrays . stream ( dp ). max (). getAsInt (); } }","title":"Approach 1: 2D DP"},{"location":"problems/0300/#approach-2-binary-search","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int ans = 0 ; // dp[i] := the minimum tail of all increasing subseqs with length i + 1 // it's easy to see that dp must be an increasing array vector < int > dp ( nums . size ()); for ( const int num : nums ) { int l = 0 ; int r = ans ; // find the first index l in dp[0..ans) s.t. dp[l] >= num while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < num ) l = m + 1 ; else r = m ; } dp [ l ] = num ; // if didn't find any number in dp[0..ans) that is >= num, it means we // can append num in the current increasing subsequence if ( l == ans ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int lengthOfLIS ( int [] nums ) { int ans = 0 ; // dp[i] := the minimum tail of all increasing subseqs with length i + 1 // it's easy to see that dp must be an increasing array int [] dp = new int [ nums . length ] ; for ( final int num : nums ) { // find the first index i in dp[0..ans) s.t. dp[i] >= num int i = Arrays . binarySearch ( dp , 0 , ans , num ); // i = -(insertion point) - 1 // insertion point = -(i + 1) if ( i < 0 ) i = - ( i + 1 ); dp [ i ] = num ; // if didn't find any number in dp[0..ans) that is >= num, it means we // can append num in the current increasing subsequence if ( i == ans ) ++ ans ; } return ans ; } }","title":"Approach 2: Binary Search"},{"location":"problems/0301/","text":"301. Remove Invalid Parentheses Time: $O(2^n)$ Space: $O(n + |ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public : vector < string > removeInvalidParentheses ( string s ) { vector < string > ans ; const auto [ l , r ] = getLeftAndRightCounts ( s ); dfs ( s , 0 , l , r , ans ); return ans ; } private : // return how many '(' and ')' need to be deleted pair < int , int > getLeftAndRightCounts ( const string & s ) { int l = 0 ; int r = 0 ; for ( const char c : s ) if ( c == '(' ) ++ l ; else if ( c == ' ) ' ) { if ( l == 0 ) ++ r ; else -- l ; } return { l , r }; } void dfs ( const string & s , int start , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . push_back ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s [ i ] == s [ i - 1 ]) continue ; if ( l > 0 && s [ i ] == '(' ) // delete s[i] dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l - 1 , r , ans ); if ( r > 0 && s [ i ] == ')' ) // delete s[i] dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l , r - 1 , ans ); } } bool isValid ( const string & s ) { int count = 0 ; // # of '(' - # of ')' for ( const char c : s ) { if ( c == '(' ) ++ count ; else if ( c == ' ) ' ) -- count ; if ( count < 0 ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public List < String > removeInvalidParentheses ( String s ) { List < String > ans = new ArrayList <> (); final int [] counts = getLeftAndRightCounts ( s ); dfs ( s , 0 , counts [ 0 ] , counts [ 1 ] , ans ); return ans ; } private void dfs ( final String s , int start , int l , int r , List < String > ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . add ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s . charAt ( i ) == s . charAt ( i - 1 )) continue ; if ( l > 0 && s . charAt ( i ) == '(' ) // delete s[i] dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l - 1 , r , ans ); else if ( r > 0 && s . charAt ( i ) == ')' ) // delete s[i] dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l , r - 1 , ans ); } } // return how many '(' and ')' need to be deleted private int [] getLeftAndRightCounts ( final String s ) { int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ()) if ( c == '(' ) ++ l ; else if ( c == ')' ) { if ( l == 0 ) ++ r ; else -- l ; } return new int [] { l , r }; } private boolean isValid ( final String s ) { int count = 0 ; // # of '(' - # of ')' for ( final char c : s . toCharArray ()) { if ( c == '(' ) ++ count ; else if ( c == ')' ) -- count ; if ( count < 0 ) return false ; } return true ; // count == 0 } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ]: def isValid ( s : str ): count = 0 for c in s : if c == '(' : count += 1 elif c == ')' : count -= 1 if count < 0 : return False return True def dfs ( s : str , start : int , l : int , r : int ) -> None : if l == 0 and r == 0 and isValid ( s ): ans . append ( s ) return for i in range ( start , len ( s )): if i > start and s [ i ] == s [ i - 1 ]: continue if r > 0 and s [ i ] == ')' : dfs ( s [: i ] + s [ i + 1 :], i , l , r - 1 ) elif l > 0 and s [ i ] == '(' : dfs ( s [: i ] + s [ i + 1 :], i , l - 1 , r ) ans = [] l = 0 r = 0 for c in s : if c == '(' : l += 1 elif c == ')' : if l == 0 : r += 1 else : l -= 1 dfs ( s , 0 , l , r ) return ans","title":"301. Remove Invalid Parentheses"},{"location":"problems/0301/#301-remove-invalid-parentheses","text":"Time: $O(2^n)$ Space: $O(n + |ans|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solution { public : vector < string > removeInvalidParentheses ( string s ) { vector < string > ans ; const auto [ l , r ] = getLeftAndRightCounts ( s ); dfs ( s , 0 , l , r , ans ); return ans ; } private : // return how many '(' and ')' need to be deleted pair < int , int > getLeftAndRightCounts ( const string & s ) { int l = 0 ; int r = 0 ; for ( const char c : s ) if ( c == '(' ) ++ l ; else if ( c == ' ) ' ) { if ( l == 0 ) ++ r ; else -- l ; } return { l , r }; } void dfs ( const string & s , int start , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . push_back ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s [ i ] == s [ i - 1 ]) continue ; if ( l > 0 && s [ i ] == '(' ) // delete s[i] dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l - 1 , r , ans ); if ( r > 0 && s [ i ] == ')' ) // delete s[i] dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l , r - 1 , ans ); } } bool isValid ( const string & s ) { int count = 0 ; // # of '(' - # of ')' for ( const char c : s ) { if ( c == '(' ) ++ count ; else if ( c == ' ) ' ) -- count ; if ( count < 0 ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public List < String > removeInvalidParentheses ( String s ) { List < String > ans = new ArrayList <> (); final int [] counts = getLeftAndRightCounts ( s ); dfs ( s , 0 , counts [ 0 ] , counts [ 1 ] , ans ); return ans ; } private void dfs ( final String s , int start , int l , int r , List < String > ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . add ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s . charAt ( i ) == s . charAt ( i - 1 )) continue ; if ( l > 0 && s . charAt ( i ) == '(' ) // delete s[i] dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l - 1 , r , ans ); else if ( r > 0 && s . charAt ( i ) == ')' ) // delete s[i] dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l , r - 1 , ans ); } } // return how many '(' and ')' need to be deleted private int [] getLeftAndRightCounts ( final String s ) { int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ()) if ( c == '(' ) ++ l ; else if ( c == ')' ) { if ( l == 0 ) ++ r ; else -- l ; } return new int [] { l , r }; } private boolean isValid ( final String s ) { int count = 0 ; // # of '(' - # of ')' for ( final char c : s . toCharArray ()) { if ( c == '(' ) ++ count ; else if ( c == ')' ) -- count ; if ( count < 0 ) return false ; } return true ; // count == 0 } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ]: def isValid ( s : str ): count = 0 for c in s : if c == '(' : count += 1 elif c == ')' : count -= 1 if count < 0 : return False return True def dfs ( s : str , start : int , l : int , r : int ) -> None : if l == 0 and r == 0 and isValid ( s ): ans . append ( s ) return for i in range ( start , len ( s )): if i > start and s [ i ] == s [ i - 1 ]: continue if r > 0 and s [ i ] == ')' : dfs ( s [: i ] + s [ i + 1 :], i , l , r - 1 ) elif l > 0 and s [ i ] == '(' : dfs ( s [: i ] + s [ i + 1 :], i , l - 1 , r ) ans = [] l = 0 r = 0 for c in s : if c == '(' : l += 1 elif c == ')' : if l == 0 : r += 1 else : l -= 1 dfs ( s , 0 , l , r ) return ans","title":"301. Remove Invalid Parentheses"},{"location":"problems/0302/","text":"302. Smallest Rectangle Enclosing Black Pixels \ud83d\udd12","title":"302. Smallest Rectangle Enclosing Black Pixels"},{"location":"problems/0302/#302-smallest-rectangle-enclosing-black-pixels","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels \ud83d\udd12"},{"location":"problems/0303/","text":"303. Range Sum Query - Immutable Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NumArray { public : NumArray ( vector < int >& nums ) : prefixSum ( nums . size () + 1 ) { for ( int i = 1 ; i <= nums . size (); ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; } int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ]; } private : vector < int > prefixSum ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class NumArray { public NumArray ( int [] nums ) { prefixSum = new int [ nums . length + 1 ] ; for ( int i = 1 ; i <= nums . length ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; } public int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ] ; } private int [] prefixSum ; }","title":"303. Range Sum Query - Immutable"},{"location":"problems/0303/#303-range-sum-query-immutable","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NumArray { public : NumArray ( vector < int >& nums ) : prefixSum ( nums . size () + 1 ) { for ( int i = 1 ; i <= nums . size (); ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; } int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ]; } private : vector < int > prefixSum ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class NumArray { public NumArray ( int [] nums ) { prefixSum = new int [ nums . length + 1 ] ; for ( int i = 1 ; i <= nums . length ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; } public int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ] ; } private int [] prefixSum ; }","title":"303. Range Sum Query - Immutable"},{"location":"problems/0304/","text":"304. Range Sum Query 2D - Immutable Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); prefixSum = vector < vector < int >> ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ]; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] + prefixSum [ row1 ][ col1 ]; } private : vector < vector < int >> prefixSum ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class NumMatrix { public NumMatrix ( int [][] matrix ) { if ( matrix . length == 0 ) return ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ] ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] + prefixSum [ row1 ][ col1 ] ; } private int [][] prefixSum ; }","title":"304. Range Sum Query 2D - Immutable"},{"location":"problems/0304/#304-range-sum-query-2d-immutable","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); prefixSum = vector < vector < int >> ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ]; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] + prefixSum [ row1 ][ col1 ]; } private : vector < vector < int >> prefixSum ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class NumMatrix { public NumMatrix ( int [][] matrix ) { if ( matrix . length == 0 ) return ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = matrix [ i - 1 ][ j - 1 ] + prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ] ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] + prefixSum [ row1 ][ col1 ] ; } private int [][] prefixSum ; }","title":"304. Range Sum Query 2D - Immutable"},{"location":"problems/0305/","text":"305. Number of Islands II \ud83d\udd12 Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class UF { public : vector < int > rank ; vector < int > parent ; UF ( int n ) : rank ( n ), parent ( n , -1 ) {} void union_ ( int pu , int pv ) { if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) u = find ( parent [ u ]); return parent [ u ]; } }; class Solution { public : vector < int > numIslands2 ( int m , int n , vector < vector < int >>& positions ) { const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < int > ans ; vector < vector < bool >> seen ( m , vector < bool > ( n )); UF uf ( m * n ); int count = 0 ; for ( const vector < int >& p : positions ) { const int i = p [ 0 ]; const int j = p [ 1 ]; if ( seen [ i ][ j ]) { ans . push_back ( count ); continue ; } seen [ i ][ j ] = true ; const int id = getId ( i , j , n ); uf . parent [ id ] = id ; ++ uf . rank [ id ]; ++ count ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; const int neighborId = getId ( x , y , n ); if ( uf . parent [ neighborId ] == -1 ) // water continue ; const int currentParent = uf . find ( id ); const int neighborParent = uf . find ( neighborId ); if ( currentParent != neighborParent ) { uf . union_ ( currentParent , neighborParent ); -- count ; } } ans . push_back ( count ); } return ans ; } private : int getId ( int i , int j , int n ) { return i * n + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class UF { public int [] rank ; public int [] parent ; public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; Arrays . fill ( parent , - 1 ); // water } public void union ( int pu , int pv ) { if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) u = find ( parent [ u ] ); return parent [ u ] ; } } class Solution { public List < Integer > numIslands2 ( int m , int n , int [][] positions ) { final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; List < Integer > ans = new ArrayList <> (); boolean [][] seen = new boolean [ m ][ n ] ; UF uf = new UF ( m * n ); int count = 0 ; for ( final int [] p : positions ) { final int i = p [ 0 ] ; final int j = p [ 1 ] ; if ( seen [ i ][ j ] ) { ans . add ( count ); continue ; } seen [ i ][ j ] = true ; final int id = getId ( i , j , n ); uf . parent [ id ] = id ; ++ uf . rank [ id ] ; ++ count ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; final int neighborId = getId ( x , y , n ); if ( uf . parent [ neighborId ] == - 1 ) // water continue ; final int currentParent = uf . find ( id ); final int neighborParent = uf . find ( neighborId ); if ( currentParent != neighborParent ) { uf . union ( currentParent , neighborParent ); -- count ; } } ans . add ( count ); } return ans ; } private int getId ( int i , int j , int n ) { return i * n + j ; } }","title":"305. Number of Islands II"},{"location":"problems/0305/#305-number-of-islands-ii","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class UF { public : vector < int > rank ; vector < int > parent ; UF ( int n ) : rank ( n ), parent ( n , -1 ) {} void union_ ( int pu , int pv ) { if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) u = find ( parent [ u ]); return parent [ u ]; } }; class Solution { public : vector < int > numIslands2 ( int m , int n , vector < vector < int >>& positions ) { const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < int > ans ; vector < vector < bool >> seen ( m , vector < bool > ( n )); UF uf ( m * n ); int count = 0 ; for ( const vector < int >& p : positions ) { const int i = p [ 0 ]; const int j = p [ 1 ]; if ( seen [ i ][ j ]) { ans . push_back ( count ); continue ; } seen [ i ][ j ] = true ; const int id = getId ( i , j , n ); uf . parent [ id ] = id ; ++ uf . rank [ id ]; ++ count ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; const int neighborId = getId ( x , y , n ); if ( uf . parent [ neighborId ] == -1 ) // water continue ; const int currentParent = uf . find ( id ); const int neighborParent = uf . find ( neighborId ); if ( currentParent != neighborParent ) { uf . union_ ( currentParent , neighborParent ); -- count ; } } ans . push_back ( count ); } return ans ; } private : int getId ( int i , int j , int n ) { return i * n + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class UF { public int [] rank ; public int [] parent ; public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; Arrays . fill ( parent , - 1 ); // water } public void union ( int pu , int pv ) { if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) u = find ( parent [ u ] ); return parent [ u ] ; } } class Solution { public List < Integer > numIslands2 ( int m , int n , int [][] positions ) { final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; List < Integer > ans = new ArrayList <> (); boolean [][] seen = new boolean [ m ][ n ] ; UF uf = new UF ( m * n ); int count = 0 ; for ( final int [] p : positions ) { final int i = p [ 0 ] ; final int j = p [ 1 ] ; if ( seen [ i ][ j ] ) { ans . add ( count ); continue ; } seen [ i ][ j ] = true ; final int id = getId ( i , j , n ); uf . parent [ id ] = id ; ++ uf . rank [ id ] ; ++ count ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; final int neighborId = getId ( x , y , n ); if ( uf . parent [ neighborId ] == - 1 ) // water continue ; final int currentParent = uf . find ( id ); final int neighborParent = uf . find ( neighborId ); if ( currentParent != neighborParent ) { uf . union ( currentParent , neighborParent ); -- count ; } } ans . add ( count ); } return ans ; } private int getId ( int i , int j , int n ) { return i * n + j ; } }","title":"305. Number of Islands II \ud83d\udd12"},{"location":"problems/0306/","text":"306. Additive Number Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isAdditiveNumber ( string num ) { const int n = num . length (); function < bool ( long , long , long ) > dfs = [ & ]( long firstNum , long secondNum , long s ) { if ( s == n ) return true ; const long thirdNum = firstNum + secondNum ; const string thirdNumStr = to_string ( thirdNum ); return num . find ( thirdNumStr , s ) == s && dfs ( secondNum , thirdNum , s + thirdNumStr . length ()); }; // num[0..i] = firstNum for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( i > 0 && num [ 0 ] == '0' ) return false ; const long firstNum = stol ( num . substr ( 0 , i + 1 )); // num[i + 1..j] = secondNum // len(thirdNum) >= max(len(firstNum), len(secondNum)) for ( int j = i + 1 ; max ( i , j - i ) < n - j ; ++ j ) { if ( j > i + 1 && num [ i + 1 ] == '0' ) break ; const long secondNum = stol ( num . substr ( i + 1 , j - i )); if ( dfs ( firstNum , secondNum , j + 1 )) return true ; } } return false ; } };","title":"306. Additive Number"},{"location":"problems/0306/#306-additive-number","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isAdditiveNumber ( string num ) { const int n = num . length (); function < bool ( long , long , long ) > dfs = [ & ]( long firstNum , long secondNum , long s ) { if ( s == n ) return true ; const long thirdNum = firstNum + secondNum ; const string thirdNumStr = to_string ( thirdNum ); return num . find ( thirdNumStr , s ) == s && dfs ( secondNum , thirdNum , s + thirdNumStr . length ()); }; // num[0..i] = firstNum for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( i > 0 && num [ 0 ] == '0' ) return false ; const long firstNum = stol ( num . substr ( 0 , i + 1 )); // num[i + 1..j] = secondNum // len(thirdNum) >= max(len(firstNum), len(secondNum)) for ( int j = i + 1 ; max ( i , j - i ) < n - j ; ++ j ) { if ( j > i + 1 && num [ i + 1 ] == '0' ) break ; const long secondNum = stol ( num . substr ( i + 1 , j - i )); if ( dfs ( firstNum , secondNum , j + 1 )) return true ; } } return false ; } };","title":"306. Additive Number"},{"location":"problems/0307/","text":"307. Range Sum Query - Mutable Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class NumArray { public : NumArray ( vector < int >& nums ) : nums ( nums ), tree ( nums . size ()) { for ( int i = 0 ; i < nums . size (); ++ i ) tree . update ( i + 1 , nums [ i ]); } void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ]); nums [ i ] = val ; } int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private : vector < int > nums ; FenwickTree tree ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class NumArray { public NumArray ( int [] nums ) { this . nums = nums ; tree = new FenwickTree ( nums . length ); for ( int i = 0 ; i < nums . length ; ++ i ) tree . update ( i + 1 , nums [ i ] ); } public void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ] ); nums [ i ] = val ; } public int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private int [] nums ; private FenwickTree tree ; } class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += i & - i ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= i & - i ; } return sum ; } private int [] sums ; }","title":"307. Range Sum Query - Mutable"},{"location":"problems/0307/#307-range-sum-query-mutable","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class NumArray { public : NumArray ( vector < int >& nums ) : nums ( nums ), tree ( nums . size ()) { for ( int i = 0 ; i < nums . size (); ++ i ) tree . update ( i + 1 , nums [ i ]); } void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ]); nums [ i ] = val ; } int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private : vector < int > nums ; FenwickTree tree ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class NumArray { public NumArray ( int [] nums ) { this . nums = nums ; tree = new FenwickTree ( nums . length ); for ( int i = 0 ; i < nums . length ; ++ i ) tree . update ( i + 1 , nums [ i ] ); } public void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ] ); nums [ i ] = val ; } public int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private int [] nums ; private FenwickTree tree ; } class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += i & - i ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= i & - i ; } return sum ; } private int [] sums ; }","title":"307. Range Sum Query - Mutable"},{"location":"problems/0308/","text":"308. Range Sum Query 2D - Mutable \ud83d\udd12 Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class FenwickTree { public : FenwickTree () {} FenwickTree ( int m , int n ) : sums ( m + 1 , vector < int > ( n + 1 )) {} void update ( int row , int col , int delta ) { for ( int i = row ; i < sums . size (); i += i & - i ) for ( int j = col ; j < sums [ 0 ]. size (); j += j & - j ) sums [ i ][ j ] += delta ; } int get ( int row , int col ) { int sum = 0 ; for ( int i = row ; i > 0 ; i -= i & - i ) for ( int j = col ; j > 0 ; j -= j & - j ) sum += sums [ i ][ j ]; return sum ; } private : vector < vector < int >> sums ; }; class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) : matrix ( matrix ) { if ( matrix . empty ()) return ; tree = FenwickTree ( matrix . size (), matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) tree . update ( i + 1 , j + 1 , matrix [ i ][ j ]); } void update ( int row , int col , int val ) { tree . update ( row + 1 , col + 1 , val - matrix [ row ][ col ]); matrix [ row ][ col ] = val ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return tree . get ( row2 + 1 , col2 + 1 ) - tree . get ( row1 , col2 + 1 ) - tree . get ( row2 + 1 , col1 ) + tree . get ( row1 , col1 ); } private : vector < vector < int >> matrix ; FenwickTree tree ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class NumMatrix { public NumMatrix ( int [][] matrix ) { if ( matrix . length == 0 ) return ; this . matrix = matrix ; tree = new FenwickTree ( matrix . length , matrix [ 0 ] . length ); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) tree . update ( i + 1 , j + 1 , matrix [ i ][ j ] ); } public void update ( int row , int col , int val ) { tree . update ( row + 1 , col + 1 , val - matrix [ row ][ col ] ); matrix [ row ][ col ] = val ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return tree . get ( row2 + 1 , col2 + 1 ) - tree . get ( row1 , col2 + 1 ) - tree . get ( row2 + 1 , col1 ) + tree . get ( row1 , col1 ); } private int [][] matrix ; private FenwickTree tree ; } class FenwickTree { public FenwickTree ( int m , int n ) { sums = new int [ m + 1 ][ n + 1 ] ; } public void update ( int row , int col , int delta ) { for ( int i = row ; i < sums . length ; i += i & - i ) for ( int j = col ; j < sums [ 0 ] . length ; j += j & - j ) sums [ i ][ j ] += delta ; } public int get ( int row , int col ) { int sum = 0 ; for ( int i = row ; i > 0 ; i -= i & - i ) for ( int j = col ; j > 0 ; j -= j & - j ) sum += sums [ i ][ j ] ; return sum ; } private int [][] sums ; }","title":"308. Range Sum Query 2D - Mutable"},{"location":"problems/0308/#308-range-sum-query-2d-mutable","text":"Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class FenwickTree { public : FenwickTree () {} FenwickTree ( int m , int n ) : sums ( m + 1 , vector < int > ( n + 1 )) {} void update ( int row , int col , int delta ) { for ( int i = row ; i < sums . size (); i += i & - i ) for ( int j = col ; j < sums [ 0 ]. size (); j += j & - j ) sums [ i ][ j ] += delta ; } int get ( int row , int col ) { int sum = 0 ; for ( int i = row ; i > 0 ; i -= i & - i ) for ( int j = col ; j > 0 ; j -= j & - j ) sum += sums [ i ][ j ]; return sum ; } private : vector < vector < int >> sums ; }; class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) : matrix ( matrix ) { if ( matrix . empty ()) return ; tree = FenwickTree ( matrix . size (), matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) tree . update ( i + 1 , j + 1 , matrix [ i ][ j ]); } void update ( int row , int col , int val ) { tree . update ( row + 1 , col + 1 , val - matrix [ row ][ col ]); matrix [ row ][ col ] = val ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return tree . get ( row2 + 1 , col2 + 1 ) - tree . get ( row1 , col2 + 1 ) - tree . get ( row2 + 1 , col1 ) + tree . get ( row1 , col1 ); } private : vector < vector < int >> matrix ; FenwickTree tree ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class NumMatrix { public NumMatrix ( int [][] matrix ) { if ( matrix . length == 0 ) return ; this . matrix = matrix ; tree = new FenwickTree ( matrix . length , matrix [ 0 ] . length ); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) tree . update ( i + 1 , j + 1 , matrix [ i ][ j ] ); } public void update ( int row , int col , int val ) { tree . update ( row + 1 , col + 1 , val - matrix [ row ][ col ] ); matrix [ row ][ col ] = val ; } public int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return tree . get ( row2 + 1 , col2 + 1 ) - tree . get ( row1 , col2 + 1 ) - tree . get ( row2 + 1 , col1 ) + tree . get ( row1 , col1 ); } private int [][] matrix ; private FenwickTree tree ; } class FenwickTree { public FenwickTree ( int m , int n ) { sums = new int [ m + 1 ][ n + 1 ] ; } public void update ( int row , int col , int delta ) { for ( int i = row ; i < sums . length ; i += i & - i ) for ( int j = col ; j < sums [ 0 ] . length ; j += j & - j ) sums [ i ][ j ] += delta ; } public int get ( int row , int col ) { int sum = 0 ; for ( int i = row ; i > 0 ; i -= i & - i ) for ( int j = col ; j > 0 ; j -= j & - j ) sum += sums [ i ][ j ] ; return sum ; } private int [][] sums ; }","title":"308. Range Sum Query 2D - Mutable \ud83d\udd12"},{"location":"problems/0309/","text":"309. Best Time to Buy and Sell Stock with Cooldown Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( const int price : prices ) { const int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( final int price : prices ) { final int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell","title":"309. Best Time to Buy and Sell Stock with Cooldown"},{"location":"problems/0309/#309-best-time-to-buy-and-sell-stock-with-cooldown","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( const int price : prices ) { const int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( final int price : prices ) { final int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell","title":"309. Best Time to Buy and Sell Stock with Cooldown"},{"location":"problems/0310/","text":"310. Minimum Height Trees Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { if ( n == 1 ) return { 0 }; vector < int > ans ; unordered_map < int , unordered_set < int >> graph ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. insert ( edge [ 1 ]); graph [ edge [ 1 ]]. insert ( edge [ 0 ]); } for ( const auto & [ label , neighbors ] : graph ) if ( neighbors . size () == 1 ) ans . push_back ( label ); while ( n > 2 ) { n -= ans . size (); vector < int > nextLeaves ; for ( int leaf : ans ) { const int j = * begin ( graph [ leaf ]); graph [ j ]. erase ( leaf ); if ( graph [ j ]. size () == 1 ) nextLeaves . push_back ( j ); } ans = nextLeaves ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public List < Integer > findMinHeightTrees ( int n , int [][] edges ) { if ( n == 0 ) return new ArrayList <> ( Arrays . asList ( 0 )); List < Integer > ans = new ArrayList <> (); Map < Integer , Set < Integer >> graph = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) graph . put ( i , new HashSet <> ()); for ( final int [] edge : edges ) { graph . get ( edge [ 0 ] ). add ( edge [ 1 ] ); graph . get ( edge [ 1 ] ). add ( edge [ 0 ] ); } for ( Map . Entry < Integer , Set < Integer >> entry : graph . entrySet ()) { final int label = entry . getKey (); final Set < Integer > neighbors = entry . getValue (); if ( neighbors . size () == 1 ) ans . add ( label ); } while ( n > 2 ) { n -= ans . size (); List < Integer > nextLeaves = new ArrayList <> (); for ( final int leaf : ans ) { final int j = ( int ) graph . get ( leaf ). iterator (). next (); graph . get ( j ). remove ( leaf ); if ( graph . get ( j ). size () == 1 ) nextLeaves . add ( j ); } ans = nextLeaves ; } return ans ; } }","title":"310. Minimum Height Trees"},{"location":"problems/0310/#310-minimum-height-trees","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { if ( n == 1 ) return { 0 }; vector < int > ans ; unordered_map < int , unordered_set < int >> graph ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. insert ( edge [ 1 ]); graph [ edge [ 1 ]]. insert ( edge [ 0 ]); } for ( const auto & [ label , neighbors ] : graph ) if ( neighbors . size () == 1 ) ans . push_back ( label ); while ( n > 2 ) { n -= ans . size (); vector < int > nextLeaves ; for ( int leaf : ans ) { const int j = * begin ( graph [ leaf ]); graph [ j ]. erase ( leaf ); if ( graph [ j ]. size () == 1 ) nextLeaves . push_back ( j ); } ans = nextLeaves ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public List < Integer > findMinHeightTrees ( int n , int [][] edges ) { if ( n == 0 ) return new ArrayList <> ( Arrays . asList ( 0 )); List < Integer > ans = new ArrayList <> (); Map < Integer , Set < Integer >> graph = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) graph . put ( i , new HashSet <> ()); for ( final int [] edge : edges ) { graph . get ( edge [ 0 ] ). add ( edge [ 1 ] ); graph . get ( edge [ 1 ] ). add ( edge [ 0 ] ); } for ( Map . Entry < Integer , Set < Integer >> entry : graph . entrySet ()) { final int label = entry . getKey (); final Set < Integer > neighbors = entry . getValue (); if ( neighbors . size () == 1 ) ans . add ( label ); } while ( n > 2 ) { n -= ans . size (); List < Integer > nextLeaves = new ArrayList <> (); for ( final int leaf : ans ) { final int j = ( int ) graph . get ( leaf ). iterator (). next (); graph . get ( j ). remove ( leaf ); if ( graph . get ( j ). size () == 1 ) nextLeaves . add ( j ); } ans = nextLeaves ; } return ans ; } }","title":"310. Minimum Height Trees"},{"location":"problems/0311/","text":"311. Sparse Matrix Multiplication \ud83d\udd12 Approach 1: Brute force Time: $O(lmn)$ Space: $O(ln)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> multiply ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int l = A . size (); const int m = B . size (); const int n = B [ 0 ]. size (); vector < vector < int >> ans ( l , vector < int > ( n )); for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int k = 0 ; k < m ; ++ k ) ans [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [][] multiply ( int [][] A , int [][] B ) { final int l = A . length ; final int m = B . length ; final int n = B [ 0 ] . length ; int [][] ans = new int [ l ][ n ] ; for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int k = 0 ; k < m ; ++ k ) ans [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ] ; return ans ; } } Approach 2: Look up Time: $O(mn + lm \\times \\text{nonZero}(B))$ Space: $O(ln + \\text{nonZero}(B))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> multiply ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int l = A . size (); const int m = B . size (); const int n = B [ 0 ]. size (); vector < vector < int >> ans ( l , vector < int > ( n )); vector < vector < int >> nonZeroColIndicesInB ; for ( int i = 0 ; i < m ; ++ i ) { vector < int > colIndices ; for ( int j = 0 ; j < n ; ++ j ) if ( B [ i ][ j ] != 0 ) colIndices . push_back ( j ); nonZeroColIndicesInB . push_back ( colIndices ); } for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { if ( A [ i ][ j ] == 0 ) continue ; for ( const int colIndex : nonZeroColIndicesInB [ j ]) ans [ i ][ colIndex ] += A [ i ][ j ] * B [ j ][ colIndex ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] multiply ( int [][] A , int [][] B ) { final int l = A . length ; final int m = B . length ; final int n = B [ 0 ] . length ; int [][] ans = new int [ l ][ n ] ; List < Integer >[] nonZeroColIndicesInB = new List [ m ] ; for ( int i = 0 ; i < m ; ++ i ) { List < Integer > colIndices = new ArrayList <> (); for ( int j = 0 ; j < n ; ++ j ) if ( B [ i ][ j ] != 0 ) colIndices . add ( j ); nonZeroColIndicesInB [ i ] = colIndices ; } for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { if ( A [ i ][ j ] == 0 ) continue ; for ( final int colIndex : nonZeroColIndicesInB [ j ] ) ans [ i ][ colIndex ] += A [ i ][ j ] * B [ j ][ colIndex ] ; } return ans ; } }","title":"311. Sparse Matrix Multiplication"},{"location":"problems/0311/#311-sparse-matrix-multiplication","text":"","title":"311. Sparse Matrix Multiplication \ud83d\udd12"},{"location":"problems/0311/#approach-1-brute-force","text":"Time: $O(lmn)$ Space: $O(ln)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> multiply ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int l = A . size (); const int m = B . size (); const int n = B [ 0 ]. size (); vector < vector < int >> ans ( l , vector < int > ( n )); for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int k = 0 ; k < m ; ++ k ) ans [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [][] multiply ( int [][] A , int [][] B ) { final int l = A . length ; final int m = B . length ; final int n = B [ 0 ] . length ; int [][] ans = new int [ l ][ n ] ; for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int k = 0 ; k < m ; ++ k ) ans [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ] ; return ans ; } }","title":"Approach 1: Brute force"},{"location":"problems/0311/#approach-2-look-up","text":"Time: $O(mn + lm \\times \\text{nonZero}(B))$ Space: $O(ln + \\text{nonZero}(B))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> multiply ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int l = A . size (); const int m = B . size (); const int n = B [ 0 ]. size (); vector < vector < int >> ans ( l , vector < int > ( n )); vector < vector < int >> nonZeroColIndicesInB ; for ( int i = 0 ; i < m ; ++ i ) { vector < int > colIndices ; for ( int j = 0 ; j < n ; ++ j ) if ( B [ i ][ j ] != 0 ) colIndices . push_back ( j ); nonZeroColIndicesInB . push_back ( colIndices ); } for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { if ( A [ i ][ j ] == 0 ) continue ; for ( const int colIndex : nonZeroColIndicesInB [ j ]) ans [ i ][ colIndex ] += A [ i ][ j ] * B [ j ][ colIndex ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] multiply ( int [][] A , int [][] B ) { final int l = A . length ; final int m = B . length ; final int n = B [ 0 ] . length ; int [][] ans = new int [ l ][ n ] ; List < Integer >[] nonZeroColIndicesInB = new List [ m ] ; for ( int i = 0 ; i < m ; ++ i ) { List < Integer > colIndices = new ArrayList <> (); for ( int j = 0 ; j < n ; ++ j ) if ( B [ i ][ j ] != 0 ) colIndices . add ( j ); nonZeroColIndicesInB [ i ] = colIndices ; } for ( int i = 0 ; i < l ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) { if ( A [ i ][ j ] == 0 ) continue ; for ( final int colIndex : nonZeroColIndicesInB [ j ] ) ans [ i ][ colIndex ] += A [ i ][ j ] * B [ j ][ colIndex ] ; } return ans ; } }","title":"Approach 2: Look up"},{"location":"problems/0312/","text":"312. Burst Balloons Approach 1: Bottom-up Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); // dp[i][j] := maxCoins(nums[i..j]) vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]); } return dp [ 1 ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int maxCoins ( int [] nums ) { final int n = nums . length ; int [] A = new int [ n + 2 ] ; System . arraycopy ( nums , 0 , A , 1 , n ); A [ 0 ] = 1 ; A [ n + 1 ] = 1 ; // dp[i][j] := maxCoins(A[i..j]) int [][] dp = new int [ n + 2 ][ n + 2 ] ; for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { final int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ] + A [ i - 1 ] * A [ k ] * A [ j + 1 ] ); } return dp [ 1 ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxCoins ( self , nums : List [ int ]) -> int : n = len ( nums ) nums = [ 1 ] + nums + [ 1 ] dp = [[ 0 ] * ( n + 2 ) for _ in range ( n + 2 )] for length in range ( 1 , n + 1 ): for i in range ( 1 , n - length + 2 ): j = i + length - 1 for k in range ( i , j + 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ] [ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]) return dp [ 1 ][ n ] Approach 2: Top-down Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); vector < vector < int >> memo ( n + 2 , vector < int > ( n + 2 )); function < int ( int , int ) > dp = [ & ]( int i , int j ) { if ( i > j ) return 0 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; for ( int k = i ; k <= j ; ++ k ) ans = max ( ans , dp ( i , k - 1 ) + dp ( k + 1 , j ) + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]); return ans ; }; return dp ( 1 , n ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int maxCoins ( int [] nums ) { final int n = nums . length ; A = new int [ n + 2 ] ; System . arraycopy ( nums , 0 , A , 1 , n ); A [ 0 ] = 1 ; A [ n + 1 ] = 1 ; memo = new int [ n + 2 ][ n + 2 ] ; return dp ( 1 , n ); } private int [] A ; private int [][] memo ; private int dp ( int i , int j ) { if ( i > j ) return 0 ; int ans = memo [ i ][ j ] ; if ( ans > 0 ) return ans ; for ( int k = i ; k <= j ; ++ k ) ans = Math . max ( ans , dp ( i , k - 1 ) + dp ( k + 1 , j ) + A [ i - 1 ] * A [ k ] * A [ j + 1 ] ); return memo [ i ][ j ] = ans ; } }","title":"312. Burst Balloons"},{"location":"problems/0312/#312-burst-balloons","text":"","title":"312. Burst Balloons"},{"location":"problems/0312/#approach-1-bottom-up","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); // dp[i][j] := maxCoins(nums[i..j]) vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]); } return dp [ 1 ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int maxCoins ( int [] nums ) { final int n = nums . length ; int [] A = new int [ n + 2 ] ; System . arraycopy ( nums , 0 , A , 1 , n ); A [ 0 ] = 1 ; A [ n + 1 ] = 1 ; // dp[i][j] := maxCoins(A[i..j]) int [][] dp = new int [ n + 2 ][ n + 2 ] ; for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { final int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i ][ k - 1 ] + dp [ k + 1 ][ j ] + A [ i - 1 ] * A [ k ] * A [ j + 1 ] ); } return dp [ 1 ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxCoins ( self , nums : List [ int ]) -> int : n = len ( nums ) nums = [ 1 ] + nums + [ 1 ] dp = [[ 0 ] * ( n + 2 ) for _ in range ( n + 2 )] for length in range ( 1 , n + 1 ): for i in range ( 1 , n - length + 2 ): j = i + length - 1 for k in range ( i , j + 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ] [ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]) return dp [ 1 ][ n ]","title":"Approach 1: Bottom-up"},{"location":"problems/0312/#approach-2-top-down","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); vector < vector < int >> memo ( n + 2 , vector < int > ( n + 2 )); function < int ( int , int ) > dp = [ & ]( int i , int j ) { if ( i > j ) return 0 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; for ( int k = i ; k <= j ; ++ k ) ans = max ( ans , dp ( i , k - 1 ) + dp ( k + 1 , j ) + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]); return ans ; }; return dp ( 1 , n ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int maxCoins ( int [] nums ) { final int n = nums . length ; A = new int [ n + 2 ] ; System . arraycopy ( nums , 0 , A , 1 , n ); A [ 0 ] = 1 ; A [ n + 1 ] = 1 ; memo = new int [ n + 2 ][ n + 2 ] ; return dp ( 1 , n ); } private int [] A ; private int [][] memo ; private int dp ( int i , int j ) { if ( i > j ) return 0 ; int ans = memo [ i ][ j ] ; if ( ans > 0 ) return ans ; for ( int k = i ; k <= j ; ++ k ) ans = Math . max ( ans , dp ( i , k - 1 ) + dp ( k + 1 , j ) + A [ i - 1 ] * A [ k ] * A [ j + 1 ] ); return memo [ i ][ j ] = ans ; } }","title":"Approach 2: Top-down"},{"location":"problems/0313/","text":"313. Super Ugly Number Approach 1: Similar to 264. Ugly Number II Time: $O(nk)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > indices ( k ); vector < int > uglyNums { 1 }; while ( uglyNums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = uglyNums [ indices [ i ]] * primes [ i ]; const int next = * min_element ( begin ( nexts ), end ( nexts )); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; uglyNums . push_back ( next ); } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { final int k = primes . length ; int [] indices = new int [ k ] ; int [] uglyNums = new int [ n ] ; uglyNums [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { int [] nexts = new int [ k ] ; for ( int j = 0 ; j < k ; ++ j ) nexts [ j ] = uglyNums [ indices [ j ]] * primes [ j ] ; final int next = Arrays . stream ( nexts ). min (). getAsInt (); for ( int j = 0 ; j < k ; ++ j ) if ( next == nexts [ j ] ) ++ indices [ j ] ; uglyNums [ i ] = next ; } return uglyNums [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ] Approach 2: Heap Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 struct UglyNum { int prime ; int index ; // point to the next index of uglyNums int value ; // prime * uglyNums[index] }; class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { auto compare = [ & ]( const UglyNum & a , const UglyNum & b ) { return a . value > b . value ; }; priority_queue < UglyNum , vector < UglyNum > , decltype ( compare ) > pq ( compare ); vector < int > uglyNums { 1 }; for ( const int prime : primes ) pq . push ({ prime , 1 , prime * uglyNums [ 0 ]}); while ( uglyNums . size () < n ) { uglyNums . push_back ( pq . top (). value ); while ( pq . top (). value == uglyNums . back ()) { const auto [ prime , index , value ] = pq . top (); pq . pop (); pq . push ({ prime , index + 1 , prime * uglyNums [ index ]}); } } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class UglyNum { public int prime ; public int index ; // point to the next index of uglyNums public int value ; // prime * uglyNums[index] public UglyNum ( int prime , int index , int value ) { this . prime = prime ; this . index = index ; this . value = value ; } } class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { PriorityQueue < UglyNum > pq = new PriorityQueue <> (( a , b ) -> a . value - b . value ); int [] uglyNums = new int [ n ] ; uglyNums [ 0 ] = 1 ; for ( final int prime : primes ) pq . offer ( new UglyNum ( prime , 1 , prime * uglyNums [ 0 ] )); for ( int i = 1 ; i < n ; ++ i ) { uglyNums [ i ] = pq . peek (). value ; while ( pq . peek (). value == uglyNums [ i ] ) { final UglyNum u = pq . poll (); pq . offer ( new UglyNum ( u . prime , u . index + 1 , u . prime * uglyNums [ u . index ] )); } } return uglyNums [ n - 1 ] ; } }","title":"313. Super Ugly Number"},{"location":"problems/0313/#313-super-ugly-number","text":"","title":"313. Super Ugly Number"},{"location":"problems/0313/#approach-1-similar-to-264-ugly-number-ii","text":"Time: $O(nk)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > indices ( k ); vector < int > uglyNums { 1 }; while ( uglyNums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = uglyNums [ indices [ i ]] * primes [ i ]; const int next = * min_element ( begin ( nexts ), end ( nexts )); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; uglyNums . push_back ( next ); } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { final int k = primes . length ; int [] indices = new int [ k ] ; int [] uglyNums = new int [ n ] ; uglyNums [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { int [] nexts = new int [ k ] ; for ( int j = 0 ; j < k ; ++ j ) nexts [ j ] = uglyNums [ indices [ j ]] * primes [ j ] ; final int next = Arrays . stream ( nexts ). min (). getAsInt (); for ( int j = 0 ; j < k ; ++ j ) if ( next == nexts [ j ] ) ++ indices [ j ] ; uglyNums [ i ] = next ; } return uglyNums [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ]","title":"Approach 1: Similar to 264. Ugly Number II"},{"location":"problems/0313/#approach-2-heap","text":"Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 struct UglyNum { int prime ; int index ; // point to the next index of uglyNums int value ; // prime * uglyNums[index] }; class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { auto compare = [ & ]( const UglyNum & a , const UglyNum & b ) { return a . value > b . value ; }; priority_queue < UglyNum , vector < UglyNum > , decltype ( compare ) > pq ( compare ); vector < int > uglyNums { 1 }; for ( const int prime : primes ) pq . push ({ prime , 1 , prime * uglyNums [ 0 ]}); while ( uglyNums . size () < n ) { uglyNums . push_back ( pq . top (). value ); while ( pq . top (). value == uglyNums . back ()) { const auto [ prime , index , value ] = pq . top (); pq . pop (); pq . push ({ prime , index + 1 , prime * uglyNums [ index ]}); } } return uglyNums . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class UglyNum { public int prime ; public int index ; // point to the next index of uglyNums public int value ; // prime * uglyNums[index] public UglyNum ( int prime , int index , int value ) { this . prime = prime ; this . index = index ; this . value = value ; } } class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { PriorityQueue < UglyNum > pq = new PriorityQueue <> (( a , b ) -> a . value - b . value ); int [] uglyNums = new int [ n ] ; uglyNums [ 0 ] = 1 ; for ( final int prime : primes ) pq . offer ( new UglyNum ( prime , 1 , prime * uglyNums [ 0 ] )); for ( int i = 1 ; i < n ; ++ i ) { uglyNums [ i ] = pq . peek (). value ; while ( pq . peek (). value == uglyNums [ i ] ) { final UglyNum u = pq . poll (); pq . offer ( new UglyNum ( u . prime , u . index + 1 , u . prime * uglyNums [ u . index ] )); } } return uglyNums [ n - 1 ] ; } }","title":"Approach 2: Heap"},{"location":"problems/0314/","text":"314. Binary Tree Vertical Order Traversal \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> verticalOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < int > range ( 2 ); getRange ( root , range , 0 ); // get the leftmost and rightmost column index vector < vector < int >> ans ( range [ 1 ] - range [ 0 ] + 1 ); queue < pair < TreeNode * , int >> q {{{ root , - range [ 0 ]}}}; // {TreeNode, colIndex} while ( ! q . empty ()) { const auto [ node , colIndex ] = q . front (); q . pop (); ans [ colIndex ]. push_back ( node -> val ); if ( node -> left ) q . push ({ node -> left , colIndex - 1 }); if ( node -> right ) q . push ({ node -> right , colIndex + 1 }); } return ans ; } private : void getRange ( TreeNode * root , vector < int >& range , int col ) { if ( ! root ) return ; range [ 0 ] = min ( range [ 0 ], col ); range [ 1 ] = max ( range [ 1 ], col ); getRange ( root -> left , range , col - 1 ); getRange ( root -> right , range , col + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public List < List < Integer >> verticalOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < Pair < TreeNode , Integer >> q = new LinkedList <> (); // {TreeNode, colIndex} int [] range = new int [ 2 ] ; getRange ( root , range , 0 ); // get the leftmost and rightmost column index q . offer ( new Pair <> ( root , - range [ 0 ] )); for ( int i = range [ 0 ] ; i <= range [ 1 ] ; ++ i ) ans . add ( new ArrayList <> ()); while ( ! q . isEmpty ()) { final TreeNode node = q . peek (). getKey (); final int colIndex = q . poll (). getValue (); ans . get ( colIndex ). add ( node . val ); if ( node . left != null ) q . offer ( new Pair <> ( node . left , colIndex - 1 )); if ( node . right != null ) q . offer ( new Pair <> ( node . right , colIndex + 1 )); } return ans ; } private void getRange ( TreeNode root , int [] range , int col ) { if ( root == null ) return ; range [ 0 ] = Math . min ( range [ 0 ] , col ); range [ 1 ] = Math . max ( range [ 1 ] , col ); getRange ( root . left , range , col - 1 ); getRange ( root . right , range , col + 1 ); } }","title":"314. Binary Tree Vertical Order Traversal"},{"location":"problems/0314/#314-binary-tree-vertical-order-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> verticalOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < int > range ( 2 ); getRange ( root , range , 0 ); // get the leftmost and rightmost column index vector < vector < int >> ans ( range [ 1 ] - range [ 0 ] + 1 ); queue < pair < TreeNode * , int >> q {{{ root , - range [ 0 ]}}}; // {TreeNode, colIndex} while ( ! q . empty ()) { const auto [ node , colIndex ] = q . front (); q . pop (); ans [ colIndex ]. push_back ( node -> val ); if ( node -> left ) q . push ({ node -> left , colIndex - 1 }); if ( node -> right ) q . push ({ node -> right , colIndex + 1 }); } return ans ; } private : void getRange ( TreeNode * root , vector < int >& range , int col ) { if ( ! root ) return ; range [ 0 ] = min ( range [ 0 ], col ); range [ 1 ] = max ( range [ 1 ], col ); getRange ( root -> left , range , col - 1 ); getRange ( root -> right , range , col + 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public List < List < Integer >> verticalOrder ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < Pair < TreeNode , Integer >> q = new LinkedList <> (); // {TreeNode, colIndex} int [] range = new int [ 2 ] ; getRange ( root , range , 0 ); // get the leftmost and rightmost column index q . offer ( new Pair <> ( root , - range [ 0 ] )); for ( int i = range [ 0 ] ; i <= range [ 1 ] ; ++ i ) ans . add ( new ArrayList <> ()); while ( ! q . isEmpty ()) { final TreeNode node = q . peek (). getKey (); final int colIndex = q . poll (). getValue (); ans . get ( colIndex ). add ( node . val ); if ( node . left != null ) q . offer ( new Pair <> ( node . left , colIndex - 1 )); if ( node . right != null ) q . offer ( new Pair <> ( node . right , colIndex + 1 )); } return ans ; } private void getRange ( TreeNode root , int [] range , int col ) { if ( root == null ) return ; range [ 0 ] = Math . min ( range [ 0 ] , col ); range [ 1 ] = Math . max ( range [ 1 ] , col ); getRange ( root . left , range , col - 1 ); getRange ( root . right , range , col + 1 ); } }","title":"314. Binary Tree Vertical Order Traversal \ud83d\udd12"},{"location":"problems/0315/","text":"315. Count of Smaller Numbers After Self Approach 1: Merge Sort Time: $O(n\\log |\\text{unique nums}|)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct Item { Item ( int num , int index ) : num ( num ), index ( index ) {} Item () : num ( 0 ), index ( 0 ) {} int num = 0 ; int index = 0 ; }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n ); vector < Item > items ( n ); for ( int i = 0 ; i < n ; ++ i ) items [ i ] = Item ( nums [ i ], i ); function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < Item > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; // # of nums < items[i].num while ( i <= m && j <= r ) if ( items [ i ]. num > items [ j ]. num ) { ++ rightCount ; sorted [ k ++ ] = items [ j ++ ]; } else { ans [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining left part to the sorted array while ( i <= m ) { ans [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = items [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( items ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n - 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Item { public int num ; public int index ; public Item ( int num , int index ) { this . num = num ; this . index = index ; } } class Solution { public List < Integer > countSmaller ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); int [] count = new int [ n ] ; Item [] items = new Item [ n ] ; for ( int i = 0 ; i < n ; ++ i ) items [ i ] = new Item ( nums [ i ] , i ); mergeSort ( items , 0 , n - 1 , count ); for ( final int c : count ) ans . add ( c ); return ans ; } private void mergeSort ( Item [] items , int l , int r , int [] count ) { if ( l >= r ) return ; final int m = l + ( r - l ) / 2 ; mergeSort ( items , l , m , count ); mergeSort ( items , m + 1 , r , count ); merge ( items , l , m , r , count ); } private void merge ( Item [] items , int l , int m , int r , int [] count ) { Item [] sorted = new Item [ r - l + 1 ] ; int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; // # of nums < items[i].num while ( i <= m && j <= r ) if ( items [ i ] . num > items [ j ] . num ) { ++ rightCount ; sorted [ k ++] = items [ j ++] ; } else { count [ items [ i ] . index ] += rightCount ; sorted [ k ++] = items [ i ++] ; } // put possible remaining left part to the sorted array while ( i <= m ) { count [ items [ i ] . index ] += rightCount ; sorted [ k ++] = items [ i ++] ; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++] = items [ j ++] ; System . arraycopy ( sorted , 0 , items , l , sorted . length ); } } Approach 2: BIT Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { vector < int > ans ; set < int > sorted ( begin ( nums ), end ( nums )); FenwickTree tree ( sorted . size ()); unordered_map < int , int > ranks ; // {num: rank} int rank = 0 ; for ( const int num : sorted ) ranks [ num ] = ++ rank ; reverse ( begin ( nums ), end ( nums )); for ( const int num : nums ) { ans . push_back ( tree . get ( ranks [ num ] - 1 )); tree . update ( ranks [ num ], 1 ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public List < Integer > countSmaller ( int [] nums ) { List < Integer > ans = new ArrayList <> (); SortedSet < Integer > sorted = new TreeSet <> (); Map < Integer , Integer > ranks = new HashMap <> (); // {num: rank} for ( final int num : nums ) sorted . add ( num ); FenwickTree tree = new FenwickTree ( sorted . size ()); int rank = 0 ; for ( Iterator < Integer > it = sorted . iterator (); it . hasNext ();) ranks . put ( it . next (), ++ rank ); for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { final int num = nums [ i ] ; ans . add ( tree . get ( ranks . get ( num ) - 1 )); tree . update ( ranks . get ( num ), 1 ); } Collections . reverse ( ans ); return ans ; } } class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += i & - i ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= i & - i ; } return sum ; } private int [] sums ; }","title":"315. Count of Smaller Numbers After Self"},{"location":"problems/0315/#315-count-of-smaller-numbers-after-self","text":"","title":"315. Count of Smaller Numbers After Self"},{"location":"problems/0315/#approach-1-merge-sort","text":"Time: $O(n\\log |\\text{unique nums}|)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 struct Item { Item ( int num , int index ) : num ( num ), index ( index ) {} Item () : num ( 0 ), index ( 0 ) {} int num = 0 ; int index = 0 ; }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ( n ); vector < Item > items ( n ); for ( int i = 0 ; i < n ; ++ i ) items [ i ] = Item ( nums [ i ], i ); function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < Item > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; // # of nums < items[i].num while ( i <= m && j <= r ) if ( items [ i ]. num > items [ j ]. num ) { ++ rightCount ; sorted [ k ++ ] = items [ j ++ ]; } else { ans [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining left part to the sorted array while ( i <= m ) { ans [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = items [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( items ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n - 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class Item { public int num ; public int index ; public Item ( int num , int index ) { this . num = num ; this . index = index ; } } class Solution { public List < Integer > countSmaller ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); int [] count = new int [ n ] ; Item [] items = new Item [ n ] ; for ( int i = 0 ; i < n ; ++ i ) items [ i ] = new Item ( nums [ i ] , i ); mergeSort ( items , 0 , n - 1 , count ); for ( final int c : count ) ans . add ( c ); return ans ; } private void mergeSort ( Item [] items , int l , int r , int [] count ) { if ( l >= r ) return ; final int m = l + ( r - l ) / 2 ; mergeSort ( items , l , m , count ); mergeSort ( items , m + 1 , r , count ); merge ( items , l , m , r , count ); } private void merge ( Item [] items , int l , int m , int r , int [] count ) { Item [] sorted = new Item [ r - l + 1 ] ; int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; // # of nums < items[i].num while ( i <= m && j <= r ) if ( items [ i ] . num > items [ j ] . num ) { ++ rightCount ; sorted [ k ++] = items [ j ++] ; } else { count [ items [ i ] . index ] += rightCount ; sorted [ k ++] = items [ i ++] ; } // put possible remaining left part to the sorted array while ( i <= m ) { count [ items [ i ] . index ] += rightCount ; sorted [ k ++] = items [ i ++] ; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++] = items [ j ++] ; System . arraycopy ( sorted , 0 , items , l , sorted . length ); } }","title":"Approach 1: Merge Sort"},{"location":"problems/0315/#approach-2-bit","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { vector < int > ans ; set < int > sorted ( begin ( nums ), end ( nums )); FenwickTree tree ( sorted . size ()); unordered_map < int , int > ranks ; // {num: rank} int rank = 0 ; for ( const int num : sorted ) ranks [ num ] = ++ rank ; reverse ( begin ( nums ), end ( nums )); for ( const int num : nums ) { ans . push_back ( tree . get ( ranks [ num ] - 1 )); tree . update ( ranks [ num ], 1 ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public List < Integer > countSmaller ( int [] nums ) { List < Integer > ans = new ArrayList <> (); SortedSet < Integer > sorted = new TreeSet <> (); Map < Integer , Integer > ranks = new HashMap <> (); // {num: rank} for ( final int num : nums ) sorted . add ( num ); FenwickTree tree = new FenwickTree ( sorted . size ()); int rank = 0 ; for ( Iterator < Integer > it = sorted . iterator (); it . hasNext ();) ranks . put ( it . next (), ++ rank ); for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { final int num = nums [ i ] ; ans . add ( tree . get ( ranks . get ( num ) - 1 )); tree . update ( ranks . get ( num ), 1 ); } Collections . reverse ( ans ); return ans ; } } class FenwickTree { public FenwickTree ( int n ) { sums = new int [ n + 1 ] ; } public void update ( int i , int delta ) { while ( i < sums . length ) { sums [ i ] += delta ; i += i & - i ; } } public int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ] ; i -= i & - i ; } return sum ; } private int [] sums ; }","title":"Approach 2: BIT"},{"location":"problems/0316/","text":"316. Remove Duplicate Letters Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string removeDuplicateLetters ( string s ) { string ans ; vector < int > count ( 128 ); vector < bool > used ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : s ) { -- count [ c ]; if ( used [ c ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back ()] > 0 ) { used [ ans . back ()] = false ; ans . pop_back (); } used [ c ] = true ; ans . push_back ( c ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String removeDuplicateLetters ( String s ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; boolean [] used = new boolean [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : s . toCharArray ()) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length () > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length () - 1 ); } used [ c ] = true ; sb . append ( c ); } return sb . toString (); } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def removeDuplicateLetters ( self , s : str ) -> str : ans = [] count = collections . Counter ( s ) used = [ False ] * 26 for c in s : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"316. Remove Duplicate Letters"},{"location":"problems/0316/#316-remove-duplicate-letters","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string removeDuplicateLetters ( string s ) { string ans ; vector < int > count ( 128 ); vector < bool > used ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : s ) { -- count [ c ]; if ( used [ c ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back ()] > 0 ) { used [ ans . back ()] = false ; ans . pop_back (); } used [ c ] = true ; ans . push_back ( c ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String removeDuplicateLetters ( String s ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; boolean [] used = new boolean [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : s . toCharArray ()) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length () > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length () - 1 ); } used [ c ] = true ; sb . append ( c ); } return sb . toString (); } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def removeDuplicateLetters ( self , s : str ) -> str : ans = [] count = collections . Counter ( s ) used = [ False ] * 26 for c in s : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"316. Remove Duplicate Letters"},{"location":"problems/0317/","text":"317. Shortest Distance from All Buildings \ud83d\udd12 Time: $O(m^2n^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public : int shortestDistance ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); const int buildingCount = getBuildingCount ( grid ); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = INT_MAX ; // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1) vector < vector < int >> dist ( m , vector < int > ( n )); // reachCount[i][j] := # of building grid[i][j] (0) can reach vector < vector < int >> reachCount ( m , vector < int > ( n )); auto bfs = [ & ]( int row , int col ) { queue < pair < int , int >> q {{{ row , col }}}; vector < vector < bool >> seen ( m , vector < bool > ( n )); int level = 0 ; while ( ! q . empty ()) { ++ level ; for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 0 || seen [ x ][ y ]) continue ; dist [ x ][ y ] += level ; ++ reachCount [ x ][ y ]; q . push ({ x , y }); seen [ x ][ y ] = true ; } } } }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) // bfs from this building bfs ( i , j ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( reachCount [ i ][ j ] == buildingCount ) ans = min ( ans , dist [ i ][ j ]); return ans == INT_MAX ? -1 : ans ; } private : int getBuildingCount ( const vector < vector < int >>& grid ) { int buildingCount = 0 ; for ( const vector < int >& row : grid ) buildingCount += count_if ( begin ( row ), end ( row ), []( int cell ) { return cell == 1 ; }); return buildingCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { public int shortestDistance ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; final int buildingCount = getBuildingCount ( grid ); int ans = Integer . MAX_VALUE ; // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1) int [][] dist = new int [ m ][ n ] ; // reachCount[i][j] := # of building grid[i][j] (0) can reach int [][] reachCount = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) // bfs from this building bfs ( grid , i , j , dist , reachCount ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( reachCount [ i ][ j ] == buildingCount ) ans = Math . min ( ans , dist [ i ][ j ] ); return ans == Integer . MAX_VALUE ? - 1 : ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( final int [][] grid , int row , int col , int [][] dist , int [][] reachCount ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; Queue < int []> q = new LinkedList <> (); boolean [][] seen = new boolean [ m ][ n ] ; int level = 0 ; q . offer ( new int [] { row , col }); while ( ! q . isEmpty ()) { ++ level ; for ( int size = q . size (); size > 0 ; -- size ) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 0 || seen [ x ][ y ] ) continue ; dist [ x ][ y ] += level ; ++ reachCount [ x ][ y ] ; q . offer ( new int [] { x , y }); seen [ x ][ y ] = true ; } } } } private int getBuildingCount ( final int [][] grid ) { int buildingCount = 0 ; for ( final int [] row : grid ) for ( final int cell : row ) if ( cell == 1 ) ++ buildingCount ; return buildingCount ; } }","title":"317. Shortest Distance from All Buildings"},{"location":"problems/0317/#317-shortest-distance-from-all-buildings","text":"Time: $O(m^2n^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public : int shortestDistance ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); const int buildingCount = getBuildingCount ( grid ); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = INT_MAX ; // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1) vector < vector < int >> dist ( m , vector < int > ( n )); // reachCount[i][j] := # of building grid[i][j] (0) can reach vector < vector < int >> reachCount ( m , vector < int > ( n )); auto bfs = [ & ]( int row , int col ) { queue < pair < int , int >> q {{{ row , col }}}; vector < vector < bool >> seen ( m , vector < bool > ( n )); int level = 0 ; while ( ! q . empty ()) { ++ level ; for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 0 || seen [ x ][ y ]) continue ; dist [ x ][ y ] += level ; ++ reachCount [ x ][ y ]; q . push ({ x , y }); seen [ x ][ y ] = true ; } } } }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) // bfs from this building bfs ( i , j ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( reachCount [ i ][ j ] == buildingCount ) ans = min ( ans , dist [ i ][ j ]); return ans == INT_MAX ? -1 : ans ; } private : int getBuildingCount ( const vector < vector < int >>& grid ) { int buildingCount = 0 ; for ( const vector < int >& row : grid ) buildingCount += count_if ( begin ( row ), end ( row ), []( int cell ) { return cell == 1 ; }); return buildingCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { public int shortestDistance ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; final int buildingCount = getBuildingCount ( grid ); int ans = Integer . MAX_VALUE ; // dist[i][j] := total distance of grid[i][j] (0) to reach all buildings (1) int [][] dist = new int [ m ][ n ] ; // reachCount[i][j] := # of building grid[i][j] (0) can reach int [][] reachCount = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) // bfs from this building bfs ( grid , i , j , dist , reachCount ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( reachCount [ i ][ j ] == buildingCount ) ans = Math . min ( ans , dist [ i ][ j ] ); return ans == Integer . MAX_VALUE ? - 1 : ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( final int [][] grid , int row , int col , int [][] dist , int [][] reachCount ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; Queue < int []> q = new LinkedList <> (); boolean [][] seen = new boolean [ m ][ n ] ; int level = 0 ; q . offer ( new int [] { row , col }); while ( ! q . isEmpty ()) { ++ level ; for ( int size = q . size (); size > 0 ; -- size ) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 0 || seen [ x ][ y ] ) continue ; dist [ x ][ y ] += level ; ++ reachCount [ x ][ y ] ; q . offer ( new int [] { x , y }); seen [ x ][ y ] = true ; } } } } private int getBuildingCount ( final int [][] grid ) { int buildingCount = 0 ; for ( final int [] row : grid ) for ( final int cell : row ) if ( cell == 1 ) ++ buildingCount ; return buildingCount ; } }","title":"317. Shortest Distance from All Buildings \ud83d\udd12"},{"location":"problems/0318/","text":"318. Maximum Product of Word Lengths Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxProduct ( vector < string >& words ) { size_t ans = 0 ; vector < int > masks ; for ( const string & word : words ) masks . push_back ( getMask ( word )); for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if (( masks [ i ] & masks [ j ]) == 0 ) ans = max ( ans , words [ i ]. length () * words [ j ]. length ()); return ans ; } private : int getMask ( const string & word ) { int mask = 0 ; for ( const char c : word ) mask |= 1 << ( c - 'a' ); return mask ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProduct ( String [] words ) { int ans = 0 ; int [] masks = new int [ words . length ] ; // \"abd\" -> (1011)2 for ( int i = 0 ; i < words . length ; ++ i ) masks [ i ] = getMask ( words [ i ] ); for ( int i = 0 ; i < masks . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if (( masks [ i ] & masks [ j ] ) == 0 ) ans = Math . max ( ans , words [ i ] . length () * words [ j ] . length ()); return ans ; } private int getMask ( final String word ) { int mask = 0 ; for ( final char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); return mask ; } }","title":"318. Maximum Product of Word Lengths"},{"location":"problems/0318/#318-maximum-product-of-word-lengths","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxProduct ( vector < string >& words ) { size_t ans = 0 ; vector < int > masks ; for ( const string & word : words ) masks . push_back ( getMask ( word )); for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if (( masks [ i ] & masks [ j ]) == 0 ) ans = max ( ans , words [ i ]. length () * words [ j ]. length ()); return ans ; } private : int getMask ( const string & word ) { int mask = 0 ; for ( const char c : word ) mask |= 1 << ( c - 'a' ); return mask ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProduct ( String [] words ) { int ans = 0 ; int [] masks = new int [ words . length ] ; // \"abd\" -> (1011)2 for ( int i = 0 ; i < words . length ; ++ i ) masks [ i ] = getMask ( words [ i ] ); for ( int i = 0 ; i < masks . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if (( masks [ i ] & masks [ j ] ) == 0 ) ans = Math . max ( ans , words [ i ] . length () * words [ j ] . length ()); return ans ; } private int getMask ( final String word ) { int mask = 0 ; for ( final char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); return mask ; } }","title":"318. Maximum Product of Word Lengths"},{"location":"problems/0319/","text":"319. Bulb Switcher Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int bulbSwitch ( int n ) { // k-th bulb only be switched when k % i == 0. // so we can reiterate the problem: // to find # of number <= n that have odd factors. // Obviously, only square numbers have odd factor(s). // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10 return sqrt ( n ); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int bulbSwitch ( int n ) { // k-th bulb only be switched when k % i == 0. // so we can reiterate the problem: // to find # of number <= n that have odd factors. // Obviously, only square numbers have odd factor(s). // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10 return ( int ) Math . sqrt ( n ); } } Python 1 2 3 class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( sqrt ( n ))","title":"319. Bulb Switcher"},{"location":"problems/0319/#319-bulb-switcher","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int bulbSwitch ( int n ) { // k-th bulb only be switched when k % i == 0. // so we can reiterate the problem: // to find # of number <= n that have odd factors. // Obviously, only square numbers have odd factor(s). // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10 return sqrt ( n ); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int bulbSwitch ( int n ) { // k-th bulb only be switched when k % i == 0. // so we can reiterate the problem: // to find # of number <= n that have odd factors. // Obviously, only square numbers have odd factor(s). // e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10 return ( int ) Math . sqrt ( n ); } } Python 1 2 3 class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( sqrt ( n ))","title":"319. Bulb Switcher"},{"location":"problems/0320/","text":"320. Generalized Abbreviation \ud83d\udd12 Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector < string > generateAbbreviations ( string word ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; function < void ( int , int ) > dfs = [ & ]( int i , int count ) { if ( i == word . length ()) { ans . push_back ( join ( path ) + getCountString ( count )); return ; } // abbreviate word[i] dfs ( i + 1 , count + 1 ); // keep word[i], so consume the count as a string path . push_back ( getCountString ( count ) + word [ i ]); dfs ( i + 1 , 0 ); // reset count to 0 path . pop_back (); }; dfs ( 0 , 0 ); return ans ; } private : string getCountString ( int count ) { return count > 0 ? to_string ( count ) : \"\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > generateAbbreviations ( String word ) { List < String > ans = new ArrayList <> (); dfs ( word , 0 , 0 , new StringBuilder (), ans ); return ans ; } private void dfs ( final String word , int i , int count , StringBuilder path , List < String > ans ) { if ( i == word . length ()) { final int length = path . length (); ans . add ( path . append ( getCountString ( count )). toString ()); path . setLength ( length ); return ; } // abbreviate word.charAt(i) dfs ( word , i + 1 , count + 1 , path , ans ); // keep word.charAt(i), so consume the count as a string final int length = path . length (); dfs ( word , i + 1 , 0 , path . append ( getCountString ( count )). append ( word . charAt ( i )), ans ); // reset count to 0 path . setLength ( length ); } private String getCountString ( int count ) { return count > 0 ? String . valueOf ( count ) : \"\" ; } }","title":"320. Generalized Abbreviation"},{"location":"problems/0320/#320-generalized-abbreviation","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector < string > generateAbbreviations ( string word ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; function < void ( int , int ) > dfs = [ & ]( int i , int count ) { if ( i == word . length ()) { ans . push_back ( join ( path ) + getCountString ( count )); return ; } // abbreviate word[i] dfs ( i + 1 , count + 1 ); // keep word[i], so consume the count as a string path . push_back ( getCountString ( count ) + word [ i ]); dfs ( i + 1 , 0 ); // reset count to 0 path . pop_back (); }; dfs ( 0 , 0 ); return ans ; } private : string getCountString ( int count ) { return count > 0 ? to_string ( count ) : \"\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > generateAbbreviations ( String word ) { List < String > ans = new ArrayList <> (); dfs ( word , 0 , 0 , new StringBuilder (), ans ); return ans ; } private void dfs ( final String word , int i , int count , StringBuilder path , List < String > ans ) { if ( i == word . length ()) { final int length = path . length (); ans . add ( path . append ( getCountString ( count )). toString ()); path . setLength ( length ); return ; } // abbreviate word.charAt(i) dfs ( word , i + 1 , count + 1 , path , ans ); // keep word.charAt(i), so consume the count as a string final int length = path . length (); dfs ( word , i + 1 , 0 , path . append ( getCountString ( count )). append ( word . charAt ( i )), ans ); // reset count to 0 path . setLength ( length ); } private String getCountString ( int count ) { return count > 0 ? String . valueOf ( count ) : \"\" ; } }","title":"320. Generalized Abbreviation \ud83d\udd12"},{"location":"problems/0321/","text":"321. Create Maximum Number Time: $O(k(m + n)^2)$ Space: $O(m + n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < int > maxNumber ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; for ( int k1 = 0 ; k1 <= k ; ++ k1 ) { const int k2 = k - k1 ; if ( k1 > nums1 . size () || k2 > nums2 . size ()) continue ; ans = max ( ans , maxNumber ( maxNumber ( nums1 , k1 ), maxNumber ( nums2 , k2 ))); } return ans ; } private : vector < int > maxNumber ( const vector < int >& nums , int k ) { if ( k == 0 ) return {}; vector < int > ans ; int toPop = nums . size () - k ; for ( const int num : nums ) { while ( ! ans . empty () && ans . back () < num && toPop -- > 0 ) ans . pop_back (); ans . push_back ( num ); } return { begin ( ans ), begin ( ans ) + k }; } private : vector < int > maxNumber ( const vector < int >& nums1 , const vector < int >& nums2 ) { vector < int > ans ; auto s1 = cbegin ( nums1 ); auto s2 = cbegin ( nums2 ); while ( s1 != cend ( nums1 ) || s2 != cend ( nums2 )) if ( lexicographical_compare ( s1 , cend ( nums1 ), s2 , cend ( nums2 ))) ans . push_back ( * s2 ++ ); else ans . push_back ( * s1 ++ ); return ans ; } };","title":"321. Create Maximum Number"},{"location":"problems/0321/#321-create-maximum-number","text":"Time: $O(k(m + n)^2)$ Space: $O(m + n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < int > maxNumber ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; for ( int k1 = 0 ; k1 <= k ; ++ k1 ) { const int k2 = k - k1 ; if ( k1 > nums1 . size () || k2 > nums2 . size ()) continue ; ans = max ( ans , maxNumber ( maxNumber ( nums1 , k1 ), maxNumber ( nums2 , k2 ))); } return ans ; } private : vector < int > maxNumber ( const vector < int >& nums , int k ) { if ( k == 0 ) return {}; vector < int > ans ; int toPop = nums . size () - k ; for ( const int num : nums ) { while ( ! ans . empty () && ans . back () < num && toPop -- > 0 ) ans . pop_back (); ans . push_back ( num ); } return { begin ( ans ), begin ( ans ) + k }; } private : vector < int > maxNumber ( const vector < int >& nums1 , const vector < int >& nums2 ) { vector < int > ans ; auto s1 = cbegin ( nums1 ); auto s2 = cbegin ( nums2 ); while ( s1 != cend ( nums1 ) || s2 != cend ( nums2 )) if ( lexicographical_compare ( s1 , cend ( nums1 ), s2 , cend ( nums2 ))) ans . push_back ( * s2 ++ ); else ans . push_back ( * s1 ++ ); return ans ; } };","title":"321. Create Maximum Number"},{"location":"problems/0322/","text":"322. Coin Change Approach 1: Combinations Time: $O(|coins||amount|)$ Space: $O(|amount|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int coinChange ( vector < int >& coins , int amount ) { // dp[i] := fewest # of coins to make up i vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( const int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? -1 : dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int coinChange ( int [] coins , int amount ) { // dp[i] := fewest # of coins to make up i int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( final int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ] ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def coinChange ( self , coins : List [ int ], amount : int ) -> int : dp = [ 0 ] + [ amount + 1 ] * amount for i in range ( 1 , amount + 1 ): for coin in coins : if coin <= i : dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ) return dp [ - 1 ] if dp [ - 1 ] < amount + 1 else - 1 Approach 2: Permutations Time: $O(|coins||amount|)$ Space: $O(|amount|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int coinChange ( vector < int >& coins , int amount ) { // dp[i] := fewest # of coins to make up i vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i <= amount ; ++ i ) for ( const int coin : coins ) if ( coin <= i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? -1 : dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int coinChange ( int [] coins , int amount ) { // dp[i] := fewest # of coins to make up i int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( int i = 1 ; i <= amount ; ++ i ) for ( final int coin : coins ) if ( coin <= i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ] ; } }","title":"322. Coin Change"},{"location":"problems/0322/#322-coin-change","text":"","title":"322. Coin Change"},{"location":"problems/0322/#approach-1-combinations","text":"Time: $O(|coins||amount|)$ Space: $O(|amount|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int coinChange ( vector < int >& coins , int amount ) { // dp[i] := fewest # of coins to make up i vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( const int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? -1 : dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int coinChange ( int [] coins , int amount ) { // dp[i] := fewest # of coins to make up i int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( final int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ] ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def coinChange ( self , coins : List [ int ], amount : int ) -> int : dp = [ 0 ] + [ amount + 1 ] * amount for i in range ( 1 , amount + 1 ): for coin in coins : if coin <= i : dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ) return dp [ - 1 ] if dp [ - 1 ] < amount + 1 else - 1","title":"Approach 1: Combinations"},{"location":"problems/0322/#approach-2-permutations","text":"Time: $O(|coins||amount|)$ Space: $O(|amount|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int coinChange ( vector < int >& coins , int amount ) { // dp[i] := fewest # of coins to make up i vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int i = 1 ; i <= amount ; ++ i ) for ( const int coin : coins ) if ( coin <= i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? -1 : dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int coinChange ( int [] coins , int amount ) { // dp[i] := fewest # of coins to make up i int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( int i = 1 ; i <= amount ; ++ i ) for ( final int coin : coins ) if ( coin <= i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] == amount + 1 ? - 1 : dp [ amount ] ; } }","title":"Approach 2: Permutations"},{"location":"problems/0323/","text":"323. Number of Connected Components in an Undirected Graph \ud83d\udd12 Approach 1: BFS Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { int ans = 0 ; vector < vector < int >> graph ( n ); unordered_set < int > seen ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < void ( int ) > bfs = [ & ]( int node ) { queue < int > q {{ node }}; seen . insert ( node ); while ( ! q . empty ()) { const int curr = q . front (); q . pop (); for ( const int neighbor : graph [ curr ]) if ( ! seen . count ( neighbor )) { q . push ( neighbor ); seen . insert ( neighbor ); } } }; for ( int i = 0 ; i < n ; ++ i ) if ( ! seen . count ( i )) { bfs ( i ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int countComponents ( int n , int [][] edges ) { int ans = 0 ; List < Integer >[] graph = new List [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < n ; ++ i ) if ( ! seen . contains ( i )) { bfs ( graph , i , seen ); ++ ans ; } return ans ; } private void bfs ( List < Integer >[] graph , int node , Set < Integer > seen ) { Queue < Integer > q = new LinkedList <> (); q . offer ( node ); seen . add ( node ); while ( ! q . isEmpty ()) { final int curr = q . poll (); for ( final int neighbor : graph [ curr ] ) if ( ! seen . contains ( neighbor )) { q . offer ( neighbor ); seen . add ( neighbor ); } } } } Approach 2: DFS Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { int ans = 0 ; vector < vector < int >> graph ( n ); unordered_set < int > seen ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < void ( int ) > dfs = [ & ]( int i ) { for ( const int neighbor : graph [ i ]) if ( seen . insert ( neighbor ). second ) dfs ( neighbor ); }; for ( int i = 0 ; i < n ; ++ i ) if ( seen . insert ( i ). second ) { dfs ( i ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int countComponents ( int n , int [][] edges ) { int ans = 0 ; List < Integer >[] graph = new List [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < n ; ++ i ) if ( seen . add ( i )) { dfs ( graph , seen , i ); ++ ans ; } return ans ; } private void dfs ( List < Integer >[] graph , Set < Integer > seen , int i ) { for ( final int neighbor : graph [ i ] ) if ( seen . add ( neighbor )) dfs ( graph , seen , neighbor ); } } Approach 3: UF Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class UF { public : UF ( int n ) : size ( n ), rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } int getSize () { return size ; } private : int size ; vector < int > rank ; vector < int > parent ; }; class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { UF uf ( n ); for ( const vector < int >& edge : edges ) uf . union_ ( edge [ 0 ], edge [ 1 ]); return uf . getSize (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public int countComponents ( int n , int [][] edges ) { UF uf = new UF ( n ); for ( int [] edge : edges ) uf . union ( edge [ 0 ] , edge [ 1 ] ); return uf . getSize (); } } class UF { public UF ( int n ) { size = n ; rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } public int getSize () { return size ; } private int size ; private int [] rank ; private int [] parent ; }","title":"323. Number of Connected Components in an Undirected Graph"},{"location":"problems/0323/#323-number-of-connected-components-in-an-undirected-graph","text":"","title":"323. Number of Connected Components in an Undirected Graph \ud83d\udd12"},{"location":"problems/0323/#approach-1-bfs","text":"Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { int ans = 0 ; vector < vector < int >> graph ( n ); unordered_set < int > seen ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < void ( int ) > bfs = [ & ]( int node ) { queue < int > q {{ node }}; seen . insert ( node ); while ( ! q . empty ()) { const int curr = q . front (); q . pop (); for ( const int neighbor : graph [ curr ]) if ( ! seen . count ( neighbor )) { q . push ( neighbor ); seen . insert ( neighbor ); } } }; for ( int i = 0 ; i < n ; ++ i ) if ( ! seen . count ( i )) { bfs ( i ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int countComponents ( int n , int [][] edges ) { int ans = 0 ; List < Integer >[] graph = new List [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < graph . length ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < n ; ++ i ) if ( ! seen . contains ( i )) { bfs ( graph , i , seen ); ++ ans ; } return ans ; } private void bfs ( List < Integer >[] graph , int node , Set < Integer > seen ) { Queue < Integer > q = new LinkedList <> (); q . offer ( node ); seen . add ( node ); while ( ! q . isEmpty ()) { final int curr = q . poll (); for ( final int neighbor : graph [ curr ] ) if ( ! seen . contains ( neighbor )) { q . offer ( neighbor ); seen . add ( neighbor ); } } } }","title":"Approach 1: BFS"},{"location":"problems/0323/#approach-2-dfs","text":"Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { int ans = 0 ; vector < vector < int >> graph ( n ); unordered_set < int > seen ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < void ( int ) > dfs = [ & ]( int i ) { for ( const int neighbor : graph [ i ]) if ( seen . insert ( neighbor ). second ) dfs ( neighbor ); }; for ( int i = 0 ; i < n ; ++ i ) if ( seen . insert ( i ). second ) { dfs ( i ); ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int countComponents ( int n , int [][] edges ) { int ans = 0 ; List < Integer >[] graph = new List [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < n ; ++ i ) if ( seen . add ( i )) { dfs ( graph , seen , i ); ++ ans ; } return ans ; } private void dfs ( List < Integer >[] graph , Set < Integer > seen , int i ) { for ( final int neighbor : graph [ i ] ) if ( seen . add ( neighbor )) dfs ( graph , seen , neighbor ); } }","title":"Approach 2: DFS"},{"location":"problems/0323/#approach-3-uf","text":"Time: $O(|V| + |E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class UF { public : UF ( int n ) : size ( n ), rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } int getSize () { return size ; } private : int size ; vector < int > rank ; vector < int > parent ; }; class Solution { public : int countComponents ( int n , vector < vector < int >>& edges ) { UF uf ( n ); for ( const vector < int >& edge : edges ) uf . union_ ( edge [ 0 ], edge [ 1 ]); return uf . getSize (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class Solution { public int countComponents ( int n , int [][] edges ) { UF uf = new UF ( n ); for ( int [] edge : edges ) uf . union ( edge [ 0 ] , edge [ 1 ] ); return uf . getSize (); } } class UF { public UF ( int n ) { size = n ; rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } public int getSize () { return size ; } private int size ; private int [] rank ; private int [] parent ; }","title":"Approach 3: UF"},{"location":"problems/0324/","text":"324. Wiggle Sort II Time: $O(n) \\to O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void wiggleSort ( vector < int >& nums ) { const int n = nums . size (); const auto it = begin ( nums ) + n / 2 ; nth_element ( begin ( nums ), it , end ( nums )); const int median = * it ; // index-rewiring #define A(i) nums[(1 + 2 * i) % (n | 1)] for ( int i = 0 , j = 0 , k = n - 1 ; i <= k ;) if ( A ( i ) > median ) swap ( A ( i ++ ), A ( j ++ )); else if ( A ( i ) < median ) swap ( A ( i ), A ( k -- )); else ++ i ; } };","title":"324. Wiggle Sort II"},{"location":"problems/0324/#324-wiggle-sort-ii","text":"Time: $O(n) \\to O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void wiggleSort ( vector < int >& nums ) { const int n = nums . size (); const auto it = begin ( nums ) + n / 2 ; nth_element ( begin ( nums ), it , end ( nums )); const int median = * it ; // index-rewiring #define A(i) nums[(1 + 2 * i) % (n | 1)] for ( int i = 0 , j = 0 , k = n - 1 ; i <= k ;) if ( A ( i ) > median ) swap ( A ( i ++ ), A ( j ++ )); else if ( A ( i ) < median ) swap ( A ( i ), A ( k -- )); else ++ i ; } };","title":"324. Wiggle Sort II"},{"location":"problems/0325/","text":"325. Maximum Size Subarray Sum Equals k \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxSubArrayLen ( vector < int >& nums , int k ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; const int target = prefixSum - k ; if ( prefixSumToIndex . count ( target )) ans = max ( ans , i - prefixSumToIndex [ target ]); if ( ! prefixSumToIndex . count ( prefixSum )) prefixSumToIndex [ prefixSum ] = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxSubArrayLen ( int [] nums , int k ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; final int target = prefixSum - k ; if ( prefixSumToIndex . containsKey ( target )) ans = Math . max ( ans , i - prefixSumToIndex . get ( target )); prefixSumToIndex . putIfAbsent ( prefixSum , i ); } return ans ; } }","title":"325. Maximum Size Subarray Sum Equals k"},{"location":"problems/0325/#325-maximum-size-subarray-sum-equals-k","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxSubArrayLen ( vector < int >& nums , int k ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; const int target = prefixSum - k ; if ( prefixSumToIndex . count ( target )) ans = max ( ans , i - prefixSumToIndex [ target ]); if ( ! prefixSumToIndex . count ( prefixSum )) prefixSumToIndex [ prefixSum ] = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxSubArrayLen ( int [] nums , int k ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; final int target = prefixSum - k ; if ( prefixSumToIndex . containsKey ( target )) ans = Math . max ( ans , i - prefixSumToIndex . get ( target )); prefixSumToIndex . putIfAbsent ( prefixSum , i ); } return ans ; } }","title":"325. Maximum Size Subarray Sum Equals k \ud83d\udd12"},{"location":"problems/0326/","text":"326. Power of Three Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool isPowerOfThree ( int n ) { return n > 0 && ( int ) pow ( 3 , 19 ) % n == 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean isPowerOfThree ( int n ) { return n > 0 && Math . pow ( 3 , 19 ) % n == 0 ; } } Python 1 2 3 class Solution : def isPowerOfThree ( self , n : int ) -> bool : return n > 0 and 3 ** 19 % n == 0","title":"326. Power of Three"},{"location":"problems/0326/#326-power-of-three","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool isPowerOfThree ( int n ) { return n > 0 && ( int ) pow ( 3 , 19 ) % n == 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean isPowerOfThree ( int n ) { return n > 0 && Math . pow ( 3 , 19 ) % n == 0 ; } } Python 1 2 3 class Solution : def isPowerOfThree ( self , n : int ) -> bool : return n > 0 and 3 ** 19 % n == 0","title":"326. Power of Three"},{"location":"problems/0327/","text":"327. Count of Range Sum Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : int countRangeSum ( vector < int >& nums , int lower , int upper ) { const int n = nums . size (); int count = 0 ; vector < long > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ]; function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { int lo = m + 1 ; // 1st index s.t. prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index s.t. prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; } vector < long > sorted ( r - l + 1 ); int k = 0 ; // point to sorted int i = l ; // point to left int j = m + 1 ; // point to right while ( i <= m && j <= r ) if ( prefixSum [ i ] < prefixSum [ j ]) sorted [ k ++ ] = prefixSum [ i ++ ]; else sorted [ k ++ ] = prefixSum [ j ++ ]; // put possible remaining left part to the sorted array while ( i <= m ) sorted [ k ++ ] = prefixSum [ i ++ ]; // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = prefixSum [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( prefixSum ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n ); return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public int countRangeSum ( int [] nums , int lower , int upper ) { final int n = nums . length ; long [] prefixSum = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ] ; mergeSort ( prefixSum , 0 , n , lower , upper ); return count ; } private int count = 0 ; private void mergeSort ( long [] prefixSum , int l , int r , int lower , int upper ) { if ( l >= r ) return ; final int m = l + ( r - l ) / 2 ; mergeSort ( prefixSum , l , m , lower , upper ); mergeSort ( prefixSum , m + 1 , r , lower , upper ); merge ( prefixSum , l , m , r , lower , upper ); } private void merge ( long [] prefixSum , int l , int m , int r , int lower , int upper ) { int lo = m + 1 ; // 1st index s.t. prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index s.t. prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; } long [] sorted = new long [ r - l + 1 ] ; int k = 0 ; // point to sorted int i = l ; // point to left int j = m + 1 ; // point to right while ( i <= m && j <= r ) if ( prefixSum [ i ] < prefixSum [ j ] ) sorted [ k ++] = prefixSum [ i ++] ; else sorted [ k ++] = prefixSum [ j ++] ; // put possible remaining left part to the sorted array while ( i <= m ) sorted [ k ++] = prefixSum [ i ++] ; // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++] = prefixSum [ j ++] ; System . arraycopy ( sorted , 0 , prefixSum , l , sorted . length ); } }","title":"327. Count of Range Sum"},{"location":"problems/0327/#327-count-of-range-sum","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : int countRangeSum ( vector < int >& nums , int lower , int upper ) { const int n = nums . size (); int count = 0 ; vector < long > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ]; function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { int lo = m + 1 ; // 1st index s.t. prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index s.t. prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; } vector < long > sorted ( r - l + 1 ); int k = 0 ; // point to sorted int i = l ; // point to left int j = m + 1 ; // point to right while ( i <= m && j <= r ) if ( prefixSum [ i ] < prefixSum [ j ]) sorted [ k ++ ] = prefixSum [ i ++ ]; else sorted [ k ++ ] = prefixSum [ j ++ ]; // put possible remaining left part to the sorted array while ( i <= m ) sorted [ k ++ ] = prefixSum [ i ++ ]; // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = prefixSum [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( prefixSum ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n ); return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public int countRangeSum ( int [] nums , int lower , int upper ) { final int n = nums . length ; long [] prefixSum = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ] ; mergeSort ( prefixSum , 0 , n , lower , upper ); return count ; } private int count = 0 ; private void mergeSort ( long [] prefixSum , int l , int r , int lower , int upper ) { if ( l >= r ) return ; final int m = l + ( r - l ) / 2 ; mergeSort ( prefixSum , l , m , lower , upper ); mergeSort ( prefixSum , m + 1 , r , lower , upper ); merge ( prefixSum , l , m , r , lower , upper ); } private void merge ( long [] prefixSum , int l , int m , int r , int lower , int upper ) { int lo = m + 1 ; // 1st index s.t. prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index s.t. prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; } long [] sorted = new long [ r - l + 1 ] ; int k = 0 ; // point to sorted int i = l ; // point to left int j = m + 1 ; // point to right while ( i <= m && j <= r ) if ( prefixSum [ i ] < prefixSum [ j ] ) sorted [ k ++] = prefixSum [ i ++] ; else sorted [ k ++] = prefixSum [ j ++] ; // put possible remaining left part to the sorted array while ( i <= m ) sorted [ k ++] = prefixSum [ i ++] ; // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++] = prefixSum [ j ++] ; System . arraycopy ( sorted , 0 , prefixSum , l , sorted . length ); } }","title":"327. Count of Range Sum"},{"location":"problems/0328/","text":"328. Odd Even Linked List Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { ListNode oddHead ( 0 ); ListNode evenHead ( 0 ); ListNode * odd = & oddHead ; ListNode * even = & evenHead ; for ( int isOdd = 0 ; head ; head = head -> next ) if ( isOdd ^= 1 ) { odd -> next = head ; odd = odd -> next ; } else { even -> next = head ; even = even -> next ; } odd -> next = evenHead . next ; even -> next = nullptr ; return oddHead . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode oddEvenList ( ListNode head ) { ListNode oddHead = new ListNode ( 0 ); ListNode evenHead = new ListNode ( 0 ); ListNode odd = oddHead ; ListNode even = evenHead ; for ( boolean isOdd = true ; head != null ; head = head . next , isOdd = ! isOdd ) if ( isOdd ) { odd . next = head ; odd = odd . next ; } else { even . next = head ; even = even . next ; } odd . next = evenHead . next ; even . next = null ; return oddHead . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : oddHead = ListNode ( 0 ) evenHead = ListNode ( 0 ) odd = oddHead even = evenHead isOdd = True while head : if isOdd : odd . next = head odd = head else : even . next = head even = head head = head . next isOdd = not isOdd even . next = None odd . next = evenHead . next return oddHead . next","title":"328. Odd Even Linked List"},{"location":"problems/0328/#328-odd-even-linked-list","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { ListNode oddHead ( 0 ); ListNode evenHead ( 0 ); ListNode * odd = & oddHead ; ListNode * even = & evenHead ; for ( int isOdd = 0 ; head ; head = head -> next ) if ( isOdd ^= 1 ) { odd -> next = head ; odd = odd -> next ; } else { even -> next = head ; even = even -> next ; } odd -> next = evenHead . next ; even -> next = nullptr ; return oddHead . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode oddEvenList ( ListNode head ) { ListNode oddHead = new ListNode ( 0 ); ListNode evenHead = new ListNode ( 0 ); ListNode odd = oddHead ; ListNode even = evenHead ; for ( boolean isOdd = true ; head != null ; head = head . next , isOdd = ! isOdd ) if ( isOdd ) { odd . next = head ; odd = odd . next ; } else { even . next = head ; even = even . next ; } odd . next = evenHead . next ; even . next = null ; return oddHead . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : oddHead = ListNode ( 0 ) evenHead = ListNode ( 0 ) odd = oddHead even = evenHead isOdd = True while head : if isOdd : odd . next = head odd = head else : even . next = head even = head head = head . next isOdd = not isOdd even . next = None odd . next = evenHead . next return oddHead . next","title":"328. Odd Even Linked List"},{"location":"problems/0329/","text":"329. Longest Increasing Path in a Matrix Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int longestIncreasingPath ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; // memo[i][j] := the LIP starting from matrix[i][j] vector < vector < int >> memo ( m , vector < int > ( n )); function < int ( int , int , int ) > dfs = [ & ]( int i , int j , int prev ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( matrix [ i ][ j ] <= prev ) return 0 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; const int curr = matrix [ i ][ j ]; return ans = 1 + max ({ dfs ( i + 1 , j , curr ), dfs ( i - 1 , j , curr ), dfs ( i , j + 1 , curr ), dfs ( i , j - 1 , curr )}); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j , INT_MIN )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int longestIncreasingPath ( int [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; // memo[i][j] := the LIP starting from matrix[i][j] int [][] memo = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = Math . max ( ans , dfs ( matrix , i , j , Integer . MIN_VALUE , memo )); return ans ; } private int dfs ( int [][] matrix , int i , int j , int prev , int [][] memo ) { if ( i < 0 || i == matrix . length || j < 0 || j == matrix [ 0 ] . length ) return 0 ; if ( matrix [ i ][ j ] <= prev ) return 0 ; if ( memo [ i ][ j ] > 0 ) return memo [ i ][ j ] ; final int curr = matrix [ i ][ j ] ; final int a = dfs ( matrix , i + 1 , j , curr , memo ); final int b = dfs ( matrix , i - 1 , j , curr , memo ); final int c = dfs ( matrix , i , j + 1 , curr , memo ); final int d = dfs ( matrix , i , j - 1 , curr , memo ); return memo [ i ][ j ] = 1 + Math . max ( Math . max ( a , b ), Math . max ( c , d )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestIncreasingPath ( self , matrix : List [ List [ int ]]) -> int : def dfs ( i : int , j : int , maxi : int ) -> int : if not 0 <= i < len ( matrix ) or not 0 <= j < len ( matrix [ 0 ]) or matrix [ i ][ j ] <= maxi : return 0 if cached [ i ][ j ] != 0 : return cached [ i ][ j ] cached [ i ][ j ] = 1 + max ( dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])) return cached [ i ][ j ] if not matrix : return 0 ans = 0 cached = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): ans = max ( ans , dfs ( i , j , float ( '-inf' ))) return ans","title":"329. Longest Increasing Path in a Matrix"},{"location":"problems/0329/#329-longest-increasing-path-in-a-matrix","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int longestIncreasingPath ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; // memo[i][j] := the LIP starting from matrix[i][j] vector < vector < int >> memo ( m , vector < int > ( n )); function < int ( int , int , int ) > dfs = [ & ]( int i , int j , int prev ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( matrix [ i ][ j ] <= prev ) return 0 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; const int curr = matrix [ i ][ j ]; return ans = 1 + max ({ dfs ( i + 1 , j , curr ), dfs ( i - 1 , j , curr ), dfs ( i , j + 1 , curr ), dfs ( i , j - 1 , curr )}); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j , INT_MIN )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int longestIncreasingPath ( int [][] matrix ) { if ( matrix . length == 0 ) return 0 ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; // memo[i][j] := the LIP starting from matrix[i][j] int [][] memo = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = Math . max ( ans , dfs ( matrix , i , j , Integer . MIN_VALUE , memo )); return ans ; } private int dfs ( int [][] matrix , int i , int j , int prev , int [][] memo ) { if ( i < 0 || i == matrix . length || j < 0 || j == matrix [ 0 ] . length ) return 0 ; if ( matrix [ i ][ j ] <= prev ) return 0 ; if ( memo [ i ][ j ] > 0 ) return memo [ i ][ j ] ; final int curr = matrix [ i ][ j ] ; final int a = dfs ( matrix , i + 1 , j , curr , memo ); final int b = dfs ( matrix , i - 1 , j , curr , memo ); final int c = dfs ( matrix , i , j + 1 , curr , memo ); final int d = dfs ( matrix , i , j - 1 , curr , memo ); return memo [ i ][ j ] = 1 + Math . max ( Math . max ( a , b ), Math . max ( c , d )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestIncreasingPath ( self , matrix : List [ List [ int ]]) -> int : def dfs ( i : int , j : int , maxi : int ) -> int : if not 0 <= i < len ( matrix ) or not 0 <= j < len ( matrix [ 0 ]) or matrix [ i ][ j ] <= maxi : return 0 if cached [ i ][ j ] != 0 : return cached [ i ][ j ] cached [ i ][ j ] = 1 + max ( dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])) return cached [ i ][ j ] if not matrix : return 0 ans = 0 cached = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): ans = max ( ans , dfs ( i , j , float ( '-inf' ))) return ans","title":"329. Longest Increasing Path in a Matrix"},{"location":"problems/0330/","text":"330. Patching Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int minPatches ( int [] nums , int n ) { int ans = 0 ; int i = 0 ; // point to nums long miss = 1 ; // min sum in [1, n] we might miss while ( miss <= n ) if ( i < nums . length && nums [ i ] <= miss ) { miss += nums [ i ++ ]; } else { // greedily add miss itself to increase the range // from [1, miss) to [1, 2 * miss) miss += miss ; ++ ans ; } return ans ; } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int minPatches ( int [] nums , int n ) { int ans = 0 ; int i = 0 ; // point to nums long miss = 1 ; // min sum in [1, n] we might miss while ( miss <= n ) if ( i < nums . length && nums [ i ] <= miss ) { miss += nums [ i ++] ; } else { // greedily add miss itself to increase the range // from [1, miss) to [1, 2 * miss) miss += miss ; ++ ans ; } return ans ; } }","title":"330. Patching Array"},{"location":"problems/0330/#330-patching-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int minPatches ( int [] nums , int n ) { int ans = 0 ; int i = 0 ; // point to nums long miss = 1 ; // min sum in [1, n] we might miss while ( miss <= n ) if ( i < nums . length && nums [ i ] <= miss ) { miss += nums [ i ++ ]; } else { // greedily add miss itself to increase the range // from [1, miss) to [1, 2 * miss) miss += miss ; ++ ans ; } return ans ; } } Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int minPatches ( int [] nums , int n ) { int ans = 0 ; int i = 0 ; // point to nums long miss = 1 ; // min sum in [1, n] we might miss while ( miss <= n ) if ( i < nums . length && nums [ i ] <= miss ) { miss += nums [ i ++] ; } else { // greedily add miss itself to increase the range // from [1, miss) to [1, 2 * miss) miss += miss ; ++ ans ; } return ans ; } }","title":"330. Patching Array"},{"location":"problems/0331/","text":"331. Verify Preorder Serialization of a Binary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isValidSerialization ( string preorder ) { int degree = 1 ; // outDegree (children) - inDegree (parent) istringstream iss ( preorder ); for ( string node ; getline ( iss , node , ',' );) { if ( -- degree < 0 ) return false ; if ( node != \"#\" ) degree += 2 ; } return degree == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isValidSerialization ( String preorder ) { int degree = 1 ; // outDegree (children) - inDegree (parent) for ( final String node : preorder . split ( \",\" )) { if ( -- degree < 0 ) // one parent return false ; if ( ! node . equals ( \"#\" )) degree += 2 ; // two children } return degree == 0 ; } }","title":"331. Verify Preorder Serialization of a Binary Tree"},{"location":"problems/0331/#331-verify-preorder-serialization-of-a-binary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isValidSerialization ( string preorder ) { int degree = 1 ; // outDegree (children) - inDegree (parent) istringstream iss ( preorder ); for ( string node ; getline ( iss , node , ',' );) { if ( -- degree < 0 ) return false ; if ( node != \"#\" ) degree += 2 ; } return degree == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isValidSerialization ( String preorder ) { int degree = 1 ; // outDegree (children) - inDegree (parent) for ( final String node : preorder . split ( \",\" )) { if ( -- degree < 0 ) // one parent return false ; if ( ! node . equals ( \"#\" )) degree += 2 ; // two children } return degree == 0 ; } }","title":"331. Verify Preorder Serialization of a Binary Tree"},{"location":"problems/0332/","text":"332. Reconstruct Itinerary Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < string > findItinerary ( vector < vector < string >>& tickets ) { vector < string > ans ; unordered_map < string , multiset < string >> graph ; for ( const vector < string >& ticket : tickets ) graph [ ticket [ 0 ]]. insert ( ticket [ 1 ]); function < void ( const string & ) > dfs = [ & ]( const string & node ) { while ( graph . count ( node ) && ! graph [ node ]. empty ()) { const string next = * begin ( graph [ node ]); graph [ node ]. erase ( begin ( graph [ node ])); dfs ( next ); } ans . push_back ( node ); }; dfs ( \"JFK\" ); reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > findItinerary ( List < List < String >> tickets ) { LinkedList < String > ans = new LinkedList <> (); Map < String , PriorityQueue < String >> graph = new HashMap <> (); for ( final List < String > ticket : tickets ) { graph . putIfAbsent ( ticket . get ( 0 ), new PriorityQueue <> ()); graph . get ( ticket . get ( 0 )). offer ( ticket . get ( 1 )); } dfs ( graph , \"JFK\" , ans ); return ans ; } private void dfs ( Map < String , PriorityQueue < String >> graph , final String node , LinkedList < String > ans ) { final PriorityQueue < String > arrivals = graph . get ( node ); while ( arrivals != null && ! arrivals . isEmpty ()) dfs ( graph , arrivals . poll (), ans ); ans . addFirst ( node ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findItinerary ( self , tickets : List [ List [ str ]]) -> List [ str ]: def dfs ( airport : str ) -> None : while airport in graph and graph [ airport ]: dfs ( graph [ airport ] . pop ()) ans . append ( airport ) ans = [] graph = collections . defaultdict ( list ) for a , b in sorted ( tickets )[:: - 1 ]: graph [ a ] . append ( b ) dfs ( 'JFK' ) return ans [:: - 1 ]","title":"332. Reconstruct Itinerary"},{"location":"problems/0332/#332-reconstruct-itinerary","text":"Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < string > findItinerary ( vector < vector < string >>& tickets ) { vector < string > ans ; unordered_map < string , multiset < string >> graph ; for ( const vector < string >& ticket : tickets ) graph [ ticket [ 0 ]]. insert ( ticket [ 1 ]); function < void ( const string & ) > dfs = [ & ]( const string & node ) { while ( graph . count ( node ) && ! graph [ node ]. empty ()) { const string next = * begin ( graph [ node ]); graph [ node ]. erase ( begin ( graph [ node ])); dfs ( next ); } ans . push_back ( node ); }; dfs ( \"JFK\" ); reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > findItinerary ( List < List < String >> tickets ) { LinkedList < String > ans = new LinkedList <> (); Map < String , PriorityQueue < String >> graph = new HashMap <> (); for ( final List < String > ticket : tickets ) { graph . putIfAbsent ( ticket . get ( 0 ), new PriorityQueue <> ()); graph . get ( ticket . get ( 0 )). offer ( ticket . get ( 1 )); } dfs ( graph , \"JFK\" , ans ); return ans ; } private void dfs ( Map < String , PriorityQueue < String >> graph , final String node , LinkedList < String > ans ) { final PriorityQueue < String > arrivals = graph . get ( node ); while ( arrivals != null && ! arrivals . isEmpty ()) dfs ( graph , arrivals . poll (), ans ); ans . addFirst ( node ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findItinerary ( self , tickets : List [ List [ str ]]) -> List [ str ]: def dfs ( airport : str ) -> None : while airport in graph and graph [ airport ]: dfs ( graph [ airport ] . pop ()) ans . append ( airport ) ans = [] graph = collections . defaultdict ( list ) for a , b in sorted ( tickets )[:: - 1 ]: graph [ a ] . append ( b ) dfs ( 'JFK' ) return ans [:: - 1 ]","title":"332. Reconstruct Itinerary"},{"location":"problems/0333/","text":"333. Largest BST Subtree \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct T { int min ; // min value in the subtree int max ; // max value in the subtree int size ; // total size of the subtree }; class Solution { public : int largestBSTSubtree ( TreeNode * root ) { return helper ( root ). size ; } private : T helper ( TreeNode * root ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 }; T l = helper ( root -> left ); T r = helper ( root -> right ); if ( l . max < root -> val && root -> val < r . min ) return { min ( l . min , root -> val ), max ( r . max , root -> val ), 1 + l . size + r . size }; // mark as invalid one, but still record the size of children // return (-INF, INF) because any node won't > INT and < -INF return { INT_MIN , INT_MAX , max ( l . size , r . size )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class T { public int min ; // min value in the subtree public int max ; // max value in the subtree public int size ; // total size of the subtree public T ( int min , int max , int size ) { this . min = min ; this . max = max ; this . size = size ; } } class Solution { public int largestBSTSubtree ( TreeNode root ) { return helper ( root ). size ; } private T helper ( TreeNode root ) { if ( root == null ) return new T ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 ); T l = helper ( root . left ); T r = helper ( root . right ); if ( l . max < root . val && root . val < r . min ) return new T ( Math . min ( l . min , root . val ), Math . max ( r . max , root . val ), 1 + l . size + r . size ); // mark as invalid one, but still record the size of children // return (-INF, INF) because any node won't > INT and < -INF return new T ( Integer . MIN_VALUE , Integer . MAX_VALUE , Math . max ( l . size , r . size )); } }","title":"333. Largest BST Subtree"},{"location":"problems/0333/#333-largest-bst-subtree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct T { int min ; // min value in the subtree int max ; // max value in the subtree int size ; // total size of the subtree }; class Solution { public : int largestBSTSubtree ( TreeNode * root ) { return helper ( root ). size ; } private : T helper ( TreeNode * root ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 }; T l = helper ( root -> left ); T r = helper ( root -> right ); if ( l . max < root -> val && root -> val < r . min ) return { min ( l . min , root -> val ), max ( r . max , root -> val ), 1 + l . size + r . size }; // mark as invalid one, but still record the size of children // return (-INF, INF) because any node won't > INT and < -INF return { INT_MIN , INT_MAX , max ( l . size , r . size )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class T { public int min ; // min value in the subtree public int max ; // max value in the subtree public int size ; // total size of the subtree public T ( int min , int max , int size ) { this . min = min ; this . max = max ; this . size = size ; } } class Solution { public int largestBSTSubtree ( TreeNode root ) { return helper ( root ). size ; } private T helper ( TreeNode root ) { if ( root == null ) return new T ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 ); T l = helper ( root . left ); T r = helper ( root . right ); if ( l . max < root . val && root . val < r . min ) return new T ( Math . min ( l . min , root . val ), Math . max ( r . max , root . val ), 1 + l . size + r . size ); // mark as invalid one, but still record the size of children // return (-INF, INF) because any node won't > INT and < -INF return new T ( Integer . MIN_VALUE , Integer . MAX_VALUE , Math . max ( l . size , r . size )); } }","title":"333. Largest BST Subtree \ud83d\udd12"},{"location":"problems/0334/","text":"334. Increasing Triplet Subsequence Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool increasingTriplet ( vector < int >& nums ) { int first = INT_MAX ; int second = INT_MAX ; for ( const int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) // first < num <= second second = num ; else return true ; // first < second < num (third) return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean increasingTriplet ( int [] nums ) { int first = Integer . MAX_VALUE ; int second = Integer . MAX_VALUE ; for ( final int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) // first < num <= second second = num ; else // first < second < num (third) return true ; return false ; } }","title":"334. Increasing Triplet Subsequence"},{"location":"problems/0334/#334-increasing-triplet-subsequence","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool increasingTriplet ( vector < int >& nums ) { int first = INT_MAX ; int second = INT_MAX ; for ( const int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) // first < num <= second second = num ; else return true ; // first < second < num (third) return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean increasingTriplet ( int [] nums ) { int first = Integer . MAX_VALUE ; int second = Integer . MAX_VALUE ; for ( final int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) // first < num <= second second = num ; else // first < second < num (third) return true ; return false ; } }","title":"334. Increasing Triplet Subsequence"},{"location":"problems/0335/","text":"335. Self Crossing Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isSelfCrossing ( vector < int >& x ) { if ( x . size () <= 3 ) return false ; for ( int i = 3 ; i < x . size (); ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ]) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ]) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isSelfCrossing ( int [] x ) { if ( x . length <= 3 ) return false ; for ( int i = 3 ; i < x . length ; ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ] ) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] ) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isSelfCrossing ( self , x : List [ int ]) -> bool : if len ( x ) <= 3 : return False for i in range ( 3 , len ( x )): if x [ i - 2 ] <= x [ i ] and x [ i - 1 ] <= x [ i - 3 ]: return True if i >= 4 and x [ i - 1 ] == x [ i - 3 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ]: return True if i >= 5 and x [ i - 4 ] <= x [ i - 2 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] and x [ i - 1 ] <= x [ i - 3 ] and x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]: return True return False","title":"335. Self Crossing"},{"location":"problems/0335/#335-self-crossing","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isSelfCrossing ( vector < int >& x ) { if ( x . size () <= 3 ) return false ; for ( int i = 3 ; i < x . size (); ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ]) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ]) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isSelfCrossing ( int [] x ) { if ( x . length <= 3 ) return false ; for ( int i = 3 ; i < x . length ; ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ] ) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] ) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isSelfCrossing ( self , x : List [ int ]) -> bool : if len ( x ) <= 3 : return False for i in range ( 3 , len ( x )): if x [ i - 2 ] <= x [ i ] and x [ i - 1 ] <= x [ i - 3 ]: return True if i >= 4 and x [ i - 1 ] == x [ i - 3 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ]: return True if i >= 5 and x [ i - 4 ] <= x [ i - 2 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] and x [ i - 1 ] <= x [ i - 3 ] and x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]: return True return False","title":"335. Self Crossing"},{"location":"problems/0336/","text":"336. Palindrome Pairs Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> palindromePairs ( vector < string >& words ) { vector < vector < int >> ans ; unordered_map < string , int > map ; // {reversed word: its index} for ( int i = 0 ; i < words . size (); ++ i ) { string word = words [ i ]; reverse ( begin ( word ), end ( word )); map [ word ] = i ; } for ( int i = 0 ; i < words . size (); ++ i ) { const string & word = words [ i ]; // special case to prevent duplicate calculation if ( map . count ( \"\" ) && map [ \"\" ] != i && isPalindrome ( word )) ans . push_back ({ i , map [ \"\" ]}); for ( int j = 1 ; j <= word . length (); ++ j ) { const string & l = word . substr ( 0 , j ); const string & r = word . substr ( j ); if ( map . count ( l ) && map [ l ] != i && isPalindrome ( r )) ans . push_back ({ i , map [ l ]}); if ( map . count ( r ) && map [ r ] != i && isPalindrome ( l )) ans . push_back ({ map [ r ], i }); } } return ans ; } private : bool isPalindrome ( const string & word ) { int l = 0 ; int r = word . length () - 1 ; while ( l < r ) if ( word [ l ++ ] != word [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> palindromePairs ( String [] words ) { List < List < Integer >> ans = new ArrayList <> (); Map < String , Integer > map = new HashMap <> (); // {reversed word: its index} for ( int i = 0 ; i < words . length ; ++ i ) map . put ( new StringBuilder ( words [ i ] ). reverse (). toString (), i ); for ( int i = 0 ; i < words . length ; ++ i ) { final String word = words [ i ] ; // special case to prevent duplicate calculation if ( map . containsKey ( \"\" ) && map . get ( \"\" ) != i && isPalindrome ( word )) ans . add ( Arrays . asList ( i , map . get ( \"\" ))); for ( int j = 1 ; j <= word . length (); ++ j ) { final String l = word . substring ( 0 , j ); final String r = word . substring ( j ); if ( map . containsKey ( l ) && map . get ( l ) != i && isPalindrome ( r )) ans . add ( Arrays . asList ( i , map . get ( l ))); if ( map . containsKey ( r ) && map . get ( r ) != i && isPalindrome ( l )) ans . add ( Arrays . asList ( map . get ( r ), i )); } } return ans ; } private boolean isPalindrome ( final String word ) { int l = 0 ; int r = word . length () - 1 ; while ( l < r ) if ( word . charAt ( l ++ ) != word . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def palindromePairs ( self , words : List [ str ]) -> List [ List [ int ]]: ans = [] dict = { word [:: - 1 ]: i for i , word in enumerate ( words )} for i , word in enumerate ( words ): if \"\" in dict and dict [ \"\" ] != i and word == word [:: - 1 ]: ans . append ([ i , dict [ \"\" ]]) for j in range ( 1 , len ( word ) + 1 ): l = word [: j ] r = word [ j :] if l in dict and dict [ l ] != i and r == r [:: - 1 ]: ans . append ([ i , dict [ l ]]) if r in dict and dict [ r ] != i and l == l [:: - 1 ]: ans . append ([ dict [ r ], i ]) return ans","title":"336. Palindrome Pairs"},{"location":"problems/0336/#336-palindrome-pairs","text":"Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> palindromePairs ( vector < string >& words ) { vector < vector < int >> ans ; unordered_map < string , int > map ; // {reversed word: its index} for ( int i = 0 ; i < words . size (); ++ i ) { string word = words [ i ]; reverse ( begin ( word ), end ( word )); map [ word ] = i ; } for ( int i = 0 ; i < words . size (); ++ i ) { const string & word = words [ i ]; // special case to prevent duplicate calculation if ( map . count ( \"\" ) && map [ \"\" ] != i && isPalindrome ( word )) ans . push_back ({ i , map [ \"\" ]}); for ( int j = 1 ; j <= word . length (); ++ j ) { const string & l = word . substr ( 0 , j ); const string & r = word . substr ( j ); if ( map . count ( l ) && map [ l ] != i && isPalindrome ( r )) ans . push_back ({ i , map [ l ]}); if ( map . count ( r ) && map [ r ] != i && isPalindrome ( l )) ans . push_back ({ map [ r ], i }); } } return ans ; } private : bool isPalindrome ( const string & word ) { int l = 0 ; int r = word . length () - 1 ; while ( l < r ) if ( word [ l ++ ] != word [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public List < List < Integer >> palindromePairs ( String [] words ) { List < List < Integer >> ans = new ArrayList <> (); Map < String , Integer > map = new HashMap <> (); // {reversed word: its index} for ( int i = 0 ; i < words . length ; ++ i ) map . put ( new StringBuilder ( words [ i ] ). reverse (). toString (), i ); for ( int i = 0 ; i < words . length ; ++ i ) { final String word = words [ i ] ; // special case to prevent duplicate calculation if ( map . containsKey ( \"\" ) && map . get ( \"\" ) != i && isPalindrome ( word )) ans . add ( Arrays . asList ( i , map . get ( \"\" ))); for ( int j = 1 ; j <= word . length (); ++ j ) { final String l = word . substring ( 0 , j ); final String r = word . substring ( j ); if ( map . containsKey ( l ) && map . get ( l ) != i && isPalindrome ( r )) ans . add ( Arrays . asList ( i , map . get ( l ))); if ( map . containsKey ( r ) && map . get ( r ) != i && isPalindrome ( l )) ans . add ( Arrays . asList ( map . get ( r ), i )); } } return ans ; } private boolean isPalindrome ( final String word ) { int l = 0 ; int r = word . length () - 1 ; while ( l < r ) if ( word . charAt ( l ++ ) != word . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def palindromePairs ( self , words : List [ str ]) -> List [ List [ int ]]: ans = [] dict = { word [:: - 1 ]: i for i , word in enumerate ( words )} for i , word in enumerate ( words ): if \"\" in dict and dict [ \"\" ] != i and word == word [:: - 1 ]: ans . append ([ i , dict [ \"\" ]]) for j in range ( 1 , len ( word ) + 1 ): l = word [: j ] r = word [ j :] if l in dict and dict [ l ] != i and r == r [:: - 1 ]: ans . append ([ i , dict [ l ]]) if r in dict and dict [ r ] != i and l == l [:: - 1 ]: ans . append ([ dict [ r ], i ]) return ans","title":"336. Palindrome Pairs"},{"location":"problems/0337/","text":"337. House Robber III Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct T { int robRoot ; int notRobRoot ; }; class Solution { public : int rob ( TreeNode * root ) { const auto & [ robRoot , notRobRoot ] = robOrNotRob ( root ); return max ( robRoot , notRobRoot ); } private : T robOrNotRob ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; const T l = robOrNotRob ( root -> left ); const T r = robOrNotRob ( root -> right ); return { root -> val + l . notRobRoot + r . notRobRoot , max ( l . robRoot , l . notRobRoot ) + max ( r . robRoot , r . notRobRoot )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class T { public int robRoot ; public int notRobRoot ; public T ( int robRoot , int notRobRoot ) { this . robRoot = robRoot ; this . notRobRoot = notRobRoot ; } } class Solution { public int rob ( TreeNode root ) { T t = robOrNotRob ( root ); return Math . max ( t . robRoot , t . notRobRoot ); } private T robOrNotRob ( TreeNode root ) { if ( root == null ) return new T ( 0 , 0 ); T l = robOrNotRob ( root . left ); T r = robOrNotRob ( root . right ); return new T ( root . val + l . notRobRoot + r . notRobRoot , Math . max ( l . robRoot , l . notRobRoot ) + Math . max ( r . robRoot , r . notRobRoot )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rob ( self , root : TreeNode ) -> int : def robOrNot ( root : TreeNode ) -> tuple : if not root : return ( 0 , 0 ) robLeft , notRobLeft = robOrNot ( root . left ) robRight , notRobRight = robOrNot ( root . right ) return ( root . val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )) return max ( robOrNot ( root ))","title":"337. House Robber III"},{"location":"problems/0337/#337-house-robber-iii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct T { int robRoot ; int notRobRoot ; }; class Solution { public : int rob ( TreeNode * root ) { const auto & [ robRoot , notRobRoot ] = robOrNotRob ( root ); return max ( robRoot , notRobRoot ); } private : T robOrNotRob ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; const T l = robOrNotRob ( root -> left ); const T r = robOrNotRob ( root -> right ); return { root -> val + l . notRobRoot + r . notRobRoot , max ( l . robRoot , l . notRobRoot ) + max ( r . robRoot , r . notRobRoot )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class T { public int robRoot ; public int notRobRoot ; public T ( int robRoot , int notRobRoot ) { this . robRoot = robRoot ; this . notRobRoot = notRobRoot ; } } class Solution { public int rob ( TreeNode root ) { T t = robOrNotRob ( root ); return Math . max ( t . robRoot , t . notRobRoot ); } private T robOrNotRob ( TreeNode root ) { if ( root == null ) return new T ( 0 , 0 ); T l = robOrNotRob ( root . left ); T r = robOrNotRob ( root . right ); return new T ( root . val + l . notRobRoot + r . notRobRoot , Math . max ( l . robRoot , l . notRobRoot ) + Math . max ( r . robRoot , r . notRobRoot )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rob ( self , root : TreeNode ) -> int : def robOrNot ( root : TreeNode ) -> tuple : if not root : return ( 0 , 0 ) robLeft , notRobLeft = robOrNot ( root . left ) robRight , notRobRight = robOrNot ( root . right ) return ( root . val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )) return max ( robOrNot ( root ))","title":"337. House Robber III"},{"location":"problems/0338/","text":"338. Counting Bits Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > countBits ( int num ) { // let f(i) := i's # of 1's in binary representation // f(i) = f(i / 2) + i % 2 vector < int > ans ( num + 1 ); for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i / 2 ] + ( i & 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int [] countBits ( int num ) { // let f(i) := i's # of 1's in binary representation // f(i) = f(i / 2) + i % 2 int [] ans = new int [ num + 1 ] ; for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i / 2 ] + ( i % 2 == 0 ? 0 : 1 ); return ans ; } }","title":"338. Counting Bits"},{"location":"problems/0338/#338-counting-bits","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > countBits ( int num ) { // let f(i) := i's # of 1's in binary representation // f(i) = f(i / 2) + i % 2 vector < int > ans ( num + 1 ); for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i / 2 ] + ( i & 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int [] countBits ( int num ) { // let f(i) := i's # of 1's in binary representation // f(i) = f(i / 2) + i % 2 int [] ans = new int [ num + 1 ] ; for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i / 2 ] + ( i % 2 == 0 ? 0 : 1 ); return ans ; } }","title":"338. Counting Bits"},{"location":"problems/0339/","text":"339. Nested List Weight Sum \ud83d\udd12 Approach 1: BFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int depthSum ( vector < NestedInteger >& nestedList ) { int ans = 0 ; int depth = 1 ; queue < NestedInteger > q ; auto addInteger = [ & ]( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else q . push ( ni ); }; addInteger ( nestedList ); while ( ! q . empty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { const auto ni = q . front (); q . pop (); addInteger ( ni . getList ()); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int depthSum ( List < NestedInteger > nestedList ) { int depth = 1 ; Queue < NestedInteger > q = new LinkedList <> (); addInteger ( nestedList , q , depth ); while ( ! q . isEmpty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { final NestedInteger ni = q . poll (); addInteger ( ni . getList (), q , depth ); } } return ans ; } private int ans = 0 ; private void addInteger ( final List < NestedInteger > nestedList , Queue < NestedInteger > q , int depth ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else q . offer ( ni ); } } Approach 2: DFS Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int depthSum ( vector < NestedInteger >& nestedList ) { int ans = 0 ; addInteger ( nestedList , 1 , ans ); return ans ; } private : void addInteger ( const vector < NestedInteger >& nestedList , int depth , int & ans ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else addInteger ( ni . getList (), depth + 1 , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int depthSum ( List < NestedInteger > nestedList ) { dfs ( nestedList , 1 ); return ans ; } private int ans = 0 ; private void dfs ( final List < NestedInteger > nestedList , int depth ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else dfs ( ni . getList (), depth + 1 ); } }","title":"339. Nested List Weight Sum"},{"location":"problems/0339/#339-nested-list-weight-sum","text":"","title":"339. Nested List Weight Sum \ud83d\udd12"},{"location":"problems/0339/#approach-1-bfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int depthSum ( vector < NestedInteger >& nestedList ) { int ans = 0 ; int depth = 1 ; queue < NestedInteger > q ; auto addInteger = [ & ]( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else q . push ( ni ); }; addInteger ( nestedList ); while ( ! q . empty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { const auto ni = q . front (); q . pop (); addInteger ( ni . getList ()); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int depthSum ( List < NestedInteger > nestedList ) { int depth = 1 ; Queue < NestedInteger > q = new LinkedList <> (); addInteger ( nestedList , q , depth ); while ( ! q . isEmpty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { final NestedInteger ni = q . poll (); addInteger ( ni . getList (), q , depth ); } } return ans ; } private int ans = 0 ; private void addInteger ( final List < NestedInteger > nestedList , Queue < NestedInteger > q , int depth ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else q . offer ( ni ); } }","title":"Approach 1: BFS"},{"location":"problems/0339/#approach-2-dfs","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int depthSum ( vector < NestedInteger >& nestedList ) { int ans = 0 ; addInteger ( nestedList , 1 , ans ); return ans ; } private : void addInteger ( const vector < NestedInteger >& nestedList , int depth , int & ans ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else addInteger ( ni . getList (), depth + 1 , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int depthSum ( List < NestedInteger > nestedList ) { dfs ( nestedList , 1 ); return ans ; } private int ans = 0 ; private void dfs ( final List < NestedInteger > nestedList , int depth ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) ans += ni . getInteger () * depth ; else dfs ( ni . getList (), depth + 1 ); } }","title":"Approach 2: DFS"},{"location":"problems/0340/","text":"340. Longest Substring with At Most K Distinct Characters \ud83d\udd12 Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int lengthOfLongestSubstringKDistinct ( string s , int k ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s [ r ]] == 1 ) -- k ; while ( k == -1 ) if ( -- count [ s [ l ++ ]] == 0 ) ++ k ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int lengthOfLongestSubstringKDistinct ( String s , int k ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) -- k ; while ( k == - 1 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) ++ k ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"340. Longest Substring with At Most K Distinct Characters"},{"location":"problems/0340/#340-longest-substring-with-at-most-k-distinct-characters","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int lengthOfLongestSubstringKDistinct ( string s , int k ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s [ r ]] == 1 ) -- k ; while ( k == -1 ) if ( -- count [ s [ l ++ ]] == 0 ) ++ k ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int lengthOfLongestSubstringKDistinct ( String s , int k ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( ++ count [ s . charAt ( r ) ] == 1 ) -- k ; while ( k == - 1 ) if ( -- count [ s . charAt ( l ++ ) ] == 0 ) ++ k ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"340. Longest Substring with At Most K Distinct Characters \ud83d\udd12"},{"location":"problems/0341/","text":"341. Flatten Nested List Iterator Approach 1: Recursive (Queue) Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { const int num = q . front (); q . pop (); return num ; } bool hasNext () { return ! q . empty (); } private : queue < int > q ; void addInteger ( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) q . push ( ni . getInteger ()); else addInteger ( ni . getList ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class NestedIterator implements Iterator < Integer > { public NestedIterator ( List < NestedInteger > nestedList ) { addInteger ( nestedList ); } @Override public Integer next () { return q . poll (); } @Override public boolean hasNext () { return ! q . isEmpty (); } private Queue < Integer > q = new LinkedList <> (); private void addInteger ( final List < NestedInteger > nestedList ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) q . offer ( ni . getInteger ()); else addInteger ( ni . getList ()); } } Approach 2: Stack Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { const int num = stack . top (). getInteger (); stack . pop (); return num ; } bool hasNext () { while ( ! stack . empty () && ! stack . top (). isInteger ()) { vector < NestedInteger > nestedList = stack . top (). getList (); stack . pop (); addInteger ( nestedList ); } return ! stack . empty (); } private : stack < NestedInteger > stack ; // addInteger([1, [4, [6]]]) -> stack = [[4, [6]], 1] // addInteger([4, [6]]) -> stack = [[6], 4] // addInteger([6]) -> stack = [6] void addInteger ( const vector < NestedInteger >& nestedList ) { for ( int i = nestedList . size () - 1 ; i >= 0 ; -- i ) stack . push ( nestedList [ i ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class NestedIterator implements Iterator < Integer > { public NestedIterator ( List < NestedInteger > nestedList ) { addInteger ( nestedList ); } @Override public Integer next () { return stack . pop (). getInteger (); } @Override public boolean hasNext () { while ( ! stack . isEmpty () && ! stack . peek (). isInteger ()) { final NestedInteger ni = stack . pop (); addInteger ( ni . getList ()); } return ! stack . isEmpty (); } private Stack < NestedInteger > stack = new Stack <> (); // addInteger([1, [4, [6]]]) -> stack = [[4, [6]], 1] // addInteger([4, [6]]) -> stack = [[6], 4] // addInteger([6]) -> stack = [6] private void addInteger ( final List < NestedInteger > nestedList ) { for ( int i = nestedList . size () - 1 ; i >= 0 ; -- i ) stack . push ( nestedList . get ( i )); } }","title":"341. Flatten Nested List Iterator"},{"location":"problems/0341/#341-flatten-nested-list-iterator","text":"","title":"341. Flatten Nested List Iterator"},{"location":"problems/0341/#approach-1-recursive-queue","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { const int num = q . front (); q . pop (); return num ; } bool hasNext () { return ! q . empty (); } private : queue < int > q ; void addInteger ( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger & ni : nestedList ) if ( ni . isInteger ()) q . push ( ni . getInteger ()); else addInteger ( ni . getList ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class NestedIterator implements Iterator < Integer > { public NestedIterator ( List < NestedInteger > nestedList ) { addInteger ( nestedList ); } @Override public Integer next () { return q . poll (); } @Override public boolean hasNext () { return ! q . isEmpty (); } private Queue < Integer > q = new LinkedList <> (); private void addInteger ( final List < NestedInteger > nestedList ) { for ( final NestedInteger ni : nestedList ) if ( ni . isInteger ()) q . offer ( ni . getInteger ()); else addInteger ( ni . getList ()); } }","title":"Approach 1: Recursive (Queue)"},{"location":"problems/0341/#approach-2-stack","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { const int num = stack . top (). getInteger (); stack . pop (); return num ; } bool hasNext () { while ( ! stack . empty () && ! stack . top (). isInteger ()) { vector < NestedInteger > nestedList = stack . top (). getList (); stack . pop (); addInteger ( nestedList ); } return ! stack . empty (); } private : stack < NestedInteger > stack ; // addInteger([1, [4, [6]]]) -> stack = [[4, [6]], 1] // addInteger([4, [6]]) -> stack = [[6], 4] // addInteger([6]) -> stack = [6] void addInteger ( const vector < NestedInteger >& nestedList ) { for ( int i = nestedList . size () - 1 ; i >= 0 ; -- i ) stack . push ( nestedList [ i ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class NestedIterator implements Iterator < Integer > { public NestedIterator ( List < NestedInteger > nestedList ) { addInteger ( nestedList ); } @Override public Integer next () { return stack . pop (). getInteger (); } @Override public boolean hasNext () { while ( ! stack . isEmpty () && ! stack . peek (). isInteger ()) { final NestedInteger ni = stack . pop (); addInteger ( ni . getList ()); } return ! stack . isEmpty (); } private Stack < NestedInteger > stack = new Stack <> (); // addInteger([1, [4, [6]]]) -> stack = [[4, [6]], 1] // addInteger([4, [6]]) -> stack = [[6], 4] // addInteger([6]) -> stack = [6] private void addInteger ( final List < NestedInteger > nestedList ) { for ( int i = nestedList . size () - 1 ; i >= 0 ; -- i ) stack . push ( nestedList . get ( i )); } }","title":"Approach 2: Stack"},{"location":"problems/0342/","text":"342. Power of Four Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool isPowerOfFour ( int num ) { // Why (4^n - 1) % 3 == 0? // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are // three consecutive numbers; among one of them, there must be a multiple // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1. // Therefore, 4^n - 1 is a multiple of 3. return num > 0 && __builtin_popcountll ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isPowerOfFour ( int num ) { // Why (4^n - 1) % 3 == 0? // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are // three consecutive numbers; among one of them, there must be a multiple // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1. // Therefore, 4^n - 1 is a multiple of 3 return num > 0 && Integer . bitCount ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } }","title":"342. Power of Four"},{"location":"problems/0342/#342-power-of-four","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool isPowerOfFour ( int num ) { // Why (4^n - 1) % 3 == 0? // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are // three consecutive numbers; among one of them, there must be a multiple // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1. // Therefore, 4^n - 1 is a multiple of 3. return num > 0 && __builtin_popcountll ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isPowerOfFour ( int num ) { // Why (4^n - 1) % 3 == 0? // (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are // three consecutive numbers; among one of them, there must be a multiple // of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1. // Therefore, 4^n - 1 is a multiple of 3 return num > 0 && Integer . bitCount ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } }","title":"342. Power of Four"},{"location":"problems/0343/","text":"343. Integer Break Time: $O(n / 3)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int integerBreak ( int n ) { // If an optimal product contains a factor f >= 4, then we can replace it // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f, // we never need a factor >= 4, meaning we only need factors 1, 2, and 3 // (and 1 is wasteful). // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice. if ( n == 2 ) return 1 ; // 1 * 1 if ( n == 3 ) return 2 ; // 1 * 2 int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int integerBreak ( int n ) { // If an optimal product contains a factor f >= 4, then we can replace it // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f, // we never need a factor >= 4, meaning we only need factors 1, 2, and 3 // (and 1 is wasteful). // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice. if ( n == 2 ) return 1 ; // 1 * 1 if ( n == 3 ) return 2 ; // 1 * 2 int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def integerBreak ( self , n : int ) -> int : if n == 2 : return 1 if n == 3 : return 2 ans = 1 while n > 4 : n -= 3 ans *= 3 ans *= n return ans","title":"343. Integer Break"},{"location":"problems/0343/#343-integer-break","text":"Time: $O(n / 3)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int integerBreak ( int n ) { // If an optimal product contains a factor f >= 4, then we can replace it // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f, // we never need a factor >= 4, meaning we only need factors 1, 2, and 3 // (and 1 is wasteful). // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice. if ( n == 2 ) return 1 ; // 1 * 1 if ( n == 3 ) return 2 ; // 1 * 2 int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int integerBreak ( int n ) { // If an optimal product contains a factor f >= 4, then we can replace it // with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f, // we never need a factor >= 4, meaning we only need factors 1, 2, and 3 // (and 1 is wasteful). // Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice. if ( n == 2 ) return 1 ; // 1 * 1 if ( n == 3 ) return 2 ; // 1 * 2 int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def integerBreak ( self , n : int ) -> int : if n == 2 : return 1 if n == 3 : return 2 ans = 1 while n > 4 : n -= 3 ans *= 3 ans *= n return ans","title":"343. Integer Break"},{"location":"problems/0344/","text":"344. Reverse String Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : void reverseString ( vector < char >& s ) { int l = 0 ; int r = s . size () - 1 ; while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public void reverseString ( char [] s ) { int l = 0 ; int r = s . length - 1 ; while ( l < r ) { char temp = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = temp ; } } } Python 1 2 3 4 5 6 7 8 9 class Solution : def reverseString ( self , s : List [ str ]) -> None : l = 0 r = len ( s ) - 1 while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1","title":"344. Reverse String"},{"location":"problems/0344/#344-reverse-string","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : void reverseString ( vector < char >& s ) { int l = 0 ; int r = s . size () - 1 ; while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public void reverseString ( char [] s ) { int l = 0 ; int r = s . length - 1 ; while ( l < r ) { char temp = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = temp ; } } } Python 1 2 3 4 5 6 7 8 9 class Solution : def reverseString ( self , s : List [ str ]) -> None : l = 0 r = len ( s ) - 1 while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1","title":"344. Reverse String"},{"location":"problems/0345/","text":"345. Reverse Vowels of a String Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string reverseVowels ( string s ) { const unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . count ( s [ l ])) ++ l ; while ( l < r && ! vowels . count ( s [ r ])) -- r ; swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String reverseVowels ( String s ) { final String vowels = \"aeiouAEIOU\" ; StringBuilder sb = new StringBuilder ( s ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . contains ( \"\" + sb . charAt ( l ))) ++ l ; while ( l < r && ! vowels . contains ( \"\" + sb . charAt ( r ))) -- r ; sb . setCharAt ( l , s . charAt ( r )); sb . setCharAt ( r , s . charAt ( l )); ++ l ; -- r ; } return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def reverseVowels ( self , s : str ) -> str : charList = list ( s ) vowels = { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' } l = 0 r = len ( s ) - 1 while l < r : while l < r and charList [ l ] not in vowels : l += 1 while l < r and charList [ r ] not in vowels : r -= 1 charList [ l ], charList [ r ] = charList [ r ], charList [ l ] l += 1 r -= 1 return '' . join ( charList )","title":"345. Reverse Vowels of a String"},{"location":"problems/0345/#345-reverse-vowels-of-a-string","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string reverseVowels ( string s ) { const unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . count ( s [ l ])) ++ l ; while ( l < r && ! vowels . count ( s [ r ])) -- r ; swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String reverseVowels ( String s ) { final String vowels = \"aeiouAEIOU\" ; StringBuilder sb = new StringBuilder ( s ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . contains ( \"\" + sb . charAt ( l ))) ++ l ; while ( l < r && ! vowels . contains ( \"\" + sb . charAt ( r ))) -- r ; sb . setCharAt ( l , s . charAt ( r )); sb . setCharAt ( r , s . charAt ( l )); ++ l ; -- r ; } return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def reverseVowels ( self , s : str ) -> str : charList = list ( s ) vowels = { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' } l = 0 r = len ( s ) - 1 while l < r : while l < r and charList [ l ] not in vowels : l += 1 while l < r and charList [ r ] not in vowels : r -= 1 charList [ l ], charList [ r ] = charList [ r ], charList [ l ] l += 1 r -= 1 return '' . join ( charList )","title":"345. Reverse Vowels of a String"},{"location":"problems/0346/","text":"346. Moving Average from Data Stream \ud83d\udd12 Time: $O(1)$ Space: $O(size)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MovingAverage { public : MovingAverage ( int size ) : size ( size ) {} double next ( int val ) { if ( q . size () == size ) sum -= q . front (), q . pop (); sum += val ; q . push ( val ); return sum / q . size (); } private : int size ; double sum = 0 ; queue < int > q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MovingAverage { public MovingAverage ( int size ) { this . size = size ; } public double next ( int val ) { if ( q . size () == size ) sum -= q . poll (); sum += val ; q . offer ( val ); return sum / q . size (); } private int size = 0 ; private double sum = 0 ; private Queue < Integer > q = new LinkedList <> (); }","title":"346. Moving Average from Data Stream"},{"location":"problems/0346/#346-moving-average-from-data-stream","text":"Time: $O(1)$ Space: $O(size)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MovingAverage { public : MovingAverage ( int size ) : size ( size ) {} double next ( int val ) { if ( q . size () == size ) sum -= q . front (), q . pop (); sum += val ; q . push ( val ); return sum / q . size (); } private : int size ; double sum = 0 ; queue < int > q ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MovingAverage { public MovingAverage ( int size ) { this . size = size ; } public double next ( int val ) { if ( q . size () == size ) sum -= q . poll (); sum += val ; q . offer ( val ); return sum / q . size (); } private int size = 0 ; private double sum = 0 ; private Queue < Integer > q = new LinkedList <> (); }","title":"346. Moving Average from Data Stream \ud83d\udd12"},{"location":"problems/0347/","text":"347. Top K Frequent Elements Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { const int n = nums . size (); vector < int > ans ; vector < vector < int >> bucket ( n + 1 ); unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) bucket [ freq ]. push_back ( num ); for ( int freq = n ; freq > 0 ; -- freq ) { for ( const int num : bucket [ freq ]) ans . push_back ( num ); if ( ans . size () == k ) return ans ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [] topKFrequent ( int [] nums , int k ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); List < Integer >[] bucket = new List [ n + 1 ] ; Map < Integer , Integer > count = new HashMap <> (); for ( final int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( final int num : count . keySet ()) { final int freq = count . get ( num ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( num ); } for ( int freq = n ; freq > 0 ; -- freq ) { if ( bucket [ freq ] != null ) ans . addAll ( bucket [ freq ] ); if ( ans . size () == k ) return ans . stream (). mapToInt ( i -> i ). toArray (); } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] bucket = [[] for _ in range ( len ( nums ) + 1 )] for num , freq in collections . Counter ( nums ) . items (): bucket [ freq ] . append ( num ) for b in bucket [:: - 1 ]: ans += b if len ( ans ) == k : return ans","title":"347. Top K Frequent Elements"},{"location":"problems/0347/#347-top-k-frequent-elements","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { const int n = nums . size (); vector < int > ans ; vector < vector < int >> bucket ( n + 1 ); unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) bucket [ freq ]. push_back ( num ); for ( int freq = n ; freq > 0 ; -- freq ) { for ( const int num : bucket [ freq ]) ans . push_back ( num ); if ( ans . size () == k ) return ans ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [] topKFrequent ( int [] nums , int k ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); List < Integer >[] bucket = new List [ n + 1 ] ; Map < Integer , Integer > count = new HashMap <> (); for ( final int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( final int num : count . keySet ()) { final int freq = count . get ( num ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( num ); } for ( int freq = n ; freq > 0 ; -- freq ) { if ( bucket [ freq ] != null ) ans . addAll ( bucket [ freq ] ); if ( ans . size () == k ) return ans . stream (). mapToInt ( i -> i ). toArray (); } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] bucket = [[] for _ in range ( len ( nums ) + 1 )] for num , freq in collections . Counter ( nums ) . items (): bucket [ freq ] . append ( num ) for b in bucket [:: - 1 ]: ans += b if len ( ans ) == k : return ans","title":"347. Top K Frequent Elements"},{"location":"problems/0348/","text":"348. Design Tic-Tac-Toe \ud83d\udd12 Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class TicTacToe { public : TicTacToe ( int n ) : n ( n ), rows ( n ), cols ( n ) {} /** Player {player} makes a move at ({row}, {col}). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ int move ( int row , int col , int player ) { const int toAdd = player == 1 ? 1 : -1 ; const int target = player == 1 ? n : - n ; if ( row == col ) { diagonal += toAdd ; if ( diagonal == target ) return player ; } if ( row + col == n - 1 ) { antiDiagonal += toAdd ; if ( antiDiagonal == target ) return player ; } rows [ row ] += toAdd ; if ( rows [ row ] == target ) return player ; cols [ col ] += toAdd ; if ( cols [ col ] == target ) return player ; return 0 ; } private : int n ; // record count('X') - count('O') vector < int > rows ; vector < int > cols ; int diagonal = 0 ; int antiDiagonal = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class TicTacToe { public TicTacToe ( int n ) { this . n = n ; rows = new int [ n ] ; cols = new int [ n ] ; } /** * Player {player} makes a move at ({row}, {col}). * * @param row The row of the board. * @param col The column of the board. * @param player The player, can be either 1 or 2. * @return The current winning condition, can be either: 0: No one wins. 1: * Player 1 wins. 2: Player 2 wins. */ public int move ( int row , int col , int player ) { final int toAdd = player == 1 ? 1 : - 1 ; final int target = player == 1 ? n : - n ; if ( row == col ) { diagonal += toAdd ; if ( diagonal == target ) return player ; } if ( row + col == n - 1 ) { antiDiagonal += toAdd ; if ( antiDiagonal == target ) return player ; } rows [ row ] += toAdd ; if ( rows [ row ] == target ) return player ; cols [ col ] += toAdd ; if ( cols [ col ] == target ) return player ; return 0 ; } private int n ; // record count('X') - count('O') private int [] rows ; private int [] cols ; private int diagonal = 0 ; private int antiDiagonal = 0 ; }","title":"348. Design Tic-Tac-Toe"},{"location":"problems/0348/#348-design-tic-tac-toe","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class TicTacToe { public : TicTacToe ( int n ) : n ( n ), rows ( n ), cols ( n ) {} /** Player {player} makes a move at ({row}, {col}). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ int move ( int row , int col , int player ) { const int toAdd = player == 1 ? 1 : -1 ; const int target = player == 1 ? n : - n ; if ( row == col ) { diagonal += toAdd ; if ( diagonal == target ) return player ; } if ( row + col == n - 1 ) { antiDiagonal += toAdd ; if ( antiDiagonal == target ) return player ; } rows [ row ] += toAdd ; if ( rows [ row ] == target ) return player ; cols [ col ] += toAdd ; if ( cols [ col ] == target ) return player ; return 0 ; } private : int n ; // record count('X') - count('O') vector < int > rows ; vector < int > cols ; int diagonal = 0 ; int antiDiagonal = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class TicTacToe { public TicTacToe ( int n ) { this . n = n ; rows = new int [ n ] ; cols = new int [ n ] ; } /** * Player {player} makes a move at ({row}, {col}). * * @param row The row of the board. * @param col The column of the board. * @param player The player, can be either 1 or 2. * @return The current winning condition, can be either: 0: No one wins. 1: * Player 1 wins. 2: Player 2 wins. */ public int move ( int row , int col , int player ) { final int toAdd = player == 1 ? 1 : - 1 ; final int target = player == 1 ? n : - n ; if ( row == col ) { diagonal += toAdd ; if ( diagonal == target ) return player ; } if ( row + col == n - 1 ) { antiDiagonal += toAdd ; if ( antiDiagonal == target ) return player ; } rows [ row ] += toAdd ; if ( rows [ row ] == target ) return player ; cols [ col ] += toAdd ; if ( cols [ col ] == target ) return player ; return 0 ; } private int n ; // record count('X') - count('O') private int [] rows ; private int [] cols ; private int diagonal = 0 ; private int antiDiagonal = 0 ; }","title":"348. Design Tic-Tac-Toe \ud83d\udd12"},{"location":"problems/0349/","text":"349. Intersection of Two Arrays Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_set < int > set { begin ( nums1 ), end ( nums1 )}; for ( const int num : nums2 ) if ( set . erase ( num )) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Set < Integer > set = new HashSet <> (); for ( final int num : nums1 ) set . add ( num ); for ( final int num : nums2 ) if ( set . remove ( num )) ans . add ( num ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def intersection ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] nums1 = set ( nums1 ) for num in nums2 : if num in nums1 : ans . append ( num ) nums1 . remove ( num ) return ans","title":"349. Intersection of Two Arrays"},{"location":"problems/0349/#349-intersection-of-two-arrays","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_set < int > set { begin ( nums1 ), end ( nums1 )}; for ( const int num : nums2 ) if ( set . erase ( num )) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Set < Integer > set = new HashSet <> (); for ( final int num : nums1 ) set . add ( num ); for ( final int num : nums2 ) if ( set . remove ( num )) ans . add ( num ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def intersection ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] nums1 = set ( nums1 ) for num in nums2 : if num in nums1 : ans . append ( num ) nums1 . remove ( num ) return ans","title":"349. Intersection of Two Arrays"},{"location":"problems/0350/","text":"350. Intersection of Two Arrays II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > count ; for ( const int num : nums1 ) ++ count [ num ]; for ( const int num : nums2 ) if ( count . count ( num ) && count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] intersect ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); for ( final int num : nums1 ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( final int num : nums2 ) if ( count . containsKey ( num ) && count . get ( num ) > 0 ) { ans . add ( num ); count . put ( num , count . get ( num ) - 1 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def intersect ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] count = collections . Counter ( nums1 ) for num in nums2 : if count [ num ] > 0 : ans . append ( num ) count [ num ] -= 1 return ans","title":"350. Intersection of Two Arrays II"},{"location":"problems/0350/#350-intersection-of-two-arrays-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > count ; for ( const int num : nums1 ) ++ count [ num ]; for ( const int num : nums2 ) if ( count . count ( num ) && count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] intersect ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); for ( final int num : nums1 ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( final int num : nums2 ) if ( count . containsKey ( num ) && count . get ( num ) > 0 ) { ans . add ( num ); count . put ( num , count . get ( num ) - 1 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def intersect ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] count = collections . Counter ( nums1 ) for num in nums2 : if count [ num ] > 0 : ans . append ( num ) count [ num ] -= 1 return ans","title":"350. Intersection of Two Arrays II"},{"location":"problems/0351/","text":"351. Android Unlock Patterns \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int numberOfPatterns ( int m , int n ) { int ans = 0 ; vector < vector < int >> across ( 10 , vector < int > ( 10 )); vector < bool > seen ( 10 ); // set across numbers across [ 1 ][ 3 ] = across [ 3 ][ 1 ] = 2 ; across [ 1 ][ 7 ] = across [ 7 ][ 1 ] = 4 ; across [ 3 ][ 9 ] = across [ 9 ][ 3 ] = 6 ; across [ 7 ][ 9 ] = across [ 9 ][ 7 ] = 8 ; across [ 1 ][ 9 ] = across [ 9 ][ 1 ] = across [ 2 ][ 8 ] = across [ 8 ][ 2 ] = across [ 3 ][ 7 ] = across [ 7 ][ 3 ] = across [ 4 ][ 6 ] = across [ 6 ][ 4 ] = 5 ; // [m, n] moves are valid function < int ( int , int ) > dfs = [ & ]( int curr , int level ) { if ( level > n ) return 0 ; int ans = level >= m ? 1 : 0 ; seen [ curr ] = true ; for ( int next = 1 ; next <= 9 ; ++ next ) { if ( next == curr || seen [ next ]) continue ; const int acrossed = across [ curr ][ next ]; if ( acrossed == 0 || seen [ acrossed ]) ans += dfs ( next , level + 1 ); } seen [ curr ] = false ; return ans ; }; ans += dfs ( 1 , 1 ) * 4 ; // 1, 3, 7, 9 are symmetric ans += dfs ( 2 , 1 ) * 4 ; // 2, 4, 6, 8 are symmetric ans += dfs ( 5 , 1 ); // 5 return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int numberOfPatterns ( int m , int n ) { int ans = 0 ; int [][] across = new int [ 10 ][ 10 ] ; boolean [] seen = new boolean [ 10 ] ; // set across numbers across [ 1 ][ 3 ] = across [ 3 ][ 1 ] = 2 ; across [ 1 ][ 7 ] = across [ 7 ][ 1 ] = 4 ; across [ 3 ][ 9 ] = across [ 9 ][ 3 ] = 6 ; across [ 7 ][ 9 ] = across [ 9 ][ 7 ] = 8 ; across [ 1 ][ 9 ] = across [ 9 ][ 1 ] = across [ 2 ][ 8 ] = across [ 8 ][ 2 ] = across [ 3 ][ 7 ] = across [ 7 ][ 3 ] = across [ 4 ][ 6 ] = across [ 6 ][ 4 ] = 5 ; ans += dfs ( m , n , 1 , 1 , seen , across ) * 4 ; // 1, 3, 7, 9 are symmetric ans += dfs ( m , n , 2 , 1 , seen , across ) * 4 ; // 2, 4, 6, 8 are symmetric ans += dfs ( m , n , 5 , 1 , seen , across ); // 5 return ans ; } // [m, n] moves are valid private int dfs ( int m , int n , int curr , int level , boolean [] seen , int [][] across ) { if ( level > n ) return 0 ; seen [ curr ] = true ; int ans = level >= m ? 1 : 0 ; for ( int next = 1 ; next <= 9 ; ++ next ) { if ( next == curr || seen [ next ] ) continue ; final int acrossed = across [ curr ][ next ] ; if ( acrossed == 0 || seen [ acrossed ] ) ans += dfs ( m , n , next , level + 1 , seen , across ); } seen [ curr ] = false ; return ans ; } }","title":"351. Android Unlock Patterns"},{"location":"problems/0351/#351-android-unlock-patterns","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int numberOfPatterns ( int m , int n ) { int ans = 0 ; vector < vector < int >> across ( 10 , vector < int > ( 10 )); vector < bool > seen ( 10 ); // set across numbers across [ 1 ][ 3 ] = across [ 3 ][ 1 ] = 2 ; across [ 1 ][ 7 ] = across [ 7 ][ 1 ] = 4 ; across [ 3 ][ 9 ] = across [ 9 ][ 3 ] = 6 ; across [ 7 ][ 9 ] = across [ 9 ][ 7 ] = 8 ; across [ 1 ][ 9 ] = across [ 9 ][ 1 ] = across [ 2 ][ 8 ] = across [ 8 ][ 2 ] = across [ 3 ][ 7 ] = across [ 7 ][ 3 ] = across [ 4 ][ 6 ] = across [ 6 ][ 4 ] = 5 ; // [m, n] moves are valid function < int ( int , int ) > dfs = [ & ]( int curr , int level ) { if ( level > n ) return 0 ; int ans = level >= m ? 1 : 0 ; seen [ curr ] = true ; for ( int next = 1 ; next <= 9 ; ++ next ) { if ( next == curr || seen [ next ]) continue ; const int acrossed = across [ curr ][ next ]; if ( acrossed == 0 || seen [ acrossed ]) ans += dfs ( next , level + 1 ); } seen [ curr ] = false ; return ans ; }; ans += dfs ( 1 , 1 ) * 4 ; // 1, 3, 7, 9 are symmetric ans += dfs ( 2 , 1 ) * 4 ; // 2, 4, 6, 8 are symmetric ans += dfs ( 5 , 1 ); // 5 return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int numberOfPatterns ( int m , int n ) { int ans = 0 ; int [][] across = new int [ 10 ][ 10 ] ; boolean [] seen = new boolean [ 10 ] ; // set across numbers across [ 1 ][ 3 ] = across [ 3 ][ 1 ] = 2 ; across [ 1 ][ 7 ] = across [ 7 ][ 1 ] = 4 ; across [ 3 ][ 9 ] = across [ 9 ][ 3 ] = 6 ; across [ 7 ][ 9 ] = across [ 9 ][ 7 ] = 8 ; across [ 1 ][ 9 ] = across [ 9 ][ 1 ] = across [ 2 ][ 8 ] = across [ 8 ][ 2 ] = across [ 3 ][ 7 ] = across [ 7 ][ 3 ] = across [ 4 ][ 6 ] = across [ 6 ][ 4 ] = 5 ; ans += dfs ( m , n , 1 , 1 , seen , across ) * 4 ; // 1, 3, 7, 9 are symmetric ans += dfs ( m , n , 2 , 1 , seen , across ) * 4 ; // 2, 4, 6, 8 are symmetric ans += dfs ( m , n , 5 , 1 , seen , across ); // 5 return ans ; } // [m, n] moves are valid private int dfs ( int m , int n , int curr , int level , boolean [] seen , int [][] across ) { if ( level > n ) return 0 ; seen [ curr ] = true ; int ans = level >= m ? 1 : 0 ; for ( int next = 1 ; next <= 9 ; ++ next ) { if ( next == curr || seen [ next ] ) continue ; final int acrossed = across [ curr ][ next ] ; if ( acrossed == 0 || seen [ acrossed ] ) ans += dfs ( m , n , next , level + 1 , seen , across ); } seen [ curr ] = false ; return ans ; } }","title":"351. Android Unlock Patterns \ud83d\udd12"},{"location":"problems/0352/","text":"352. Data Stream as Disjoint Intervals Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class SummaryRanges { public : void addNum ( int val ) { if ( map . count ( val )) return ; const int lo = lowerKey ( val ); const int hi = higherKey ( val ); // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]} if ( lo >= 0 && hi >= 0 && map [ lo ][ 1 ] + 1 == val && val + 1 == hi ) { map [ lo ][ 1 ] = map [ hi ][ 1 ]; map . erase ( hi ); // {lo, map[lo][1]} + val = {lo, val} // (prevent adding duplicate entry by using '>=' instead of '==') } else if ( lo >= 0 && map [ lo ][ 1 ] + 1 >= val ) { map [ lo ][ 1 ] = max ( map [ lo ][ 1 ], val ); } else if ( hi >= 0 && val + 1 == hi ) { // val + {hi, map[hi][1]} = {val, map[hi][1]} map [ val ] = { val , map [ hi ][ 1 ]}; map . erase ( hi ); } else { map [ val ] = { val , val }; } } vector < vector < int >> getIntervals () { vector < vector < int >> intervals ; for ( const auto & [ _ , interval ] : map ) intervals . push_back ( interval ); return intervals ; } private : map < int , vector < int >> map ; // {start: {start, end}} // maximum in map < key int lowerKey ( int key ) { auto it = map . lower_bound ( key ); // minimum in map >= key if ( it == begin ( map )) return -1 ; return ( -- it ) -> first ; } // minimum in map > key int higherKey ( int key ) { const auto it = map . upper_bound ( key ); // minimum in map > key if ( it == cend ( map )) return -1 ; return it -> first ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class SummaryRanges { public void addNum ( int val ) { if ( map . containsKey ( val )) return ; final Integer lo = map . lowerKey ( val ); // maximum in map < key final Integer hi = map . higherKey ( val ); // minimum in map > key // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]} if ( lo != null && hi != null && map . get ( lo ) [ 1 ] + 1 == val && val + 1 == hi ) { map . get ( lo ) [ 1 ] = map . get ( hi ) [ 1 ] ; map . remove ( hi ); // {lo, map.get(lo)[1]} + val = {lo, val} // (prevent adding duplicate entry by using '>=' instead of '==') } else if ( lo != null && map . get ( lo ) [ 1 ] + 1 >= val ) { map . get ( lo ) [ 1 ] = Math . max ( map . get ( lo ) [ 1 ] , val ); // val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]} } else if ( hi != null && val + 1 == hi ) { map . put ( val , new int [] { val , map . get ( hi ) [ 1 ] }); map . remove ( hi ); } else { map . put ( val , new int [] { val , val }); } } public int [][] getIntervals () { List < int []> intervals = new ArrayList <> ( map . values ()); return intervals . toArray ( new int [ intervals . size () ][] ); } // {start: {start, end}} private TreeMap < Integer , int []> map = new TreeMap <> (); }","title":"352. Data Stream as Disjoint Intervals"},{"location":"problems/0352/#352-data-stream-as-disjoint-intervals","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class SummaryRanges { public : void addNum ( int val ) { if ( map . count ( val )) return ; const int lo = lowerKey ( val ); const int hi = higherKey ( val ); // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]} if ( lo >= 0 && hi >= 0 && map [ lo ][ 1 ] + 1 == val && val + 1 == hi ) { map [ lo ][ 1 ] = map [ hi ][ 1 ]; map . erase ( hi ); // {lo, map[lo][1]} + val = {lo, val} // (prevent adding duplicate entry by using '>=' instead of '==') } else if ( lo >= 0 && map [ lo ][ 1 ] + 1 >= val ) { map [ lo ][ 1 ] = max ( map [ lo ][ 1 ], val ); } else if ( hi >= 0 && val + 1 == hi ) { // val + {hi, map[hi][1]} = {val, map[hi][1]} map [ val ] = { val , map [ hi ][ 1 ]}; map . erase ( hi ); } else { map [ val ] = { val , val }; } } vector < vector < int >> getIntervals () { vector < vector < int >> intervals ; for ( const auto & [ _ , interval ] : map ) intervals . push_back ( interval ); return intervals ; } private : map < int , vector < int >> map ; // {start: {start, end}} // maximum in map < key int lowerKey ( int key ) { auto it = map . lower_bound ( key ); // minimum in map >= key if ( it == begin ( map )) return -1 ; return ( -- it ) -> first ; } // minimum in map > key int higherKey ( int key ) { const auto it = map . upper_bound ( key ); // minimum in map > key if ( it == cend ( map )) return -1 ; return it -> first ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class SummaryRanges { public void addNum ( int val ) { if ( map . containsKey ( val )) return ; final Integer lo = map . lowerKey ( val ); // maximum in map < key final Integer hi = map . higherKey ( val ); // minimum in map > key // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]} if ( lo != null && hi != null && map . get ( lo ) [ 1 ] + 1 == val && val + 1 == hi ) { map . get ( lo ) [ 1 ] = map . get ( hi ) [ 1 ] ; map . remove ( hi ); // {lo, map.get(lo)[1]} + val = {lo, val} // (prevent adding duplicate entry by using '>=' instead of '==') } else if ( lo != null && map . get ( lo ) [ 1 ] + 1 >= val ) { map . get ( lo ) [ 1 ] = Math . max ( map . get ( lo ) [ 1 ] , val ); // val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]} } else if ( hi != null && val + 1 == hi ) { map . put ( val , new int [] { val , map . get ( hi ) [ 1 ] }); map . remove ( hi ); } else { map . put ( val , new int [] { val , val }); } } public int [][] getIntervals () { List < int []> intervals = new ArrayList <> ( map . values ()); return intervals . toArray ( new int [ intervals . size () ][] ); } // {start: {start, end}} private TreeMap < Integer , int []> map = new TreeMap <> (); }","title":"352. Data Stream as Disjoint Intervals"},{"location":"problems/0353/","text":"353. Design Snake Game \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SnakeGame { public : SnakeGame ( int width , int height , vector < vector < int >>& food ) : width ( width ), height ( height ), food ( food ) { lookup . insert ( getId ( 0 , 0 )); body . push_back ( getId ( 0 , 0 )); } int move ( string direction ) { // old head's position int i = body . front () / width ; int j = body . front () % width ; // update head's position and check if out of bound if ( direction == \"U\" && -- i < 0 ) return -1 ; else if ( direction == \"L\" && -- j < 0 ) return -1 ; else if ( direction == \"R\" && ++ j == width ) return -1 ; else if ( direction == \"D\" && ++ i == height ) return -1 ; const int newHead = getId ( i , j ); // case 1: eat food and increase size by 1 if ( k < food . size () && i == food [ k ][ 0 ] && j == food [ k ][ 1 ]) { lookup . insert ( newHead ); body . push_front ( newHead ); ++ k ; return ++ score ; } // case 2: new head != old tail and eat body! if ( newHead != body . back () && lookup . count ( newHead )) return -1 ; // case 3: normal case // remove old tail first (important), then add new head // because new head may be in old tail's position lookup . erase ( body . back ()); lookup . insert ( newHead ); body . pop_back (); body . push_front ( newHead ); return score ; } private : int width ; int height ; int score = 0 ; int k = 0 ; // food's index vector < vector < int >> food ; unordered_set < int > lookup ; deque < int > body ; // snake's body int getId ( int i , int j ) { return i * width + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class SnakeGame { public SnakeGame ( int width , int height , int [][] food ) { this . width = width ; this . height = height ; this . food = food ; lookup . add ( getId ( 0 , 0 )); body . offerLast ( getId ( 0 , 0 )); } public int move ( String direction ) { // old head's position int i = body . peekFirst () / width ; int j = body . peekFirst () % width ; // update head's position and check if out of bound if ( direction . equals ( \"U\" ) && -- i < 0 ) return - 1 ; else if ( direction . equals ( \"L\" ) && -- j < 0 ) return - 1 ; else if ( direction . equals ( \"R\" ) && ++ j == width ) return - 1 ; else if ( direction . equals ( \"D\" ) && ++ i == height ) return - 1 ; final int newHead = getId ( i , j ); // case 1: eat food and increase size by 1 if ( k < food . length && i == food [ k ][ 0 ] && j == food [ k ][ 1 ] ) { lookup . add ( newHead ); body . offerFirst ( newHead ); ++ k ; return ++ score ; } // case 2: new head != old tail and eat body! if ( newHead != body . peekLast () && lookup . contains ( newHead )) return - 1 ; // case 3: normal case // remove old tail first (important), then add new head // because new head may be in old tail's position lookup . remove ( body . peekLast ()); lookup . add ( newHead ); body . pollLast (); body . offerFirst ( newHead ); return score ; } private int width ; private int height ; private int score = 0 ; private int k = 0 ; // food's index private int [][] food ; private Set < Integer > lookup = new HashSet <> (); private Deque < Integer > body = new ArrayDeque <> (); // snake's body private int getId ( int i , int j ) { return i * width + j ; } }","title":"353. Design Snake Game"},{"location":"problems/0353/#353-design-snake-game","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class SnakeGame { public : SnakeGame ( int width , int height , vector < vector < int >>& food ) : width ( width ), height ( height ), food ( food ) { lookup . insert ( getId ( 0 , 0 )); body . push_back ( getId ( 0 , 0 )); } int move ( string direction ) { // old head's position int i = body . front () / width ; int j = body . front () % width ; // update head's position and check if out of bound if ( direction == \"U\" && -- i < 0 ) return -1 ; else if ( direction == \"L\" && -- j < 0 ) return -1 ; else if ( direction == \"R\" && ++ j == width ) return -1 ; else if ( direction == \"D\" && ++ i == height ) return -1 ; const int newHead = getId ( i , j ); // case 1: eat food and increase size by 1 if ( k < food . size () && i == food [ k ][ 0 ] && j == food [ k ][ 1 ]) { lookup . insert ( newHead ); body . push_front ( newHead ); ++ k ; return ++ score ; } // case 2: new head != old tail and eat body! if ( newHead != body . back () && lookup . count ( newHead )) return -1 ; // case 3: normal case // remove old tail first (important), then add new head // because new head may be in old tail's position lookup . erase ( body . back ()); lookup . insert ( newHead ); body . pop_back (); body . push_front ( newHead ); return score ; } private : int width ; int height ; int score = 0 ; int k = 0 ; // food's index vector < vector < int >> food ; unordered_set < int > lookup ; deque < int > body ; // snake's body int getId ( int i , int j ) { return i * width + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class SnakeGame { public SnakeGame ( int width , int height , int [][] food ) { this . width = width ; this . height = height ; this . food = food ; lookup . add ( getId ( 0 , 0 )); body . offerLast ( getId ( 0 , 0 )); } public int move ( String direction ) { // old head's position int i = body . peekFirst () / width ; int j = body . peekFirst () % width ; // update head's position and check if out of bound if ( direction . equals ( \"U\" ) && -- i < 0 ) return - 1 ; else if ( direction . equals ( \"L\" ) && -- j < 0 ) return - 1 ; else if ( direction . equals ( \"R\" ) && ++ j == width ) return - 1 ; else if ( direction . equals ( \"D\" ) && ++ i == height ) return - 1 ; final int newHead = getId ( i , j ); // case 1: eat food and increase size by 1 if ( k < food . length && i == food [ k ][ 0 ] && j == food [ k ][ 1 ] ) { lookup . add ( newHead ); body . offerFirst ( newHead ); ++ k ; return ++ score ; } // case 2: new head != old tail and eat body! if ( newHead != body . peekLast () && lookup . contains ( newHead )) return - 1 ; // case 3: normal case // remove old tail first (important), then add new head // because new head may be in old tail's position lookup . remove ( body . peekLast ()); lookup . add ( newHead ); body . pollLast (); body . offerFirst ( newHead ); return score ; } private int width ; private int height ; private int score = 0 ; private int k = 0 ; // food's index private int [][] food ; private Set < Integer > lookup = new HashSet <> (); private Deque < Integer > body = new ArrayDeque <> (); // snake's body private int getId ( int i , int j ) { return i * width + j ; } }","title":"353. Design Snake Game \ud83d\udd12"},{"location":"problems/0354/","text":"354. Russian Doll Envelopes Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { sort ( begin ( envelopes ), end ( envelopes ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); // same as 300. Longest Increasing Subsequence int ans = 0 ; vector < int > dp ( envelopes . size ()); for ( const vector < int >& e : envelopes ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < e [ 1 ]) l = m + 1 ; else r = m ; } dp [ l ] = e [ 1 ]; if ( l == ans ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxEnvelopes ( int [][] envelopes ) { Arrays . sort ( envelopes , ( a , b ) -> a [ 0 ] == b [ 0 ] ? b [ 1 ] - a [ 1 ] : a [ 0 ] - b [ 0 ] ); // same as 300. Longest Increasing Subsequence int ans = 0 ; int [] dp = new int [ envelopes . length ] ; for ( final int [] e : envelopes ) { int i = Arrays . binarySearch ( dp , 0 , ans , e [ 1 ] ); if ( i < 0 ) i = - ( i + 1 ); dp [ i ] = e [ 1 ] ; if ( i == ans ) ++ ans ; } return ans ; } }","title":"354. Russian Doll Envelopes"},{"location":"problems/0354/#354-russian-doll-envelopes","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { sort ( begin ( envelopes ), end ( envelopes ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); // same as 300. Longest Increasing Subsequence int ans = 0 ; vector < int > dp ( envelopes . size ()); for ( const vector < int >& e : envelopes ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < e [ 1 ]) l = m + 1 ; else r = m ; } dp [ l ] = e [ 1 ]; if ( l == ans ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxEnvelopes ( int [][] envelopes ) { Arrays . sort ( envelopes , ( a , b ) -> a [ 0 ] == b [ 0 ] ? b [ 1 ] - a [ 1 ] : a [ 0 ] - b [ 0 ] ); // same as 300. Longest Increasing Subsequence int ans = 0 ; int [] dp = new int [ envelopes . length ] ; for ( final int [] e : envelopes ) { int i = Arrays . binarySearch ( dp , 0 , ans , e [ 1 ] ); if ( i < 0 ) i = - ( i + 1 ); dp [ i ] = e [ 1 ] ; if ( i == ans ) ++ ans ; } return ans ; } }","title":"354. Russian Doll Envelopes"},{"location":"problems/0355/","text":"355. Design Twitter Time: $O(n + k\\log k)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 struct Tweet { int id ; int time ; Tweet * next = nullptr ; Tweet ( int id , int time ) : id ( id ), time ( time ) {} }; struct User { int id ; unordered_set < int > followeeIds ; Tweet * tweetHead = nullptr ; User () {} User ( int id ) : id ( id ) { follow ( id ); // follow himself } void follow ( int followeeId ) { followeeIds . insert ( followeeId ); } void unfollow ( int followeeId ) { followeeIds . erase ( followeeId ); } void post ( int tweetId , int time ) { Tweet * oldTweetHead = tweetHead ; tweetHead = new Tweet ( tweetId , time ); tweetHead -> next = oldTweetHead ; } }; class Twitter { public : /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { if ( ! users . count ( userId )) users [ userId ] = User ( userId ); users [ userId ]. post ( tweetId , time ++ ); } /** * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in * the news feed must be posted by users who the user followed or by the user * herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { if ( ! users . count ( userId )) return {}; vector < int > newsFeed ; auto compare = []( const Tweet * a , const Tweet * b ) { return a -> time < b -> time ; }; priority_queue < Tweet * , vector < Tweet *> , decltype ( compare ) > pq ( compare ); for ( const int followeeId : users [ userId ]. followeeIds ) { Tweet * tweetHead = users [ followeeId ]. tweetHead ; if ( tweetHead ) pq . push ( tweetHead ); } int count = 0 ; while ( ! pq . empty () && count ++ < 10 ) { Tweet * tweet = pq . top (); pq . pop (); newsFeed . push_back ( tweet -> id ); if ( tweet -> next ) pq . push ( tweet -> next ); } return newsFeed ; } /** * Follower follows a followee. * If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( ! users . count ( followerId )) users [ followerId ] = User ( followerId ); if ( ! users . count ( followeeId )) users [ followeeId ] = User ( followeeId ); users [ followerId ]. follow ( followeeId ); } /** * Follower unfollows a followee. * If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( users . count ( followerId ) && users . count ( followeeId )) users [ followerId ]. unfollow ( followeeId ); } private : int time = 0 ; unordered_map < int , User > users ; // {userId: User} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class Tweet { public int id ; public int time ; public Tweet next = null ; public Tweet ( int id , int time ) { this . id = id ; this . time = time ; } } class User { private int id ; public Set < Integer > followeeIds = new HashSet <> (); public Tweet tweetHead = null ; public User ( int id ) { this . id = id ; follow ( id ); // follow himself } public void follow ( int followeeId ) { followeeIds . add ( followeeId ); } public void unfollow ( int followeeId ) { followeeIds . remove ( followeeId ); } public void post ( int tweetId , int time ) { final Tweet oldTweetHead = tweetHead ; tweetHead = new Tweet ( tweetId , time ); tweetHead . next = oldTweetHead ; } } class Twitter { /** Compose a new tweet. */ public void postTweet ( int userId , int tweetId ) { users . putIfAbsent ( userId , new User ( userId )); users . get ( userId ). post ( tweetId , time ++ ); } /** * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in * the news feed must be posted by users who the user followed or by the user * herself. Tweets must be ordered from most recent to least recent. */ public List < Integer > getNewsFeed ( int userId ) { if ( ! users . containsKey ( userId )) return new ArrayList <> (); List < Integer > newsFeed = new ArrayList <> (); PriorityQueue < Tweet > pq = new PriorityQueue <> (( a , b ) -> b . time - a . time ); for ( final int followeeId : users . get ( userId ). followeeIds ) { Tweet tweetHead = users . get ( followeeId ). tweetHead ; if ( tweetHead != null ) pq . offer ( tweetHead ); } int count = 0 ; while ( ! pq . isEmpty () && count ++ < 10 ) { Tweet tweet = pq . poll (); newsFeed . add ( tweet . id ); if ( tweet . next != null ) pq . offer ( tweet . next ); } return newsFeed ; } /** * Follower follows a followee. * If the operation is invalid, it should be a no-op. */ public void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; users . putIfAbsent ( followerId , new User ( followerId )); users . putIfAbsent ( followeeId , new User ( followeeId )); users . get ( followerId ). follow ( followeeId ); } /** * Follower unfollows a followee. * If the operation is invalid, it should be a no-op. */ public void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( users . containsKey ( followerId ) && users . containsKey ( followeeId )) users . get ( followerId ). unfollow ( followeeId ); } private int time = 0 ; private Map < Integer , User > users = new HashMap <> (); // {userId: User} } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Twitter : def __init__ ( self ): self . timer = itertools . count ( step =- 1 ) self . tweets = collections . defaultdict ( collections . deque ) self . followees = collections . defaultdict ( set ) def postTweet ( self , userId : int , tweetId : int ) -> None : self . tweets [ userId ] . appendleft (( next ( self . timer ), tweetId )) if len ( self . tweets [ userId ]) > 10 : self . tweets [ userId ] . pop () def getNewsFeed ( self , userId : int ) -> List [ int ]: tweets = list ( heapq . merge ( * ( self . tweets [ followee ] for followee in self . followees [ userId ] | { userId }))) return [ tweetId for _ , tweetId in tweets [: 10 ]] def follow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . add ( followeeId ) def unfollow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . discard ( followeeId )","title":"355. Design Twitter"},{"location":"problems/0355/#355-design-twitter","text":"Time: $O(n + k\\log k)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 struct Tweet { int id ; int time ; Tweet * next = nullptr ; Tweet ( int id , int time ) : id ( id ), time ( time ) {} }; struct User { int id ; unordered_set < int > followeeIds ; Tweet * tweetHead = nullptr ; User () {} User ( int id ) : id ( id ) { follow ( id ); // follow himself } void follow ( int followeeId ) { followeeIds . insert ( followeeId ); } void unfollow ( int followeeId ) { followeeIds . erase ( followeeId ); } void post ( int tweetId , int time ) { Tweet * oldTweetHead = tweetHead ; tweetHead = new Tweet ( tweetId , time ); tweetHead -> next = oldTweetHead ; } }; class Twitter { public : /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { if ( ! users . count ( userId )) users [ userId ] = User ( userId ); users [ userId ]. post ( tweetId , time ++ ); } /** * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in * the news feed must be posted by users who the user followed or by the user * herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { if ( ! users . count ( userId )) return {}; vector < int > newsFeed ; auto compare = []( const Tweet * a , const Tweet * b ) { return a -> time < b -> time ; }; priority_queue < Tweet * , vector < Tweet *> , decltype ( compare ) > pq ( compare ); for ( const int followeeId : users [ userId ]. followeeIds ) { Tweet * tweetHead = users [ followeeId ]. tweetHead ; if ( tweetHead ) pq . push ( tweetHead ); } int count = 0 ; while ( ! pq . empty () && count ++ < 10 ) { Tweet * tweet = pq . top (); pq . pop (); newsFeed . push_back ( tweet -> id ); if ( tweet -> next ) pq . push ( tweet -> next ); } return newsFeed ; } /** * Follower follows a followee. * If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( ! users . count ( followerId )) users [ followerId ] = User ( followerId ); if ( ! users . count ( followeeId )) users [ followeeId ] = User ( followeeId ); users [ followerId ]. follow ( followeeId ); } /** * Follower unfollows a followee. * If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( users . count ( followerId ) && users . count ( followeeId )) users [ followerId ]. unfollow ( followeeId ); } private : int time = 0 ; unordered_map < int , User > users ; // {userId: User} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class Tweet { public int id ; public int time ; public Tweet next = null ; public Tweet ( int id , int time ) { this . id = id ; this . time = time ; } } class User { private int id ; public Set < Integer > followeeIds = new HashSet <> (); public Tweet tweetHead = null ; public User ( int id ) { this . id = id ; follow ( id ); // follow himself } public void follow ( int followeeId ) { followeeIds . add ( followeeId ); } public void unfollow ( int followeeId ) { followeeIds . remove ( followeeId ); } public void post ( int tweetId , int time ) { final Tweet oldTweetHead = tweetHead ; tweetHead = new Tweet ( tweetId , time ); tweetHead . next = oldTweetHead ; } } class Twitter { /** Compose a new tweet. */ public void postTweet ( int userId , int tweetId ) { users . putIfAbsent ( userId , new User ( userId )); users . get ( userId ). post ( tweetId , time ++ ); } /** * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in * the news feed must be posted by users who the user followed or by the user * herself. Tweets must be ordered from most recent to least recent. */ public List < Integer > getNewsFeed ( int userId ) { if ( ! users . containsKey ( userId )) return new ArrayList <> (); List < Integer > newsFeed = new ArrayList <> (); PriorityQueue < Tweet > pq = new PriorityQueue <> (( a , b ) -> b . time - a . time ); for ( final int followeeId : users . get ( userId ). followeeIds ) { Tweet tweetHead = users . get ( followeeId ). tweetHead ; if ( tweetHead != null ) pq . offer ( tweetHead ); } int count = 0 ; while ( ! pq . isEmpty () && count ++ < 10 ) { Tweet tweet = pq . poll (); newsFeed . add ( tweet . id ); if ( tweet . next != null ) pq . offer ( tweet . next ); } return newsFeed ; } /** * Follower follows a followee. * If the operation is invalid, it should be a no-op. */ public void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; users . putIfAbsent ( followerId , new User ( followerId )); users . putIfAbsent ( followeeId , new User ( followeeId )); users . get ( followerId ). follow ( followeeId ); } /** * Follower unfollows a followee. * If the operation is invalid, it should be a no-op. */ public void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( users . containsKey ( followerId ) && users . containsKey ( followeeId )) users . get ( followerId ). unfollow ( followeeId ); } private int time = 0 ; private Map < Integer , User > users = new HashMap <> (); // {userId: User} } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Twitter : def __init__ ( self ): self . timer = itertools . count ( step =- 1 ) self . tweets = collections . defaultdict ( collections . deque ) self . followees = collections . defaultdict ( set ) def postTweet ( self , userId : int , tweetId : int ) -> None : self . tweets [ userId ] . appendleft (( next ( self . timer ), tweetId )) if len ( self . tweets [ userId ]) > 10 : self . tweets [ userId ] . pop () def getNewsFeed ( self , userId : int ) -> List [ int ]: tweets = list ( heapq . merge ( * ( self . tweets [ followee ] for followee in self . followees [ userId ] | { userId }))) return [ tweetId for _ , tweetId in tweets [: 10 ]] def follow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . add ( followeeId ) def unfollow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . discard ( followeeId )","title":"355. Design Twitter"},{"location":"problems/0356/","text":"356. Line Reflection \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isReflected ( vector < vector < int >>& points ) { int minX = INT_MAX ; int maxX = INT_MIN ; unordered_set < pair < int , int > , pairHash > seen ; for ( const vector < int >& point : points ) { minX = min ( minX , point [ 0 ]); maxX = max ( maxX , point [ 0 ]); seen . insert ({ point [ 0 ], point [ 1 ]}); } const int sum = minX + maxX ; // (leftX + rightX) / 2 = (minX + maxX) / 2 // leftX = minX + maxX - rightX // rightX = minX + maxX - leftX for ( const vector < int >& point : points ) if ( ! seen . count ({ sum - point [ 0 ], point [ 1 ]})) return false ; return true ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isReflected ( int [][] points ) { int minX = Integer . MAX_VALUE ; int maxX = Integer . MIN_VALUE ; Set < String > seen = new HashSet <> (); for ( final int [] point : points ) { minX = Math . min ( minX , point [ 0 ] ); maxX = Math . max ( maxX , point [ 0 ] ); seen . add ( point [ 0 ] + \",\" + point [ 1 ] ); } final int sum = minX + maxX ; // (leftX + rightX) / 2 = (minX + maxX) / 2 // leftX = minX + maxX - rightX // rightX = minX + maxX - leftX for ( final int [] point : points ) if ( ! seen . contains ( sum - point [ 0 ] + \",\" + point [ 1 ] )) return false ; return true ; } }","title":"356. Line Reflection"},{"location":"problems/0356/#356-line-reflection","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isReflected ( vector < vector < int >>& points ) { int minX = INT_MAX ; int maxX = INT_MIN ; unordered_set < pair < int , int > , pairHash > seen ; for ( const vector < int >& point : points ) { minX = min ( minX , point [ 0 ]); maxX = max ( maxX , point [ 0 ]); seen . insert ({ point [ 0 ], point [ 1 ]}); } const int sum = minX + maxX ; // (leftX + rightX) / 2 = (minX + maxX) / 2 // leftX = minX + maxX - rightX // rightX = minX + maxX - leftX for ( const vector < int >& point : points ) if ( ! seen . count ({ sum - point [ 0 ], point [ 1 ]})) return false ; return true ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public boolean isReflected ( int [][] points ) { int minX = Integer . MAX_VALUE ; int maxX = Integer . MIN_VALUE ; Set < String > seen = new HashSet <> (); for ( final int [] point : points ) { minX = Math . min ( minX , point [ 0 ] ); maxX = Math . max ( maxX , point [ 0 ] ); seen . add ( point [ 0 ] + \",\" + point [ 1 ] ); } final int sum = minX + maxX ; // (leftX + rightX) / 2 = (minX + maxX) / 2 // leftX = minX + maxX - rightX // rightX = minX + maxX - leftX for ( final int [] point : points ) if ( ! seen . contains ( sum - point [ 0 ] + \",\" + point [ 1 ] )) return false ; return true ; } }","title":"356. Line Reflection \ud83d\udd12"},{"location":"problems/0357/","text":"357. Count Numbers with Unique Digits Time: $O(9)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def countNumbersWithUniqueDigits ( self , n : int ) -> int : if n == 0 : return 1 ans = 10 uniqueDigits = 9 availableNum = 9 while n > 1 and availableNum > 0 : uniqueDigits *= availableNum ans += uniqueDigits n -= 1 availableNum -= 1 return ans","title":"357. Count Numbers with Unique Digits"},{"location":"problems/0357/#357-count-numbers-with-unique-digits","text":"Time: $O(9)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def countNumbersWithUniqueDigits ( self , n : int ) -> int : if n == 0 : return 1 ans = 10 uniqueDigits = 9 availableNum = 9 while n > 1 and availableNum > 0 : uniqueDigits *= availableNum ans += uniqueDigits n -= 1 availableNum -= 1 return ans","title":"357. Count Numbers with Unique Digits"},{"location":"problems/0358/","text":"358. Rearrange String k Distance Apart \ud83d\udd12 Time: $O(26n) = O(n)$ Space: $O(128) = O(1)$","title":"358. Rearrange String k Distance Apart"},{"location":"problems/0358/#358-rearrange-string-k-distance-apart","text":"Time: $O(26n) = O(n)$ Space: $O(128) = O(1)$","title":"358. Rearrange String k Distance Apart \ud83d\udd12"},{"location":"problems/0359/","text":"359. Logger Rate Limiter \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Logger { public : bool shouldPrintMessage ( int timestamp , string message ) { if ( timestamp < okTime [ message ]) return false ; okTime [ message ] = timestamp + 10 ; return true ; } private : unordered_map < string , int > okTime ; // {message: ok time} }; Java 1 2 3 4 5 6 7 8 9 10 11 class Logger { public boolean shouldPrintMessage ( int timestamp , String message ) { if ( timestamp < okTime . getOrDefault ( message , 0 )) return false ; okTime . put ( message , timestamp + 10 ); return true ; } private Map < String , Integer > okTime = new HashMap <> (); // {message: ok time} }","title":"359. Logger Rate Limiter"},{"location":"problems/0359/#359-logger-rate-limiter","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Logger { public : bool shouldPrintMessage ( int timestamp , string message ) { if ( timestamp < okTime [ message ]) return false ; okTime [ message ] = timestamp + 10 ; return true ; } private : unordered_map < string , int > okTime ; // {message: ok time} }; Java 1 2 3 4 5 6 7 8 9 10 11 class Logger { public boolean shouldPrintMessage ( int timestamp , String message ) { if ( timestamp < okTime . getOrDefault ( message , 0 )) return false ; okTime . put ( message , timestamp + 10 ); return true ; } private Map < String , Integer > okTime = new HashMap <> (); // {message: ok time} }","title":"359. Logger Rate Limiter \ud83d\udd12"},{"location":"problems/0360/","text":"360. Sort Transformed Array \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > sortTransformedArray ( vector < int >& nums , int a , int b , int c ) { const int n = nums . size (); const bool upward = a > 0 ; vector < int > ans ( n ); vector < int > quad ; for ( const int num : nums ) quad . push_back ( f ( num , a , b , c )); int i = upward ? n - 1 : 0 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( upward ) // maximum in both ends ans [ i -- ] = quad [ l ] > quad [ r ] ? quad [ l ++ ] : quad [ r -- ]; else // minimum in both ends ans [ i ++ ] = quad [ l ] < quad [ r ] ? quad [ l ++ ] : quad [ r -- ]; return ans ; } private : // the concavity of f only depends on a's sign int f ( int x , int a , int b , int c ) { return ( a * x + b ) * x + c ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int [] sortTransformedArray ( int [] nums , int a , int b , int c ) { final int n = nums . length ; final boolean upward = a > 0 ; int [] ans = new int [ n ] ; int [] quad = new int [ n ] ; for ( int i = 0 ; i < nums . length ; ++ i ) quad [ i ] = f ( nums [ i ] , a , b , c ); int i = upward ? n - 1 : 0 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( upward ) // maximum in both ends ans [ i --] = quad [ l ] > quad [ r ] ? quad [ l ++] : quad [ r --] ; else // minimum in both ends ans [ i ++] = quad [ l ] < quad [ r ] ? quad [ l ++] : quad [ r --] ; return ans ; } // the concavity of f only depends on a's sign private int f ( int x , int a , int b , int c ) { return ( a * x + b ) * x + c ; } }","title":"360. Sort Transformed Array"},{"location":"problems/0360/#360-sort-transformed-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > sortTransformedArray ( vector < int >& nums , int a , int b , int c ) { const int n = nums . size (); const bool upward = a > 0 ; vector < int > ans ( n ); vector < int > quad ; for ( const int num : nums ) quad . push_back ( f ( num , a , b , c )); int i = upward ? n - 1 : 0 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( upward ) // maximum in both ends ans [ i -- ] = quad [ l ] > quad [ r ] ? quad [ l ++ ] : quad [ r -- ]; else // minimum in both ends ans [ i ++ ] = quad [ l ] < quad [ r ] ? quad [ l ++ ] : quad [ r -- ]; return ans ; } private : // the concavity of f only depends on a's sign int f ( int x , int a , int b , int c ) { return ( a * x + b ) * x + c ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int [] sortTransformedArray ( int [] nums , int a , int b , int c ) { final int n = nums . length ; final boolean upward = a > 0 ; int [] ans = new int [ n ] ; int [] quad = new int [ n ] ; for ( int i = 0 ; i < nums . length ; ++ i ) quad [ i ] = f ( nums [ i ] , a , b , c ); int i = upward ? n - 1 : 0 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( upward ) // maximum in both ends ans [ i --] = quad [ l ] > quad [ r ] ? quad [ l ++] : quad [ r --] ; else // minimum in both ends ans [ i ++] = quad [ l ] < quad [ r ] ? quad [ l ++] : quad [ r --] ; return ans ; } // the concavity of f only depends on a's sign private int f ( int x , int a , int b , int c ) { return ( a * x + b ) * x + c ; } }","title":"360. Sort Transformed Array \ud83d\udd12"},{"location":"problems/0361/","text":"361. Bomb Enemy \ud83d\udd12 Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : int maxKilledEnemies ( vector < vector < char >>& grid ) { if ( grid . empty () || grid [ 0 ]. empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int enemyCount = 0 ; // dp[i][j] := max enemies grid[i][j] can kill vector < vector < int >> dp ( m , vector < int > ( n )); auto update = [ & ]( int i , int j ) { if ( grid [ i ][ j ] == '0' ) dp [ i ][ j ] += enemyCount ; else if ( grid [ i ][ j ] == 'E' ) ++ enemyCount ; else // grid[i][j] == 'W' enemyCount = 0 ; }; // extend four directions, if meet 'W', need to start over from 0 for ( int i = 0 ; i < m ; ++ i ) { enemyCount = 0 ; for ( int j = 0 ; j < n ; ++ j ) update ( i , j ); enemyCount = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) update ( i , j ); } for ( int j = 0 ; j < n ; ++ j ) { enemyCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) update ( i , j ); enemyCount = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) update ( i , j ); } for ( const vector < int >& row : dp ) ans = max ( ans , * max_element ( begin ( row ), end ( row ))); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public int maxKilledEnemies ( char [][] grid ) { if ( grid . length == 0 || grid [ 0 ] . length == 0 ) return 0 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; // dp[i][j] := max enemies grid[i][j] can kill int [][] dp = new int [ m ][ n ] ; // extend four directions, if meet 'W', need to start over from 0 for ( int i = 0 ; i < m ; ++ i ) { enemyCount = 0 ; for ( int j = 0 ; j < n ; ++ j ) update ( grid , i , j , dp ); enemyCount = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) update ( grid , i , j , dp ); } for ( int j = 0 ; j < n ; ++ j ) { enemyCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) update ( grid , i , j , dp ); enemyCount = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) update ( grid , i , j , dp ); } for ( final int [] row : dp ) ans = Math . max ( ans , Arrays . stream ( row ). max (). getAsInt ()); return ans ; } private int enemyCount = 0 ; private void update ( char [][] grid , int i , int j , int [][] dp ) { if ( grid [ i ][ j ] == '0' ) dp [ i ][ j ] += enemyCount ; else if ( grid [ i ][ j ] == 'E' ) ++ enemyCount ; else // grid[i][j] == 'W' enemyCount = 0 ; } }","title":"361. Bomb Enemy"},{"location":"problems/0361/#361-bomb-enemy","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : int maxKilledEnemies ( vector < vector < char >>& grid ) { if ( grid . empty () || grid [ 0 ]. empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int enemyCount = 0 ; // dp[i][j] := max enemies grid[i][j] can kill vector < vector < int >> dp ( m , vector < int > ( n )); auto update = [ & ]( int i , int j ) { if ( grid [ i ][ j ] == '0' ) dp [ i ][ j ] += enemyCount ; else if ( grid [ i ][ j ] == 'E' ) ++ enemyCount ; else // grid[i][j] == 'W' enemyCount = 0 ; }; // extend four directions, if meet 'W', need to start over from 0 for ( int i = 0 ; i < m ; ++ i ) { enemyCount = 0 ; for ( int j = 0 ; j < n ; ++ j ) update ( i , j ); enemyCount = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) update ( i , j ); } for ( int j = 0 ; j < n ; ++ j ) { enemyCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) update ( i , j ); enemyCount = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) update ( i , j ); } for ( const vector < int >& row : dp ) ans = max ( ans , * max_element ( begin ( row ), end ( row ))); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public int maxKilledEnemies ( char [][] grid ) { if ( grid . length == 0 || grid [ 0 ] . length == 0 ) return 0 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; // dp[i][j] := max enemies grid[i][j] can kill int [][] dp = new int [ m ][ n ] ; // extend four directions, if meet 'W', need to start over from 0 for ( int i = 0 ; i < m ; ++ i ) { enemyCount = 0 ; for ( int j = 0 ; j < n ; ++ j ) update ( grid , i , j , dp ); enemyCount = 0 ; for ( int j = n - 1 ; j >= 0 ; -- j ) update ( grid , i , j , dp ); } for ( int j = 0 ; j < n ; ++ j ) { enemyCount = 0 ; for ( int i = 0 ; i < m ; ++ i ) update ( grid , i , j , dp ); enemyCount = 0 ; for ( int i = m - 1 ; i >= 0 ; -- i ) update ( grid , i , j , dp ); } for ( final int [] row : dp ) ans = Math . max ( ans , Arrays . stream ( row ). max (). getAsInt ()); return ans ; } private int enemyCount = 0 ; private void update ( char [][] grid , int i , int j , int [][] dp ) { if ( grid [ i ][ j ] == '0' ) dp [ i ][ j ] += enemyCount ; else if ( grid [ i ][ j ] == 'E' ) ++ enemyCount ; else // grid[i][j] == 'W' enemyCount = 0 ; } }","title":"361. Bomb Enemy \ud83d\udd12"},{"location":"problems/0362/","text":"362. Design Hit Counter \ud83d\udd12 Time: $O(1)$ Space: $O(second) = O(300) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class HitCounter { public : /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ void hit ( int timestamp ) { const int i = timestamp % 300 ; if ( timestamps [ i ] == timestamp ) { ++ hits [ i ]; } else { timestamps [ i ] = timestamp ; hits [ i ] = 1 ; // reset hit count to 1 } } /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ int getHits ( int timestamp ) { int countHits = 0 ; for ( int i = 0 ; i < 300 ; ++ i ) if ( timestamp - timestamps [ i ] < 300 ) countHits += hits [ i ]; return countHits ; } private : vector < int > timestamps = vector < int > ( 300 ); vector < int > hits = vector < int > ( 300 ); }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class HitCounter { /** * Record a hit. * * @param timestamp - The current timestamp (in seconds granularity). */ public void hit ( int timestamp ) { final int i = timestamp % 300 ; if ( timestamps [ i ] == timestamp ) { ++ hits [ i ] ; } else { timestamps [ i ] = timestamp ; hits [ i ] = 1 ; // reset hit count to 1 } } /** * Return the number of hits in the past 5 minutes. * * @param timestamp - The current timestamp (in seconds granularity). */ public int getHits ( int timestamp ) { int countHits = 0 ; for ( int i = 0 ; i < 300 ; ++ i ) if ( timestamp - timestamps [ i ] < 300 ) countHits += hits [ i ] ; return countHits ; } private int [] timestamps = new int [ 300 ] ; private int [] hits = new int [ 300 ] ; }","title":"362. Design Hit Counter"},{"location":"problems/0362/#362-design-hit-counter","text":"Time: $O(1)$ Space: $O(second) = O(300) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class HitCounter { public : /** Record a hit. @param timestamp - The current timestamp (in seconds granularity). */ void hit ( int timestamp ) { const int i = timestamp % 300 ; if ( timestamps [ i ] == timestamp ) { ++ hits [ i ]; } else { timestamps [ i ] = timestamp ; hits [ i ] = 1 ; // reset hit count to 1 } } /** Return the number of hits in the past 5 minutes. @param timestamp - The current timestamp (in seconds granularity). */ int getHits ( int timestamp ) { int countHits = 0 ; for ( int i = 0 ; i < 300 ; ++ i ) if ( timestamp - timestamps [ i ] < 300 ) countHits += hits [ i ]; return countHits ; } private : vector < int > timestamps = vector < int > ( 300 ); vector < int > hits = vector < int > ( 300 ); }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class HitCounter { /** * Record a hit. * * @param timestamp - The current timestamp (in seconds granularity). */ public void hit ( int timestamp ) { final int i = timestamp % 300 ; if ( timestamps [ i ] == timestamp ) { ++ hits [ i ] ; } else { timestamps [ i ] = timestamp ; hits [ i ] = 1 ; // reset hit count to 1 } } /** * Return the number of hits in the past 5 minutes. * * @param timestamp - The current timestamp (in seconds granularity). */ public int getHits ( int timestamp ) { int countHits = 0 ; for ( int i = 0 ; i < 300 ; ++ i ) if ( timestamp - timestamps [ i ] < 300 ) countHits += hits [ i ] ; return countHits ; } private int [] timestamps = new int [ 300 ] ; private int [] hits = new int [ 300 ] ; }","title":"362. Design Hit Counter \ud83d\udd12"},{"location":"problems/0363/","text":"363. Max Sum of Rectangle No Larger Than K Time: $O(\\min(m, n)^2 \\cdot \\max(m, n) \\cdot \\log\\max(m, n))$ Space: $O(\\max(m, n))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = INT_MIN ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { // sums[i] := sum(matrix[i][baseCol..j]) vector < int > sums ( m , 0 ); for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ]; // find the max subarray no more than k set < int > accumulate { 0 }; int prefixSum = 0 ; for ( const int sum : sums ) { prefixSum += sum ; const auto it = accumulate . lower_bound ( prefixSum - k ); if ( it != cend ( accumulate )) ans = max ( ans , prefixSum - * it ); accumulate . insert ( prefixSum ); } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int maxSumSubmatrix ( int [][] matrix , int k ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = Integer . MIN_VALUE ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { // sums[i] := sum(matrix[i][baseCol..j]) int [] sums = new int [ m ] ; for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ] ; // find the max subarray no more than k TreeSet < Integer > accumulate = new TreeSet <> ( Arrays . asList ( 0 )); int prefixSum = 0 ; for ( final int sum : sums ) { prefixSum += sum ; final Integer lo = accumulate . ceiling ( prefixSum - k ); if ( lo != null ) ans = Math . max ( ans , prefixSum - lo ); accumulate . add ( prefixSum ); } } } return ans ; } }","title":"363. Max Sum of Rectangle No Larger Than K"},{"location":"problems/0363/#363-max-sum-of-rectangle-no-larger-than-k","text":"Time: $O(\\min(m, n)^2 \\cdot \\max(m, n) \\cdot \\log\\max(m, n))$ Space: $O(\\max(m, n))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = INT_MIN ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { // sums[i] := sum(matrix[i][baseCol..j]) vector < int > sums ( m , 0 ); for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ]; // find the max subarray no more than k set < int > accumulate { 0 }; int prefixSum = 0 ; for ( const int sum : sums ) { prefixSum += sum ; const auto it = accumulate . lower_bound ( prefixSum - k ); if ( it != cend ( accumulate )) ans = max ( ans , prefixSum - * it ); accumulate . insert ( prefixSum ); } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int maxSumSubmatrix ( int [][] matrix , int k ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = Integer . MIN_VALUE ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { // sums[i] := sum(matrix[i][baseCol..j]) int [] sums = new int [ m ] ; for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ] ; // find the max subarray no more than k TreeSet < Integer > accumulate = new TreeSet <> ( Arrays . asList ( 0 )); int prefixSum = 0 ; for ( final int sum : sums ) { prefixSum += sum ; final Integer lo = accumulate . ceiling ( prefixSum - k ); if ( lo != null ) ans = Math . max ( ans , prefixSum - lo ); accumulate . add ( prefixSum ); } } } return ans ; } }","title":"363. Max Sum of Rectangle No Larger Than K"},{"location":"problems/0364/","text":"364. Nested List Weight Sum II \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int depthSumInverse ( vector < NestedInteger >& nestedList ) { int ans = 0 ; int prevSum = 0 ; queue < NestedInteger > q {{ begin ( nestedList ), end ( nestedList )}}; while ( ! q . empty ()) { for ( int i = q . size (); i > 0 ; -- i ) { const NestedInteger ni = q . front (); q . pop (); if ( ni . isInteger ()) prevSum += ni . getInteger (); else { for ( const NestedInteger nextNi : ni . getList ()) q . push ( nextNi ); } } ans += prevSum ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int depthSumInverse ( List < NestedInteger > nestedList ) { int ans = 0 ; int prevSum = 0 ; Queue < NestedInteger > q = new LinkedList <> ( nestedList ); while ( ! q . isEmpty ()) { for ( int i = q . size (); i > 0 ; -- i ) { final NestedInteger ni = q . poll (); if ( ni . isInteger ()) prevSum += ni . getInteger (); else q . addAll ( ni . getList ()); } ans += prevSum ; } return ans ; } }","title":"364. Nested List Weight Sum II"},{"location":"problems/0364/#364-nested-list-weight-sum-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int depthSumInverse ( vector < NestedInteger >& nestedList ) { int ans = 0 ; int prevSum = 0 ; queue < NestedInteger > q {{ begin ( nestedList ), end ( nestedList )}}; while ( ! q . empty ()) { for ( int i = q . size (); i > 0 ; -- i ) { const NestedInteger ni = q . front (); q . pop (); if ( ni . isInteger ()) prevSum += ni . getInteger (); else { for ( const NestedInteger nextNi : ni . getList ()) q . push ( nextNi ); } } ans += prevSum ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int depthSumInverse ( List < NestedInteger > nestedList ) { int ans = 0 ; int prevSum = 0 ; Queue < NestedInteger > q = new LinkedList <> ( nestedList ); while ( ! q . isEmpty ()) { for ( int i = q . size (); i > 0 ; -- i ) { final NestedInteger ni = q . poll (); if ( ni . isInteger ()) prevSum += ni . getInteger (); else q . addAll ( ni . getList ()); } ans += prevSum ; } return ans ; } }","title":"364. Nested List Weight Sum II \ud83d\udd12"},{"location":"problems/0365/","text":"365. Water and Jug Problem Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % __gcd ( x , y ) == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % gcd ( x , y ) == 0 ; } private int gcd ( int x , int y ) { return y == 0 ? x : gcd ( y , x % y ); } } Python 1 2 3 4 5 6 from fractions import gcd class Solution : def canMeasureWater ( self , x : int , y : int , z : int ) -> bool : return z == 0 or x + y >= z and z % gcd ( x , y ) == 0","title":"365. Water and Jug Problem"},{"location":"problems/0365/#365-water-and-jug-problem","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % __gcd ( x , y ) == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % gcd ( x , y ) == 0 ; } private int gcd ( int x , int y ) { return y == 0 ? x : gcd ( y , x % y ); } } Python 1 2 3 4 5 6 from fractions import gcd class Solution : def canMeasureWater ( self , x : int , y : int , z : int ) -> bool : return z == 0 or x + y >= z and z % gcd ( x , y ) == 0","title":"365. Water and Jug Problem"},{"location":"problems/0366/","text":"366. Find Leaves of Binary Tree \ud83d\udd12 Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> findLeaves ( TreeNode * root ) { vector < vector < int >> ans ; // height of root function < int ( TreeNode * ) > height = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int h = 1 + max ( height ( root -> left ), height ( root -> right )); if ( ans . size () == h - 1 ) // meet leaf ans . push_back ( vector < int > ()); ans [ h - 1 ]. push_back ( root -> val ); return h ; }; height ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> findLeaves ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); height ( root , ans ); return ans ; } // height of root private int height ( TreeNode root , List < List < Integer >> ans ) { if ( root == null ) return 0 ; final int h = 1 + Math . max ( height ( root . left , ans ), height ( root . right , ans )); if ( ans . size () == h - 1 ) // meet leaf ans . add ( new ArrayList <> ()); ans . get ( h - 1 ). add ( root . val ); return h ; } }","title":"366. Find Leaves of Binary Tree"},{"location":"problems/0366/#366-find-leaves-of-binary-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> findLeaves ( TreeNode * root ) { vector < vector < int >> ans ; // height of root function < int ( TreeNode * ) > height = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int h = 1 + max ( height ( root -> left ), height ( root -> right )); if ( ans . size () == h - 1 ) // meet leaf ans . push_back ( vector < int > ()); ans [ h - 1 ]. push_back ( root -> val ); return h ; }; height ( root ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> findLeaves ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); height ( root , ans ); return ans ; } // height of root private int height ( TreeNode root , List < List < Integer >> ans ) { if ( root == null ) return 0 ; final int h = 1 + Math . max ( height ( root . left , ans ), height ( root . right , ans )); if ( ans . size () == h - 1 ) // meet leaf ans . add ( new ArrayList <> ()); ans . get ( h - 1 ). add ( root . val ); return h ; } }","title":"366. Find Leaves of Binary Tree \ud83d\udd12"},{"location":"problems/0367/","text":"367. Valid Perfect Square Time: $O(\\log num)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 ; long r = num ; while ( l < r ) { const long m = l + ( r - l ) / 2 ; if ( m < num / m ) l = m + 1 ; else r = m ; } return l * l == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isPerfectSquare ( int num ) { long l = 1 ; long r = num ; while ( l < r ) { final long m = l + ( r - l ) / 2 ; if ( m < num / m ) l = m + 1 ; else r = m ; } return l * l == num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPerfectSquare ( self , num : int ) -> bool : l = 1 r = num + 1 while l < r : m = ( l + r ) // 2 if m > num / m : r = m else : l = m + 1 return ( l - 1 ) * ( l - 1 ) == num","title":"367. Valid Perfect Square"},{"location":"problems/0367/#367-valid-perfect-square","text":"Time: $O(\\log num)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPerfectSquare ( int num ) { long l = 1 ; long r = num ; while ( l < r ) { const long m = l + ( r - l ) / 2 ; if ( m < num / m ) l = m + 1 ; else r = m ; } return l * l == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean isPerfectSquare ( int num ) { long l = 1 ; long r = num ; while ( l < r ) { final long m = l + ( r - l ) / 2 ; if ( m < num / m ) l = m + 1 ; else r = m ; } return l * l == num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPerfectSquare ( self , num : int ) -> bool : l = 1 r = num + 1 while l < r : m = ( l + r ) // 2 if m > num / m : r = m else : l = m + 1 return ( l - 1 ) * ( l - 1 ) == num","title":"367. Valid Perfect Square"},{"location":"problems/0368/","text":"368. Largest Divisible Subset Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ; // sizeEndsAt[i] := largest size ends at nums[i] vector < int > sizeEndsAt ( n , 1 ); // prevIndex[i] := the best index s.t. // 1. nums[i] % nums[prevIndex[i]] == 0 and // 2. can increase the size of the subset vector < int > prevIndex ( n , -1 ); int maxSize = 0 ; // max size of the subset int index = -1 ; // track the best ending index sort ( begin ( nums ), end ( nums )); // fix max ending num in the subset first for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && sizeEndsAt [ i ] < sizeEndsAt [ j ] + 1 ) { sizeEndsAt [ i ] = sizeEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } // find a new subset that has a bigger size if ( maxSize < sizeEndsAt [ i ]) { maxSize = sizeEndsAt [ i ]; index = i ; // update the best ending index } } // loop from back to front while ( index != -1 ) { ans . push_back ( nums [ index ]); index = prevIndex [ index ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < Integer > largestDivisibleSubset ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); // sizeEndsAt[i] := largest size ends at nums[i] int [] sizeEndsAt = new int [ n ] ; // prevIndex[i] := the best index s.t. // 1. nums[i] % nums[prevIndex[i]] == 0 and // 2. can increase the size of the subset int [] prevIndex = new int [ n ] ; int maxSize = 0 ; // max size of the subset int index = - 1 ; // track the best ending index Arrays . fill ( sizeEndsAt , 1 ); Arrays . fill ( prevIndex , - 1 ); Arrays . sort ( nums ); // fix max ending num in the subset first for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && sizeEndsAt [ i ] < sizeEndsAt [ j ] + 1 ) { sizeEndsAt [ i ] = sizeEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } // find a new subset that has a bigger size if ( maxSize < sizeEndsAt [ i ] ) { maxSize = sizeEndsAt [ i ] ; index = i ; // update the best ending index } } // loop from back to front while ( index != - 1 ) { ans . add ( nums [ index ] ); index = prevIndex [ index ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def largestDivisibleSubset ( self , nums : List [ int ]) -> List [ int ]: n = len ( nums ) ans = [] count = [ 1 ] * n prevIndex = [ - 1 ] * n maxCount = 0 index = - 1 nums . sort () for i , num in enumerate ( nums ): for j in range ( i )[:: - 1 ]: if num % nums [ j ] == 0 and count [ i ] < count [ j ] + 1 : count [ i ] = count [ j ] + 1 prevIndex [ i ] = j if count [ i ] > maxCount : maxCount = count [ i ] index = i while index != - 1 : ans . append ( nums [ index ]) index = prevIndex [ index ] return ans","title":"368. Largest Divisible Subset"},{"location":"problems/0368/#368-largest-divisible-subset","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ; // sizeEndsAt[i] := largest size ends at nums[i] vector < int > sizeEndsAt ( n , 1 ); // prevIndex[i] := the best index s.t. // 1. nums[i] % nums[prevIndex[i]] == 0 and // 2. can increase the size of the subset vector < int > prevIndex ( n , -1 ); int maxSize = 0 ; // max size of the subset int index = -1 ; // track the best ending index sort ( begin ( nums ), end ( nums )); // fix max ending num in the subset first for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && sizeEndsAt [ i ] < sizeEndsAt [ j ] + 1 ) { sizeEndsAt [ i ] = sizeEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } // find a new subset that has a bigger size if ( maxSize < sizeEndsAt [ i ]) { maxSize = sizeEndsAt [ i ]; index = i ; // update the best ending index } } // loop from back to front while ( index != -1 ) { ans . push_back ( nums [ index ]); index = prevIndex [ index ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < Integer > largestDivisibleSubset ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); // sizeEndsAt[i] := largest size ends at nums[i] int [] sizeEndsAt = new int [ n ] ; // prevIndex[i] := the best index s.t. // 1. nums[i] % nums[prevIndex[i]] == 0 and // 2. can increase the size of the subset int [] prevIndex = new int [ n ] ; int maxSize = 0 ; // max size of the subset int index = - 1 ; // track the best ending index Arrays . fill ( sizeEndsAt , 1 ); Arrays . fill ( prevIndex , - 1 ); Arrays . sort ( nums ); // fix max ending num in the subset first for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && sizeEndsAt [ i ] < sizeEndsAt [ j ] + 1 ) { sizeEndsAt [ i ] = sizeEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } // find a new subset that has a bigger size if ( maxSize < sizeEndsAt [ i ] ) { maxSize = sizeEndsAt [ i ] ; index = i ; // update the best ending index } } // loop from back to front while ( index != - 1 ) { ans . add ( nums [ index ] ); index = prevIndex [ index ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def largestDivisibleSubset ( self , nums : List [ int ]) -> List [ int ]: n = len ( nums ) ans = [] count = [ 1 ] * n prevIndex = [ - 1 ] * n maxCount = 0 index = - 1 nums . sort () for i , num in enumerate ( nums ): for j in range ( i )[:: - 1 ]: if num % nums [ j ] == 0 and count [ i ] < count [ j ] + 1 : count [ i ] = count [ j ] + 1 prevIndex [ i ] = j if count [ i ] > maxCount : maxCount = count [ i ] index = i while index != - 1 : ans . append ( nums [ index ]) index = prevIndex [ index ] return ans","title":"368. Largest Divisible Subset"},{"location":"problems/0369/","text":"369. Plus One Linked List \ud83d\udd12 Approach 1: Recursive Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * plusOne ( ListNode * head ) { ListNode * dummy = new ListNode ( 0 ); ListNode * i = dummy ; dummy -> next = head ; while ( head ) { if ( head -> val != 9 ) i = head ; head = head -> next ; } // i point to the rightmost non-9 node ++ i -> val ; while ( i -> next ) { i -> next -> val = 0 ; i = i -> next ; } return dummy -> val == 0 ? dummy -> next : dummy ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode plusOne ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode i = dummy ; dummy . next = head ; while ( head != null ) { if ( head . val != 9 ) i = head ; head = head . next ; } // i point to the rightmost non-9 node ++ i . val ; while ( i . next != null ) { i . next . val = 0 ; i = i . next ; } return dummy . val == 0 ? dummy . next : dummy ; } } Approach 2: Iterative Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * plusOne ( ListNode * head ) { if ( ! head ) return new ListNode ( 1 ); if ( addOne ( head ) != 0 ) return new ListNode ( 1 , head ); return head ; } private : int addOne ( ListNode * node ) { const int carry = node -> next ? addOne ( node -> next ) : 1 ; const int sum = node -> val + carry ; node -> val = sum % 10 ; return sum / 10 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public ListNode plusOne ( ListNode head ) { if ( head == null ) return new ListNode ( 1 ); if ( addOne ( head ) != 0 ) return new ListNode ( 1 , head ); return head ; } private int addOne ( ListNode node ) { final int carry = node . next == null ? 1 : addOne ( node . next ); final int sum = node . val + carry ; node . val = sum % 10 ; return sum / 10 ; } }","title":"369. Plus One Linked List"},{"location":"problems/0369/#369-plus-one-linked-list","text":"","title":"369. Plus One Linked List \ud83d\udd12"},{"location":"problems/0369/#approach-1-recursive","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : ListNode * plusOne ( ListNode * head ) { ListNode * dummy = new ListNode ( 0 ); ListNode * i = dummy ; dummy -> next = head ; while ( head ) { if ( head -> val != 9 ) i = head ; head = head -> next ; } // i point to the rightmost non-9 node ++ i -> val ; while ( i -> next ) { i -> next -> val = 0 ; i = i -> next ; } return dummy -> val == 0 ? dummy -> next : dummy ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode plusOne ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode i = dummy ; dummy . next = head ; while ( head != null ) { if ( head . val != 9 ) i = head ; head = head . next ; } // i point to the rightmost non-9 node ++ i . val ; while ( i . next != null ) { i . next . val = 0 ; i = i . next ; } return dummy . val == 0 ? dummy . next : dummy ; } }","title":"Approach 1: Recursive"},{"location":"problems/0369/#approach-2-iterative","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * plusOne ( ListNode * head ) { if ( ! head ) return new ListNode ( 1 ); if ( addOne ( head ) != 0 ) return new ListNode ( 1 , head ); return head ; } private : int addOne ( ListNode * node ) { const int carry = node -> next ? addOne ( node -> next ) : 1 ; const int sum = node -> val + carry ; node -> val = sum % 10 ; return sum / 10 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public ListNode plusOne ( ListNode head ) { if ( head == null ) return new ListNode ( 1 ); if ( addOne ( head ) != 0 ) return new ListNode ( 1 , head ); return head ; } private int addOne ( ListNode node ) { final int carry = node . next == null ? 1 : addOne ( node . next ); final int sum = node . val + carry ; node . val = sum % 10 ; return sum / 10 ; } }","title":"Approach 2: Iterative"},{"location":"problems/0370/","text":"370. Range Addition \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > getModifiedArray ( int length , vector < vector < int >>& updates ) { vector < int > ans ( length ); int prefixSum = 0 ; for ( const vector < int >& update : updates ) { const int startIndex = update [ 0 ]; const int endIndex = update [ 1 ]; const int inc = update [ 2 ]; ans [ startIndex ] += inc ; if ( endIndex + 1 < length ) ans [ endIndex + 1 ] -= inc ; } for ( int i = 0 ; i < length ; ++ i ) { prefixSum += ans [ i ]; ans [ i ] = prefixSum ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] getModifiedArray ( int length , int [][] updates ) { int [] ans = new int [ length ] ; int prefixSum = 0 ; for ( final int [] update : updates ) { final int startIndex = update [ 0 ] ; final int endIndex = update [ 1 ] ; final int inc = update [ 2 ] ; ans [ startIndex ] += inc ; if ( endIndex + 1 < length ) ans [ endIndex + 1 ] -= inc ; } for ( int i = 0 ; i < length ; ++ i ) { prefixSum += ans [ i ] ; ans [ i ] = prefixSum ; } return ans ; } }","title":"370. Range Addition"},{"location":"problems/0370/#370-range-addition","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > getModifiedArray ( int length , vector < vector < int >>& updates ) { vector < int > ans ( length ); int prefixSum = 0 ; for ( const vector < int >& update : updates ) { const int startIndex = update [ 0 ]; const int endIndex = update [ 1 ]; const int inc = update [ 2 ]; ans [ startIndex ] += inc ; if ( endIndex + 1 < length ) ans [ endIndex + 1 ] -= inc ; } for ( int i = 0 ; i < length ; ++ i ) { prefixSum += ans [ i ]; ans [ i ] = prefixSum ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] getModifiedArray ( int length , int [][] updates ) { int [] ans = new int [ length ] ; int prefixSum = 0 ; for ( final int [] update : updates ) { final int startIndex = update [ 0 ] ; final int endIndex = update [ 1 ] ; final int inc = update [ 2 ] ; ans [ startIndex ] += inc ; if ( endIndex + 1 < length ) ans [ endIndex + 1 ] -= inc ; } for ( int i = 0 ; i < length ; ++ i ) { prefixSum += ans [ i ] ; ans [ i ] = prefixSum ; } return ans ; } }","title":"370. Range Addition \ud83d\udd12"},{"location":"problems/0371/","text":"371. Sum of Two Integers Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int getSum ( unsigned a , unsigned b ) { while ( b != 0 ) { // still have carry bits const unsigned carry = a & b ; // record carry bits a ^= b ; // ^ works like + but doesn't handle carry bits b = carry << 1 ; } return a ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int getSum ( int a , int b ) { while ( b != 0 ) { // still have carry bits final int carry = a & b ; // record carry bits a ^= b ; // ^ works like + but doesn't handle carry bits b = carry << 1 ; } return a ; } }","title":"371. Sum of Two Integers"},{"location":"problems/0371/#371-sum-of-two-integers","text":"Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int getSum ( unsigned a , unsigned b ) { while ( b != 0 ) { // still have carry bits const unsigned carry = a & b ; // record carry bits a ^= b ; // ^ works like + but doesn't handle carry bits b = carry << 1 ; } return a ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int getSum ( int a , int b ) { while ( b != 0 ) { // still have carry bits final int carry = a & b ; // record carry bits a ^= b ; // ^ works like + but doesn't handle carry bits b = carry << 1 ; } return a ; } }","title":"371. Sum of Two Integers"},{"location":"problems/0372/","text":"372. Super Pow Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int superPow ( int a , vector < int >& b ) { const int k = 1337 ; int ans = 1 ; auto powMod = [ & ]( int x , int y ) { // x^y % k int pow = 1 ; while ( y -- ) pow = ( pow * x ) % k ; return pow ; }; a %= k ; for ( const int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int superPow ( int a , int [] b ) { int ans = 1 ; a %= k ; for ( final int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } private final int k = 1337 ; private int powMod ( int x , int y ) { int pow = 1 ; while ( y -- > 0 ) pow = ( pow * x ) % k ; return pow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def superPow ( self , a : int , b : List [ int ]) -> int : def powMod ( x : int , y : int ) -> int : pow = 1 for _ in range ( y ): pow = ( pow * x ) % k return pow k = 1337 ans = 1 for i in b : ans = powMod ( ans , 10 ) * powMod ( a , i ) % k return ans","title":"372. Super Pow"},{"location":"problems/0372/#372-super-pow","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int superPow ( int a , vector < int >& b ) { const int k = 1337 ; int ans = 1 ; auto powMod = [ & ]( int x , int y ) { // x^y % k int pow = 1 ; while ( y -- ) pow = ( pow * x ) % k ; return pow ; }; a %= k ; for ( const int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int superPow ( int a , int [] b ) { int ans = 1 ; a %= k ; for ( final int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } private final int k = 1337 ; private int powMod ( int x , int y ) { int pow = 1 ; while ( y -- > 0 ) pow = ( pow * x ) % k ; return pow ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def superPow ( self , a : int , b : List [ int ]) -> int : def powMod ( x : int , y : int ) -> int : pow = 1 for _ in range ( y ): pow = ( pow * x ) % k return pow k = 1337 ans = 1 for i in b : ans = powMod ( ans , 10 ) * powMod ( a , i ) % k return ans","title":"372. Super Pow"},{"location":"problems/0373/","text":"373. Find K Pairs with Smallest Sums Time: $O(k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct Item { int i ; int j ; int sum ; // nums1[i] + nums2[j]; }; class Solution { public : vector < vector < int >> kSmallestPairs ( vector < int >& nums1 , vector < int >& nums2 , int k ) { if ( nums1 . empty () || nums2 . empty () || k == 0 ) return {}; vector < vector < int >> ans ; auto compare = [ & ]( const Item & a , const Item & b ) { return a . sum > b . sum ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < nums1 . size (); ++ i ) pq . push ({ i , 0 , nums1 [ i ] + nums2 [ 0 ]}); while ( ! pq . empty () && ans . size () < k ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); ans . push_back ({ nums1 [ i ], nums2 [ j ]}); if ( j + 1 < nums2 . size ()) pq . push ({ i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Item { public int i ; public int j ; public int sum ; // nums1[i] + nums2[j] public Item ( int i , int j , int sum ) { this . i = i ; this . j = j ; this . sum = sum ; } } class Solution { public List < List < Integer >> kSmallestPairs ( int [] nums1 , int [] nums2 , int k ) { if ( nums1 . length == 0 || nums2 . length == 0 || k == 0 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . sum - b . sum ); for ( int i = 0 ; i < k && i < nums1 . length ; ++ i ) pq . offer ( new Item ( i , 0 , nums1 [ i ] + nums2 [ 0 ] )); while ( ! pq . isEmpty () && ans . size () < k ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; ans . add ( Arrays . asList ( nums1 [ i ] , nums2 [ j ] )); if ( j + 1 < nums2 . length ) pq . offer ( new Item ( i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ] )); } return ans ; } }","title":"373. Find K Pairs with Smallest Sums"},{"location":"problems/0373/#373-find-k-pairs-with-smallest-sums","text":"Time: $O(k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 struct Item { int i ; int j ; int sum ; // nums1[i] + nums2[j]; }; class Solution { public : vector < vector < int >> kSmallestPairs ( vector < int >& nums1 , vector < int >& nums2 , int k ) { if ( nums1 . empty () || nums2 . empty () || k == 0 ) return {}; vector < vector < int >> ans ; auto compare = [ & ]( const Item & a , const Item & b ) { return a . sum > b . sum ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < nums1 . size (); ++ i ) pq . push ({ i , 0 , nums1 [ i ] + nums2 [ 0 ]}); while ( ! pq . empty () && ans . size () < k ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); ans . push_back ({ nums1 [ i ], nums2 [ j ]}); if ( j + 1 < nums2 . size ()) pq . push ({ i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Item { public int i ; public int j ; public int sum ; // nums1[i] + nums2[j] public Item ( int i , int j , int sum ) { this . i = i ; this . j = j ; this . sum = sum ; } } class Solution { public List < List < Integer >> kSmallestPairs ( int [] nums1 , int [] nums2 , int k ) { if ( nums1 . length == 0 || nums2 . length == 0 || k == 0 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . sum - b . sum ); for ( int i = 0 ; i < k && i < nums1 . length ; ++ i ) pq . offer ( new Item ( i , 0 , nums1 [ i ] + nums2 [ 0 ] )); while ( ! pq . isEmpty () && ans . size () < k ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; ans . add ( Arrays . asList ( nums1 [ i ] , nums2 [ j ] )); if ( j + 1 < nums2 . length ) pq . offer ( new Item ( i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ] )); } return ans ; } }","title":"373. Find K Pairs with Smallest Sums"},{"location":"problems/0374/","text":"374. Guess Number Higher or Lower Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Forward declaration of guess API. * (The problem description is not clear, so I translate it into follows.) * * @param traget num * guess num * * @return -1 if guess num > target num * 1 if guess num < target num * 0 if guess num == target num */ class Solution { public : int guessNumber ( int n ) { int l = 1 ; int r = n ; // find the first guess num that >= target num while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( guess ( m ) == 1 ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Forward declaration of guess API. * (The problem description is not clear, so I translate it into follows.) * * @param traget num * guess num * * @return -1 if guess num > target num * 1 if guess num < target num * 0 if guess num == target num */ public class Solution extends GuessGame { public int guessNumber ( int n ) { int l = 1 ; int r = n ; // find the first guess num that >= target num while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( guess ( m ) == 1 ) l = m + 1 ; else r = m ; } return l ; } }","title":"374. Guess Number Higher or Lower"},{"location":"problems/0374/#374-guess-number-higher-or-lower","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Forward declaration of guess API. * (The problem description is not clear, so I translate it into follows.) * * @param traget num * guess num * * @return -1 if guess num > target num * 1 if guess num < target num * 0 if guess num == target num */ class Solution { public : int guessNumber ( int n ) { int l = 1 ; int r = n ; // find the first guess num that >= target num while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( guess ( m ) == 1 ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Forward declaration of guess API. * (The problem description is not clear, so I translate it into follows.) * * @param traget num * guess num * * @return -1 if guess num > target num * 1 if guess num < target num * 0 if guess num == target num */ public class Solution extends GuessGame { public int guessNumber ( int n ) { int l = 1 ; int r = n ; // find the first guess num that >= target num while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( guess ( m ) == 1 ) l = m + 1 ; else r = m ; } return l ; } }","title":"374. Guess Number Higher or Lower"},{"location":"problems/0375/","text":"375. Guess Number Higher or Lower II Approach 1: Bottom-up Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; dp [ i ][ j ] = INT_MAX ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]) + k ); } return dp [ 1 ][ n ]; } }; Approach 2: Top-down Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> memo ( n + 1 , vector < int > ( n + 1 , 0 )); function < int ( int , int ) > dp = [ & ]( int l , int r ) { if ( l >= r ) return 0 ; int & ans = memo [ l ][ r ]; if ( ans ) return ans ; ans = INT_MAX ; for ( int i = l ; i <= r ; ++ i ) ans = min ( ans , max ( dp ( l , i - 1 ), dp ( i + 1 , r )) + i ); return ans ; }; return dp ( 1 , n ); } };","title":"375. Guess Number Higher or Lower II"},{"location":"problems/0375/#375-guess-number-higher-or-lower-ii","text":"","title":"375. Guess Number Higher or Lower II"},{"location":"problems/0375/#approach-1-bottom-up","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; dp [ i ][ j ] = INT_MAX ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]) + k ); } return dp [ 1 ][ n ]; } };","title":"Approach 1: Bottom-up"},{"location":"problems/0375/#approach-2-top-down","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> memo ( n + 1 , vector < int > ( n + 1 , 0 )); function < int ( int , int ) > dp = [ & ]( int l , int r ) { if ( l >= r ) return 0 ; int & ans = memo [ l ][ r ]; if ( ans ) return ans ; ans = INT_MAX ; for ( int i = l ; i <= r ; ++ i ) ans = min ( ans , max ( dp ( l , i - 1 ), dp ( i + 1 , r )) + i ); return ans ; }; return dp ( 1 , n ); } };","title":"Approach 2: Top-down"},{"location":"problems/0376/","text":"376. Wiggle Subsequence Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int wiggleMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ]) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ]) decreasing = increasing + 1 ; return max ( increasing , decreasing ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int wiggleMaxLength ( int [] nums ) { if ( nums . length == 0 ) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] > nums [ i - 1 ] ) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ] ) decreasing = increasing + 1 ; return Math . max ( increasing , decreasing ); } }","title":"376. Wiggle Subsequence"},{"location":"problems/0376/#376-wiggle-subsequence","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int wiggleMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ]) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ]) decreasing = increasing + 1 ; return max ( increasing , decreasing ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int wiggleMaxLength ( int [] nums ) { if ( nums . length == 0 ) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] > nums [ i - 1 ] ) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ] ) decreasing = increasing + 1 ; return Math . max ( increasing , decreasing ); } }","title":"376. Wiggle Subsequence"},{"location":"problems/0377/","text":"377. Combination Sum IV Time: $O(|coins| \\times target)$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < unsigned long long > dp ( target + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= target ; ++ i ) for ( const int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int combinationSum4 ( int [] nums , int target ) { // dp[i] := # of combinations that add up to i int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i <= target ; ++ i ) for ( final int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans","title":"377. Combination Sum IV"},{"location":"problems/0377/#377-combination-sum-iv","text":"Time: $O(|coins| \\times target)$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < unsigned long long > dp ( target + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= target ; ++ i ) for ( const int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int combinationSum4 ( int [] nums , int target ) { // dp[i] := # of combinations that add up to i int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i <= target ; ++ i ) for ( final int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans","title":"377. Combination Sum IV"},{"location":"problems/0378/","text":"378. Kth Smallest Element in a Sorted Matrix Approach 1: Heap Time: $O(k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Item { int i ; int j ; int num ; // matrix[i][j] }; class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { auto compare = [ & ]( const Item & a , const Item & b ) { return a . num > b . num ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < matrix . size (); ++ i ) pq . push ({ i , 0 , matrix [ i ][ 0 ]}); while ( k -- > 1 ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); if ( j + 1 < matrix [ 0 ]. size ()) pq . push ({ i , j + 1 , matrix [ i ][ j + 1 ]}); } return pq . top (). num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Item { public int i ; public int j ; public int num ; // matrix[i][j] public Item ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int kthSmallest ( int [][] matrix , int k ) { PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . num - b . num ); for ( int i = 0 ; i < k && i < matrix . length ; ++ i ) pq . offer ( new Item ( i , 0 , matrix [ i ][ 0 ] )); while ( k -- > 1 ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; if ( j + 1 < matrix [ 0 ] . length ) pq . offer ( new Item ( i , j + 1 , matrix [ i ][ j + 1 ] )); } return pq . peek (). num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l Approach 2: Binary Search Time: $O(n\\log(\\max - \\min))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); auto numsNoGreaterThan = [ & ]( int m ) { int count = 0 ; int j = matrix [ 0 ]. size () - 1 ; // for each row, find the first index j s.t. row[j] <= m // so numsNoGreaterThan m for this row will be j + 1 for ( const vector < int >& row : matrix ) { while ( j >= 0 && row [ j ] > m ) -- j ; count += j + 1 ; } return count ; }; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( m ) >= k ) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int kthSmallest ( int [][] matrix , int k ) { int l = matrix [ 0 ][ 0 ] ; int r = matrix [ matrix . length - 1 ][ matrix . length - 1 ] ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( matrix , m ) < k ) l = m + 1 ; else r = m ; } return l ; } private int numsNoGreaterThan ( int [][] matrix , int m ) { int count = 0 ; int j = matrix [ 0 ] . length - 1 ; // for each row, find the first index j s.t. row[j] <= m // so numsNoGreaterThan m for this row will be j + 1 for ( final int [] row : matrix ) { while ( j >= 0 && row [ j ] > m ) -- j ; count += j + 1 ; } return count ; } }","title":"378. Kth Smallest Element in a Sorted Matrix"},{"location":"problems/0378/#378-kth-smallest-element-in-a-sorted-matrix","text":"","title":"378. Kth Smallest Element in a Sorted Matrix"},{"location":"problems/0378/#approach-1-heap","text":"Time: $O(k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Item { int i ; int j ; int num ; // matrix[i][j] }; class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { auto compare = [ & ]( const Item & a , const Item & b ) { return a . num > b . num ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < matrix . size (); ++ i ) pq . push ({ i , 0 , matrix [ i ][ 0 ]}); while ( k -- > 1 ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); if ( j + 1 < matrix [ 0 ]. size ()) pq . push ({ i , j + 1 , matrix [ i ][ j + 1 ]}); } return pq . top (). num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Item { public int i ; public int j ; public int num ; // matrix[i][j] public Item ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int kthSmallest ( int [][] matrix , int k ) { PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . num - b . num ); for ( int i = 0 ; i < k && i < matrix . length ; ++ i ) pq . offer ( new Item ( i , 0 , matrix [ i ][ 0 ] )); while ( k -- > 1 ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; if ( j + 1 < matrix [ 0 ] . length ) pq . offer ( new Item ( i , j + 1 , matrix [ i ][ j + 1 ] )); } return pq . peek (). num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l","title":"Approach 1: Heap"},{"location":"problems/0378/#approach-2-binary-search","text":"Time: $O(n\\log(\\max - \\min))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); auto numsNoGreaterThan = [ & ]( int m ) { int count = 0 ; int j = matrix [ 0 ]. size () - 1 ; // for each row, find the first index j s.t. row[j] <= m // so numsNoGreaterThan m for this row will be j + 1 for ( const vector < int >& row : matrix ) { while ( j >= 0 && row [ j ] > m ) -- j ; count += j + 1 ; } return count ; }; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( m ) >= k ) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int kthSmallest ( int [][] matrix , int k ) { int l = matrix [ 0 ][ 0 ] ; int r = matrix [ matrix . length - 1 ][ matrix . length - 1 ] ; while ( l < r ) { final int m = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( matrix , m ) < k ) l = m + 1 ; else r = m ; } return l ; } private int numsNoGreaterThan ( int [][] matrix , int m ) { int count = 0 ; int j = matrix [ 0 ] . length - 1 ; // for each row, find the first index j s.t. row[j] <= m // so numsNoGreaterThan m for this row will be j + 1 for ( final int [] row : matrix ) { while ( j >= 0 && row [ j ] > m ) -- j ; count += j + 1 ; } return count ; } }","title":"Approach 2: Binary Search"},{"location":"problems/0379/","text":"379. Design Phone Directory \ud83d\udd12 Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class PhoneDirectory { public : /** Initialize your data structure here @param maxNumbers - The maximum numbers that can be stored in the phone directory. */ PhoneDirectory ( int maxNumbers ) : next ( maxNumbers ) { for ( int i = 0 ; i < maxNumbers - 1 ; ++ i ) next [ i ] = i + 1 ; next . back () = 0 ; } /** Provide a number which is not assigned to anyone. @return - Return an available number. Return -1 if none is available. */ int get () { if ( next [ number ] == -1 ) return -1 ; const int ans = number ; number = next [ number ]; next [ ans ] = -1 ; // mark as used return ans ; } /** Check if a number is available or not. */ bool check ( int number ) { return next [ number ] != -1 ; } /** Recycle or release a number. */ void release ( int number ) { if ( next [ number ] != -1 ) return ; next [ number ] = this -> number ; this -> number = number ; } private : int number = 0 ; // current possible available number vector < int > next ; // next available number }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PhoneDirectory { /** * Initialize your data structure here * * @param maxNumbers - The maximum numbers that can be stored in the phone * directory. */ public PhoneDirectory ( int maxNumbers ) { next = new int [ maxNumbers ] ; for ( int i = 0 ; i < maxNumbers - 1 ; ++ i ) next [ i ] = i + 1 ; next [ maxNumbers - 1 ] = 0 ; } /** * Provide a number which is not assigned to anyone. * * @return - Return an available number. Return -1 if none is available. */ public int get () { if ( next [ number ] == - 1 ) return - 1 ; final int availableNum = number ; number = next [ number ] ; next [ availableNum ] = - 1 ; // mark as used return ans ; } /** Check if a number is available or not. */ public boolean check ( int number ) { return next [ number ] != - 1 ; } /** Recycle or release a number. */ public void release ( int number ) { if ( next [ number ] != - 1 ) return ; next [ number ] = this . number ; this . number = number ; } private int number ; // current possible available number private int [] next ; // next available number }","title":"379. Design Phone Directory"},{"location":"problems/0379/#379-design-phone-directory","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class PhoneDirectory { public : /** Initialize your data structure here @param maxNumbers - The maximum numbers that can be stored in the phone directory. */ PhoneDirectory ( int maxNumbers ) : next ( maxNumbers ) { for ( int i = 0 ; i < maxNumbers - 1 ; ++ i ) next [ i ] = i + 1 ; next . back () = 0 ; } /** Provide a number which is not assigned to anyone. @return - Return an available number. Return -1 if none is available. */ int get () { if ( next [ number ] == -1 ) return -1 ; const int ans = number ; number = next [ number ]; next [ ans ] = -1 ; // mark as used return ans ; } /** Check if a number is available or not. */ bool check ( int number ) { return next [ number ] != -1 ; } /** Recycle or release a number. */ void release ( int number ) { if ( next [ number ] != -1 ) return ; next [ number ] = this -> number ; this -> number = number ; } private : int number = 0 ; // current possible available number vector < int > next ; // next available number }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PhoneDirectory { /** * Initialize your data structure here * * @param maxNumbers - The maximum numbers that can be stored in the phone * directory. */ public PhoneDirectory ( int maxNumbers ) { next = new int [ maxNumbers ] ; for ( int i = 0 ; i < maxNumbers - 1 ; ++ i ) next [ i ] = i + 1 ; next [ maxNumbers - 1 ] = 0 ; } /** * Provide a number which is not assigned to anyone. * * @return - Return an available number. Return -1 if none is available. */ public int get () { if ( next [ number ] == - 1 ) return - 1 ; final int availableNum = number ; number = next [ number ] ; next [ availableNum ] = - 1 ; // mark as used return ans ; } /** Check if a number is available or not. */ public boolean check ( int number ) { return next [ number ] != - 1 ; } /** Recycle or release a number. */ public void release ( int number ) { if ( next [ number ] != - 1 ) return ; next [ number ] = this . number ; this . number = number ; } private int number ; // current possible available number private int [] next ; // next available number }","title":"379. Design Phone Directory \ud83d\udd12"},{"location":"problems/0380/","text":"380. Insert Delete GetRandom O(1) Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class RandomizedSet { public : /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert ( int val ) { if ( valToIndex . count ( val )) return false ; valToIndex [ val ] = vals . size (); vals . push_back ( val ); return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove ( int val ) { if ( ! valToIndex . count ( val )) return false ; const int index = valToIndex [ val ]; // following two lines order are important when vals.size() == 1 valToIndex [ vals . back ()] = index ; valToIndex . erase ( val ); vals [ index ] = vals . back (); vals . pop_back (); return true ; } /** Get a random element from the set. */ int getRandom () { const int index = rand () % vals . size (); return vals [ index ]; } private : unordered_map < int , int > valToIndex ; // {val: index in vals} vector < int > vals ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class RandomizedSet { /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert ( int val ) { if ( valToIndex . containsKey ( val )) return false ; valToIndex . put ( val , vals . size ()); vals . add ( val ); return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove ( int val ) { if ( ! valToIndex . containsKey ( val )) return false ; final int index = valToIndex . get ( val ); // following two lines order are important when vals.size() == 1 valToIndex . put ( last ( vals ), index ); valToIndex . remove ( val ); vals . set ( index , last ( vals )); vals . remove ( vals . size () - 1 ); return true ; } /** Get a random element from the set. */ public int getRandom () { final int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private Map < Integer , Integer > valToIndex = new HashMap <> (); // {val: index in vals} private List < Integer > vals = new ArrayList <> (); private Random rand = new Random (); private int last ( List < Integer > vals ) { return vals . get ( vals . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"380. Insert Delete GetRandom O(1)"},{"location":"problems/0380/#380-insert-delete-getrandom-o1","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class RandomizedSet { public : /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert ( int val ) { if ( valToIndex . count ( val )) return false ; valToIndex [ val ] = vals . size (); vals . push_back ( val ); return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove ( int val ) { if ( ! valToIndex . count ( val )) return false ; const int index = valToIndex [ val ]; // following two lines order are important when vals.size() == 1 valToIndex [ vals . back ()] = index ; valToIndex . erase ( val ); vals [ index ] = vals . back (); vals . pop_back (); return true ; } /** Get a random element from the set. */ int getRandom () { const int index = rand () % vals . size (); return vals [ index ]; } private : unordered_map < int , int > valToIndex ; // {val: index in vals} vector < int > vals ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class RandomizedSet { /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert ( int val ) { if ( valToIndex . containsKey ( val )) return false ; valToIndex . put ( val , vals . size ()); vals . add ( val ); return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove ( int val ) { if ( ! valToIndex . containsKey ( val )) return false ; final int index = valToIndex . get ( val ); // following two lines order are important when vals.size() == 1 valToIndex . put ( last ( vals ), index ); valToIndex . remove ( val ); vals . set ( index , last ( vals )); vals . remove ( vals . size () - 1 ); return true ; } /** Get a random element from the set. */ public int getRandom () { final int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private Map < Integer , Integer > valToIndex = new HashMap <> (); // {val: index in vals} private List < Integer > vals = new ArrayList <> (); private Random rand = new Random (); private int last ( List < Integer > vals ) { return vals . get ( vals . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"380. Insert Delete GetRandom O(1)"},{"location":"problems/0381/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Item { int val ; int indexInMap ; }; class RandomizedCollection { public : /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ bool insert ( int val ) { valToIndices [ val ]. push_back ( items . size ()); items . push_back ({ val , ( int ) valToIndices [ val ]. size () - 1 }); return valToIndices [ val ]. size () == 1 ; } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ bool remove ( int val ) { if ( ! valToIndices . count ( val )) return false ; const int index = valToIndices [ val ]. back (); valToIndices [ items . back (). val ][ items . back (). indexInMap ] = index ; valToIndices [ val ]. pop_back (); if ( valToIndices [ val ]. empty ()) valToIndices . erase ( val ); items [ index ] = items . back (); items . pop_back (); return true ; } /** Get a random element from the collection. */ int getRandom () { const int index = rand () % items . size (); return items [ index ]. val ; } private : unordered_map < int , vector < int >> valToIndices ; vector < Item > items ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Item { public int val ; public int indexInMap ; public Item ( int val , int indexInMap ) { this . val = val ; this . indexInMap = indexInMap ; } } class RandomizedCollection { /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ public boolean insert ( int val ) { valToIndices . putIfAbsent ( val , new ArrayList <> ()); valToIndices . get ( val ). add ( items . size ()); items . add ( new Item ( val , valToIndices . get ( val ). size () - 1 )); return valToIndices . get ( val ). size () == 1 ; } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ public boolean remove ( int val ) { if ( ! valToIndices . containsKey ( val )) return false ; final int index = lastIndex ( valToIndices . get ( val )); valToIndices . get ( last ( items ). val ). set ( last ( items ). indexInMap , index ); final int indicesSize = valToIndices . get ( val ). size (); valToIndices . get ( val ). remove ( indicesSize - 1 ); if ( valToIndices . get ( val ). isEmpty ()) valToIndices . remove ( val ); items . set ( index , last ( items )); items . remove ( items . size () - 1 ); return true ; } /** Get a random element from the collection. */ public int getRandom () { final int index = rand . nextInt ( items . size ()); return items . get ( index ). val ; } private Map < Integer , List < Integer >> valToIndices = new HashMap <> (); private List < Item > items = new ArrayList <> (); private Random rand = new Random (); private int lastIndex ( List < Integer > indices ) { return indices . get ( indices . size () - 1 ); } private Item last ( List < Item > items ) { return items . get ( items . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ]","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed"},{"location":"problems/0381/#381-insert-delete-getrandom-o1-duplicates-allowed","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Item { int val ; int indexInMap ; }; class RandomizedCollection { public : /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ bool insert ( int val ) { valToIndices [ val ]. push_back ( items . size ()); items . push_back ({ val , ( int ) valToIndices [ val ]. size () - 1 }); return valToIndices [ val ]. size () == 1 ; } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ bool remove ( int val ) { if ( ! valToIndices . count ( val )) return false ; const int index = valToIndices [ val ]. back (); valToIndices [ items . back (). val ][ items . back (). indexInMap ] = index ; valToIndices [ val ]. pop_back (); if ( valToIndices [ val ]. empty ()) valToIndices . erase ( val ); items [ index ] = items . back (); items . pop_back (); return true ; } /** Get a random element from the collection. */ int getRandom () { const int index = rand () % items . size (); return items [ index ]. val ; } private : unordered_map < int , vector < int >> valToIndices ; vector < Item > items ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Item { public int val ; public int indexInMap ; public Item ( int val , int indexInMap ) { this . val = val ; this . indexInMap = indexInMap ; } } class RandomizedCollection { /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ public boolean insert ( int val ) { valToIndices . putIfAbsent ( val , new ArrayList <> ()); valToIndices . get ( val ). add ( items . size ()); items . add ( new Item ( val , valToIndices . get ( val ). size () - 1 )); return valToIndices . get ( val ). size () == 1 ; } /** Removes a value from the collection. Returns true if the collection contained the specified element. */ public boolean remove ( int val ) { if ( ! valToIndices . containsKey ( val )) return false ; final int index = lastIndex ( valToIndices . get ( val )); valToIndices . get ( last ( items ). val ). set ( last ( items ). indexInMap , index ); final int indicesSize = valToIndices . get ( val ). size (); valToIndices . get ( val ). remove ( indicesSize - 1 ); if ( valToIndices . get ( val ). isEmpty ()) valToIndices . remove ( val ); items . set ( index , last ( items )); items . remove ( items . size () - 1 ); return true ; } /** Get a random element from the collection. */ public int getRandom () { final int index = rand . nextInt ( items . size ()); return items . get ( index ). val ; } private Map < Integer , List < Integer >> valToIndices = new HashMap <> (); private List < Item > items = new ArrayList <> (); private Random rand = new Random (); private int lastIndex ( List < Integer > indices ) { return indices . get ( indices . size () - 1 ); } private Item last ( List < Item > items ) { return items . get ( items . size () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ]","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed"},{"location":"problems/0382/","text":"382. Linked List Random Node Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution ( ListNode * head ) : head ( head ) {} /** Returns a random node's value. */ int getRandom () { int ans = -1 ; int i = 1 ; for ( ListNode * curr = head ; curr ; curr = curr -> next , ++ i ) if ( rand () % i == 0 ) ans = curr -> val ; return ans ; } private : ListNode * head ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { /** * @param head The linked list's head. Note that the head is guaranteed to be * not null, so it contains at least one node. */ public Solution ( ListNode head ) { this . head = head ; } /** Returns a random node's value. */ public int getRandom () { int ans = - 1 ; int i = 1 ; for ( ListNode curr = head ; curr != null ; curr = curr . next , ++ i ) if ( rand . nextInt ( i ) == i - 1 ) ans = curr . val ; return ans ; } private ListNode head ; private Random rand = new Random (); }","title":"382. Linked List Random Node"},{"location":"problems/0382/#382-linked-list-random-node","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution ( ListNode * head ) : head ( head ) {} /** Returns a random node's value. */ int getRandom () { int ans = -1 ; int i = 1 ; for ( ListNode * curr = head ; curr ; curr = curr -> next , ++ i ) if ( rand () % i == 0 ) ans = curr -> val ; return ans ; } private : ListNode * head ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { /** * @param head The linked list's head. Note that the head is guaranteed to be * not null, so it contains at least one node. */ public Solution ( ListNode head ) { this . head = head ; } /** Returns a random node's value. */ public int getRandom () { int ans = - 1 ; int i = 1 ; for ( ListNode curr = head ; curr != null ; curr = curr . next , ++ i ) if ( rand . nextInt ( i ) == i - 1 ) ans = curr . val ; return ans ; } private ListNode head ; private Random rand = new Random (); }","title":"382. Linked List Random Node"},{"location":"problems/0383/","text":"383. Ransom Note Time: $O(|ransomNote| + |magazine|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canConstruct ( string ransomNote , string magazine ) { vector < int > count ( 128 ); for ( const char c : magazine ) ++ count [ c ]; for ( const char c : ransomNote ) if ( -- count [ c ] < 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [] count = new int [ 128 ] ; for ( final char c : magazine . toCharArray ()) ++ count [ c ] ; for ( final char c : ransomNote . toCharArray ()) if ( -- count [ c ] < 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 class Solution : def canConstruct ( self , ransomNote : str , magazine : str ) -> bool : count1 = collections . Counter ( ransomNote ) count2 = collections . Counter ( magazine ) return all ( count1 [ c ] <= count2 [ c ] for c in string . ascii_lowercase )","title":"383. Ransom Note"},{"location":"problems/0383/#383-ransom-note","text":"Time: $O(|ransomNote| + |magazine|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canConstruct ( string ransomNote , string magazine ) { vector < int > count ( 128 ); for ( const char c : magazine ) ++ count [ c ]; for ( const char c : ransomNote ) if ( -- count [ c ] < 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [] count = new int [ 128 ] ; for ( final char c : magazine . toCharArray ()) ++ count [ c ] ; for ( final char c : ransomNote . toCharArray ()) if ( -- count [ c ] < 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 class Solution : def canConstruct ( self , ransomNote : str , magazine : str ) -> bool : count1 = collections . Counter ( ransomNote ) count2 = collections . Counter ( magazine ) return all ( count1 [ c ] <= count2 [ c ] for c in string . ascii_lowercase )","title":"383. Ransom Note"},{"location":"problems/0384/","text":"384. Shuffle an Array Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) {} /** Resets the array to its original configuration and return it. */ vector < int > reset () { return nums ; } /** Returns a random shuffling of the array. */ vector < int > shuffle () { vector < int > A ( nums ); for ( int i = A . size () - 1 ; i > 0 ; -- i ) { const int j = rand () % ( i + 1 ); swap ( A [ i ], A [ j ]); } return A ; } private : vector < int > nums ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public Solution ( int [] nums ) { this . nums = nums ; } /** Resets the array to its original configuration and return it. */ public int [] reset () { return nums ; } /** Returns a random shuffling of the array. */ public int [] shuffle () { int [] A = Arrays . copyOf ( nums , nums . length ); for ( int i = A . length - 1 ; i > 0 ; -- i ) { final int j = rand . nextInt ( i + 1 ); swap ( A , i , j ); } return A ; } private int [] nums ; private Random rand = new Random (); private void swap ( int [] A , int i , int j ) { final int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } }","title":"384. Shuffle an Array"},{"location":"problems/0384/#384-shuffle-an-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) {} /** Resets the array to its original configuration and return it. */ vector < int > reset () { return nums ; } /** Returns a random shuffling of the array. */ vector < int > shuffle () { vector < int > A ( nums ); for ( int i = A . size () - 1 ; i > 0 ; -- i ) { const int j = rand () % ( i + 1 ); swap ( A [ i ], A [ j ]); } return A ; } private : vector < int > nums ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public Solution ( int [] nums ) { this . nums = nums ; } /** Resets the array to its original configuration and return it. */ public int [] reset () { return nums ; } /** Returns a random shuffling of the array. */ public int [] shuffle () { int [] A = Arrays . copyOf ( nums , nums . length ); for ( int i = A . length - 1 ; i > 0 ; -- i ) { final int j = rand . nextInt ( i + 1 ); swap ( A , i , j ); } return A ; } private int [] nums ; private Random rand = new Random (); private void swap ( int [] A , int i , int j ) { final int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } }","title":"384. Shuffle an Array"},{"location":"problems/0385/","text":"385. Mini Parser Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : NestedInteger deserialize ( string s ) { if ( s [ 0 ] != '[' ) return NestedInteger ( stoi ( s )); stack < NestedInteger > stack ; int start ; // the start index of num for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '[' : stack . push ( NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { const int num = stoi ( s . substr ( start , i )); stack . top (). add ( NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . top (); stack . pop (); if ( i > start ) { const int num = stoi ( s . substr ( start , i )); popped . add ( NestedInteger ( num )); } if ( stack . empty ()) return popped ; else stack . top (). add ( popped ); start = i + 1 ; break ; } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public NestedInteger deserialize ( String s ) { if ( s . charAt ( 0 ) != '[' ) return new NestedInteger ( Integer . valueOf ( s )); Stack < NestedInteger > stack = new Stack <> (); int start = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) switch ( s . charAt ( i )) { case '[' : stack . push ( new NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { final int num = Integer . valueOf ( s . substring ( start , i )); stack . peek (). add ( new NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . pop (); if ( i > start ) { final int num = Integer . valueOf ( s . substring ( start , i )); popped . add ( new NestedInteger ( num )); } if ( ! stack . isEmpty ()) stack . peek (). add ( popped ); else return popped ; start = i + 1 ; break ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def deserialize ( self , s : str ) -> NestedInteger : if s [ 0 ] != '[' : return NestedInteger ( int ( s )) stack = [] for i , c in enumerate ( s ): if c == '[' : stack . append ( NestedInteger ()) start = i + 1 elif c == ',' : if i > start : num = int ( s [ start : i ]) stack [ - 1 ] . add ( NestedInteger ( num )) start = i + 1 elif c == ']' : popped = stack . pop () if i > start : num = int ( s [ start : i ]) popped . add ( NestedInteger ( num )) if stack : stack [ - 1 ] . add ( popped ) else : return popped start = i + 1","title":"385. Mini Parser"},{"location":"problems/0385/#385-mini-parser","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : NestedInteger deserialize ( string s ) { if ( s [ 0 ] != '[' ) return NestedInteger ( stoi ( s )); stack < NestedInteger > stack ; int start ; // the start index of num for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '[' : stack . push ( NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { const int num = stoi ( s . substr ( start , i )); stack . top (). add ( NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . top (); stack . pop (); if ( i > start ) { const int num = stoi ( s . substr ( start , i )); popped . add ( NestedInteger ( num )); } if ( stack . empty ()) return popped ; else stack . top (). add ( popped ); start = i + 1 ; break ; } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public NestedInteger deserialize ( String s ) { if ( s . charAt ( 0 ) != '[' ) return new NestedInteger ( Integer . valueOf ( s )); Stack < NestedInteger > stack = new Stack <> (); int start = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) switch ( s . charAt ( i )) { case '[' : stack . push ( new NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { final int num = Integer . valueOf ( s . substring ( start , i )); stack . peek (). add ( new NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . pop (); if ( i > start ) { final int num = Integer . valueOf ( s . substring ( start , i )); popped . add ( new NestedInteger ( num )); } if ( ! stack . isEmpty ()) stack . peek (). add ( popped ); else return popped ; start = i + 1 ; break ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def deserialize ( self , s : str ) -> NestedInteger : if s [ 0 ] != '[' : return NestedInteger ( int ( s )) stack = [] for i , c in enumerate ( s ): if c == '[' : stack . append ( NestedInteger ()) start = i + 1 elif c == ',' : if i > start : num = int ( s [ start : i ]) stack [ - 1 ] . add ( NestedInteger ( num )) start = i + 1 elif c == ']' : popped = stack . pop () if i > start : num = int ( s [ start : i ]) popped . add ( NestedInteger ( num )) if stack : stack [ - 1 ] . add ( popped ) else : return popped start = i + 1","title":"385. Mini Parser"},{"location":"problems/0386/","text":"386. Lexicographical Numbers Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > lexicalOrder ( int n ) { vector < int > ans ; int curr = 1 ; while ( ans . size () < n ) { ans . push_back ( curr ); if ( curr * 10 <= n ) { curr *= 10 ; } else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > lexicalOrder ( int n ) { List < Integer > ans = new ArrayList <> (); int curr = 1 ; while ( ans . size () < n ) { ans . add ( curr ); if ( curr * 10 <= n ) { curr *= 10 ; } else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } }","title":"386. Lexicographical Numbers"},{"location":"problems/0386/#386-lexicographical-numbers","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > lexicalOrder ( int n ) { vector < int > ans ; int curr = 1 ; while ( ans . size () < n ) { ans . push_back ( curr ); if ( curr * 10 <= n ) { curr *= 10 ; } else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > lexicalOrder ( int n ) { List < Integer > ans = new ArrayList <> (); int curr = 1 ; while ( ans . size () < n ) { ans . add ( curr ); if ( curr * 10 <= n ) { curr *= 10 ; } else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } }","title":"386. Lexicographical Numbers"},{"location":"problems/0387/","text":"387. First Unique Character in a String Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int firstUniqChar ( string s ) { vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s [ i ]] == 1 ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int firstUniqChar ( String s ) { int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s . charAt ( i ) ] == 1 ) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def firstUniqChar ( self , s : str ) -> int : count = collections . Counter ( s ) for i , c in enumerate ( s ): if count [ c ] == 1 : return i return - 1","title":"387. First Unique Character in a String"},{"location":"problems/0387/#387-first-unique-character-in-a-string","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int firstUniqChar ( string s ) { vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s [ i ]] == 1 ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int firstUniqChar ( String s ) { int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s . charAt ( i ) ] == 1 ) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def firstUniqChar ( self , s : str ) -> int : count = collections . Counter ( s ) for i , c in enumerate ( s ): if count [ c ] == 1 : return i return - 1","title":"387. First Unique Character in a String"},{"location":"problems/0388/","text":"388. Longest Absolute File Path Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Item { int depth ; size_t length ; }; class Solution { public : int lengthLongestPath ( string input ) { size_t ans = 0 ; stack < Item > stack {{{ -1 , 0 }}}; // placeholder istringstream iss ( input ); for ( string token ; getline ( iss , token , '\\n' );) { const int depth = count_if ( begin ( token ), end ( token ), []( char c ) { return c == '\\t' ; }); token . erase ( remove ( begin ( token ), end ( token ), '\\t' ), end ( token )); while ( depth <= stack . top (). depth ) stack . pop (); if ( isFile ( token )) ans = max ( ans , stack . top (). length + token . length ()); else // directory + '/' stack . push ({ depth , stack . top (). length + token . length () + 1 }); } return ans ; } private : bool isFile ( const string & token ) { return token . find ( '.' ) != string :: npos ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Item { public int depth ; public int length ; public Item ( int depth , int length ) { this . depth = depth ; this . length = length ; } } class Solution { public int lengthLongestPath ( String input ) { int ans = 0 ; Stack < Item > stack = new Stack <> (); stack . push ( new Item ( - 1 , 0 )); for ( String token : input . split ( \"\\n\" )) { final int depth = getDepth ( token ); token = token . replace ( \"\\t\" , \"\" ); while ( depth <= stack . peek (). depth ) stack . pop (); if ( token . contains ( \".\" )) // file ans = Math . max ( ans , stack . peek (). length + token . length ()); else // directory + '/' stack . push ( new Item ( depth , stack . peek (). length + token . length () + 1 )); } return ans ; } private int getDepth ( final String token ) { return ( int ) token . chars (). filter ( c -> c == '\\t' ). count (); } }","title":"388. Longest Absolute File Path"},{"location":"problems/0388/#388-longest-absolute-file-path","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Item { int depth ; size_t length ; }; class Solution { public : int lengthLongestPath ( string input ) { size_t ans = 0 ; stack < Item > stack {{{ -1 , 0 }}}; // placeholder istringstream iss ( input ); for ( string token ; getline ( iss , token , '\\n' );) { const int depth = count_if ( begin ( token ), end ( token ), []( char c ) { return c == '\\t' ; }); token . erase ( remove ( begin ( token ), end ( token ), '\\t' ), end ( token )); while ( depth <= stack . top (). depth ) stack . pop (); if ( isFile ( token )) ans = max ( ans , stack . top (). length + token . length ()); else // directory + '/' stack . push ({ depth , stack . top (). length + token . length () + 1 }); } return ans ; } private : bool isFile ( const string & token ) { return token . find ( '.' ) != string :: npos ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Item { public int depth ; public int length ; public Item ( int depth , int length ) { this . depth = depth ; this . length = length ; } } class Solution { public int lengthLongestPath ( String input ) { int ans = 0 ; Stack < Item > stack = new Stack <> (); stack . push ( new Item ( - 1 , 0 )); for ( String token : input . split ( \"\\n\" )) { final int depth = getDepth ( token ); token = token . replace ( \"\\t\" , \"\" ); while ( depth <= stack . peek (). depth ) stack . pop (); if ( token . contains ( \".\" )) // file ans = Math . max ( ans , stack . peek (). length + token . length ()); else // directory + '/' stack . push ( new Item ( depth , stack . peek (). length + token . length () + 1 )); } return ans ; } private int getDepth ( final String token ) { return ( int ) token . chars (). filter ( c -> c == '\\t' ). count (); } }","title":"388. Longest Absolute File Path"},{"location":"problems/0389/","text":"389. Find the Difference Approach 1: Bit Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : char findTheDifference ( string s , string t ) { char ans = 0 ; for ( const char c : s ) ans ^= c ; for ( const char c : t ) ans ^= c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public char findTheDifference ( String s , String t ) { char ans = 0 ; for ( final char c : s . toCharArray ()) ans ^= c ; for ( final char c : t . toCharArray ()) ans ^= c ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def findTheDifference ( self , s : str , t : str ) -> str : count = collections . Counter ( s ) for i , c in enumerate ( t ): count [ c ] -= 1 if count [ c ] == - 1 : return c Approach 2: Hash Table Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : char findTheDifference ( string s , string t ) { vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : t ) if ( -- count [ c ] < 0 ) return c ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public char findTheDifference ( String s , String t ) { int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : t . toCharArray ()) if ( -- count [ c ] < 0 ) return c ; throw new IllegalArgumentException (); } }","title":"389. Find the Difference"},{"location":"problems/0389/#389-find-the-difference","text":"","title":"389. Find the Difference"},{"location":"problems/0389/#approach-1-bit","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : char findTheDifference ( string s , string t ) { char ans = 0 ; for ( const char c : s ) ans ^= c ; for ( const char c : t ) ans ^= c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public char findTheDifference ( String s , String t ) { char ans = 0 ; for ( final char c : s . toCharArray ()) ans ^= c ; for ( final char c : t . toCharArray ()) ans ^= c ; return ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def findTheDifference ( self , s : str , t : str ) -> str : count = collections . Counter ( s ) for i , c in enumerate ( t ): count [ c ] -= 1 if count [ c ] == - 1 : return c","title":"Approach 1: Bit"},{"location":"problems/0389/#approach-2-hash-table","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : char findTheDifference ( string s , string t ) { vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const char c : t ) if ( -- count [ c ] < 0 ) return c ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public char findTheDifference ( String s , String t ) { int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final char c : t . toCharArray ()) if ( -- count [ c ] < 0 ) return c ; throw new IllegalArgumentException (); } }","title":"Approach 2: Hash Table"},{"location":"problems/0390/","text":"390. Elimination Game Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 class Solution { public : int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } }; Java 1 2 3 4 5 class Solution { public int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } }","title":"390. Elimination Game"},{"location":"problems/0390/#390-elimination-game","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 class Solution { public : int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } }; Java 1 2 3 4 5 class Solution { public int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } }","title":"390. Elimination Game"},{"location":"problems/0391/","text":"391. Perfect Rectangle Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isRectangleCover ( vector < vector < int >>& rectangles ) { int area = 0 ; int x1 = INT_MAX ; int y1 = INT_MAX ; int x2 = INT_MIN ; int y2 = INT_MIN ; unordered_set < string > corners ; for ( const vector < int >& r : rectangles ) { area += ( r [ 2 ] - r [ 0 ]) * ( r [ 3 ] - r [ 1 ]); x1 = min ( x1 , r [ 0 ]); y1 = min ( y1 , r [ 1 ]); x2 = max ( x2 , r [ 2 ]); y2 = max ( y2 , r [ 3 ]); // four points of current rectangle const vector < string > points { to_string ( r [ 0 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 0 ]) + \" \" + to_string ( r [ 3 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 3 ]) }; for ( const string & point : points ) if ( ! corners . insert ( point ). second ) corners . erase ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y2 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y2 ))) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean isRectangleCover ( int [][] rectangles ) { int area = 0 ; int x1 = Integer . MAX_VALUE ; int y1 = Integer . MAX_VALUE ; int x2 = Integer . MIN_VALUE ; int y2 = Integer . MIN_VALUE ; Set < String > corners = new HashSet <> (); for ( final int [] r : rectangles ) { area += ( r [ 2 ] - r [ 0 ] ) * ( r [ 3 ] - r [ 1 ] ); x1 = Math . min ( x1 , r [ 0 ] ); y1 = Math . min ( y1 , r [ 1 ] ); x2 = Math . max ( x2 , r [ 2 ] ); y2 = Math . max ( y2 , r [ 3 ] ); // four points of current rectangle final String [] points = new String [] { r [ 0 ] + \" \" + r [ 1 ] , r [ 0 ] + \" \" + r [ 3 ] , r [ 2 ] + \" \" + r [ 1 ] , r [ 2 ] + \" \" + r [ 3 ] }; for ( final String point : points ) if ( ! corners . add ( point )) corners . remove ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . contains ( x1 + \" \" + y1 ) || ! corners . contains ( x1 + \" \" + y2 ) || ! corners . contains ( x2 + \" \" + y1 ) || ! corners . contains ( x2 + \" \" + y2 )) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } }","title":"391. Perfect Rectangle"},{"location":"problems/0391/#391-perfect-rectangle","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isRectangleCover ( vector < vector < int >>& rectangles ) { int area = 0 ; int x1 = INT_MAX ; int y1 = INT_MAX ; int x2 = INT_MIN ; int y2 = INT_MIN ; unordered_set < string > corners ; for ( const vector < int >& r : rectangles ) { area += ( r [ 2 ] - r [ 0 ]) * ( r [ 3 ] - r [ 1 ]); x1 = min ( x1 , r [ 0 ]); y1 = min ( y1 , r [ 1 ]); x2 = max ( x2 , r [ 2 ]); y2 = max ( y2 , r [ 3 ]); // four points of current rectangle const vector < string > points { to_string ( r [ 0 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 0 ]) + \" \" + to_string ( r [ 3 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 3 ]) }; for ( const string & point : points ) if ( ! corners . insert ( point ). second ) corners . erase ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y2 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y2 ))) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean isRectangleCover ( int [][] rectangles ) { int area = 0 ; int x1 = Integer . MAX_VALUE ; int y1 = Integer . MAX_VALUE ; int x2 = Integer . MIN_VALUE ; int y2 = Integer . MIN_VALUE ; Set < String > corners = new HashSet <> (); for ( final int [] r : rectangles ) { area += ( r [ 2 ] - r [ 0 ] ) * ( r [ 3 ] - r [ 1 ] ); x1 = Math . min ( x1 , r [ 0 ] ); y1 = Math . min ( y1 , r [ 1 ] ); x2 = Math . max ( x2 , r [ 2 ] ); y2 = Math . max ( y2 , r [ 3 ] ); // four points of current rectangle final String [] points = new String [] { r [ 0 ] + \" \" + r [ 1 ] , r [ 0 ] + \" \" + r [ 3 ] , r [ 2 ] + \" \" + r [ 1 ] , r [ 2 ] + \" \" + r [ 3 ] }; for ( final String point : points ) if ( ! corners . add ( point )) corners . remove ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . contains ( x1 + \" \" + y1 ) || ! corners . contains ( x1 + \" \" + y2 ) || ! corners . contains ( x2 + \" \" + y1 ) || ! corners . contains ( x2 + \" \" + y2 )) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } }","title":"391. Perfect Rectangle"},{"location":"problems/0392/","text":"392. Is Subsequence Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isSubsequence ( string s , string t ) { if ( s . empty ()) return true ; int i = 0 ; for ( const char c : t ) if ( s [ i ] == c && ++ i == s . length ()) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isSubsequence ( String s , String t ) { if ( s . isEmpty ()) return true ; int i = 0 ; for ( final char c : t . toCharArray ()) if ( s . charAt ( i ) == c && ++ i == s . length ()) return true ; return false ; } }","title":"392. Is Subsequence"},{"location":"problems/0392/#392-is-subsequence","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isSubsequence ( string s , string t ) { if ( s . empty ()) return true ; int i = 0 ; for ( const char c : t ) if ( s [ i ] == c && ++ i == s . length ()) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean isSubsequence ( String s , String t ) { if ( s . isEmpty ()) return true ; int i = 0 ; for ( final char c : t . toCharArray ()) if ( s . charAt ( i ) == c && ++ i == s . length ()) return true ; return false ; } }","title":"392. Is Subsequence"},{"location":"problems/0393/","text":"393. UTF-8 Validation Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool validUtf8 ( vector < int >& data ) { int leftToCheck = 0 ; for ( const int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean validUtf8 ( int [] data ) { int leftToCheck = 0 ; for ( final int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } }","title":"393. UTF-8 Validation"},{"location":"problems/0393/#393-utf-8-validation","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool validUtf8 ( vector < int >& data ) { int leftToCheck = 0 ; for ( const int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean validUtf8 ( int [] data ) { int leftToCheck = 0 ; for ( final int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } }","title":"393. UTF-8 Validation"},{"location":"problems/0394/","text":"394. Decode String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : string decodeString ( string s ) { stack < pair < string , int >> stack ; // {prevStr, repeatCount} string currStr ; int currNum = 0 ; for ( const char c : s ) if ( isdigit ( c )) { currNum = currNum * 10 + ( c - '0' ); } else { if ( c == '[' ) { stack . push ({ currStr , currNum }); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { const auto [ prevStr , n ] = stack . top (); stack . pop (); currStr = prevStr + getRepeatedStr ( currStr , n ); currNum = 0 ; } else { currStr += c ; } } return currStr ; } private : // s * n times string getRepeatedStr ( const string & s , int n ) { string repeat ; while ( n -- ) repeat += s ; return repeat ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public String decodeString ( String s ) { Stack < Pair < StringBuilder , Integer >> stack = new Stack <> (); // {prevStr, repeatCount} StringBuilder currStr = new StringBuilder (); int currNum = 0 ; for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) { currNum = currNum * 10 + ( c - '0' ); } else { if ( c == '[' ) { stack . push ( new Pair <> ( currStr , currNum )); currStr = new StringBuilder (); currNum = 0 ; } else if ( c == ']' ) { final Pair < StringBuilder , Integer > pair = stack . pop (); final StringBuilder prevStr = pair . getKey (); final int n = pair . getValue (); currStr = prevStr . append ( getRepeatedStr ( currStr , n )); currNum = 0 ; } else { currStr . append ( c ); } } return currStr . toString (); } // s * n times private StringBuilder getRepeatedStr ( StringBuilder s , int n ) { StringBuilder sb = new StringBuilder (); while ( n -- > 0 ) sb . append ( s ); return sb ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def decodeString ( self , s : str ) -> str : currNum = 0 currStr = '' stack = [] for c in s : if c . isdigit (): currNum = currNum * 10 + int ( c ) elif c == '[' : stack . append ( currStr ) stack . append ( currNum ) currStr = '' currNum = 0 elif c == ']' : num = stack . pop () prevStr = stack . pop () currStr = prevStr + num * currStr else : currStr += c return currStr","title":"394. Decode String"},{"location":"problems/0394/#394-decode-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : string decodeString ( string s ) { stack < pair < string , int >> stack ; // {prevStr, repeatCount} string currStr ; int currNum = 0 ; for ( const char c : s ) if ( isdigit ( c )) { currNum = currNum * 10 + ( c - '0' ); } else { if ( c == '[' ) { stack . push ({ currStr , currNum }); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { const auto [ prevStr , n ] = stack . top (); stack . pop (); currStr = prevStr + getRepeatedStr ( currStr , n ); currNum = 0 ; } else { currStr += c ; } } return currStr ; } private : // s * n times string getRepeatedStr ( const string & s , int n ) { string repeat ; while ( n -- ) repeat += s ; return repeat ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public String decodeString ( String s ) { Stack < Pair < StringBuilder , Integer >> stack = new Stack <> (); // {prevStr, repeatCount} StringBuilder currStr = new StringBuilder (); int currNum = 0 ; for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) { currNum = currNum * 10 + ( c - '0' ); } else { if ( c == '[' ) { stack . push ( new Pair <> ( currStr , currNum )); currStr = new StringBuilder (); currNum = 0 ; } else if ( c == ']' ) { final Pair < StringBuilder , Integer > pair = stack . pop (); final StringBuilder prevStr = pair . getKey (); final int n = pair . getValue (); currStr = prevStr . append ( getRepeatedStr ( currStr , n )); currNum = 0 ; } else { currStr . append ( c ); } } return currStr . toString (); } // s * n times private StringBuilder getRepeatedStr ( StringBuilder s , int n ) { StringBuilder sb = new StringBuilder (); while ( n -- > 0 ) sb . append ( s ); return sb ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def decodeString ( self , s : str ) -> str : currNum = 0 currStr = '' stack = [] for c in s : if c . isdigit (): currNum = currNum * 10 + int ( c ) elif c == '[' : stack . append ( currStr ) stack . append ( currNum ) currStr = '' currNum = 0 elif c == ']' : num = stack . pop () prevStr = stack . pop () currStr = prevStr + num * currStr else : currStr += c return currStr","title":"394. Decode String"},{"location":"problems/0395/","text":"395. Longest Substring with At Least K Repeating Characters Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int longestSubstring ( string s , int k ) { int ans = 0 ; for ( int n = 1 ; n <= 26 ; ++ n ) ans = max ( ans , longestSubstringWithNUniqueCharacters ( s , k , n )); return ans ; } private : int longestSubstringWithNUniqueCharacters ( const string & s , int k , int n ) { int ans = 0 ; int uniqueChars = 0 ; // # of unique chars in window int noLessThanK = 0 ; // # of chars >= k in window vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s [ r ]] == 0 ) ++ uniqueChars ; if ( ++ count [ s [ r ]] == k ) ++ noLessThanK ; while ( uniqueChars > n ) { if ( count [ s [ l ]] == k ) -- noLessThanK ; if ( -- count [ s [ l ]] == 0 ) -- uniqueChars ; ++ l ; } if ( noLessThanK == n ) // unique chars also == n ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int longestSubstring ( String s , int k ) { int ans = 0 ; for ( int n = 1 ; n <= 26 ; ++ n ) ans = Math . max ( ans , longestSubstringWithNUniqueCharacters ( s , k , n )); return ans ; } private int longestSubstringWithNUniqueCharacters ( final String s , int k , int n ) { int ans = 0 ; int uniqueChars = 0 ; // unique chars in current substring s[l..r] int noLessThanK = 0 ; // # of chars >= k int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s . charAt ( r ) ] == 0 ) ++ uniqueChars ; if ( ++ count [ s . charAt ( r ) ] == k ) ++ noLessThanK ; while ( uniqueChars > n ) { if ( count [ s . charAt ( l ) ] == k ) -- noLessThanK ; if ( -- count [ s . charAt ( l ) ] == 0 ) -- uniqueChars ; ++ l ; } if ( noLessThanK == n ) // unique chars also == n ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"395. Longest Substring with At Least K Repeating Characters"},{"location":"problems/0395/#395-longest-substring-with-at-least-k-repeating-characters","text":"Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int longestSubstring ( string s , int k ) { int ans = 0 ; for ( int n = 1 ; n <= 26 ; ++ n ) ans = max ( ans , longestSubstringWithNUniqueCharacters ( s , k , n )); return ans ; } private : int longestSubstringWithNUniqueCharacters ( const string & s , int k , int n ) { int ans = 0 ; int uniqueChars = 0 ; // # of unique chars in window int noLessThanK = 0 ; // # of chars >= k in window vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s [ r ]] == 0 ) ++ uniqueChars ; if ( ++ count [ s [ r ]] == k ) ++ noLessThanK ; while ( uniqueChars > n ) { if ( count [ s [ l ]] == k ) -- noLessThanK ; if ( -- count [ s [ l ]] == 0 ) -- uniqueChars ; ++ l ; } if ( noLessThanK == n ) // unique chars also == n ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int longestSubstring ( String s , int k ) { int ans = 0 ; for ( int n = 1 ; n <= 26 ; ++ n ) ans = Math . max ( ans , longestSubstringWithNUniqueCharacters ( s , k , n )); return ans ; } private int longestSubstringWithNUniqueCharacters ( final String s , int k , int n ) { int ans = 0 ; int uniqueChars = 0 ; // unique chars in current substring s[l..r] int noLessThanK = 0 ; // # of chars >= k int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s . charAt ( r ) ] == 0 ) ++ uniqueChars ; if ( ++ count [ s . charAt ( r ) ] == k ) ++ noLessThanK ; while ( uniqueChars > n ) { if ( count [ s . charAt ( l ) ] == k ) -- noLessThanK ; if ( -- count [ s . charAt ( l ) ] == 0 ) -- uniqueChars ; ++ l ; } if ( noLessThanK == n ) // unique chars also == n ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"395. Longest Substring with At Least K Repeating Characters"},{"location":"problems/0396/","text":"396. Rotate Function Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxRotateFunction ( vector < int >& A ) { const int sum = accumulate ( begin ( A ), end ( A ), ( long ) 0 ); int f = 0 ; // calculate F(0) first for ( int i = 0 ; i < A . size (); ++ i ) f += i * A [ i ]; int ans = f ; for ( int i = A . size () - 1 ; i > 0 ; -- i ) { f += sum - A . size () * A [ i ]; ans = max ( ans , f ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxRotateFunction ( int [] A ) { final int sum = Arrays . stream ( A ). sum (); int f = 0 ; // calculate F(0) first for ( int i = 0 ; i < A . length ; ++ i ) f += i * A [ i ] ; int ans = f ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) { f += sum - A . length * A [ i ] ; ans = Math . max ( ans , f ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxRotateFunction ( self , A : List [ int ]) -> int : f = sum ( i * a for i , a in enumerate ( A )) ans = f summ = sum ( A ) for a in reversed ( A ): f += summ - len ( A ) * a ans = max ( ans , f ) return ans","title":"396. Rotate Function"},{"location":"problems/0396/#396-rotate-function","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxRotateFunction ( vector < int >& A ) { const int sum = accumulate ( begin ( A ), end ( A ), ( long ) 0 ); int f = 0 ; // calculate F(0) first for ( int i = 0 ; i < A . size (); ++ i ) f += i * A [ i ]; int ans = f ; for ( int i = A . size () - 1 ; i > 0 ; -- i ) { f += sum - A . size () * A [ i ]; ans = max ( ans , f ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxRotateFunction ( int [] A ) { final int sum = Arrays . stream ( A ). sum (); int f = 0 ; // calculate F(0) first for ( int i = 0 ; i < A . length ; ++ i ) f += i * A [ i ] ; int ans = f ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) { f += sum - A . length * A [ i ] ; ans = Math . max ( ans , f ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxRotateFunction ( self , A : List [ int ]) -> int : f = sum ( i * a for i , a in enumerate ( A )) ans = f summ = sum ( A ) for a in reversed ( A ): f += summ - len ( A ) * a ans = max ( ans , f ) return ans","title":"396. Rotate Function"},{"location":"problems/0397/","text":"397. Integer Replacement Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def integerReplacement ( self , n : int ) -> int : ans = 0 while n > 1 : if ( n & 1 ) == 0 : n >>= 1 elif n == 3 or (( n >> 1 ) & 1 ) == 0 : n -= 1 else : n += 1 ans += 1 return ans","title":"397. Integer Replacement"},{"location":"problems/0397/#397-integer-replacement","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def integerReplacement ( self , n : int ) -> int : ans = 0 while n > 1 : if ( n & 1 ) == 0 : n >>= 1 elif n == 3 or (( n >> 1 ) & 1 ) == 0 : n -= 1 else : n += 1 ans += 1 return ans","title":"397. Integer Replacement"},{"location":"problems/0398/","text":"398. Random Pick Index Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) {} int pick ( int target ) { int ans = -1 ; int range = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] == target && rand () % ++ range == 0 ) ans = i ; return ans ; } private : vector < int > nums ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.Random ; class Solution { public Solution ( int [] nums ) { this . nums = nums ; } public int pick ( int target ) { int ans = - 1 ; int range = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == target && rand . nextInt ( ++ range ) == 0 ) ans = i ; return ans ; } private int [] nums ; private Random rand = new Random (); }","title":"398. Random Pick Index"},{"location":"problems/0398/#398-random-pick-index","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) {} int pick ( int target ) { int ans = -1 ; int range = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] == target && rand () % ++ range == 0 ) ans = i ; return ans ; } private : vector < int > nums ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.util.Random ; class Solution { public Solution ( int [] nums ) { this . nums = nums ; } public int pick ( int target ) { int ans = - 1 ; int range = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] == target && rand . nextInt ( ++ range ) == 0 ) ans = i ; return ans ; } private int [] nums ; private Random rand = new Random (); }","title":"398. Random Pick Index"},{"location":"problems/0399/","text":"399. Evaluate Division Time: $O(e + eq) \\to O(e + q)$, where e = len(equations) and q = len(queries) Space: $O(e)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < double > calcEquation ( vector < vector < string >>& equations , vector < double >& values , vector < vector < string >>& queries ) { vector < double > ans ; // graph[A][B] := A / B unordered_map < string , unordered_map < string , double >> graph ; // construct the graph for ( int i = 0 ; i < equations . size (); ++ i ) { const string & A = equations [ i ][ 0 ]; const string & B = equations [ i ][ 1 ]; graph [ A ][ B ] = values [ i ]; graph [ B ][ A ] = 1 / values [ i ]; } for ( const vector < string >& query : queries ) { const string & A = query [ 0 ]; const string & C = query [ 1 ]; if ( ! graph . count ( A ) || ! graph . count ( C )) { ans . push_back ( -1 ); continue ; } unordered_set < string > seen ; ans . push_back ( divide ( A , C , graph , seen )); } return ans ; } private : // return A / C double divide ( const string & A , const string & C , unordered_map < string , unordered_map < string , double >>& graph , unordered_set < string >& seen ) { if ( A == C ) return 1.0 ; seen . insert ( A ); // value := A / B for ( const auto & [ B , value ] : graph [ A ]) { if ( seen . count ( B )) continue ; const double res = divide ( B , C , graph , seen ); // B / C if ( res > 0 ) // valid result return value * res ; // A / C = (A / B) * (B / C) } return -1 ; // invalid result } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public double [] calcEquation ( List < List < String >> equations , double [] values , List < List < String >> queries ) { double [] ans = new double [ queries . size () ] ; // graph.get(A).get(B) := A / B Map < String , Map < String , Double >> graph = new HashMap <> (); // construct the graph for ( int i = 0 ; i < equations . size (); ++ i ) { final String A = equations . get ( i ). get ( 0 ); final String B = equations . get ( i ). get ( 1 ); graph . putIfAbsent ( A , new HashMap <> ()); graph . putIfAbsent ( B , new HashMap <> ()); graph . get ( A ). put ( B , values [ i ] ); graph . get ( B ). put ( A , 1.0 / values [ i ] ); } for ( int i = 0 ; i < queries . size (); ++ i ) { final String A = queries . get ( i ). get ( 0 ); final String C = queries . get ( i ). get ( 1 ); if ( ! graph . containsKey ( A ) || ! graph . containsKey ( C )) { ans [ i ] = - 1.0 ; continue ; } Set < String > seen = new HashSet <> (); ans [ i ] = divide ( A , C , graph , seen ); } return ans ; } // return A / C private double divide ( final String A , final String C , Map < String , Map < String , Double >> graph , Set < String > seen ) { if ( A . equals ( C )) return 1.0 ; seen . add ( A ); for ( final String B : graph . get ( A ). keySet ()) { if ( seen . contains ( B )) continue ; final double res = divide ( B , C , graph , seen ); // B / C if ( res > 0 ) // valid result return graph . get ( A ). get ( B ) * res ; // A / C = (A / B) * (B / C) } return - 1.0 ; // invalid result } }","title":"399. Evaluate Division"},{"location":"problems/0399/#399-evaluate-division","text":"Time: $O(e + eq) \\to O(e + q)$, where e = len(equations) and q = len(queries) Space: $O(e)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : vector < double > calcEquation ( vector < vector < string >>& equations , vector < double >& values , vector < vector < string >>& queries ) { vector < double > ans ; // graph[A][B] := A / B unordered_map < string , unordered_map < string , double >> graph ; // construct the graph for ( int i = 0 ; i < equations . size (); ++ i ) { const string & A = equations [ i ][ 0 ]; const string & B = equations [ i ][ 1 ]; graph [ A ][ B ] = values [ i ]; graph [ B ][ A ] = 1 / values [ i ]; } for ( const vector < string >& query : queries ) { const string & A = query [ 0 ]; const string & C = query [ 1 ]; if ( ! graph . count ( A ) || ! graph . count ( C )) { ans . push_back ( -1 ); continue ; } unordered_set < string > seen ; ans . push_back ( divide ( A , C , graph , seen )); } return ans ; } private : // return A / C double divide ( const string & A , const string & C , unordered_map < string , unordered_map < string , double >>& graph , unordered_set < string >& seen ) { if ( A == C ) return 1.0 ; seen . insert ( A ); // value := A / B for ( const auto & [ B , value ] : graph [ A ]) { if ( seen . count ( B )) continue ; const double res = divide ( B , C , graph , seen ); // B / C if ( res > 0 ) // valid result return value * res ; // A / C = (A / B) * (B / C) } return -1 ; // invalid result } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public double [] calcEquation ( List < List < String >> equations , double [] values , List < List < String >> queries ) { double [] ans = new double [ queries . size () ] ; // graph.get(A).get(B) := A / B Map < String , Map < String , Double >> graph = new HashMap <> (); // construct the graph for ( int i = 0 ; i < equations . size (); ++ i ) { final String A = equations . get ( i ). get ( 0 ); final String B = equations . get ( i ). get ( 1 ); graph . putIfAbsent ( A , new HashMap <> ()); graph . putIfAbsent ( B , new HashMap <> ()); graph . get ( A ). put ( B , values [ i ] ); graph . get ( B ). put ( A , 1.0 / values [ i ] ); } for ( int i = 0 ; i < queries . size (); ++ i ) { final String A = queries . get ( i ). get ( 0 ); final String C = queries . get ( i ). get ( 1 ); if ( ! graph . containsKey ( A ) || ! graph . containsKey ( C )) { ans [ i ] = - 1.0 ; continue ; } Set < String > seen = new HashSet <> (); ans [ i ] = divide ( A , C , graph , seen ); } return ans ; } // return A / C private double divide ( final String A , final String C , Map < String , Map < String , Double >> graph , Set < String > seen ) { if ( A . equals ( C )) return 1.0 ; seen . add ( A ); for ( final String B : graph . get ( A ). keySet ()) { if ( seen . contains ( B )) continue ; final double res = divide ( B , C , graph , seen ); // B / C if ( res > 0 ) // valid result return graph . get ( A ). get ( B ) * res ; // A / C = (A / B) * (B / C) } return - 1.0 ; // invalid result } }","title":"399. Evaluate Division"},{"location":"problems/0400/","text":"400. Nth Digit Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; long count = 9 ; while ( digitSize * count < n ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; count *= 10 ; } const int targetNum = startNum + ( n - 1 ) / digitSize ; const int pos = ( n - 1 ) % digitSize ; return to_string ( targetNum )[ pos ] - '0' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; long count = 9 ; while ( digitSize * count < n ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; count *= 10 ; } final int targetNum = startNum + ( n - 1 ) / digitSize ; final int pos = ( n - 1 ) % digitSize ; return String . valueOf ( targetNum ). charAt ( pos ) - '0' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def findNthDigit ( self , n : int ) -> int : def getDigit ( num : int , pos : int , digitSize : int ): if pos == 0 : return num % 10 for _ in range ( digitSize - pos ): num //= 10 return num % 10 digitSize = 1 startNum = 1 count = 9 while digitSize * count < n : n -= digitSize * count digitSize += 1 startNum *= 10 count *= 10 targetNum = startNum + ( n - 1 ) // digitSize pos = n % digitSize return getDigit ( targetNum , pos , digitSize )","title":"400. Nth Digit"},{"location":"problems/0400/#400-nth-digit","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; long count = 9 ; while ( digitSize * count < n ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; count *= 10 ; } const int targetNum = startNum + ( n - 1 ) / digitSize ; const int pos = ( n - 1 ) % digitSize ; return to_string ( targetNum )[ pos ] - '0' ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; long count = 9 ; while ( digitSize * count < n ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; count *= 10 ; } final int targetNum = startNum + ( n - 1 ) / digitSize ; final int pos = ( n - 1 ) % digitSize ; return String . valueOf ( targetNum ). charAt ( pos ) - '0' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def findNthDigit ( self , n : int ) -> int : def getDigit ( num : int , pos : int , digitSize : int ): if pos == 0 : return num % 10 for _ in range ( digitSize - pos ): num //= 10 return num % 10 digitSize = 1 startNum = 1 count = 9 while digitSize * count < n : n -= digitSize * count digitSize += 1 startNum *= 10 count *= 10 targetNum = startNum + ( n - 1 ) // digitSize pos = n % digitSize return getDigit ( targetNum , pos , digitSize )","title":"400. Nth Digit"},{"location":"problems/0401/","text":"401. Binary Watch Approach 1: DFS Time: $O(2^{10})$ Space: $O(2^{10})$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > readBinaryWatch ( int num ) { const vector < int > hours { 1 , 2 , 4 , 8 }; const vector < int > minutes { 1 , 2 , 4 , 8 , 16 , 32 }; vector < string > ans ; function < void ( int , int , int , int ) > dfs = [ & ]( int n , int s , int h , int m ) { if ( n == 0 ) { string time = to_string ( h ) + \":\" + ( m < 10 ? \"0\" : \"\" ) + to_string ( m ); ans . push_back ( time ); return ; } for ( int i = s ; i < hours . size () + minutes . size (); ++ i ) if ( i < 4 && h + hours [ i ] < 12 ) dfs ( n - 1 , i + 1 , h + hours [ i ], m ); else if ( i >= 4 && m + minutes [ i - 4 ] < 60 ) dfs ( n - 1 , i + 1 , h , m + minutes [ i - 4 ]); }; dfs ( num , 0 , 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < String > readBinaryWatch ( int num ) { List < String > ans = new ArrayList <> (); dfs ( num , 0 , 0 , 0 , ans ); return ans ; } private int [] hours = new int [] { 1 , 2 , 4 , 8 }; private int [] minutes = new int [] { 1 , 2 , 4 , 8 , 16 , 32 }; private void dfs ( int n , int s , int h , int m , List < String > ans ) { if ( n == 0 ) { final String time = String . valueOf ( h ) + \":\" + ( m < 10 ? \"0\" : \"\" ) + String . valueOf ( m ); ans . add ( time ); return ; } for ( int i = s ; i < hours . length + minutes . length ; ++ i ) if ( i < 4 && h + hours [ i ] < 12 ) dfs ( n - 1 , i + 1 , h + hours [ i ] , m , ans ); else if ( i >= 4 && m + minutes [ i - 4 ] < 60 ) dfs ( n - 1 , i + 1 , h , m + minutes [ i - 4 ] , ans /* */ ); } } Approach 2: Bit Time: $O(12 \\cdot 60)$ Space: $O(12 \\cdot 60)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < string > readBinaryWatch ( int num ) { vector < string > ans ; for ( int h = 0 ; h < 12 ; ++ h ) for ( int m = 0 ; m < 60 ; ++ m ) if ( __builtin_popcount ( h << 6 | m ) == num ) ans . push_back ( to_string ( h ) + ( m < 10 ? \":0\" : \":\" ) + to_string ( m )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < String > readBinaryWatch ( int num ) { List < String > ans = new LinkedList <> (); for ( int h = 0 ; h < 12 ; ++ h ) for ( int m = 0 ; m < 60 ; ++ m ) if ( Integer . bitCount ( h ) + Integer . bitCount ( m ) == num ) ans . add ( h + ( m < 10 ? \":0\" : \":\" ) + m ); return ans ; } }","title":"401. Binary Watch"},{"location":"problems/0401/#401-binary-watch","text":"","title":"401. Binary Watch"},{"location":"problems/0401/#approach-1-dfs","text":"Time: $O(2^{10})$ Space: $O(2^{10})$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > readBinaryWatch ( int num ) { const vector < int > hours { 1 , 2 , 4 , 8 }; const vector < int > minutes { 1 , 2 , 4 , 8 , 16 , 32 }; vector < string > ans ; function < void ( int , int , int , int ) > dfs = [ & ]( int n , int s , int h , int m ) { if ( n == 0 ) { string time = to_string ( h ) + \":\" + ( m < 10 ? \"0\" : \"\" ) + to_string ( m ); ans . push_back ( time ); return ; } for ( int i = s ; i < hours . size () + minutes . size (); ++ i ) if ( i < 4 && h + hours [ i ] < 12 ) dfs ( n - 1 , i + 1 , h + hours [ i ], m ); else if ( i >= 4 && m + minutes [ i - 4 ] < 60 ) dfs ( n - 1 , i + 1 , h , m + minutes [ i - 4 ]); }; dfs ( num , 0 , 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < String > readBinaryWatch ( int num ) { List < String > ans = new ArrayList <> (); dfs ( num , 0 , 0 , 0 , ans ); return ans ; } private int [] hours = new int [] { 1 , 2 , 4 , 8 }; private int [] minutes = new int [] { 1 , 2 , 4 , 8 , 16 , 32 }; private void dfs ( int n , int s , int h , int m , List < String > ans ) { if ( n == 0 ) { final String time = String . valueOf ( h ) + \":\" + ( m < 10 ? \"0\" : \"\" ) + String . valueOf ( m ); ans . add ( time ); return ; } for ( int i = s ; i < hours . length + minutes . length ; ++ i ) if ( i < 4 && h + hours [ i ] < 12 ) dfs ( n - 1 , i + 1 , h + hours [ i ] , m , ans ); else if ( i >= 4 && m + minutes [ i - 4 ] < 60 ) dfs ( n - 1 , i + 1 , h , m + minutes [ i - 4 ] , ans /* */ ); } }","title":"Approach 1: DFS"},{"location":"problems/0401/#approach-2-bit","text":"Time: $O(12 \\cdot 60)$ Space: $O(12 \\cdot 60)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < string > readBinaryWatch ( int num ) { vector < string > ans ; for ( int h = 0 ; h < 12 ; ++ h ) for ( int m = 0 ; m < 60 ; ++ m ) if ( __builtin_popcount ( h << 6 | m ) == num ) ans . push_back ( to_string ( h ) + ( m < 10 ? \":0\" : \":\" ) + to_string ( m )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < String > readBinaryWatch ( int num ) { List < String > ans = new LinkedList <> (); for ( int h = 0 ; h < 12 ; ++ h ) for ( int m = 0 ; m < 60 ; ++ m ) if ( Integer . bitCount ( h ) + Integer . bitCount ( m ) == num ) ans . add ( h + ( m < 10 ? \":0\" : \":\" ) + m ); return ans ; } }","title":"Approach 2: Bit"},{"location":"problems/0402/","text":"402. Remove K Digits Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string removeKdigits ( string num , int k ) { if ( num . length () == k ) return \"0\" ; string ans ; vector < char > stack ; for ( int i = 0 ; i < num . length (); ++ i ) { while ( k > 0 && ! stack . empty () && stack . back () > num [ i ]) { stack . pop_back (); -- k ; } stack . push_back ( num [ i ]); } while ( k -- > 0 ) stack . pop_back (); for ( const char c : stack ) { if ( c == '0' && ans . empty ()) continue ; ans += c ; } return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String removeKdigits ( String num , int k ) { if ( num . length () == k ) return \"0\" ; StringBuilder sb = new StringBuilder (); LinkedList < Character > stack = new LinkedList <> (); for ( int i = 0 ; i < num . length (); ++ i ) { while ( k > 0 && ! stack . isEmpty () && stack . getLast () > num . charAt ( i )) { stack . pollLast (); -- k ; } stack . addLast ( num . charAt ( i )); } while ( k -- > 0 ) stack . pollLast (); for ( final char c : stack ) { if ( c == '0' && sb . length () == 0 ) continue ; sb . append ( c ); } return sb . length () == 0 ? \"0\" : sb . toString (); } }","title":"402. Remove K Digits"},{"location":"problems/0402/#402-remove-k-digits","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string removeKdigits ( string num , int k ) { if ( num . length () == k ) return \"0\" ; string ans ; vector < char > stack ; for ( int i = 0 ; i < num . length (); ++ i ) { while ( k > 0 && ! stack . empty () && stack . back () > num [ i ]) { stack . pop_back (); -- k ; } stack . push_back ( num [ i ]); } while ( k -- > 0 ) stack . pop_back (); for ( const char c : stack ) { if ( c == '0' && ans . empty ()) continue ; ans += c ; } return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String removeKdigits ( String num , int k ) { if ( num . length () == k ) return \"0\" ; StringBuilder sb = new StringBuilder (); LinkedList < Character > stack = new LinkedList <> (); for ( int i = 0 ; i < num . length (); ++ i ) { while ( k > 0 && ! stack . isEmpty () && stack . getLast () > num . charAt ( i )) { stack . pollLast (); -- k ; } stack . addLast ( num . charAt ( i )); } while ( k -- > 0 ) stack . pollLast (); for ( final char c : stack ) { if ( c == '0' && sb . length () == 0 ) continue ; sb . append ( c ); } return sb . length () == 0 ? \"0\" : sb . toString (); } }","title":"402. Remove K Digits"},{"location":"problems/0403/","text":"403. Frog Jump Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool canCross ( vector < int >& stones ) { const int n = stones . size (); // dp[i][j] := true if a frog can jumps to stones[i] with j units vector < vector < bool >> dp ( n , vector < bool > ( n + 1 )); dp [ 0 ][ 1 ] = true ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const int k = stones [ i ] - stones [ j ]; if ( k <= n && dp [ j ][ k ]) { dp [ i ][ k - 1 ] = true ; dp [ i ][ k ] = true ; dp [ i ][ k + 1 ] = true ; } } return any_of ( begin ( dp . back ()), end ( dp . back ()), []( bool val ) { return val ; }); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean canCross ( int [] stones ) { final int n = stones . length ; // dp[i][j] := true if a frog can jumps to stones[i] with j units boolean [][] dp = new boolean [ n ][ n + 1 ] ; dp [ 0 ][ 1 ] = true ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int k = stones [ i ] - stones [ j ] ; if ( k <= n && dp [ j ][ k ] ) { dp [ i ][ k - 1 ] = true ; dp [ i ][ k ] = true ; dp [ i ][ k + 1 ] = true ; } } for ( int j = 0 ; j <= n ; ++ j ) if ( dp [ n - 1 ][ j ] ) return true ; return false ; } }","title":"403. Frog Jump"},{"location":"problems/0403/#403-frog-jump","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool canCross ( vector < int >& stones ) { const int n = stones . size (); // dp[i][j] := true if a frog can jumps to stones[i] with j units vector < vector < bool >> dp ( n , vector < bool > ( n + 1 )); dp [ 0 ][ 1 ] = true ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const int k = stones [ i ] - stones [ j ]; if ( k <= n && dp [ j ][ k ]) { dp [ i ][ k - 1 ] = true ; dp [ i ][ k ] = true ; dp [ i ][ k + 1 ] = true ; } } return any_of ( begin ( dp . back ()), end ( dp . back ()), []( bool val ) { return val ; }); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public boolean canCross ( int [] stones ) { final int n = stones . length ; // dp[i][j] := true if a frog can jumps to stones[i] with j units boolean [][] dp = new boolean [ n ][ n + 1 ] ; dp [ 0 ][ 1 ] = true ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int k = stones [ i ] - stones [ j ] ; if ( k <= n && dp [ j ][ k ] ) { dp [ i ][ k - 1 ] = true ; dp [ i ][ k ] = true ; dp [ i ][ k + 1 ] = true ; } } for ( int j = 0 ; j <= n ; ++ j ) if ( dp [ n - 1 ][ j ] ) return true ; return false ; } }","title":"403. Frog Jump"},{"location":"problems/0404/","text":"404. Sum of Left Leaves Approach 1: Recursive Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int sumOfLeftLeaves ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; if ( root -> left ) { if ( ! root -> left -> left && ! root -> left -> right ) ans += root -> left -> val ; else ans += sumOfLeftLeaves ( root -> left ); } ans += sumOfLeftLeaves ( root -> right ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int sumOfLeftLeaves ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; if ( root . left != null ) { if ( root . left . left == null && root . left . right == null ) ans += root . left . val ; else ans += sumOfLeftLeaves ( root . left ); } ans += sumOfLeftLeaves ( root . right ); return ans ; } } Approach 2: Iterative Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int sumOfLeftLeaves ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> left ) { if ( ! root -> left -> left && ! root -> left -> right ) ans += root -> left -> val ; else stack . push ( root -> left ); } if ( root -> right ) stack . push ( root -> right ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int sumOfLeftLeaves ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); if ( root . left != null ) { if ( root . left . left == null && root . left . right == null ) ans += root . left . val ; else stack . push ( root . left ); } if ( root . right != null ) stack . push ( root . right ); } return ans ; } }","title":"404. Sum of Left Leaves"},{"location":"problems/0404/#404-sum-of-left-leaves","text":"","title":"404. Sum of Left Leaves"},{"location":"problems/0404/#approach-1-recursive","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int sumOfLeftLeaves ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; if ( root -> left ) { if ( ! root -> left -> left && ! root -> left -> right ) ans += root -> left -> val ; else ans += sumOfLeftLeaves ( root -> left ); } ans += sumOfLeftLeaves ( root -> right ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int sumOfLeftLeaves ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; if ( root . left != null ) { if ( root . left . left == null && root . left . right == null ) ans += root . left . val ; else ans += sumOfLeftLeaves ( root . left ); } ans += sumOfLeftLeaves ( root . right ); return ans ; } }","title":"Approach 1: Recursive"},{"location":"problems/0404/#approach-2-iterative","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int sumOfLeftLeaves ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> left ) { if ( ! root -> left -> left && ! root -> left -> right ) ans += root -> left -> val ; else stack . push ( root -> left ); } if ( root -> right ) stack . push ( root -> right ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int sumOfLeftLeaves ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Stack < TreeNode > stack = new Stack <> (); stack . push ( root ); while ( ! stack . isEmpty ()) { root = stack . pop (); if ( root . left != null ) { if ( root . left . left == null && root . left . right == null ) ans += root . left . val ; else stack . push ( root . left ); } if ( root . right != null ) stack . push ( root . right ); } return ans ; } }","title":"Approach 2: Iterative"},{"location":"problems/0405/","text":"405. Convert a Number to Hexadecimal Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string toHex ( unsigned num ) { const vector < char > hex { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; string ans ; while ( num ) { ans += hex [ num & 0xf ]; num >>= 4 ; } reverse ( begin ( ans ), end ( ans )); return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String toHex ( int num ) { final char [] hex = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; StringBuilder sb = new StringBuilder (); while ( num != 0 ) { sb . append ( hex [ num & 0xf ] ); num >>>= 4 ; } return sb . length () == 0 ? \"0\" : sb . reverse (). toString (); } }","title":"405. Convert a Number to Hexadecimal"},{"location":"problems/0405/#405-convert-a-number-to-hexadecimal","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string toHex ( unsigned num ) { const vector < char > hex { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; string ans ; while ( num ) { ans += hex [ num & 0xf ]; num >>= 4 ; } reverse ( begin ( ans ), end ( ans )); return ans . empty () ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String toHex ( int num ) { final char [] hex = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; StringBuilder sb = new StringBuilder (); while ( num != 0 ) { sb . append ( hex [ num & 0xf ] ); num >>>= 4 ; } return sb . length () == 0 ? \"0\" : sb . reverse (). toString (); } }","title":"405. Convert a Number to Hexadecimal"},{"location":"problems/0406/","text":"406. Queue Reconstruction by Height Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> reconstructQueue ( vector < vector < int >>& people ) { vector < vector < int >> ans ; sort ( begin ( people ), end ( people ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] > b [ 0 ]; }); for ( const vector < int >& p : people ) ans . insert ( begin ( ans ) + p [ 1 ], p ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int [][] reconstructQueue ( int [][] people ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( people , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : b [ 0 ] - a [ 0 ] ); for ( final int [] p : people ) ans . add ( p [ 1 ] , p ); return ans . toArray ( new int [ ans . size () ][] ); } }","title":"406. Queue Reconstruction by Height"},{"location":"problems/0406/#406-queue-reconstruction-by-height","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> reconstructQueue ( vector < vector < int >>& people ) { vector < vector < int >> ans ; sort ( begin ( people ), end ( people ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] > b [ 0 ]; }); for ( const vector < int >& p : people ) ans . insert ( begin ( ans ) + p [ 1 ], p ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int [][] reconstructQueue ( int [][] people ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( people , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : b [ 0 ] - a [ 0 ] ); for ( final int [] p : people ) ans . add ( p [ 1 ] , p ); return ans . toArray ( new int [ ans . size () ][] ); } }","title":"406. Queue Reconstruction by Height"},{"location":"problems/0407/","text":"407. Trapping Rain Water II Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 struct Item { int i ; int j ; int h ; // heightMap[i][j] or the height after filling water }; class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { const int m = heightMap . size (); const int n = heightMap [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; auto compare = []( const Item & a , const Item & b ) { return a . h > b . h ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); vector < vector < bool >> seen ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) { pq . push ({ i , 0 , heightMap [ i ][ 0 ]}); pq . push ({ i , n - 1 , heightMap [ i ][ n - 1 ]}); seen [ i ][ 0 ] = true ; seen [ i ][ n - 1 ] = true ; } for ( int j = 1 ; j < n - 1 ; ++ j ) { pq . push ({ 0 , j , heightMap [ 0 ][ j ]}); pq . push ({ m - 1 , j , heightMap [ m - 1 ][ j ]}); seen [ 0 ][ j ] = true ; seen [ m - 1 ][ j ] = true ; } while ( ! pq . empty ()) { const auto [ i , j , h ] = pq . top (); pq . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; if ( heightMap [ x ][ y ] < h ) { ans += h - heightMap [ x ][ y ]; pq . push ({ x , y , h }); // fill the water on grid[x][y] } else { pq . push ({ x , y , heightMap [ x ][ y ]}); } seen [ x ][ y ] = true ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Item { public int i ; public int j ; public int h ; // heightMap[i][j] or the height after filling water public Item ( int i , int j , int h ) { this . i = i ; this . j = j ; this . h = h ; } } class Solution { public int trapRainWater ( int [][] heightMap ) { final int m = heightMap . length ; final int n = heightMap [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; int ans = 0 ; PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . h - b . h ); boolean [][] seen = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { pq . offer ( new Item ( i , 0 , heightMap [ i ][ 0 ] )); pq . offer ( new Item ( i , n - 1 , heightMap [ i ][ n - 1 ] )); seen [ i ][ 0 ] = true ; seen [ i ][ n - 1 ] = true ; } for ( int j = 1 ; j < n - 1 ; ++ j ) { pq . offer ( new Item ( 0 , j , heightMap [ 0 ][ j ] )); pq . offer ( new Item ( m - 1 , j , heightMap [ m - 1 ][ j ] )); seen [ 0 ][ j ] = true ; seen [ m - 1 ][ j ] = true ; } while ( ! pq . isEmpty ()) { final int i = pq . peek (). i ; final int j = pq . peek (). j ; final int h = pq . poll (). h ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] ) continue ; if ( heightMap [ x ][ y ] < h ) { ans += h - heightMap [ x ][ y ] ; pq . offer ( new Item ( x , y , h )); // fill the water on grid[x][y] } else { pq . offer ( new Item ( x , y , heightMap [ x ][ y ] )); } seen [ x ][ y ] = true ; } } return ans ; } }","title":"407. Trapping Rain Water II"},{"location":"problems/0407/#407-trapping-rain-water-ii","text":"Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 struct Item { int i ; int j ; int h ; // heightMap[i][j] or the height after filling water }; class Solution { public : int trapRainWater ( vector < vector < int >>& heightMap ) { const int m = heightMap . size (); const int n = heightMap [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; auto compare = []( const Item & a , const Item & b ) { return a . h > b . h ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); vector < vector < bool >> seen ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) { pq . push ({ i , 0 , heightMap [ i ][ 0 ]}); pq . push ({ i , n - 1 , heightMap [ i ][ n - 1 ]}); seen [ i ][ 0 ] = true ; seen [ i ][ n - 1 ] = true ; } for ( int j = 1 ; j < n - 1 ; ++ j ) { pq . push ({ 0 , j , heightMap [ 0 ][ j ]}); pq . push ({ m - 1 , j , heightMap [ m - 1 ][ j ]}); seen [ 0 ][ j ] = true ; seen [ m - 1 ][ j ] = true ; } while ( ! pq . empty ()) { const auto [ i , j , h ] = pq . top (); pq . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; if ( heightMap [ x ][ y ] < h ) { ans += h - heightMap [ x ][ y ]; pq . push ({ x , y , h }); // fill the water on grid[x][y] } else { pq . push ({ x , y , heightMap [ x ][ y ]}); } seen [ x ][ y ] = true ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Item { public int i ; public int j ; public int h ; // heightMap[i][j] or the height after filling water public Item ( int i , int j , int h ) { this . i = i ; this . j = j ; this . h = h ; } } class Solution { public int trapRainWater ( int [][] heightMap ) { final int m = heightMap . length ; final int n = heightMap [ 0 ] . length ; final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; int ans = 0 ; PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . h - b . h ); boolean [][] seen = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { pq . offer ( new Item ( i , 0 , heightMap [ i ][ 0 ] )); pq . offer ( new Item ( i , n - 1 , heightMap [ i ][ n - 1 ] )); seen [ i ][ 0 ] = true ; seen [ i ][ n - 1 ] = true ; } for ( int j = 1 ; j < n - 1 ; ++ j ) { pq . offer ( new Item ( 0 , j , heightMap [ 0 ][ j ] )); pq . offer ( new Item ( m - 1 , j , heightMap [ m - 1 ][ j ] )); seen [ 0 ][ j ] = true ; seen [ m - 1 ][ j ] = true ; } while ( ! pq . isEmpty ()) { final int i = pq . peek (). i ; final int j = pq . peek (). j ; final int h = pq . poll (). h ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] ) continue ; if ( heightMap [ x ][ y ] < h ) { ans += h - heightMap [ x ][ y ] ; pq . offer ( new Item ( x , y , h )); // fill the water on grid[x][y] } else { pq . offer ( new Item ( x , y , heightMap [ x ][ y ] )); } seen [ x ][ y ] = true ; } } return ans ; } }","title":"407. Trapping Rain Water II"},{"location":"problems/0408/","text":"408. Valid Word Abbreviation \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool validWordAbbreviation ( const string & word , const string & abbr ) { int i = 0 ; // word's pointer int j = 0 ; // abbr's pointer while ( i < word . length () && j < abbr . length ()) { if ( word [ i ] == abbr [ j ]) { ++ i ; ++ j ; continue ; } if ( abbr [ j ] <= '0' || abbr [ j ] > '9' ) return false ; int num = 0 ; while ( j < abbr . length () && isdigit ( abbr [ j ])) { num = num * 10 + abbr [ j ] - '0' ; if ( num == 0 ) return false ; ++ j ; } i += num ; } return i == word . length () && j == abbr . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean validWordAbbreviation ( String word , String abbr ) { int i = 0 ; // word's pointer int j = 0 ; // abbr's pointer while ( i < word . length () && j < abbr . length ()) { if ( word . charAt ( i ) == abbr . charAt ( j )) { ++ i ; ++ j ; continue ; } if ( abbr . charAt ( j ) <= '0' || abbr . charAt ( j ) > '9' ) return false ; int num = 0 ; while ( j < abbr . length () && Character . isDigit ( abbr . charAt ( j ))) { num = num * 10 + abbr . charAt ( j ) - '0' ; if ( num == 0 ) return false ; ++ j ; } i += num ; } return i == word . length () && j == abbr . length (); } }","title":"408. Valid Word Abbreviation"},{"location":"problems/0408/#408-valid-word-abbreviation","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool validWordAbbreviation ( const string & word , const string & abbr ) { int i = 0 ; // word's pointer int j = 0 ; // abbr's pointer while ( i < word . length () && j < abbr . length ()) { if ( word [ i ] == abbr [ j ]) { ++ i ; ++ j ; continue ; } if ( abbr [ j ] <= '0' || abbr [ j ] > '9' ) return false ; int num = 0 ; while ( j < abbr . length () && isdigit ( abbr [ j ])) { num = num * 10 + abbr [ j ] - '0' ; if ( num == 0 ) return false ; ++ j ; } i += num ; } return i == word . length () && j == abbr . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean validWordAbbreviation ( String word , String abbr ) { int i = 0 ; // word's pointer int j = 0 ; // abbr's pointer while ( i < word . length () && j < abbr . length ()) { if ( word . charAt ( i ) == abbr . charAt ( j )) { ++ i ; ++ j ; continue ; } if ( abbr . charAt ( j ) <= '0' || abbr . charAt ( j ) > '9' ) return false ; int num = 0 ; while ( j < abbr . length () && Character . isDigit ( abbr . charAt ( j ))) { num = num * 10 + abbr . charAt ( j ) - '0' ; if ( num == 0 ) return false ; ++ j ; } i += num ; } return i == word . length () && j == abbr . length (); } }","title":"408. Valid Word Abbreviation \ud83d\udd12"},{"location":"problems/0409/","text":"409. Longest Palindrome Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int longestPalindrome ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const int c : count ) ans += c % 2 == 0 ? c : c - 1 ; const bool hasOddCount = any_of ( begin ( count ), end ( count ), []( int c ) { return c & 1 ; }); return ans + hasOddCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final int c : count ) ans += c % 2 == 0 ? c : c - 1 ; final boolean hasOddCount = Arrays . stream ( count ). anyMatch ( c -> c % 2 == 1 ); return ans + ( hasOddCount ? 1 : 0 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def longestPalindrome ( self , s : str ) -> int : ans = 0 count = collections . Counter ( s ) for c in count . values (): ans += c if c % 2 == 0 else c - 1 hasOddCount = any ( c % 2 == 1 for c in count . values ()) return ans + hasOddCount","title":"409. Longest Palindrome"},{"location":"problems/0409/#409-longest-palindrome","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int longestPalindrome ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( const char c : s ) ++ count [ c ]; for ( const int c : count ) ans += c % 2 == 0 ? c : c - 1 ; const bool hasOddCount = any_of ( begin ( count ), end ( count ), []( int c ) { return c & 1 ; }); return ans + hasOddCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( final int c : count ) ans += c % 2 == 0 ? c : c - 1 ; final boolean hasOddCount = Arrays . stream ( count ). anyMatch ( c -> c % 2 == 1 ); return ans + ( hasOddCount ? 1 : 0 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def longestPalindrome ( self , s : str ) -> int : ans = 0 count = collections . Counter ( s ) for c in count . values (): ans += c if c % 2 == 0 else c - 1 hasOddCount = any ( c % 2 == 1 for c in count . values ()) return ans + hasOddCount","title":"409. Longest Palindrome"},{"location":"problems/0410/","text":"410. Split Array Largest Sum Approach 1: Bottom-up Time: $O(mn^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int splitArray ( vector < int >& nums , int m ) { const int n = nums . size (); // dp[i][k] := min of largest sum to split first i nums into k groups vector < vector < long >> dp ( n + 1 , vector < long > ( m + 1 , INT_MAX )); vector < long > prefixSum ( n + 1 ); // prefixSum[i] := sum of first i nums for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; dp [ i ][ 1 ] = prefixSum [ i ]; } for ( int k = 2 ; k <= m ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = min ( dp [ i ][ k ], max ( dp [ j ][ k - 1 ], prefixSum [ i ] - prefixSum [ j ])); return dp [ n ][ m ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int splitArray ( int [] nums , int m ) { final int n = nums . length ; // dp[i][k] := min of largest sum to split first i nums into k groups int [][] dp = new int [ n + 1 ][ m + 1 ] ; int [] prefixSum = new int [ n + 1 ] ; // prefixSum[i] := sum of first i nums for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; dp [ i ][ 1 ] = prefixSum [ i ] ; } for ( int k = 2 ; k <= m ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , Math . max ( dp [ j ][ k - 1 ] , prefixSum [ i ] - prefixSum [ j ] )); return dp [ n ][ m ] ; } } Approach 2: Top-down Time: $O(mn^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int splitArray ( vector < int >& nums , int m ) { const int n = nums . size (); vector < vector < long >> memo ( n + 1 , vector < long > ( m + 1 , INT_MAX )); vector < long > prefixSum ( n + 1 ); // prefixSum[i] := sum of nums[0..i) for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; // dp(n, m) := min of largest sum to split nums[0..n) into m groups function < long ( int , int ) > dp = [ & ]( int n , int m ) { if ( m == 1 ) return prefixSum [ n ]; long & ans = memo [ n ][ m ]; if ( ans < INT_MAX ) return ans ; // try all possible partitions for ( int i = m - 1 ; i < n ; ++ i ) ans = min ( ans , max ( dp ( i , m - 1 ), prefixSum [ n ] - prefixSum [ i ])); return ans ; }; return dp ( n , m ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int splitArray ( int [] nums , int m ) { final int n = nums . length ; memo = new int [ n + 1 ][ m + 1 ] ; prefixSum = new int [ n + 1 ] ; for ( int [] row : memo ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; return dp ( nums , n , m ); } private int [][] memo ; private int [] prefixSum ; // prefixSum[i] := sum of first i nums // dp(nums, n, m) := min of largest sum to split nums[0..n) into m groups private int dp ( int [] nums , int n , int m ) { if ( m == 1 ) return prefixSum [ n ] ; int ans = memo [ n ][ m ] ; if ( ans < Integer . MAX_VALUE ) return ans ; // try all possible partitions for ( int i = m - 1 ; i < n ; ++ i ) ans = Math . min ( ans , Math . max ( dp ( nums , i , m - 1 ), prefixSum [ n ] - prefixSum [ i ] )); return memo [ n ][ m ] = ans ; } }","title":"410. Split Array Largest Sum"},{"location":"problems/0410/#410-split-array-largest-sum","text":"","title":"410. Split Array Largest Sum"},{"location":"problems/0410/#approach-1-bottom-up","text":"Time: $O(mn^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int splitArray ( vector < int >& nums , int m ) { const int n = nums . size (); // dp[i][k] := min of largest sum to split first i nums into k groups vector < vector < long >> dp ( n + 1 , vector < long > ( m + 1 , INT_MAX )); vector < long > prefixSum ( n + 1 ); // prefixSum[i] := sum of first i nums for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; dp [ i ][ 1 ] = prefixSum [ i ]; } for ( int k = 2 ; k <= m ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = min ( dp [ i ][ k ], max ( dp [ j ][ k - 1 ], prefixSum [ i ] - prefixSum [ j ])); return dp [ n ][ m ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int splitArray ( int [] nums , int m ) { final int n = nums . length ; // dp[i][k] := min of largest sum to split first i nums into k groups int [][] dp = new int [ n + 1 ][ m + 1 ] ; int [] prefixSum = new int [ n + 1 ] ; // prefixSum[i] := sum of first i nums for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; dp [ i ][ 1 ] = prefixSum [ i ] ; } for ( int k = 2 ; k <= m ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , Math . max ( dp [ j ][ k - 1 ] , prefixSum [ i ] - prefixSum [ j ] )); return dp [ n ][ m ] ; } }","title":"Approach 1: Bottom-up"},{"location":"problems/0410/#approach-2-top-down","text":"Time: $O(mn^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int splitArray ( vector < int >& nums , int m ) { const int n = nums . size (); vector < vector < long >> memo ( n + 1 , vector < long > ( m + 1 , INT_MAX )); vector < long > prefixSum ( n + 1 ); // prefixSum[i] := sum of nums[0..i) for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; // dp(n, m) := min of largest sum to split nums[0..n) into m groups function < long ( int , int ) > dp = [ & ]( int n , int m ) { if ( m == 1 ) return prefixSum [ n ]; long & ans = memo [ n ][ m ]; if ( ans < INT_MAX ) return ans ; // try all possible partitions for ( int i = m - 1 ; i < n ; ++ i ) ans = min ( ans , max ( dp ( i , m - 1 ), prefixSum [ n ] - prefixSum [ i ])); return ans ; }; return dp ( n , m ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int splitArray ( int [] nums , int m ) { final int n = nums . length ; memo = new int [ n + 1 ][ m + 1 ] ; prefixSum = new int [ n + 1 ] ; for ( int [] row : memo ) Arrays . fill ( row , Integer . MAX_VALUE ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ] ; return dp ( nums , n , m ); } private int [][] memo ; private int [] prefixSum ; // prefixSum[i] := sum of first i nums // dp(nums, n, m) := min of largest sum to split nums[0..n) into m groups private int dp ( int [] nums , int n , int m ) { if ( m == 1 ) return prefixSum [ n ] ; int ans = memo [ n ][ m ] ; if ( ans < Integer . MAX_VALUE ) return ans ; // try all possible partitions for ( int i = m - 1 ; i < n ; ++ i ) ans = Math . min ( ans , Math . max ( dp ( nums , i , m - 1 ), prefixSum [ n ] - prefixSum [ i ] )); return memo [ n ][ m ] = ans ; } }","title":"Approach 2: Top-down"},{"location":"problems/0411/","text":"411. Minimum Unique Word Abbreviation \ud83d\udd12","title":"411. Minimum Unique Word Abbreviation"},{"location":"problems/0411/#411-minimum-unique-word-abbreviation","text":"","title":"411. Minimum Unique Word Abbreviation \ud83d\udd12"},{"location":"problems/0412/","text":"412. Fizz Buzz Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > fizzBuzz ( int n ) { vector < string > ans ; for ( int i = 1 ; i <= n ; ++ i ) if ( i % 15 == 0 ) ans . push_back ( \"FizzBuzz\" ); else if ( i % 3 == 0 ) ans . push_back ( \"Fizz\" ); else if ( i % 5 == 0 ) ans . push_back ( \"Buzz\" ); else ans . push_back ( to_string ( i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < String > fizzBuzz ( int n ) { List < String > ans = new ArrayList <> (); for ( int i = 1 ; i <= n ; ++ i ) if ( i % 15 == 0 ) ans . add ( \"FizzBuzz\" ); else if ( i % 3 == 0 ) ans . add ( \"Fizz\" ); else if ( i % 5 == 0 ) ans . add ( \"Buzz\" ); else ans . add ( String . valueOf ( i )); return ans ; } }","title":"412. Fizz Buzz"},{"location":"problems/0412/#412-fizz-buzz","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > fizzBuzz ( int n ) { vector < string > ans ; for ( int i = 1 ; i <= n ; ++ i ) if ( i % 15 == 0 ) ans . push_back ( \"FizzBuzz\" ); else if ( i % 3 == 0 ) ans . push_back ( \"Fizz\" ); else if ( i % 5 == 0 ) ans . push_back ( \"Buzz\" ); else ans . push_back ( to_string ( i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < String > fizzBuzz ( int n ) { List < String > ans = new ArrayList <> (); for ( int i = 1 ; i <= n ; ++ i ) if ( i % 15 == 0 ) ans . add ( \"FizzBuzz\" ); else if ( i % 3 == 0 ) ans . add ( \"Fizz\" ); else if ( i % 5 == 0 ) ans . add ( \"Buzz\" ); else ans . add ( String . valueOf ( i )); return ans ; } }","title":"412. Fizz Buzz"},{"location":"problems/0413/","text":"413. Arithmetic Slices Approach 1: $O(n)$ space Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { const int n = A . size (); if ( n < 3 ) return 0 ; vector < int > dp ( n ); // # arithmetic slices ends at i for ( int i = 2 ; i < A . size (); ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) dp [ i ] = dp [ i - 1 ] + 1 ; return accumulate ( begin ( dp ), end ( dp ), 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numberOfArithmeticSlices ( int [] A ) { final int n = A . length ; if ( n < 3 ) return 0 ; int [] dp = new int [ n ] ; // dp[i] := # of arithmetic slices ends at A[i] for ( int i = 2 ; i < n ; ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) dp [ i ] += dp [ i - 1 ] + 1 ; return Arrays . stream ( dp ). sum (); } } Approach 2: $O(1)$ space Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int ans = 0 ; int dp = 0 ; // # arithmetic slices ends at i for ( int i = 2 ; i < A . size (); ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) ans += ++ dp ; else dp = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numberOfArithmeticSlices ( int [] A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . length ; ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) ans += ++ dp ; else dp = 0 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def numberOfArithmeticSlices ( self , A : List [ int ]) -> int : ans = 0 dp = 0 for i in range ( 2 , len ( A )): if A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]: dp += 1 ans += dp else : dp = 0 return ans","title":"413. Arithmetic Slices"},{"location":"problems/0413/#413-arithmetic-slices","text":"","title":"413. Arithmetic Slices"},{"location":"problems/0413/#approach-1-on-space","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { const int n = A . size (); if ( n < 3 ) return 0 ; vector < int > dp ( n ); // # arithmetic slices ends at i for ( int i = 2 ; i < A . size (); ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) dp [ i ] = dp [ i - 1 ] + 1 ; return accumulate ( begin ( dp ), end ( dp ), 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numberOfArithmeticSlices ( int [] A ) { final int n = A . length ; if ( n < 3 ) return 0 ; int [] dp = new int [ n ] ; // dp[i] := # of arithmetic slices ends at A[i] for ( int i = 2 ; i < n ; ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) dp [ i ] += dp [ i - 1 ] + 1 ; return Arrays . stream ( dp ). sum (); } }","title":"Approach 1: $O(n)$ space"},{"location":"problems/0413/#approach-2-o1-space","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int ans = 0 ; int dp = 0 ; // # arithmetic slices ends at i for ( int i = 2 ; i < A . size (); ++ i ) if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) ans += ++ dp ; else dp = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numberOfArithmeticSlices ( int [] A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . length ; ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) ans += ++ dp ; else dp = 0 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def numberOfArithmeticSlices ( self , A : List [ int ]) -> int : ans = 0 dp = 0 for i in range ( 2 , len ( A )): if A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]: dp += 1 ans += dp else : dp = 0 return ans","title":"Approach 2: $O(1)$ space"},{"location":"problems/0414/","text":"414. Third Maximum Number Approach 1: $O(n)$ Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int thirdMax ( vector < int >& nums ) { long max1 = LONG_MIN ; // the maximum long max2 = LONG_MIN ; // 2nd maximum long max3 = LONG_MIN ; // 3rd maximum for ( const int num : nums ) if ( num > max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( max1 > num && num > max2 ) { max3 = max2 ; max2 = num ; } else if ( max2 > num && num > max3 ) { max3 = num ; } return max3 == LONG_MIN ? max1 : max3 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public int thirdMax ( int [] nums ) { long max1 = Long . MIN_VALUE ; // the maximum long max2 = Long . MIN_VALUE ; // 2nd maximum long max3 = Long . MIN_VALUE ; // 3rd maximum for ( final int num : nums ) if ( num > max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( max1 > num && num > max2 ) { max3 = max2 ; max2 = num ; } else if ( max2 > num && num > max3 ) { max3 = num ; } return max3 == Long . MIN_VALUE ? ( int ) max1 : ( int ) max3 ; } } Approach 2: Heap Time: $O(n\\log 3) = O(n)$ Space: $O(\\log 3) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , greater <>> pq ; // min-heap unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . count ( num )) { seen . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <> (); // min-heap Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) if ( seen . add ( num )) { pq . offer ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def thirdMax ( self , nums : List [ int ]) -> int : pq = [] seen = set () for num in nums : if num not in seen : seen . add ( num ) heapq . heappush ( pq , num ) if len ( pq ) > 3 : heapq . heappop ( pq ) if len ( pq ) == 2 : heapq . heappop ( pq ) return pq [ 0 ]","title":"414. Third Maximum Number"},{"location":"problems/0414/#414-third-maximum-number","text":"","title":"414. Third Maximum Number"},{"location":"problems/0414/#approach-1-on","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int thirdMax ( vector < int >& nums ) { long max1 = LONG_MIN ; // the maximum long max2 = LONG_MIN ; // 2nd maximum long max3 = LONG_MIN ; // 3rd maximum for ( const int num : nums ) if ( num > max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( max1 > num && num > max2 ) { max3 = max2 ; max2 = num ; } else if ( max2 > num && num > max3 ) { max3 = num ; } return max3 == LONG_MIN ? max1 : max3 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public int thirdMax ( int [] nums ) { long max1 = Long . MIN_VALUE ; // the maximum long max2 = Long . MIN_VALUE ; // 2nd maximum long max3 = Long . MIN_VALUE ; // 3rd maximum for ( final int num : nums ) if ( num > max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( max1 > num && num > max2 ) { max3 = max2 ; max2 = num ; } else if ( max2 > num && num > max3 ) { max3 = num ; } return max3 == Long . MIN_VALUE ? ( int ) max1 : ( int ) max3 ; } }","title":"Approach 1: $O(n)$"},{"location":"problems/0414/#approach-2-heap","text":"Time: $O(n\\log 3) = O(n)$ Space: $O(\\log 3) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , greater <>> pq ; // min-heap unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . count ( num )) { seen . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <> (); // min-heap Set < Integer > seen = new HashSet <> (); for ( final int num : nums ) if ( seen . add ( num )) { pq . offer ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def thirdMax ( self , nums : List [ int ]) -> int : pq = [] seen = set () for num in nums : if num not in seen : seen . add ( num ) heapq . heappush ( pq , num ) if len ( pq ) > 3 : heapq . heappop ( pq ) if len ( pq ) == 2 : heapq . heappop ( pq ) return pq [ 0 ]","title":"Approach 2: Heap"},{"location":"problems/0415/","text":"415. Add Strings Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string addStrings ( string num1 , string num2 ) { string ans ; int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += num1 [ i -- ] - '0' ; if ( j >= 0 ) carry += num2 [ j -- ] - '0' ; ans += carry % 10 + '0' ; carry /= 10 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder (); int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry > 0 ) { if ( i >= 0 ) carry += num1 . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += num2 . charAt ( j -- ) - '0' ; sb . append ( carry % 10 ); carry /= 10 ; } return sb . reverse (). toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addStrings ( self , num1 : str , num2 : str ) -> str : ans = [] carry = 0 i = len ( num1 ) - 1 j = len ( num2 ) - 1 while i >= 0 or j >= 0 or carry : if i >= 0 : carry += int ( num1 [ i ]) if j >= 0 : carry += int ( num2 [ j ]) ans . append ( str ( carry % 10 )) carry //= 10 i -= 1 j -= 1 return '' . join ( reversed ( ans ))","title":"415. Add Strings"},{"location":"problems/0415/#415-add-strings","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string addStrings ( string num1 , string num2 ) { string ans ; int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += num1 [ i -- ] - '0' ; if ( j >= 0 ) carry += num2 [ j -- ] - '0' ; ans += carry % 10 + '0' ; carry /= 10 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder (); int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry > 0 ) { if ( i >= 0 ) carry += num1 . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += num2 . charAt ( j -- ) - '0' ; sb . append ( carry % 10 ); carry /= 10 ; } return sb . reverse (). toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addStrings ( self , num1 : str , num2 : str ) -> str : ans = [] carry = 0 i = len ( num1 ) - 1 j = len ( num2 ) - 1 while i >= 0 or j >= 0 or carry : if i >= 0 : carry += int ( num1 [ i ]) if j >= 0 : carry += int ( num2 [ j ]) ans . append ( str ( carry % 10 )) carry //= 10 i -= 1 j -= 1 return '' . join ( reversed ( ans ))","title":"415. Add Strings"},{"location":"problems/0416/","text":"416. Partition Equal Subset Sum Time: $O(nk)$, where k = sum(nums) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canPartition ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum & 1 ) return false ; return subsetSum ( nums , sum / 2 ); } private : bool subsetSum ( const vector < int >& nums , int target ) { vector < bool > dp ( target + 1 ); // dp[i] := true if can sum to i dp [ 0 ] = true ; for ( const int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean canPartition ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum % 2 == 1 ) return false ; return subsetSum ( nums , sum / 2 ); } private boolean subsetSum ( final int [] nums , int target ) { boolean [] dp = new boolean [ target + 1 ] ; // dp[i] := true if can sum to i dp [ 0 ] = true ; for ( final int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canPartition ( self , nums : List [ int ]) -> bool : summ = sum ( nums ) if summ & 1 : return False dp = [ True ] + [ False ] * ( summ // 2 ) for num in nums : for w in range ( summ // 2 , num - 1 , - 1 ): dp [ w ] = dp [ w ] or dp [ w - num ] return dp [ summ // 2 ]","title":"416. Partition Equal Subset Sum"},{"location":"problems/0416/#416-partition-equal-subset-sum","text":"Time: $O(nk)$, where k = sum(nums) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canPartition ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum & 1 ) return false ; return subsetSum ( nums , sum / 2 ); } private : bool subsetSum ( const vector < int >& nums , int target ) { vector < bool > dp ( target + 1 ); // dp[i] := true if can sum to i dp [ 0 ] = true ; for ( const int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean canPartition ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum % 2 == 1 ) return false ; return subsetSum ( nums , sum / 2 ); } private boolean subsetSum ( final int [] nums , int target ) { boolean [] dp = new boolean [ target + 1 ] ; // dp[i] := true if can sum to i dp [ 0 ] = true ; for ( final int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canPartition ( self , nums : List [ int ]) -> bool : summ = sum ( nums ) if summ & 1 : return False dp = [ True ] + [ False ] * ( summ // 2 ) for num in nums : for w in range ( summ // 2 , num - 1 , - 1 ): dp [ w ] = dp [ w ] or dp [ w - num ] return dp [ summ // 2 ]","title":"416. Partition Equal Subset Sum"},{"location":"problems/0417/","text":"417. Pacific Atlantic Water Flow Approach 1: BFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < vector < int >> ans ; queue < pair < int , int >> qP ; queue < pair < int , int >> qA ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); auto bfs = [ & ]( queue < pair < int , int >>& q , vector < vector < bool >>& seen ) { while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); const int h = matrix [ i ][ j ]; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . push ({ x , y }); seen [ x ][ y ] = true ; } } }; for ( int i = 0 ; i < m ; ++ i ) { qP . push ({ i , 0 }); qA . push ({ i , n - 1 }); seenP [ i ][ 0 ] = true ; seenA [ i ][ n - 1 ] = true ; } for ( int j = 0 ; j < n ; ++ j ) { qP . push ({ 0 , j }); qA . push ({ m - 1 , j }); seenP [ 0 ][ j ] = true ; seenA [ m - 1 ][ j ] = true ; } bfs ( qP , seenP ); bfs ( qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); Queue < int []> qP = new LinkedList <> (); Queue < int []> qA = new LinkedList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { qP . offer ( new int [] { i , 0 }); qA . offer ( new int [] { i , n - 1 }); seenP [ i ][ 0 ] = true ; seenA [ i ][ n - 1 ] = true ; } for ( int j = 0 ; j < n ; ++ j ) { qP . offer ( new int [] { 0 , j }); qA . offer ( new int [] { m - 1 , j }); seenP [ 0 ][ j ] = true ; seenA [ m - 1 ][ j ] = true ; } bfs ( matrix , qP , seenP ); bfs ( matrix , qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( final int [][] matrix , Queue < int []> q , boolean [][] seen ) { while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; final int h = matrix [ i ][ j ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == matrix . length || y < 0 || y == matrix [ 0 ] . length ) continue ; if ( seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . offer ( new int [] { x , y }); seen [ x ][ y ] = true ; } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def pacificAtlantic ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: def bfs ( q : collections . deque , seen : List [ List [ bool ]]): while q : [ i , j ] = q . popleft () h = matrix [ i ][ j ] seen [ i ][ j ] = True for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if not 0 <= x < m or not 0 <= y < n or matrix [ x ][ y ] < h or seen [ x ][ y ]: continue q . append (( x , y )) if not matrix : return [] m = len ( matrix ) n = len ( matrix [ 0 ]) dirs = [ 0 , 1 , 0 , - 1 , 0 ] qP = collections . deque () qA = collections . deque () seenP = [[ False ] * n for _ in range ( m )] seenA = [[ False ] * n for _ in range ( m )] for i in range ( m ): qP . append (( i , 0 )) qA . append (( i , n - 1 )) for j in range ( n ): qP . append (( 0 , j )) qA . append (( m - 1 , j )) bfs ( qP , seenP ) bfs ( qA , seenA ) return [[ i , j ] for i in range ( m ) for j in range ( n ) if seenP [ i ][ j ] and seenA [ i ][ j ]] Approach 2: DFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < vector < int >> ans ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , seenP ); dfs ( matrix , i , n - 1 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , seenP ); dfs ( matrix , m - 1 , j , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } private : void dfs ( const vector < vector < int >>& matrix , int i , int j , const vector < vector < bool >>& seen , int h = 0 ) { if ( i < 0 || i == matrix . size () || j < 0 || j == matrix [ 0 ]. size ()) return ; if ( seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , seen , matrix [ i ][ j ]); dfs ( matrix , i - 1 , j , seen , matrix [ i ][ j ]); dfs ( matrix , i , j + 1 , seen , matrix [ i ][ j ]); dfs ( matrix , i , j - 1 , seen , matrix [ i ][ j ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , 0 , seenP ); dfs ( matrix , i , n - 1 , 0 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , 0 , seenP ); dfs ( matrix , m - 1 , j , 0 , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private void dfs ( final int [][] matrix , int i , int j , int h , boolean [][] seen ) { if ( i < 0 || i == matrix . length || j < 0 || j == matrix [ 0 ] . length ) return ; if ( seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , seen ); } }","title":"417. Pacific Atlantic Water Flow"},{"location":"problems/0417/#417-pacific-atlantic-water-flow","text":"","title":"417. Pacific Atlantic Water Flow"},{"location":"problems/0417/#approach-1-bfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < vector < int >> ans ; queue < pair < int , int >> qP ; queue < pair < int , int >> qA ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); auto bfs = [ & ]( queue < pair < int , int >>& q , vector < vector < bool >>& seen ) { while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); const int h = matrix [ i ][ j ]; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . push ({ x , y }); seen [ x ][ y ] = true ; } } }; for ( int i = 0 ; i < m ; ++ i ) { qP . push ({ i , 0 }); qA . push ({ i , n - 1 }); seenP [ i ][ 0 ] = true ; seenA [ i ][ n - 1 ] = true ; } for ( int j = 0 ; j < n ; ++ j ) { qP . push ({ 0 , j }); qA . push ({ m - 1 , j }); seenP [ 0 ][ j ] = true ; seenA [ m - 1 ][ j ] = true ; } bfs ( qP , seenP ); bfs ( qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); Queue < int []> qP = new LinkedList <> (); Queue < int []> qA = new LinkedList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { qP . offer ( new int [] { i , 0 }); qA . offer ( new int [] { i , n - 1 }); seenP [ i ][ 0 ] = true ; seenA [ i ][ n - 1 ] = true ; } for ( int j = 0 ; j < n ; ++ j ) { qP . offer ( new int [] { 0 , j }); qA . offer ( new int [] { m - 1 , j }); seenP [ 0 ][ j ] = true ; seenA [ m - 1 ][ j ] = true ; } bfs ( matrix , qP , seenP ); bfs ( matrix , qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private final int [] dirs = { 0 , 1 , 0 , - 1 , 0 }; private void bfs ( final int [][] matrix , Queue < int []> q , boolean [][] seen ) { while ( ! q . isEmpty ()) { final int i = q . peek () [ 0 ] ; final int j = q . poll () [ 1 ] ; final int h = matrix [ i ][ j ] ; for ( int k = 0 ; k < 4 ; ++ k ) { final int x = i + dirs [ k ] ; final int y = j + dirs [ k + 1 ] ; if ( x < 0 || x == matrix . length || y < 0 || y == matrix [ 0 ] . length ) continue ; if ( seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . offer ( new int [] { x , y }); seen [ x ][ y ] = true ; } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def pacificAtlantic ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: def bfs ( q : collections . deque , seen : List [ List [ bool ]]): while q : [ i , j ] = q . popleft () h = matrix [ i ][ j ] seen [ i ][ j ] = True for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if not 0 <= x < m or not 0 <= y < n or matrix [ x ][ y ] < h or seen [ x ][ y ]: continue q . append (( x , y )) if not matrix : return [] m = len ( matrix ) n = len ( matrix [ 0 ]) dirs = [ 0 , 1 , 0 , - 1 , 0 ] qP = collections . deque () qA = collections . deque () seenP = [[ False ] * n for _ in range ( m )] seenA = [[ False ] * n for _ in range ( m )] for i in range ( m ): qP . append (( i , 0 )) qA . append (( i , n - 1 )) for j in range ( n ): qP . append (( 0 , j )) qA . append (( m - 1 , j )) bfs ( qP , seenP ) bfs ( qA , seenA ) return [[ i , j ] for i in range ( m ) for j in range ( n ) if seenP [ i ][ j ] and seenA [ i ][ j ]]","title":"Approach 1: BFS"},{"location":"problems/0417/#approach-2-dfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < vector < int >> ans ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , seenP ); dfs ( matrix , i , n - 1 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , seenP ); dfs ( matrix , m - 1 , j , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } private : void dfs ( const vector < vector < int >>& matrix , int i , int j , const vector < vector < bool >>& seen , int h = 0 ) { if ( i < 0 || i == matrix . size () || j < 0 || j == matrix [ 0 ]. size ()) return ; if ( seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , seen , matrix [ i ][ j ]); dfs ( matrix , i - 1 , j , seen , matrix [ i ][ j ]); dfs ( matrix , i , j + 1 , seen , matrix [ i ][ j ]); dfs ( matrix , i , j - 1 , seen , matrix [ i ][ j ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , 0 , seenP ); dfs ( matrix , i , n - 1 , 0 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , 0 , seenP ); dfs ( matrix , m - 1 , j , 0 , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private void dfs ( final int [][] matrix , int i , int j , int h , boolean [][] seen ) { if ( i < 0 || i == matrix . length || j < 0 || j == matrix [ 0 ] . length ) return ; if ( seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , seen ); } }","title":"Approach 2: DFS"},{"location":"problems/0418/","text":"418. Sentence Screen Fitting \ud83d\udd12 Time: $O(|rows| \\codt 10)$ Space: $O(\\Sigma|sentence_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int wordsTyping ( vector < string >& sentence , int rows , int cols ) { const string & combined = getCombined ( sentence ); const int n = combined . length (); int start = 0 ; // the start index of combined in each row for ( int i = 0 ; i < rows ; ++ i ) { start += cols ; if ( combined [ start % n ] == ' ' ) { ++ start ; } else { while ( start > 0 && combined [( start - 1 ) % n ] != ' ' ) -- start ; } } return start / n ; } private : string getCombined ( const vector < string >& sentence ) { string combined ; for ( const string & word : sentence ) combined += ( word + ' ' ); return combined ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int wordsTyping ( String [] sentence , int rows , int cols ) { StringBuilder combined = getCombined ( sentence ); final int n = combined . length (); int start = 0 ; // the start index of combined in each row for ( int i = 0 ; i < rows ; ++ i ) { start += cols ; if ( combined . charAt ( start % n ) == ' ' ) { ++ start ; } else { while ( start > 0 && combined . charAt (( start - 1 ) % n ) != ' ' ) -- start ; } } return start / n ; } private StringBuilder getCombined ( final String [] sentence ) { StringBuilder sb = new StringBuilder (); for ( final String word : sentence ) sb . append ( word ). append ( ' ' ); return sb ; } }","title":"418. Sentence Screen Fitting"},{"location":"problems/0418/#418-sentence-screen-fitting","text":"Time: $O(|rows| \\codt 10)$ Space: $O(\\Sigma|sentence_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int wordsTyping ( vector < string >& sentence , int rows , int cols ) { const string & combined = getCombined ( sentence ); const int n = combined . length (); int start = 0 ; // the start index of combined in each row for ( int i = 0 ; i < rows ; ++ i ) { start += cols ; if ( combined [ start % n ] == ' ' ) { ++ start ; } else { while ( start > 0 && combined [( start - 1 ) % n ] != ' ' ) -- start ; } } return start / n ; } private : string getCombined ( const vector < string >& sentence ) { string combined ; for ( const string & word : sentence ) combined += ( word + ' ' ); return combined ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int wordsTyping ( String [] sentence , int rows , int cols ) { StringBuilder combined = getCombined ( sentence ); final int n = combined . length (); int start = 0 ; // the start index of combined in each row for ( int i = 0 ; i < rows ; ++ i ) { start += cols ; if ( combined . charAt ( start % n ) == ' ' ) { ++ start ; } else { while ( start > 0 && combined . charAt (( start - 1 ) % n ) != ' ' ) -- start ; } } return start / n ; } private StringBuilder getCombined ( final String [] sentence ) { StringBuilder sb = new StringBuilder (); for ( final String word : sentence ) sb . append ( word ). append ( ' ' ); return sb ; } }","title":"418. Sentence Screen Fitting \ud83d\udd12"},{"location":"problems/0419/","text":"419. Battleships in a Board Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int countBattleships ( vector < vector < char >>& board ) { if ( board . empty ()) return 0 ; int ans = 0 ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; if ( i > 0 && board [ i - 1 ][ j ] == 'X' ) continue ; if ( j > 0 && board [ i ][ j - 1 ] == 'X' ) continue ; ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countBattleships ( char [][] board ) { if ( board . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; if ( i > 0 && board [ i - 1 ][ j ] == 'X' ) continue ; if ( j > 0 && board [ i ][ j - 1 ] == 'X' ) continue ; ++ ans ; } return ans ; } }","title":"419. Battleships in a Board"},{"location":"problems/0419/#419-battleships-in-a-board","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int countBattleships ( vector < vector < char >>& board ) { if ( board . empty ()) return 0 ; int ans = 0 ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; if ( i > 0 && board [ i - 1 ][ j ] == 'X' ) continue ; if ( j > 0 && board [ i ][ j - 1 ] == 'X' ) continue ; ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countBattleships ( char [][] board ) { if ( board . length == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) { if ( board [ i ][ j ] == '.' ) continue ; if ( i > 0 && board [ i - 1 ][ j ] == 'X' ) continue ; if ( j > 0 && board [ i ][ j - 1 ] == 'X' ) continue ; ++ ans ; } return ans ; } }","title":"419. Battleships in a Board"},{"location":"problems/0420/","text":"420. Strong Password Checker Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : int strongPasswordChecker ( string s ) { const int n = s . length (); const int missing = getMissing ( s ); int replaces = 0 ; // # of replacements to deal with three repeating characters int oneSeq = 0 ; // # of seqs that can be substituted with 1 deletions, (3k)-seqs int twoSeq = 0 ; // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs for ( int i = 2 ; i < n ;) if ( s [ i ] == s [ i - 1 ] && s [ i - 1 ] == s [ i - 2 ]) { int length = 2 ; // length of repeating s while ( i < n && s [ i ] == s [ i - 1 ]) { ++ length ; ++ i ; } replaces += length / 3 ; // 'aaaaaaa' -> 'aaxaaxa' if ( length % 3 == 0 ) ++ oneSeq ; if ( length % 3 == 1 ) ++ twoSeq ; } else { ++ i ; } if ( n < 6 ) return max ( 6 - n , missing ); if ( n <= 20 ) return max ( replaces , missing ); const int deletes = n - 20 ; // each replacement in (3k)-seqs can be substituted with 1 deletions replaces -= min ( oneSeq , deletes ); // each replacement in (3k + 1)-seqs can be substituted with 2 deletions replaces -= min ( max ( deletes - oneSeq , 0 ), twoSeq * 2 ) / 2 ; // each replacement in other seqs can be substituted with 3 deletions replaces -= max ( deletes - oneSeq - twoSeq * 2 , 0 ) / 3 ; return deletes + max ( replaces , missing ); } private : int getMissing ( const string & s ) { int missing = 3 ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return isupper ( c ); })) -- missing ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return islower ( c ); })) -- missing ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return isdigit ( c ); })) -- missing ; return missing ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public int strongPasswordChecker ( String s ) { final int n = s . length (); final char [] chars = s . toCharArray (); final int missing = getMissing ( chars ); int replaces = 0 ; // # of replacements to deal with three repeating characters int oneSeq = 0 ; // # of seqs that can be substituted with 1 deletions, (3k)-seqs int twoSeq = 0 ; // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs for ( int i = 2 ; i < n ;) if ( chars [ i ] == chars [ i - 1 ] && chars [ i - 1 ] == chars [ i - 2 ] ) { int length = 2 ; // length of repeating chars while ( i < n && chars [ i ] == chars [ i - 1 ] ) { ++ length ; ++ i ; } replaces += length / 3 ; // 'aaaaaaa' -> 'aaxaaxa' if ( length % 3 == 0 ) ++ oneSeq ; if ( length % 3 == 1 ) ++ twoSeq ; } else { ++ i ; } if ( n < 6 ) return Math . max ( 6 - n , missing ); if ( n <= 20 ) return Math . max ( replaces , missing ); final int deletes = n - 20 ; // each replacement in (3k)-seqs can be substituted with 1 deletions replaces -= Math . min ( oneSeq , deletes ); // each replacement in (3k + 1)-seqs can be substituted with 2 deletions replaces -= Math . min ( Math . max ( deletes - oneSeq , 0 ), twoSeq * 2 ) / 2 ; // each replacement in other seqs can be substituted with 3 deletions replaces -= Math . max ( deletes - oneSeq - twoSeq * 2 , 0 ) / 3 ; return deletes + Math . max ( replaces , missing ); } private int getMissing ( final char [] chars ) { int missing = 3 ; for ( final char c : chars ) if ( Character . isUpperCase ( c )) { -- missing ; break ; } for ( final char c : chars ) if ( Character . isLowerCase ( c )) { -- missing ; break ; } for ( final char c : chars ) if ( Character . isDigit ( c )) { -- missing ; break ; } return missing ; } }","title":"420. Strong Password Checker"},{"location":"problems/0420/#420-strong-password-checker","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : int strongPasswordChecker ( string s ) { const int n = s . length (); const int missing = getMissing ( s ); int replaces = 0 ; // # of replacements to deal with three repeating characters int oneSeq = 0 ; // # of seqs that can be substituted with 1 deletions, (3k)-seqs int twoSeq = 0 ; // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs for ( int i = 2 ; i < n ;) if ( s [ i ] == s [ i - 1 ] && s [ i - 1 ] == s [ i - 2 ]) { int length = 2 ; // length of repeating s while ( i < n && s [ i ] == s [ i - 1 ]) { ++ length ; ++ i ; } replaces += length / 3 ; // 'aaaaaaa' -> 'aaxaaxa' if ( length % 3 == 0 ) ++ oneSeq ; if ( length % 3 == 1 ) ++ twoSeq ; } else { ++ i ; } if ( n < 6 ) return max ( 6 - n , missing ); if ( n <= 20 ) return max ( replaces , missing ); const int deletes = n - 20 ; // each replacement in (3k)-seqs can be substituted with 1 deletions replaces -= min ( oneSeq , deletes ); // each replacement in (3k + 1)-seqs can be substituted with 2 deletions replaces -= min ( max ( deletes - oneSeq , 0 ), twoSeq * 2 ) / 2 ; // each replacement in other seqs can be substituted with 3 deletions replaces -= max ( deletes - oneSeq - twoSeq * 2 , 0 ) / 3 ; return deletes + max ( replaces , missing ); } private : int getMissing ( const string & s ) { int missing = 3 ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return isupper ( c ); })) -- missing ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return islower ( c ); })) -- missing ; if ( any_of ( begin ( s ), end ( s ), []( char c ) { return isdigit ( c ); })) -- missing ; return missing ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public int strongPasswordChecker ( String s ) { final int n = s . length (); final char [] chars = s . toCharArray (); final int missing = getMissing ( chars ); int replaces = 0 ; // # of replacements to deal with three repeating characters int oneSeq = 0 ; // # of seqs that can be substituted with 1 deletions, (3k)-seqs int twoSeq = 0 ; // # of seqs that can be substituted with 2 deletions, (3k + 1)-seqs for ( int i = 2 ; i < n ;) if ( chars [ i ] == chars [ i - 1 ] && chars [ i - 1 ] == chars [ i - 2 ] ) { int length = 2 ; // length of repeating chars while ( i < n && chars [ i ] == chars [ i - 1 ] ) { ++ length ; ++ i ; } replaces += length / 3 ; // 'aaaaaaa' -> 'aaxaaxa' if ( length % 3 == 0 ) ++ oneSeq ; if ( length % 3 == 1 ) ++ twoSeq ; } else { ++ i ; } if ( n < 6 ) return Math . max ( 6 - n , missing ); if ( n <= 20 ) return Math . max ( replaces , missing ); final int deletes = n - 20 ; // each replacement in (3k)-seqs can be substituted with 1 deletions replaces -= Math . min ( oneSeq , deletes ); // each replacement in (3k + 1)-seqs can be substituted with 2 deletions replaces -= Math . min ( Math . max ( deletes - oneSeq , 0 ), twoSeq * 2 ) / 2 ; // each replacement in other seqs can be substituted with 3 deletions replaces -= Math . max ( deletes - oneSeq - twoSeq * 2 , 0 ) / 3 ; return deletes + Math . max ( replaces , missing ); } private int getMissing ( final char [] chars ) { int missing = 3 ; for ( final char c : chars ) if ( Character . isUpperCase ( c )) { -- missing ; break ; } for ( final char c : chars ) if ( Character . isLowerCase ( c )) { -- missing ; break ; } for ( final char c : chars ) if ( Character . isDigit ( c )) { -- missing ; break ; } return missing ; } }","title":"420. Strong Password Checker"},{"location":"problems/0421/","text":"421. Maximum XOR of Two Numbers in an Array Time: $O(32n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int findMaximumXOR ( vector < int >& nums ) { int ans = 0 ; int mask = 0 ; // if ans is 11100 at i = 2, it means before we reach the last two bits, // 11100 is the maximum XOR we have, and we're going to explore if we can // get another two '1's and put them into ans for ( int i = 31 ; i >= 0 ; -- i ) { // mask grows like: 100...000, 110...000, 111...000, ..., 111...111 mask |= 1 << i ; unordered_set < int > prefixes ; // we only care about the left parts, // if i = 2, nums = {1110, 1011, 0111} // -> prefixes = {1100, 1000, 0100} for ( const int num : nums ) prefixes . insert ( num & mask ); // if i = 1 and before this iteration, the ans is 1100, // we hope to grow ans to 1110, so find a candidate // which can give a greedy try const int candidate = ans | ( 1 << i ); for ( const int prefix : prefixes ) if ( prefixes . count ( prefix ^ candidate )) { ans = candidate ; break ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findMaximumXOR ( int [] nums ) { int ans = 0 ; int mask = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { mask |= 1 << i ; Set < Integer > prefixes = new HashSet <> (); for ( final int num : nums ) prefixes . add ( num & mask ); final int candidate = ans | 1 << i ; for ( final int prefix : prefixes ) if ( prefixes . contains ( prefix ^ candidate )) { ans = candidate ; break ; } } return ans ; } }","title":"421. Maximum XOR of Two Numbers in an Array"},{"location":"problems/0421/#421-maximum-xor-of-two-numbers-in-an-array","text":"Time: $O(32n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int findMaximumXOR ( vector < int >& nums ) { int ans = 0 ; int mask = 0 ; // if ans is 11100 at i = 2, it means before we reach the last two bits, // 11100 is the maximum XOR we have, and we're going to explore if we can // get another two '1's and put them into ans for ( int i = 31 ; i >= 0 ; -- i ) { // mask grows like: 100...000, 110...000, 111...000, ..., 111...111 mask |= 1 << i ; unordered_set < int > prefixes ; // we only care about the left parts, // if i = 2, nums = {1110, 1011, 0111} // -> prefixes = {1100, 1000, 0100} for ( const int num : nums ) prefixes . insert ( num & mask ); // if i = 1 and before this iteration, the ans is 1100, // we hope to grow ans to 1110, so find a candidate // which can give a greedy try const int candidate = ans | ( 1 << i ); for ( const int prefix : prefixes ) if ( prefixes . count ( prefix ^ candidate )) { ans = candidate ; break ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findMaximumXOR ( int [] nums ) { int ans = 0 ; int mask = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { mask |= 1 << i ; Set < Integer > prefixes = new HashSet <> (); for ( final int num : nums ) prefixes . add ( num & mask ); final int candidate = ans | 1 << i ; for ( final int prefix : prefixes ) if ( prefixes . contains ( prefix ^ candidate )) { ans = candidate ; break ; } } return ans ; } }","title":"421. Maximum XOR of Two Numbers in an Array"},{"location":"problems/0422/","text":"422. Valid Word Square \ud83d\udd12 Time: $O(\\Sigma|words_i|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validWordSquare ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < words [ i ]. size (); ++ j ) { if ( words . size () <= j || words [ j ]. size () <= i ) // out of bound return false ; if ( words [ i ][ j ] != words [ j ][ i ]) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean validWordSquare ( List < String > words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < words . get ( i ). length (); ++ j ) { if ( words . size () <= j || words . get ( j ). length () <= i ) // out of bound return false ; if ( words . get ( i ). charAt ( j ) != words . get ( j ). charAt ( i )) return false ; } return true ; } }","title":"422. Valid Word Square"},{"location":"problems/0422/#422-valid-word-square","text":"Time: $O(\\Sigma|words_i|)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validWordSquare ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < words [ i ]. size (); ++ j ) { if ( words . size () <= j || words [ j ]. size () <= i ) // out of bound return false ; if ( words [ i ][ j ] != words [ j ][ i ]) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean validWordSquare ( List < String > words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j < words . get ( i ). length (); ++ j ) { if ( words . size () <= j || words . get ( j ). length () <= i ) // out of bound return false ; if ( words . get ( i ). charAt ( j ) != words . get ( j ). charAt ( i )) return false ; } return true ; } }","title":"422. Valid Word Square \ud83d\udd12"},{"location":"problems/0423/","text":"423. Reconstruct Original Digits from English Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string originalDigits ( string s ) { string ans ; vector < int > count ( 10 ); for ( const char c : s ) { if ( c == 'z' ) ++ count [ 0 ]; if ( c == 'o' ) ++ count [ 1 ]; if ( c == 'w' ) ++ count [ 2 ]; if ( c == 'h' ) ++ count [ 3 ]; if ( c == 'u' ) ++ count [ 4 ]; if ( c == 'f' ) ++ count [ 5 ]; if ( c == 'x' ) ++ count [ 6 ]; if ( c == 's' ) ++ count [ 7 ]; if ( c == 'g' ) ++ count [ 8 ]; if ( c == 'i' ) ++ count [ 9 ]; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ]; count [ 3 ] -= count [ 8 ]; count [ 5 ] -= count [ 4 ]; count [ 7 ] -= count [ 6 ]; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ]; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ]; ++ j ) ans += i + '0' ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String originalDigits ( String s ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 10 ] ; for ( final char c : s . toCharArray ()) { if ( c == 'z' ) ++ count [ 0 ] ; if ( c == 'o' ) ++ count [ 1 ] ; if ( c == 'w' ) ++ count [ 2 ] ; if ( c == 'h' ) ++ count [ 3 ] ; if ( c == 'u' ) ++ count [ 4 ] ; if ( c == 'f' ) ++ count [ 5 ] ; if ( c == 'x' ) ++ count [ 6 ] ; if ( c == 's' ) ++ count [ 7 ] ; if ( c == 'g' ) ++ count [ 8 ] ; if ( c == 'i' ) ++ count [ 9 ] ; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] ; count [ 3 ] -= count [ 8 ] ; count [ 5 ] -= count [ 4 ] ; count [ 7 ] -= count [ 6 ] ; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] ; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ] ; ++ j ) sb . append ( i ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def originalDigits ( self , s : str ) -> str : count = [ 0 ] * 10 for c in s : if c == 'z' : count [ 0 ] += 1 if c == 'o' : count [ 1 ] += 1 if c == 'w' : count [ 2 ] += 1 if c == 'h' : count [ 3 ] += 1 if c == 'u' : count [ 4 ] += 1 if c == 'f' : count [ 5 ] += 1 if c == 'x' : count [ 6 ] += 1 if c == 's' : count [ 7 ] += 1 if c == 'g' : count [ 8 ] += 1 if c == 'i' : count [ 9 ] += 1 count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] count [ 3 ] -= count [ 8 ] count [ 5 ] -= count [ 4 ] count [ 7 ] -= count [ 6 ] count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] return '' . join ( chr ( i + ord ( '0' )) for i , c in enumerate ( count ) for j in range ( c ))","title":"423. Reconstruct Original Digits from English"},{"location":"problems/0423/#423-reconstruct-original-digits-from-english","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string originalDigits ( string s ) { string ans ; vector < int > count ( 10 ); for ( const char c : s ) { if ( c == 'z' ) ++ count [ 0 ]; if ( c == 'o' ) ++ count [ 1 ]; if ( c == 'w' ) ++ count [ 2 ]; if ( c == 'h' ) ++ count [ 3 ]; if ( c == 'u' ) ++ count [ 4 ]; if ( c == 'f' ) ++ count [ 5 ]; if ( c == 'x' ) ++ count [ 6 ]; if ( c == 's' ) ++ count [ 7 ]; if ( c == 'g' ) ++ count [ 8 ]; if ( c == 'i' ) ++ count [ 9 ]; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ]; count [ 3 ] -= count [ 8 ]; count [ 5 ] -= count [ 4 ]; count [ 7 ] -= count [ 6 ]; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ]; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ]; ++ j ) ans += i + '0' ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String originalDigits ( String s ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 10 ] ; for ( final char c : s . toCharArray ()) { if ( c == 'z' ) ++ count [ 0 ] ; if ( c == 'o' ) ++ count [ 1 ] ; if ( c == 'w' ) ++ count [ 2 ] ; if ( c == 'h' ) ++ count [ 3 ] ; if ( c == 'u' ) ++ count [ 4 ] ; if ( c == 'f' ) ++ count [ 5 ] ; if ( c == 'x' ) ++ count [ 6 ] ; if ( c == 's' ) ++ count [ 7 ] ; if ( c == 'g' ) ++ count [ 8 ] ; if ( c == 'i' ) ++ count [ 9 ] ; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] ; count [ 3 ] -= count [ 8 ] ; count [ 5 ] -= count [ 4 ] ; count [ 7 ] -= count [ 6 ] ; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] ; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ] ; ++ j ) sb . append ( i ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def originalDigits ( self , s : str ) -> str : count = [ 0 ] * 10 for c in s : if c == 'z' : count [ 0 ] += 1 if c == 'o' : count [ 1 ] += 1 if c == 'w' : count [ 2 ] += 1 if c == 'h' : count [ 3 ] += 1 if c == 'u' : count [ 4 ] += 1 if c == 'f' : count [ 5 ] += 1 if c == 'x' : count [ 6 ] += 1 if c == 's' : count [ 7 ] += 1 if c == 'g' : count [ 8 ] += 1 if c == 'i' : count [ 9 ] += 1 count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] count [ 3 ] -= count [ 8 ] count [ 5 ] -= count [ 4 ] count [ 7 ] -= count [ 6 ] count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] return '' . join ( chr ( i + ord ( '0' )) for i , c in enumerate ( count ) for j in range ( c ))","title":"423. Reconstruct Original Digits from English"},{"location":"problems/0424/","text":"424. Longest Repeating Character Replacement Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int characterReplacement ( string s , int k ) { int ans = 0 ; int maxCount = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { maxCount = max ( maxCount , ++ count [ s [ r ]]); while ( maxCount + k < r - l + 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int characterReplacement ( String s , int k ) { int ans = 0 ; int maxCount = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { maxCount = Math . max ( maxCount , ++ count [ s . charAt ( r ) ] ); while ( maxCount + k < r - l + 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def characterReplacement ( self , s : str , k : int ) -> int : ans = 0 maxFreq = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 maxFreq = max ( maxFreq , count [ c ]) while maxFreq + k < r - l + 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"424. Longest Repeating Character Replacement"},{"location":"problems/0424/#424-longest-repeating-character-replacement","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int characterReplacement ( string s , int k ) { int ans = 0 ; int maxCount = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { maxCount = max ( maxCount , ++ count [ s [ r ]]); while ( maxCount + k < r - l + 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int characterReplacement ( String s , int k ) { int ans = 0 ; int maxCount = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { maxCount = Math . max ( maxCount , ++ count [ s . charAt ( r ) ] ); while ( maxCount + k < r - l + 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def characterReplacement ( self , s : str , k : int ) -> int : ans = 0 maxFreq = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 maxFreq = max ( maxFreq , count [ c ]) while maxFreq + k < r - l + 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"424. Longest Repeating Character Replacement"},{"location":"problems/0425/","text":"425. Word Squares \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 struct TrieNode { TrieNode () : children ( 26 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; vector < const string *> startsWith ; }; class Trie { public : Trie ( const vector < string >& words ) { for ( const string & word : words ) insert ( word ); } vector < const string *> findBy ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { const int i = c - 'a' ; if ( ! node -> children [ i ]) return {}; node = node -> children [ i ]; } return node -> startsWith ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { const int i = c - 'a' ; if ( ! node -> children [ i ]) node -> children [ i ] = new TrieNode (); node = node -> children [ i ]; node -> startsWith . push_back ( & word ); } } }; class Solution { public : vector < vector < string >> wordSquares ( vector < string >& words ) { if ( words . empty ()) return {}; const int n = words [ 0 ]. length (); vector < vector < string >> ans ; vector < string > path ; Trie trie ( words ); for ( const string & word : words ) { path . push_back ( word ); dfs ( trie , n , path , ans ); path . pop_back (); } return ans ; } private : void dfs ( Trie & trie , const int n , vector < string >& path , vector < vector < string >>& ans ) { if ( path . size () == n ) { ans . push_back ( path ); return ; } const string prefix = getPrefix ( path ); for ( const string * s : trie . findBy ( prefix )) { path . push_back ( * s ); dfs ( trie , n , path , ans ); path . pop_back (); } } // e.g. path = [\"wall\", // \"area\"] // prefix = \"le..\" string getPrefix ( const vector < string >& path ) { string prefix ; const int index = path . size (); for ( const string & s : path ) prefix += s [ index ]; return prefix ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public List < String > startsWith = new ArrayList <> (); } class Trie { public Trie ( final String [] words ) { for ( final String word : words ) insert ( word ); } public List < String > findBy ( final String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ()) { final int i = c - 'a' ; if ( node . children [ i ] == null ) return new ArrayList <> (); node = node . children [ i ] ; } return node . startsWith ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { final int i = c - 'a' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode (); node = node . children [ i ] ; node . startsWith . add ( word ); } } } class Solution { public List < List < String >> wordSquares ( String [] words ) { if ( words . length == 0 ) return new ArrayList <> (); final int n = words [ 0 ] . length (); List < List < String >> ans = new ArrayList <> (); List < String > path = new ArrayList <> (); Trie trie = new Trie ( words ); for ( final String word : words ) { path . add ( word ); dfs ( trie , n , path , ans ); path . remove ( path . size () - 1 ); } return ans ; } private void dfs ( Trie trie , final int n , List < String > path , List < List < String >> ans ) { if ( path . size () == n ) { ans . add ( new ArrayList <> ( path )); return ; } final String prefix = getPrefix ( path ); for ( final String s : trie . findBy ( prefix )) { path . add ( s ); dfs ( trie , n , path , ans ); path . remove ( path . size () - 1 ); } } // e.g. path = [\"wall\", // \"area\"] // prefix = \"le..\" private String getPrefix ( List < String > path ) { StringBuilder sb = new StringBuilder (); final int index = path . size (); for ( final String s : path ) sb . append ( s . charAt ( index )); return sb . toString (); } }","title":"425. Word Squares"},{"location":"problems/0425/#425-word-squares","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 struct TrieNode { TrieNode () : children ( 26 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; vector < const string *> startsWith ; }; class Trie { public : Trie ( const vector < string >& words ) { for ( const string & word : words ) insert ( word ); } vector < const string *> findBy ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { const int i = c - 'a' ; if ( ! node -> children [ i ]) return {}; node = node -> children [ i ]; } return node -> startsWith ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { const int i = c - 'a' ; if ( ! node -> children [ i ]) node -> children [ i ] = new TrieNode (); node = node -> children [ i ]; node -> startsWith . push_back ( & word ); } } }; class Solution { public : vector < vector < string >> wordSquares ( vector < string >& words ) { if ( words . empty ()) return {}; const int n = words [ 0 ]. length (); vector < vector < string >> ans ; vector < string > path ; Trie trie ( words ); for ( const string & word : words ) { path . push_back ( word ); dfs ( trie , n , path , ans ); path . pop_back (); } return ans ; } private : void dfs ( Trie & trie , const int n , vector < string >& path , vector < vector < string >>& ans ) { if ( path . size () == n ) { ans . push_back ( path ); return ; } const string prefix = getPrefix ( path ); for ( const string * s : trie . findBy ( prefix )) { path . push_back ( * s ); dfs ( trie , n , path , ans ); path . pop_back (); } } // e.g. path = [\"wall\", // \"area\"] // prefix = \"le..\" string getPrefix ( const vector < string >& path ) { string prefix ; const int index = path . size (); for ( const string & s : path ) prefix += s [ index ]; return prefix ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class TrieNode { public TrieNode [] children = new TrieNode [ 26 ] ; public List < String > startsWith = new ArrayList <> (); } class Trie { public Trie ( final String [] words ) { for ( final String word : words ) insert ( word ); } public List < String > findBy ( final String prefix ) { TrieNode node = root ; for ( final char c : prefix . toCharArray ()) { final int i = c - 'a' ; if ( node . children [ i ] == null ) return new ArrayList <> (); node = node . children [ i ] ; } return node . startsWith ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( final char c : word . toCharArray ()) { final int i = c - 'a' ; if ( node . children [ i ] == null ) node . children [ i ] = new TrieNode (); node = node . children [ i ] ; node . startsWith . add ( word ); } } } class Solution { public List < List < String >> wordSquares ( String [] words ) { if ( words . length == 0 ) return new ArrayList <> (); final int n = words [ 0 ] . length (); List < List < String >> ans = new ArrayList <> (); List < String > path = new ArrayList <> (); Trie trie = new Trie ( words ); for ( final String word : words ) { path . add ( word ); dfs ( trie , n , path , ans ); path . remove ( path . size () - 1 ); } return ans ; } private void dfs ( Trie trie , final int n , List < String > path , List < List < String >> ans ) { if ( path . size () == n ) { ans . add ( new ArrayList <> ( path )); return ; } final String prefix = getPrefix ( path ); for ( final String s : trie . findBy ( prefix )) { path . add ( s ); dfs ( trie , n , path , ans ); path . remove ( path . size () - 1 ); } } // e.g. path = [\"wall\", // \"area\"] // prefix = \"le..\" private String getPrefix ( List < String > path ) { StringBuilder sb = new StringBuilder (); final int index = path . size (); for ( final String s : path ) sb . append ( s . charAt ( index )); return sb . toString (); } }","title":"425. Word Squares \ud83d\udd12"},{"location":"problems/0426/","text":"426. Convert Binary Search Tree to Sorted Doubly Linked List \ud83d\udd12 Approach 1: Divide and conquer Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : Node * treeToDoublyList ( Node * root ) { if ( ! root ) return nullptr ; Node * leftHead = treeToDoublyList ( root -> left ); Node * rightHead = treeToDoublyList ( root -> right ); root -> left = root ; root -> right = root ; return connect ( connect ( leftHead , root ), rightHead ); } private : Node * connect ( Node * node1 , Node * node2 ) { if ( ! node1 ) return node2 ; if ( ! node2 ) return node1 ; Node * tail1 = node1 -> left ; Node * tail2 = node2 -> left ; // connect node1's tail with node2 tail1 -> right = node2 ; node2 -> left = tail1 ; // connect node2's tail with node1 tail2 -> right = node1 ; node1 -> left = tail2 ; return node1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public Node treeToDoublyList ( Node root ) { if ( root == null ) return null ; Node leftHead = treeToDoublyList ( root . left ); Node rightHead = treeToDoublyList ( root . right ); root . left = root ; root . right = root ; return connect ( connect ( leftHead , root ), rightHead ); } private Node connect ( Node node1 , Node node2 ) { if ( node1 == null ) return node2 ; if ( node2 == null ) return node1 ; Node tail1 = node1 . left ; Node tail2 = node2 . left ; // connect node1's tail with node2 tail1 . right = node2 ; node2 . left = tail1 ; // connect node2's tail with node1 tail2 . right = node1 ; node1 . left = tail2 ; return node1 ; } } Approach 2: Stack Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : Node * treeToDoublyList ( Node * root ) { // very similar to 94. Binary Tree Inorder Traversal if ( ! root ) return nullptr ; stack < Node *> stack ; Node * first = nullptr ; Node * prev = nullptr ; while ( root || ! stack . empty ()) { while ( root ) { stack . push ( root ); root = root -> left ; } root = stack . top (), stack . pop (); if ( ! first ) first = root ; if ( prev ) { prev -> right = root ; root -> left = prev ; } prev = root ; root = root -> right ; } prev -> right = first ; first -> left = prev ; return first ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.Stack ; import org.w3c.dom.Node ; class Solution { public Node treeToDoublyList ( Node root ) { // very similar to 94. Binary Tree Inorder Traversal if ( root == null ) return null ; Stack < Node > stack = new Stack <> (); Node first = null ; Node prev = null ; while ( root != null || ! stack . isEmpty ()) { while ( root != null ) { stack . push ( root ); root = root . left ; } root = stack . pop (); if ( first == null ) first = root ; if ( prev ) { prev . right = root ; root . left = prev ; } prev = root ; root = root . right ; } prev . right = first ; first . left = prev ; return first ; } }","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List"},{"location":"problems/0426/#426-convert-binary-search-tree-to-sorted-doubly-linked-list","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List \ud83d\udd12"},{"location":"problems/0426/#approach-1-divide-and-conquer","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : Node * treeToDoublyList ( Node * root ) { if ( ! root ) return nullptr ; Node * leftHead = treeToDoublyList ( root -> left ); Node * rightHead = treeToDoublyList ( root -> right ); root -> left = root ; root -> right = root ; return connect ( connect ( leftHead , root ), rightHead ); } private : Node * connect ( Node * node1 , Node * node2 ) { if ( ! node1 ) return node2 ; if ( ! node2 ) return node1 ; Node * tail1 = node1 -> left ; Node * tail2 = node2 -> left ; // connect node1's tail with node2 tail1 -> right = node2 ; node2 -> left = tail1 ; // connect node2's tail with node1 tail2 -> right = node1 ; node1 -> left = tail2 ; return node1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public Node treeToDoublyList ( Node root ) { if ( root == null ) return null ; Node leftHead = treeToDoublyList ( root . left ); Node rightHead = treeToDoublyList ( root . right ); root . left = root ; root . right = root ; return connect ( connect ( leftHead , root ), rightHead ); } private Node connect ( Node node1 , Node node2 ) { if ( node1 == null ) return node2 ; if ( node2 == null ) return node1 ; Node tail1 = node1 . left ; Node tail2 = node2 . left ; // connect node1's tail with node2 tail1 . right = node2 ; node2 . left = tail1 ; // connect node2's tail with node1 tail2 . right = node1 ; node1 . left = tail2 ; return node1 ; } }","title":"Approach 1: Divide and conquer"},{"location":"problems/0426/#approach-2-stack","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : Node * treeToDoublyList ( Node * root ) { // very similar to 94. Binary Tree Inorder Traversal if ( ! root ) return nullptr ; stack < Node *> stack ; Node * first = nullptr ; Node * prev = nullptr ; while ( root || ! stack . empty ()) { while ( root ) { stack . push ( root ); root = root -> left ; } root = stack . top (), stack . pop (); if ( ! first ) first = root ; if ( prev ) { prev -> right = root ; root -> left = prev ; } prev = root ; root = root -> right ; } prev -> right = first ; first -> left = prev ; return first ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.Stack ; import org.w3c.dom.Node ; class Solution { public Node treeToDoublyList ( Node root ) { // very similar to 94. Binary Tree Inorder Traversal if ( root == null ) return null ; Stack < Node > stack = new Stack <> (); Node first = null ; Node prev = null ; while ( root != null || ! stack . isEmpty ()) { while ( root != null ) { stack . push ( root ); root = root . left ; } root = stack . pop (); if ( first == null ) first = root ; if ( prev ) { prev . right = root ; root . left = prev ; } prev = root ; root = root . right ; } prev . right = first ; first . left = prev ; return first ; } }","title":"Approach 2: Stack"},{"location":"problems/0427/","text":"427. Construct Quad Tree Time: $O(n^2 \\log_4 n)$ Space: $O(\\log_4 n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : Node * construct ( vector < vector < int >>& grid ) { function < Node * ( int , int , int ) > helper = [ & ]( int i , int j , int w ) -> Node * { if ( all_of ( begin ( grid ) + i , begin ( grid ) + i + w , [ & ]( vector < int >& row ) { return all_of ( begin ( row ) + j , begin ( row ) + j + w , [ & ]( int num ) { return num == grid [ i ][ j ]; }); })) return new Node ( grid [ i ][ j ], true ); Node * node = new Node ( true , false ); node -> topLeft = helper ( i , j , w / 2 ); node -> topRight = helper ( i , j + w / 2 , w / 2 ); node -> bottomLeft = helper ( i + w / 2 , j , w / 2 ); node -> bottomRight = helper ( i + w / 2 , j + w / 2 , w / 2 ); return node ; }; return helper ( 0 , 0 , grid . size ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public Node construct ( int [][] grid ) { return helper ( grid , 0 , 0 , grid . length ); } private Node helper ( final int [][] grid , int i , int j , int w ) { if ( allSame ( grid , i , j , w )) return new Node ( grid [ i ][ j ] == 1 ? true : false , true ); Node node = new Node ( true , false ); node . topLeft = helper ( grid , i , j , w / 2 ); node . topRight = helper ( grid , i , j + w / 2 , w / 2 ); node . bottomLeft = helper ( grid , i + w / 2 , j , w / 2 ); node . bottomRight = helper ( grid , i + w / 2 , j + w / 2 , w / 2 ); return node ; } private boolean allSame ( final int [][] grid , int i , int j , int w ) { for ( int x = i ; x < i + w ; ++ x ) for ( int y = j ; y < j + w ; ++ y ) if ( grid [ x ][ y ] != grid [ i ][ j ] ) return false ; return true ; } }","title":"427. Construct Quad Tree"},{"location":"problems/0427/#427-construct-quad-tree","text":"Time: $O(n^2 \\log_4 n)$ Space: $O(\\log_4 n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : Node * construct ( vector < vector < int >>& grid ) { function < Node * ( int , int , int ) > helper = [ & ]( int i , int j , int w ) -> Node * { if ( all_of ( begin ( grid ) + i , begin ( grid ) + i + w , [ & ]( vector < int >& row ) { return all_of ( begin ( row ) + j , begin ( row ) + j + w , [ & ]( int num ) { return num == grid [ i ][ j ]; }); })) return new Node ( grid [ i ][ j ], true ); Node * node = new Node ( true , false ); node -> topLeft = helper ( i , j , w / 2 ); node -> topRight = helper ( i , j + w / 2 , w / 2 ); node -> bottomLeft = helper ( i + w / 2 , j , w / 2 ); node -> bottomRight = helper ( i + w / 2 , j + w / 2 , w / 2 ); return node ; }; return helper ( 0 , 0 , grid . size ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public Node construct ( int [][] grid ) { return helper ( grid , 0 , 0 , grid . length ); } private Node helper ( final int [][] grid , int i , int j , int w ) { if ( allSame ( grid , i , j , w )) return new Node ( grid [ i ][ j ] == 1 ? true : false , true ); Node node = new Node ( true , false ); node . topLeft = helper ( grid , i , j , w / 2 ); node . topRight = helper ( grid , i , j + w / 2 , w / 2 ); node . bottomLeft = helper ( grid , i + w / 2 , j , w / 2 ); node . bottomRight = helper ( grid , i + w / 2 , j + w / 2 , w / 2 ); return node ; } private boolean allSame ( final int [][] grid , int i , int j , int w ) { for ( int x = i ; x < i + w ; ++ x ) for ( int y = j ; y < j + w ; ++ y ) if ( grid [ x ][ y ] != grid [ i ][ j ] ) return false ; return true ; } }","title":"427. Construct Quad Tree"},{"location":"problems/0428/","text":"428. Serialize and Deserialize N-ary Tree \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Codec { public : // Encodes a tree to a single string. string serialize ( Node * root ) { if ( ! root ) return \"\" ; string s ; queue < Node *> q {{ root }}; s += to_string ( root -> val ) + \" \" ; while ( ! q . empty ()) for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); if ( root -> children . empty ()) { s += \"n\" ; } else { for ( Node * child : root -> children ) { q . push ( child ); s += to_string ( child -> val ) + \"#\" ; } } s += \" \" ; } return s ; } // Decodes your encoded data to tree. Node * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string word ; iss >> word ; Node * root = new Node ( stoi ( word )); queue < Node *> q {{ root }}; while ( iss >> word ) { Node * parent = q . front (); q . pop (); vector < string > kids = getKids ( word ); vector < Node *> children ; for ( const string & kid : kids ) { if ( kid == \"n\" ) continue ; Node * child = new Node ( stoi ( kid )); children . push_back ( child ); q . push ( child ); } parent -> children = children ; } return root ; } private : vector < string > getKids ( const string & word ) { vector < string > kids ; for ( int i = 0 , j = 0 ; j < word . length (); ++ j ) if ( word [ j ] == '#' ) { kids . push_back ( word . substr ( i , j - i )); i = j + 1 ; } return kids ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Codec { // Encodes a tree to a single string. public String serialize ( Node root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); Queue < Node > q = new LinkedList <> (); q . offer ( root ); sb . append ( root . val ). append ( \",\" ); while ( ! q . isEmpty ()) for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); if ( root . children . isEmpty ()) { sb . append ( \"n\" ); } else { for ( Node child : root . children ) { q . offer ( child ); sb . append ( child . val ). append ( \"#\" ); } } sb . append ( \",\" ); } return sb . toString (); } // Decodes your encoded data to tree. public Node deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; final String [] vals = data . split ( \",\" ); Node root = new Node ( Integer . parseInt ( vals [ 0 ] )); Queue < Node > q = new LinkedList <> (); q . offer ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { Node parent = q . poll (); final String [] kids = vals [ i ] . split ( \"#\" ); List < Node > children = new ArrayList <> (); for ( final String kid : kids ) { if ( kid . equals ( \"n\" )) continue ; Node child = new Node ( Integer . parseInt ( kid )); children . add ( child ); q . offer ( child ); } parent . children = children ; } return root ; } }","title":"428. Serialize and Deserialize N-ary Tree"},{"location":"problems/0428/#428-serialize-and-deserialize-n-ary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Codec { public : // Encodes a tree to a single string. string serialize ( Node * root ) { if ( ! root ) return \"\" ; string s ; queue < Node *> q {{ root }}; s += to_string ( root -> val ) + \" \" ; while ( ! q . empty ()) for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); if ( root -> children . empty ()) { s += \"n\" ; } else { for ( Node * child : root -> children ) { q . push ( child ); s += to_string ( child -> val ) + \"#\" ; } } s += \" \" ; } return s ; } // Decodes your encoded data to tree. Node * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string word ; iss >> word ; Node * root = new Node ( stoi ( word )); queue < Node *> q {{ root }}; while ( iss >> word ) { Node * parent = q . front (); q . pop (); vector < string > kids = getKids ( word ); vector < Node *> children ; for ( const string & kid : kids ) { if ( kid == \"n\" ) continue ; Node * child = new Node ( stoi ( kid )); children . push_back ( child ); q . push ( child ); } parent -> children = children ; } return root ; } private : vector < string > getKids ( const string & word ) { vector < string > kids ; for ( int i = 0 , j = 0 ; j < word . length (); ++ j ) if ( word [ j ] == '#' ) { kids . push_back ( word . substr ( i , j - i )); i = j + 1 ; } return kids ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Codec { // Encodes a tree to a single string. public String serialize ( Node root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); Queue < Node > q = new LinkedList <> (); q . offer ( root ); sb . append ( root . val ). append ( \",\" ); while ( ! q . isEmpty ()) for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); if ( root . children . isEmpty ()) { sb . append ( \"n\" ); } else { for ( Node child : root . children ) { q . offer ( child ); sb . append ( child . val ). append ( \"#\" ); } } sb . append ( \",\" ); } return sb . toString (); } // Decodes your encoded data to tree. public Node deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; final String [] vals = data . split ( \",\" ); Node root = new Node ( Integer . parseInt ( vals [ 0 ] )); Queue < Node > q = new LinkedList <> (); q . offer ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { Node parent = q . poll (); final String [] kids = vals [ i ] . split ( \"#\" ); List < Node > children = new ArrayList <> (); for ( final String kid : kids ) { if ( kid . equals ( \"n\" )) continue ; Node child = new Node ( Integer . parseInt ( kid )); children . add ( child ); q . offer ( child ); } parent . children = children ; } return root ; } }","title":"428. Serialize and Deserialize N-ary Tree \ud83d\udd12"},{"location":"problems/0429/","text":"429. N-ary Tree Level Order Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> levelOrder ( Node * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < Node *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); for ( Node * child : root -> children ) q . push ( child ); } ans . push_back ( currLevel ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < List < Integer >> levelOrder ( Node root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < Node > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); for ( Node child : root . children ) q . offer ( child ); } ans . add ( currLevel ); } return ans ; } }","title":"429. N-ary Tree Level Order Traversal"},{"location":"problems/0429/#429-n-ary-tree-level-order-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> levelOrder ( Node * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < Node *> q {{ root }}; while ( ! q . empty ()) { vector < int > currLevel ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); currLevel . push_back ( root -> val ); for ( Node * child : root -> children ) q . push ( child ); } ans . push_back ( currLevel ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < List < Integer >> levelOrder ( Node root ) { if ( root == null ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); Queue < Node > q = new LinkedList <> (); q . offer ( root ); while ( ! q . isEmpty ()) { List < Integer > currLevel = new ArrayList <> (); for ( int i = q . size (); i > 0 ; -- i ) { root = q . poll (); currLevel . add ( root . val ); for ( Node child : root . children ) q . offer ( child ); } ans . add ( currLevel ); } return ans ; } }","title":"429. N-ary Tree Level Order Traversal"},{"location":"problems/0430/","text":"430. Flatten a Multilevel Doubly Linked List Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * cachedNext = curr -> next ; curr -> next = curr -> child ; curr -> child -> prev = curr ; curr -> child = nullptr ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = cachedNext ; if ( cachedNext ) cachedNext -> prev = tail ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public Node flatten ( Node head ) { for ( Node curr = head ; curr != null ; curr = curr . next ) if ( curr . child != null ) { Node cachedNext = curr . next ; curr . next = curr . child ; curr . child . prev = curr ; curr . child = null ; Node tail = curr . next ; while ( tail . next != null ) tail = tail . next ; tail . next = cachedNext ; if ( cachedNext != null ) cachedNext . prev = tail ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def flatten ( self , head : 'Node' ) -> 'Node' : curr = head while curr : if curr . child : cachedNext = curr . next curr . next = curr . child curr . child . prev = curr curr . child = None tail = curr . next while tail . next : tail = tail . next tail . next = cachedNext if cachedNext : cachedNext . prev = tail curr = curr . next return head","title":"430. Flatten a Multilevel Doubly Linked List"},{"location":"problems/0430/#430-flatten-a-multilevel-doubly-linked-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * cachedNext = curr -> next ; curr -> next = curr -> child ; curr -> child -> prev = curr ; curr -> child = nullptr ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = cachedNext ; if ( cachedNext ) cachedNext -> prev = tail ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public Node flatten ( Node head ) { for ( Node curr = head ; curr != null ; curr = curr . next ) if ( curr . child != null ) { Node cachedNext = curr . next ; curr . next = curr . child ; curr . child . prev = curr ; curr . child = null ; Node tail = curr . next ; while ( tail . next != null ) tail = tail . next ; tail . next = cachedNext ; if ( cachedNext != null ) cachedNext . prev = tail ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def flatten ( self , head : 'Node' ) -> 'Node' : curr = head while curr : if curr . child : cachedNext = curr . next curr . next = curr . child curr . child . prev = curr curr . child = None tail = curr . next while tail . next : tail = tail . next tail . next = cachedNext if cachedNext : cachedNext . prev = tail curr = curr . next return head","title":"430. Flatten a Multilevel Doubly Linked List"},{"location":"problems/0431/","text":"431. Encode N-ary Tree to Binary Tree \ud83d\udd12","title":"431. Encode N-ary Tree to Binary Tree"},{"location":"problems/0431/#431-encode-n-ary-tree-to-binary-tree","text":"","title":"431. Encode N-ary Tree to Binary Tree \ud83d\udd12"},{"location":"problems/0432/","text":"432. All O`one Data Structure Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class AllOne { public : void inc ( string key ) { const auto it = keyToIterator . find ( key ); // doesn't find the key if ( it == cend ( keyToIterator )) { if ( l . empty () || l . front (). value > 1 ) l . push_front ({ 1 , { key }}); else l . front (). keys . insert ( key ); keyToIterator [ key ] = begin ( l ); return ; } const auto lit = it -> second ; // list iterator auto nit = next ( lit ); // next iterator if ( nit == end ( l ) || nit -> value > lit -> value + 1 ) nit = l . insert ( nit , { lit -> value + 1 , { key }}); else // nit->value == lit->value + 1 nit -> keys . insert ( key ); keyToIterator [ key ] = nit ; // reset the mapping // remove the key in keys set lit -> keys . erase ( key ); if ( lit -> keys . empty ()) l . erase ( lit ); } void dec ( string key ) { const auto it = keyToIterator . find ( key ); // doens't find the key if ( it == cend ( keyToIterator )) return ; const auto lit = it -> second ; // list iterator if ( lit -> value == 1 ) { // no need to find prev iterator in this case keyToIterator . erase ( key ); } else { auto pit = prev ( lit ); // prev iterator if ( lit == begin ( l ) || pit -> value < lit -> value - 1 ) pit = l . insert ( lit , { lit -> value - 1 , { key }}); else // pit->value == lit-value - 1 pit -> keys . insert ( key ); keyToIterator [ key ] = pit ; // reset the mapping } // remove the key in keys set lit -> keys . erase ( key ); if ( lit -> keys . empty ()) l . erase ( lit ); } string getMaxKey () { return l . empty () ? \"\" : * cbegin ( l . back (). keys ); } string getMinKey () { return l . empty () ? \"\" : * cbegin ( l . front (). keys ); } private : struct Node { int value ; unordered_set < string > keys ; }; list < Node > l ; unordered_map < string , list < Node >:: iterator > keyToIterator ; };","title":"432. All O`one Data Structure"},{"location":"problems/0432/#432-all-oone-data-structure","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class AllOne { public : void inc ( string key ) { const auto it = keyToIterator . find ( key ); // doesn't find the key if ( it == cend ( keyToIterator )) { if ( l . empty () || l . front (). value > 1 ) l . push_front ({ 1 , { key }}); else l . front (). keys . insert ( key ); keyToIterator [ key ] = begin ( l ); return ; } const auto lit = it -> second ; // list iterator auto nit = next ( lit ); // next iterator if ( nit == end ( l ) || nit -> value > lit -> value + 1 ) nit = l . insert ( nit , { lit -> value + 1 , { key }}); else // nit->value == lit->value + 1 nit -> keys . insert ( key ); keyToIterator [ key ] = nit ; // reset the mapping // remove the key in keys set lit -> keys . erase ( key ); if ( lit -> keys . empty ()) l . erase ( lit ); } void dec ( string key ) { const auto it = keyToIterator . find ( key ); // doens't find the key if ( it == cend ( keyToIterator )) return ; const auto lit = it -> second ; // list iterator if ( lit -> value == 1 ) { // no need to find prev iterator in this case keyToIterator . erase ( key ); } else { auto pit = prev ( lit ); // prev iterator if ( lit == begin ( l ) || pit -> value < lit -> value - 1 ) pit = l . insert ( lit , { lit -> value - 1 , { key }}); else // pit->value == lit-value - 1 pit -> keys . insert ( key ); keyToIterator [ key ] = pit ; // reset the mapping } // remove the key in keys set lit -> keys . erase ( key ); if ( lit -> keys . empty ()) l . erase ( lit ); } string getMaxKey () { return l . empty () ? \"\" : * cbegin ( l . back (). keys ); } string getMinKey () { return l . empty () ? \"\" : * cbegin ( l . front (). keys ); } private : struct Node { int value ; unordered_set < string > keys ; }; list < Node > l ; unordered_map < string , list < Node >:: iterator > keyToIterator ; };","title":"432. All O`one Data Structure"},{"location":"problems/0433/","text":"433. Minimum Genetic Mutation Time: $O(n4^l)$, where n = len(bank) and l = len(word) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int minMutation ( string start , string end , vector < string >& bank ) { unordered_set < string > bankSet { bank . begin (), bank . end ()}; if ( ! bankSet . count ( end )) return -1 ; int ans = 0 ; queue < string > q {{ start }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { string word = q . front (); q . pop (); for ( int j = 0 ; j < word . length (); ++ j ) { const char cache = word [ j ]; for ( const char c : { 'A' , 'C' , 'G' , 'T' }) { word [ j ] = c ; if ( word == end ) return ans ; if ( bankSet . count ( word )) { bankSet . erase ( word ); q . push ( word ); } } word [ j ] = cache ; } } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int minMutation ( String start , String end , String [] bank ) { Set < String > bankSet = new HashSet <> ( Arrays . asList ( bank )); if ( ! bankSet . contains ( end )) return - 1 ; int ans = 0 ; Queue < String > q = new LinkedList <> (); q . offer ( start ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { StringBuilder sb = new StringBuilder ( q . poll ()); for ( int j = 0 ; j < sb . length (); ++ j ) { final char cache = sb . charAt ( j ); for ( final char c : new char [] { 'A' , 'C' , 'G' , 'T' }) { sb . setCharAt ( j , c ); final String word = sb . toString (); if ( word . equals ( end )) return ans ; if ( bankSet . contains ( word )) { bankSet . remove ( word ); q . offer ( word ); } } sb . setCharAt ( j , cache ); } } } return - 1 ; } }","title":"433. Minimum Genetic Mutation"},{"location":"problems/0433/#433-minimum-genetic-mutation","text":"Time: $O(n4^l)$, where n = len(bank) and l = len(word) Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int minMutation ( string start , string end , vector < string >& bank ) { unordered_set < string > bankSet { bank . begin (), bank . end ()}; if ( ! bankSet . count ( end )) return -1 ; int ans = 0 ; queue < string > q {{ start }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { string word = q . front (); q . pop (); for ( int j = 0 ; j < word . length (); ++ j ) { const char cache = word [ j ]; for ( const char c : { 'A' , 'C' , 'G' , 'T' }) { word [ j ] = c ; if ( word == end ) return ans ; if ( bankSet . count ( word )) { bankSet . erase ( word ); q . push ( word ); } } word [ j ] = cache ; } } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public int minMutation ( String start , String end , String [] bank ) { Set < String > bankSet = new HashSet <> ( Arrays . asList ( bank )); if ( ! bankSet . contains ( end )) return - 1 ; int ans = 0 ; Queue < String > q = new LinkedList <> (); q . offer ( start ); while ( ! q . isEmpty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { StringBuilder sb = new StringBuilder ( q . poll ()); for ( int j = 0 ; j < sb . length (); ++ j ) { final char cache = sb . charAt ( j ); for ( final char c : new char [] { 'A' , 'C' , 'G' , 'T' }) { sb . setCharAt ( j , c ); final String word = sb . toString (); if ( word . equals ( end )) return ans ; if ( bankSet . contains ( word )) { bankSet . remove ( word ); q . offer ( word ); } } sb . setCharAt ( j , cache ); } } } return - 1 ; } }","title":"433. Minimum Genetic Mutation"},{"location":"problems/0434/","text":"434. Number of Segments in a String Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int countSegments ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] != ' ' && ( i == 0 || s [ i - 1 ] == ' ' )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int countSegments ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s . charAt ( i ) != ' ' && ( i == 0 || s . charAt ( i - 1 ) == ' ' )) ++ ans ; return ans ; } } Python 1 2 3 class Solution : def countSegments ( self , s : str ) -> int : return len ( s . split ())","title":"434. Number of Segments in a String"},{"location":"problems/0434/#434-number-of-segments-in-a-string","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int countSegments ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] != ' ' && ( i == 0 || s [ i - 1 ] == ' ' )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int countSegments ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s . charAt ( i ) != ' ' && ( i == 0 || s . charAt ( i - 1 ) == ' ' )) ++ ans ; return ans ; } } Python 1 2 3 class Solution : def countSegments ( self , s : str ) -> int : return len ( s . split ())","title":"434. Number of Segments in a String"},{"location":"problems/0435/","text":"435. Non-overlapping Intervals Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int ans = 0 ; int currentEnd = INT_MIN ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& interval : intervals ) if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ]; else ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int eraseOverlapIntervals ( int [][] intervals ) { int ans = 0 ; int currentEnd = Integer . MIN_VALUE ; Arrays . sort ( intervals , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( final int [] interval : intervals ) if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ] ; else ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ans = 0 currentEnd = float ( '-inf' ) for interval in sorted ( intervals , key = lambda x : x [ 1 ]): if interval [ 0 ] >= currentEnd : currentEnd = interval [ 1 ] else : ans += 1 return ans","title":"435. Non-overlapping Intervals"},{"location":"problems/0435/#435-non-overlapping-intervals","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int ans = 0 ; int currentEnd = INT_MIN ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& interval : intervals ) if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ]; else ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int eraseOverlapIntervals ( int [][] intervals ) { int ans = 0 ; int currentEnd = Integer . MIN_VALUE ; Arrays . sort ( intervals , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( final int [] interval : intervals ) if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ] ; else ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ans = 0 currentEnd = float ( '-inf' ) for interval in sorted ( intervals , key = lambda x : x [ 1 ]): if interval [ 0 ] >= currentEnd : currentEnd = interval [ 1 ] else : ans += 1 return ans","title":"435. Non-overlapping Intervals"},{"location":"problems/0436/","text":"436. Find Right Interval Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > findRightInterval ( vector < vector < int >>& intervals ) { vector < int > ans ; map < int , int > startToIndex ; for ( int i = 0 ; i < intervals . size (); ++ i ) startToIndex [ intervals [ i ][ 0 ]] = i ; for ( const vector < int >& interval : intervals ) { const auto it = startToIndex . lower_bound ( interval [ 1 ]); if ( it == cend ( startToIndex )) ans . push_back ( -1 ); else ans . push_back ( it -> second ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] findRightInterval ( int [][] intervals ) { final int n = intervals . length ; int [] ans = new int [ n ] ; java . util . NavigableMap < Integer , Integer > startToIndex = new TreeMap <> (); for ( int i = 0 ; i < n ; ++ i ) startToIndex . put ( intervals [ i ][ 0 ] , i ); for ( int i = 0 ; i < n ; ++ i ) { Map . Entry < Integer , Integer > entry = startToIndex . ceilingEntry ( intervals [ i ][ 1 ] ); if ( entry == null ) ans [ i ] = - 1 ; else ans [ i ] = entry . getValue (); } return ans ; } }","title":"436. Find Right Interval"},{"location":"problems/0436/#436-find-right-interval","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > findRightInterval ( vector < vector < int >>& intervals ) { vector < int > ans ; map < int , int > startToIndex ; for ( int i = 0 ; i < intervals . size (); ++ i ) startToIndex [ intervals [ i ][ 0 ]] = i ; for ( const vector < int >& interval : intervals ) { const auto it = startToIndex . lower_bound ( interval [ 1 ]); if ( it == cend ( startToIndex )) ans . push_back ( -1 ); else ans . push_back ( it -> second ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] findRightInterval ( int [][] intervals ) { final int n = intervals . length ; int [] ans = new int [ n ] ; java . util . NavigableMap < Integer , Integer > startToIndex = new TreeMap <> (); for ( int i = 0 ; i < n ; ++ i ) startToIndex . put ( intervals [ i ][ 0 ] , i ); for ( int i = 0 ; i < n ; ++ i ) { Map . Entry < Integer , Integer > entry = startToIndex . ceilingEntry ( intervals [ i ][ 1 ] ); if ( entry == null ) ans [ i ] = - 1 ; else ans [ i ] = entry . getValue (); } return ans ; } }","title":"436. Find Right Interval"},{"location":"problems/0437/","text":"437. Path Sum III Time: $O(n\\log n) \\to O(n^2)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int pathSum ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return helper ( root , sum ) + pathSum ( root . left , sum ) + pathSum ( root . right , sum ); } private int helper ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return ( sum == root . val ? 1 : 0 ) + helper ( root . left , sum - root . val ) + helper ( root . right , sum - root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val )","title":"437. Path Sum III"},{"location":"problems/0437/#437-path-sum-iii","text":"Time: $O(n\\log n) \\to O(n^2)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int pathSum ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return helper ( root , sum ) + pathSum ( root . left , sum ) + pathSum ( root . right , sum ); } private int helper ( TreeNode root , int sum ) { if ( root == null ) return 0 ; return ( sum == root . val ? 1 : 0 ) + helper ( root . left , sum - root . val ) + helper ( root . right , sum - root . val ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val )","title":"437. Path Sum III"},{"location":"problems/0438/","text":"438. Find All Anagrams in a String Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < int > findAnagrams ( string s , string p ) { vector < int > ans ; vector < int > count ( 128 ); int required = p . length (); for ( const char c : p ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . push_back ( l ); if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > ans = new ArrayList <> (); int [] count = new int [ 128 ] ; int required = p . length (); for ( final char c : p . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . add ( l ); if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: ans = [] count = collections . Counter ( p ) required = len ( p ) for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( p ): count [ s [ r - len ( p )]] += 1 if count [ s [ r - len ( p )]] > 0 : required += 1 if required == 0 : ans . append ( r - len ( p ) + 1 ) return ans","title":"438. Find All Anagrams in a String"},{"location":"problems/0438/#438-find-all-anagrams-in-a-string","text":"Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < int > findAnagrams ( string s , string p ) { vector < int > ans ; vector < int > count ( 128 ); int required = p . length (); for ( const char c : p ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . push_back ( l ); if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > ans = new ArrayList <> (); int [] count = new int [ 128 ] ; int required = p . length (); for ( final char c : p . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . add ( l ); if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: ans = [] count = collections . Counter ( p ) required = len ( p ) for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( p ): count [ s [ r - len ( p )]] += 1 if count [ s [ r - len ( p )]] > 0 : required += 1 if required == 0 : ans . append ( r - len ( p ) + 1 ) return ans","title":"438. Find All Anagrams in a String"},{"location":"problems/0439/","text":"439. Ternary Expression Parser \ud83d\udd12","title":"439. Ternary Expression Parser"},{"location":"problems/0439/#439-ternary-expression-parser","text":"","title":"439. Ternary Expression Parser \ud83d\udd12"},{"location":"problems/0440/","text":"440. K-th Smallest in Lexicographical Order Time: $O(\\log^2 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int findKthNumber ( long n , int k ) { auto getGap = [ & n ]( long a , long b ) { long gap = 0 ; while ( a <= n ) { gap += min ( n + 1 , b ) - a ; a *= 10 ; b *= 10 ; } return gap ; }; long currNum = 1 ; for ( int i = 1 ; i < k ;) { long gap = getGap ( currNum , currNum + 1 ); if ( i + gap <= k ) { i += gap ; ++ currNum ; } else { ++ i ; currNum *= 10 ; } } return currNum ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int findKthNumber ( int n , int k ) { long currNum = 1 ; for ( int i = 1 ; i < k ;) { long gap = getGap ( currNum , currNum + 1 , n ); if ( i + gap <= k ) { i += gap ; ++ currNum ; } else { ++ i ; currNum *= 10 ; } } return ( int ) currNum ; } private long getGap ( long a , long b , long n ) { long gap = 0 ; while ( a <= n ) { gap += Math . min ( n + 1 , b ) - a ; a *= 10 ; b *= 10 ; } return gap ; } }","title":"440. K-th Smallest in Lexicographical Order"},{"location":"problems/0440/#440-k-th-smallest-in-lexicographical-order","text":"Time: $O(\\log^2 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int findKthNumber ( long n , int k ) { auto getGap = [ & n ]( long a , long b ) { long gap = 0 ; while ( a <= n ) { gap += min ( n + 1 , b ) - a ; a *= 10 ; b *= 10 ; } return gap ; }; long currNum = 1 ; for ( int i = 1 ; i < k ;) { long gap = getGap ( currNum , currNum + 1 ); if ( i + gap <= k ) { i += gap ; ++ currNum ; } else { ++ i ; currNum *= 10 ; } } return currNum ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int findKthNumber ( int n , int k ) { long currNum = 1 ; for ( int i = 1 ; i < k ;) { long gap = getGap ( currNum , currNum + 1 , n ); if ( i + gap <= k ) { i += gap ; ++ currNum ; } else { ++ i ; currNum *= 10 ; } } return ( int ) currNum ; } private long getGap ( long a , long b , long n ) { long gap = 0 ; while ( a <= n ) { gap += Math . min ( n + 1 , b ) - a ; a *= 10 ; b *= 10 ; } return gap ; } }","title":"440. K-th Smallest in Lexicographical Order"},{"location":"problems/0441/","text":"441. Arranging Coins Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int arrangeCoins ( long n ) { return ( -1 + sqrt ( 8 * n + 1 )) / 2 ; } }; Java 1 2 3 4 5 class Solution { public int arrangeCoins ( long n ) { return ( int ) ( - 1 + Math . sqrt ( 8 * n + 1 )) / 2 ; } } Python 1 2 3 class Solution : def arrangeCoins ( self , n : int ) -> int : return int (( - 1 + sqrt ( 8 * n + 1 )) // 2 )","title":"441. Arranging Coins"},{"location":"problems/0441/#441-arranging-coins","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int arrangeCoins ( long n ) { return ( -1 + sqrt ( 8 * n + 1 )) / 2 ; } }; Java 1 2 3 4 5 class Solution { public int arrangeCoins ( long n ) { return ( int ) ( - 1 + Math . sqrt ( 8 * n + 1 )) / 2 ; } } Python 1 2 3 class Solution : def arrangeCoins ( self , n : int ) -> int : return int (( - 1 + sqrt ( 8 * n + 1 )) // 2 )","title":"441. Arranging Coins"},{"location":"problems/0442/","text":"442. Find All Duplicates in an Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( const int num : nums ) { nums [ abs ( num ) - 1 ] *= -1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( final int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans","title":"442. Find All Duplicates in an Array"},{"location":"problems/0442/#442-find-all-duplicates-in-an-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( const int num : nums ) { nums [ abs ( num ) - 1 ] *= -1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( final int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans","title":"442. Find All Duplicates in an Array"},{"location":"problems/0443/","text":"443. String Compression Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int compress ( vector < char >& chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . size ();) { const char letter = chars [ i ]; int count = 0 ; while ( i < chars . size () && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++ ] = letter ; if ( count > 1 ) for ( const char c : to_string ( count )) chars [ ans ++ ] = c ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int compress ( char [] chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . length ;) { final char letter = chars [ i ] ; int count = 0 ; while ( i < chars . length && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++] = letter ; if ( count > 1 ) for ( final char c : String . valueOf ( count ). toCharArray ()) chars [ ans ++] = c ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def compress ( self , chars : List [ str ]) -> int : ans = 0 i = 0 while i < len ( chars ): letter = chars [ i ] count = 0 while i < len ( chars ) and chars [ i ] == letter : count += 1 i += 1 chars [ ans ] = letter ans += 1 if count > 1 : for c in str ( count ): chars [ ans ] = c ans += 1 return ans","title":"443. String Compression"},{"location":"problems/0443/#443-string-compression","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int compress ( vector < char >& chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . size ();) { const char letter = chars [ i ]; int count = 0 ; while ( i < chars . size () && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++ ] = letter ; if ( count > 1 ) for ( const char c : to_string ( count )) chars [ ans ++ ] = c ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int compress ( char [] chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . length ;) { final char letter = chars [ i ] ; int count = 0 ; while ( i < chars . length && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++] = letter ; if ( count > 1 ) for ( final char c : String . valueOf ( count ). toCharArray ()) chars [ ans ++] = c ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def compress ( self , chars : List [ str ]) -> int : ans = 0 i = 0 while i < len ( chars ): letter = chars [ i ] count = 0 while i < len ( chars ) and chars [ i ] == letter : count += 1 i += 1 chars [ ans ] = letter ans += 1 if count > 1 : for c in str ( count ): chars [ ans ] = c ans += 1 return ans","title":"443. String Compression"},{"location":"problems/0444/","text":"444. Sequence Reconstruction \ud83d\udd12","title":"444. Sequence Reconstruction"},{"location":"problems/0444/#444-sequence-reconstruction","text":"","title":"444. Sequence Reconstruction \ud83d\udd12"},{"location":"problems/0445/","text":"445. Add Two Numbers II Time: $O(m + n)$, where m = len(l1) and n = len(l2) Space: $O(m + n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = nullptr ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) carry += stack1 . top () -> val , stack1 . pop (); if ( ! stack2 . empty ()) carry += stack2 . top () -> val , stack2 . pop (); ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { Stack < ListNode > stack1 = new Stack <> (); Stack < ListNode > stack2 = new Stack <> (); while ( l1 != null ) { stack1 . push ( l1 ); l1 = l1 . next ; } while ( l2 != null ) { stack2 . push ( l2 ); l2 = l2 . next ; } ListNode head = null ; int carry = 0 ; while ( carry > 0 || ! stack1 . isEmpty () || ! stack2 . isEmpty ()) { if ( ! stack1 . isEmpty ()) carry += stack1 . pop (). val ; if ( ! stack2 . isEmpty ()) carry += stack2 . pop (). val ; ListNode node = new ListNode ( carry % 10 ); node . next = head ; head = node ; carry /= 10 ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : if stack1 : carry += stack1 . pop () . val if stack2 : carry += stack2 . pop () . val node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head","title":"445. Add Two Numbers II"},{"location":"problems/0445/#445-add-two-numbers-ii","text":"Time: $O(m + n)$, where m = len(l1) and n = len(l2) Space: $O(m + n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = nullptr ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) carry += stack1 . top () -> val , stack1 . pop (); if ( ! stack2 . empty ()) carry += stack2 . top () -> val , stack2 . pop (); ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { Stack < ListNode > stack1 = new Stack <> (); Stack < ListNode > stack2 = new Stack <> (); while ( l1 != null ) { stack1 . push ( l1 ); l1 = l1 . next ; } while ( l2 != null ) { stack2 . push ( l2 ); l2 = l2 . next ; } ListNode head = null ; int carry = 0 ; while ( carry > 0 || ! stack1 . isEmpty () || ! stack2 . isEmpty ()) { if ( ! stack1 . isEmpty ()) carry += stack1 . pop (). val ; if ( ! stack2 . isEmpty ()) carry += stack2 . pop (). val ; ListNode node = new ListNode ( carry % 10 ); node . next = head ; head = node ; carry /= 10 ; } return head ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : if stack1 : carry += stack1 . pop () . val if stack2 : carry += stack2 . pop () . val node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head","title":"445. Add Two Numbers II"},{"location":"problems/0446/","text":"446. Arithmetic Slices II - Subsequence Time: $O(n^2)$, where n = len(A) Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; // dp[i][j] := # of subsequences end w/ A[j] A[i] vector < vector < int >> dp ( n , vector < int > ( n )); unordered_map < long , vector < int >> numToIndices ; for ( int i = 0 ; i < n ; ++ i ) numToIndices [ A [ i ]]. push_back ( i ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const long target = ( long ) A [ j ] * 2 - A [ i ]; if ( numToIndices . count ( target )) for ( const int k : numToIndices [ target ]) if ( k < j ) dp [ i ][ j ] += ( dp [ j ][ k ] + 1 ); ans += dp [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int numberOfArithmeticSlices ( int [] A ) { final int n = A . length ; int ans = 0 ; // dp[i][j] := # of subsequences end w/ A[j] A[i] int [][] dp = new int [ n ][ n ] ; Map < Long , List < Integer >> numToIndices = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) { numToIndices . putIfAbsent (( long ) A [ i ] , new ArrayList <> ()); numToIndices . get (( long ) A [ i ] ). add ( i ); } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final long target = ( long ) A [ j ] * 2 - A [ i ] ; if ( numToIndices . containsKey ( target )) for ( final int k : numToIndices . get ( target )) if ( k < j ) dp [ i ][ j ] += ( dp [ j ][ k ] + 1 ); ans += dp [ i ][ j ] ; } return ans ; } }","title":"446. Arithmetic Slices II - Subsequence"},{"location":"problems/0446/#446-arithmetic-slices-ii-subsequence","text":"Time: $O(n^2)$, where n = len(A) Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; // dp[i][j] := # of subsequences end w/ A[j] A[i] vector < vector < int >> dp ( n , vector < int > ( n )); unordered_map < long , vector < int >> numToIndices ; for ( int i = 0 ; i < n ; ++ i ) numToIndices [ A [ i ]]. push_back ( i ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const long target = ( long ) A [ j ] * 2 - A [ i ]; if ( numToIndices . count ( target )) for ( const int k : numToIndices [ target ]) if ( k < j ) dp [ i ][ j ] += ( dp [ j ][ k ] + 1 ); ans += dp [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int numberOfArithmeticSlices ( int [] A ) { final int n = A . length ; int ans = 0 ; // dp[i][j] := # of subsequences end w/ A[j] A[i] int [][] dp = new int [ n ][ n ] ; Map < Long , List < Integer >> numToIndices = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) { numToIndices . putIfAbsent (( long ) A [ i ] , new ArrayList <> ()); numToIndices . get (( long ) A [ i ] ). add ( i ); } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final long target = ( long ) A [ j ] * 2 - A [ i ] ; if ( numToIndices . containsKey ( target )) for ( final int k : numToIndices . get ( target )) if ( k < j ) dp [ i ][ j ] += ( dp [ j ][ k ] + 1 ); ans += dp [ i ][ j ] ; } return ans ; } }","title":"446. Arithmetic Slices II - Subsequence"},{"location":"problems/0447/","text":"447. Number of Boomerangs Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numberOfBoomerangs ( vector < vector < int >>& points ) { int ans = 0 ; for ( const vector < int >& p : points ) { unordered_map < int , int > distCount ; for ( const vector < int >& q : points ) { const int dist = getDist ( p , q ); ++ distCount [ dist ]; } for ( const auto & [ _ , freq ] : distCount ) ans += freq * ( freq - 1 ); // C(freq, 2) } return ans ; } private : int getDist ( const vector < int >& p , const vector < int >& q ) { return pow ( p [ 0 ] - q [ 0 ], 2 ) + pow ( p [ 1 ] - q [ 1 ], 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numberOfBoomerangs ( int [][] points ) { int ans = 0 ; for ( final int [] p : points ) { Map < Integer , Integer > distCount = new HashMap <> (); for ( final int [] q : points ) { final int dist = ( int ) getDist ( p , q ); distCount . put ( dist , distCount . getOrDefault ( dist , 0 ) + 1 ); } for ( final int freq : distCount . values ()) ans += freq * ( freq - 1 ); // C(freq, 2) } return ans ; } private double getDist ( final int [] p , final int [] q ) { return Math . pow ( p [ 0 ] - q [ 0 ] , 2 ) + Math . pow ( p [ 1 ] - q [ 1 ] , 2 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numberOfBoomerangs ( self , points : List [ List [ int ]]) -> int : ans = 0 for x1 , y1 in points : count = collections . defaultdict ( int ) for x2 , y2 in points : ans += 2 * count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] += 1 return ans","title":"447. Number of Boomerangs"},{"location":"problems/0447/#447-number-of-boomerangs","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numberOfBoomerangs ( vector < vector < int >>& points ) { int ans = 0 ; for ( const vector < int >& p : points ) { unordered_map < int , int > distCount ; for ( const vector < int >& q : points ) { const int dist = getDist ( p , q ); ++ distCount [ dist ]; } for ( const auto & [ _ , freq ] : distCount ) ans += freq * ( freq - 1 ); // C(freq, 2) } return ans ; } private : int getDist ( const vector < int >& p , const vector < int >& q ) { return pow ( p [ 0 ] - q [ 0 ], 2 ) + pow ( p [ 1 ] - q [ 1 ], 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numberOfBoomerangs ( int [][] points ) { int ans = 0 ; for ( final int [] p : points ) { Map < Integer , Integer > distCount = new HashMap <> (); for ( final int [] q : points ) { final int dist = ( int ) getDist ( p , q ); distCount . put ( dist , distCount . getOrDefault ( dist , 0 ) + 1 ); } for ( final int freq : distCount . values ()) ans += freq * ( freq - 1 ); // C(freq, 2) } return ans ; } private double getDist ( final int [] p , final int [] q ) { return Math . pow ( p [ 0 ] - q [ 0 ] , 2 ) + Math . pow ( p [ 1 ] - q [ 1 ] , 2 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numberOfBoomerangs ( self , points : List [ List [ int ]]) -> int : ans = 0 for x1 , y1 in points : count = collections . defaultdict ( int ) for x2 , y2 in points : ans += 2 * count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] += 1 return ans","title":"447. Number of Boomerangs"},{"location":"problems/0448/","text":"448. Find All Numbers Disappeared in an Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( const int num : nums ) { const int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( final int num : nums ) { final int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ] ); } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } } Python 1 2 3 4 5 6 7 class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ]","title":"448. Find All Numbers Disappeared in an Array"},{"location":"problems/0448/#448-find-all-numbers-disappeared-in-an-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( const int num : nums ) { const int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( final int num : nums ) { final int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ] ); } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } } Python 1 2 3 4 5 6 7 class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ]","title":"448. Find All Numbers Disappeared in an Array"},{"location":"problems/0449/","text":"449. Serialize and Deserialize BST Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Codec { public : string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s ; serialize ( root , s ); return s ; } TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); queue < int > q ; for ( string s ; iss >> s ;) q . push ( stoi ( s )); return deserialize ( INT_MIN , INT_MAX , q ); } private : void serialize ( TreeNode * root , string & s ) { if ( ! root ) return ; s += to_string ( root -> val ) + \" \" ; serialize ( root -> left , s ); serialize ( root -> right , s ); } TreeNode * deserialize ( int min , int max , queue < int >& q ) { if ( q . empty ()) return nullptr ; const int val = q . front (); if ( val < min || val > max ) return nullptr ; q . pop (); TreeNode * root = new TreeNode ( val ); root -> left = deserialize ( min , val , q ); root -> right = deserialize ( val , max , q ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); serialize ( root , sb ); return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { if ( data . isEmpty ()) return null ; final String [] vals = data . split ( \" \" ); Queue < Integer > q = new LinkedList <> (); for ( final String val : vals ) q . offer ( Integer . parseInt ( val )); return deserialize ( Integer . MIN_VALUE , Integer . MAX_VALUE , q ); } private void serialize ( TreeNode root , StringBuilder sb ) { if ( root == null ) return ; sb . append ( root . val ). append ( \" \" ); serialize ( root . left , sb ); serialize ( root . right , sb ); } private TreeNode deserialize ( int min , int max , Queue < Integer > q ) { if ( q . isEmpty ()) return null ; final int val = q . peek (); if ( val < min || val > max ) return null ; q . poll (); TreeNode root = new TreeNode ( val ); root . left = deserialize ( min , val , q ); root . right = deserialize ( val , max , q ); return root ; } }","title":"449. Serialize and Deserialize BST"},{"location":"problems/0449/#449-serialize-and-deserialize-bst","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Codec { public : string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string s ; serialize ( root , s ); return s ; } TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); queue < int > q ; for ( string s ; iss >> s ;) q . push ( stoi ( s )); return deserialize ( INT_MIN , INT_MAX , q ); } private : void serialize ( TreeNode * root , string & s ) { if ( ! root ) return ; s += to_string ( root -> val ) + \" \" ; serialize ( root -> left , s ); serialize ( root -> right , s ); } TreeNode * deserialize ( int min , int max , queue < int >& q ) { if ( q . empty ()) return nullptr ; const int val = q . front (); if ( val < min || val > max ) return nullptr ; q . pop (); TreeNode * root = new TreeNode ( val ); root -> left = deserialize ( min , val , q ); root -> right = deserialize ( val , max , q ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class Codec { // Encodes a tree to a single string. public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder sb = new StringBuilder (); serialize ( root , sb ); return sb . toString (); } // Decodes your encoded data to tree. public TreeNode deserialize ( String data ) { if ( data . isEmpty ()) return null ; final String [] vals = data . split ( \" \" ); Queue < Integer > q = new LinkedList <> (); for ( final String val : vals ) q . offer ( Integer . parseInt ( val )); return deserialize ( Integer . MIN_VALUE , Integer . MAX_VALUE , q ); } private void serialize ( TreeNode root , StringBuilder sb ) { if ( root == null ) return ; sb . append ( root . val ). append ( \" \" ); serialize ( root . left , sb ); serialize ( root . right , sb ); } private TreeNode deserialize ( int min , int max , Queue < Integer > q ) { if ( q . isEmpty ()) return null ; final int val = q . peek (); if ( val < min || val > max ) return null ; q . poll (); TreeNode root = new TreeNode ( val ); root . left = deserialize ( min , val , q ); root . right = deserialize ( val , max , q ); return root ; } }","title":"449. Serialize and Deserialize BST"},{"location":"problems/0450/","text":"450. Delete Node in a BST Time: $O(h) = O(\\log n)$ Space: $O(h) = O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : TreeNode * deleteNode ( TreeNode * root , int key ) { if ( ! root ) return nullptr ; if ( root -> val > key ) root -> left = deleteNode ( root -> left , key ); else if ( root -> val < key ) root -> right = deleteNode ( root -> right , key ); else { // root->val == key if ( ! root -> left ) return root -> right ; if ( ! root -> right ) return root -> left ; TreeNode * cache = root ; root = getMin ( root -> right ); root -> right = deleteMin ( cache -> right ); root -> left = cache -> left ; delete cache ; } return root ; } private : TreeNode * getMin ( TreeNode * root ) { if ( ! root -> left ) return root ; return getMin ( root -> left ); } TreeNode * deleteMin ( TreeNode * root ) { if ( ! root -> left ) return root -> right ; root -> left = deleteMin ( root -> left ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public TreeNode deleteNode ( TreeNode root , int key ) { if ( root == null ) return null ; if ( root . val > key ) root . left = deleteNode ( root . left , key ); else if ( root . val < key ) root . right = deleteNode ( root . right , key ); else { // root.val == key if ( root . left == null ) return root . right ; if ( root . right == null ) return root . left ; TreeNode cache = root ; // update root to be the minimum value of root's right subtree root = getMin ( root . right ); root . right = deleteMin ( cache . right ); root . left = cache . left ; } return root ; } private TreeNode getMin ( TreeNode root ) { if ( root . left == null ) return root ; return getMin ( root . left ); } private TreeNode deleteMin ( TreeNode root ) { if ( root . left == null ) // delete root itself return root . right ; root . left = deleteMin ( root . left ); return root ; } }","title":"450. Delete Node in a BST"},{"location":"problems/0450/#450-delete-node-in-a-bst","text":"Time: $O(h) = O(\\log n)$ Space: $O(h) = O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : TreeNode * deleteNode ( TreeNode * root , int key ) { if ( ! root ) return nullptr ; if ( root -> val > key ) root -> left = deleteNode ( root -> left , key ); else if ( root -> val < key ) root -> right = deleteNode ( root -> right , key ); else { // root->val == key if ( ! root -> left ) return root -> right ; if ( ! root -> right ) return root -> left ; TreeNode * cache = root ; root = getMin ( root -> right ); root -> right = deleteMin ( cache -> right ); root -> left = cache -> left ; delete cache ; } return root ; } private : TreeNode * getMin ( TreeNode * root ) { if ( ! root -> left ) return root ; return getMin ( root -> left ); } TreeNode * deleteMin ( TreeNode * root ) { if ( ! root -> left ) return root -> right ; root -> left = deleteMin ( root -> left ); return root ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public TreeNode deleteNode ( TreeNode root , int key ) { if ( root == null ) return null ; if ( root . val > key ) root . left = deleteNode ( root . left , key ); else if ( root . val < key ) root . right = deleteNode ( root . right , key ); else { // root.val == key if ( root . left == null ) return root . right ; if ( root . right == null ) return root . left ; TreeNode cache = root ; // update root to be the minimum value of root's right subtree root = getMin ( root . right ); root . right = deleteMin ( cache . right ); root . left = cache . left ; } return root ; } private TreeNode getMin ( TreeNode root ) { if ( root . left == null ) return root ; return getMin ( root . left ); } private TreeNode deleteMin ( TreeNode root ) { if ( root . left == null ) // delete root itself return root . right ; root . left = deleteMin ( root . left ); return root ; } }","title":"450. Delete Node in a BST"},{"location":"problems/0451/","text":"451. Sort Characters By Frequency Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string frequencySort ( string s ) { const int n = s . length (); string ans ; vector < int > count ( 128 ); // bucket[i] := stores chars that appear i times in s vector < vector < char >> bucket ( n + 1 ); for ( const char c : s ) ++ count [ c ]; for ( int i = 0 ; i < 128 ; ++ i ) { const int freq = count [ i ]; if ( freq > 0 ) bucket [ freq ]. push_back (( char ) i ); } for ( int freq = n ; freq > 0 ; -- freq ) for ( const char c : bucket [ freq ]) ans += string ( freq , c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String frequencySort ( String s ) { final int n = s . length (); StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; // bucket[i] := stores chars that appear i times in s List < Character >[] bucket = new List [ n + 1 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < 128 ; ++ i ) { final int freq = count [ i ] ; if ( freq > 0 ) { if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add (( char ) i ); } } for ( int freq = n ; freq > 0 ; -- freq ) if ( bucket [ freq ] != null ) for ( final char c : bucket [ freq ] ) for ( int i = 0 ; i < freq ; ++ i ) sb . append ( c ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def frequencySort ( self , s : str ) -> str : ans = \"\" bucket = [[] for _ in range ( len ( s ) + 1 )] for c , freq in collections . Counter ( s ) . items (): bucket [ freq ] . append ( c ) for freq in range ( len ( bucket ))[:: - 1 ]: for c in bucket [ freq ]: ans += c * freq return ans","title":"451. Sort Characters By Frequency"},{"location":"problems/0451/#451-sort-characters-by-frequency","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string frequencySort ( string s ) { const int n = s . length (); string ans ; vector < int > count ( 128 ); // bucket[i] := stores chars that appear i times in s vector < vector < char >> bucket ( n + 1 ); for ( const char c : s ) ++ count [ c ]; for ( int i = 0 ; i < 128 ; ++ i ) { const int freq = count [ i ]; if ( freq > 0 ) bucket [ freq ]. push_back (( char ) i ); } for ( int freq = n ; freq > 0 ; -- freq ) for ( const char c : bucket [ freq ]) ans += string ( freq , c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String frequencySort ( String s ) { final int n = s . length (); StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; // bucket[i] := stores chars that appear i times in s List < Character >[] bucket = new List [ n + 1 ] ; for ( final char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < 128 ; ++ i ) { final int freq = count [ i ] ; if ( freq > 0 ) { if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add (( char ) i ); } } for ( int freq = n ; freq > 0 ; -- freq ) if ( bucket [ freq ] != null ) for ( final char c : bucket [ freq ] ) for ( int i = 0 ; i < freq ; ++ i ) sb . append ( c ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def frequencySort ( self , s : str ) -> str : ans = \"\" bucket = [[] for _ in range ( len ( s ) + 1 )] for c , freq in collections . Counter ( s ) . items (): bucket [ freq ] . append ( c ) for freq in range ( len ( bucket ))[:: - 1 ]: for c in bucket [ freq ]: ans += c * freq return ans","title":"451. Sort Characters By Frequency"},{"location":"problems/0452/","text":"452. Minimum Number of Arrows to Burst Balloons Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findMinArrowShots ( vector < vector < int >>& points ) { if ( points . empty ()) return 0 ; sort ( begin ( points ), end ( points ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); int ans = 1 ; int arrowX = points [ 0 ][ 1 ]; for ( int i = 1 ; i < points . size (); ++ i ) if ( points [ i ][ 0 ] > arrowX ) { arrowX = points [ i ][ 1 ]; ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findMinArrowShots ( int [][] points ) { if ( points . length == 0 ) return 0 ; Arrays . sort ( points , ( a , b ) -> a [ 1 ] - b [ 1 ] ); int ans = 1 ; int arrowX = points [ 0 ][ 1 ] ; for ( int i = 1 ; i < points . length ; ++ i ) if ( points [ i ][ 0 ] > arrowX ) { arrowX = points [ i ][ 1 ] ; ++ ans ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ans = 0 arrowX = float ( '-inf' ) for point in sorted ( points , key = lambda x : x [ 1 ]): if point [ 0 ] > arrowX : ans += 1 arrowX = point [ 1 ] return ans","title":"452. Minimum Number of Arrows to Burst Balloons"},{"location":"problems/0452/#452-minimum-number-of-arrows-to-burst-balloons","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findMinArrowShots ( vector < vector < int >>& points ) { if ( points . empty ()) return 0 ; sort ( begin ( points ), end ( points ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); int ans = 1 ; int arrowX = points [ 0 ][ 1 ]; for ( int i = 1 ; i < points . size (); ++ i ) if ( points [ i ][ 0 ] > arrowX ) { arrowX = points [ i ][ 1 ]; ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findMinArrowShots ( int [][] points ) { if ( points . length == 0 ) return 0 ; Arrays . sort ( points , ( a , b ) -> a [ 1 ] - b [ 1 ] ); int ans = 1 ; int arrowX = points [ 0 ][ 1 ] ; for ( int i = 1 ; i < points . length ; ++ i ) if ( points [ i ][ 0 ] > arrowX ) { arrowX = points [ i ][ 1 ] ; ++ ans ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ans = 0 arrowX = float ( '-inf' ) for point in sorted ( points , key = lambda x : x [ 1 ]): if point [ 0 ] > arrowX : ans += 1 arrowX = point [ 1 ] return ans","title":"452. Minimum Number of Arrows to Burst Balloons"},{"location":"problems/0453/","text":"453. Minimum Moves to Equal Array Elements Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int minMoves ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + ( b - min ); }); } }; Java 1 2 3 4 5 6 7 class Solution { public int minMoves ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); final int min = Arrays . stream ( nums ). min (). getAsInt (); return sum - min * nums . length ; } } Python 1 2 3 4 5 class Solution : def minMoves ( self , nums : List [ int ]) -> int : mini = min ( nums ) return sum ( num - mini for num in nums )","title":"453. Minimum Moves to Equal Array Elements"},{"location":"problems/0453/#453-minimum-moves-to-equal-array-elements","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int minMoves ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + ( b - min ); }); } }; Java 1 2 3 4 5 6 7 class Solution { public int minMoves ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); final int min = Arrays . stream ( nums ). min (). getAsInt (); return sum - min * nums . length ; } } Python 1 2 3 4 5 class Solution : def minMoves ( self , nums : List [ int ]) -> int : mini = min ( nums ) return sum ( num - mini for num in nums )","title":"453. Minimum Moves to Equal Array Elements"},{"location":"problems/0454/","text":"454. 4Sum II Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int a : A ) for ( const int b : B ) ++ count [ a + b ]; for ( const int c : C ) for ( const int d : D ) if ( count . count ( - c - d )) ans += count [ - c - d ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int fourSumCount ( int [] A , int [] B , int [] C , int [] D ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( final int a : A ) for ( final int b : B ) count . put ( a + b , count . getOrDefault ( a + b , 0 ) + 1 ); for ( final int c : C ) for ( final int d : D ) if ( count . containsKey ( - c - d )) ans += count . get ( - c - d ); return ans ; } } Python 1 2 3 4 5 class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : count = collections . Counter ( a + b for a in A for b in B ) return sum ( count [ - c - d ] for c in C for d in D )","title":"454. 4Sum II"},{"location":"problems/0454/#454-4sum-ii","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int a : A ) for ( const int b : B ) ++ count [ a + b ]; for ( const int c : C ) for ( const int d : D ) if ( count . count ( - c - d )) ans += count [ - c - d ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int fourSumCount ( int [] A , int [] B , int [] C , int [] D ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( final int a : A ) for ( final int b : B ) count . put ( a + b , count . getOrDefault ( a + b , 0 ) + 1 ); for ( final int c : C ) for ( final int d : D ) if ( count . containsKey ( - c - d )) ans += count . get ( - c - d ); return ans ; } } Python 1 2 3 4 5 class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : count = collections . Counter ( a + b for a in A for b in B ) return sum ( count [ - c - d ] for c in C for d in D )","title":"454. 4Sum II"},{"location":"problems/0455/","text":"455. Assign Cookies Time: $O(\\max(n\\log n, m\\log m))$, where n = len(g) and m = len(s) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findContentChildren ( vector < int >& g , vector < int >& s ) { sort ( begin ( g ), end ( g )); sort ( begin ( s ), end ( s )); int i = 0 ; for ( int j = 0 ; j < s . size () && i < g . size (); ++ j ) if ( g [ i ] <= s [ j ]) ++ i ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findContentChildren ( int [] g , int [] s ) { Arrays . sort ( g ); Arrays . sort ( s ); int i = 0 ; for ( int j = 0 ; i < g . length && j < s . length ; ++ j ) if ( g [ i ] <= s [ j ] ) ++ i ; return i ; } }","title":"455. Assign Cookies"},{"location":"problems/0455/#455-assign-cookies","text":"Time: $O(\\max(n\\log n, m\\log m))$, where n = len(g) and m = len(s) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findContentChildren ( vector < int >& g , vector < int >& s ) { sort ( begin ( g ), end ( g )); sort ( begin ( s ), end ( s )); int i = 0 ; for ( int j = 0 ; j < s . size () && i < g . size (); ++ j ) if ( g [ i ] <= s [ j ]) ++ i ; return i ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findContentChildren ( int [] g , int [] s ) { Arrays . sort ( g ); Arrays . sort ( s ); int i = 0 ; for ( int j = 0 ; i < g . length && j < s . length ; ++ j ) if ( g [ i ] <= s [ j ] ) ++ i ; return i ; } }","title":"455. Assign Cookies"},{"location":"problems/0456/","text":"456. 132 Pattern Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool find132pattern ( vector < int >& nums ) { stack < int > stack ; // max stack int ak = INT_MIN ; // we want to find a seq ai < ak < aj for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { // ai < ak, we're done because ai must also smaller than aj if ( nums [ i ] < ak ) return true ; while ( ! stack . empty () && stack . top () < nums [ i ]) ak = stack . top (), stack . pop (); stack . push ( nums [ i ]); // nums[i] is a candidate of aj } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean find132pattern ( int [] nums ) { Stack < Integer > stack = new Stack <> (); // max stack int ak = Integer . MIN_VALUE ; // we want to find a seq ai < ak < aj for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { if ( nums [ i ] < ak ) // ai < ak, we're done because ai must also smaller than aj return true ; while ( ! stack . isEmpty () && stack . peek () < nums [ i ] ) ak = stack . pop (); stack . push ( nums [ i ] ); // nums[i] is a candidate of aj } return false ; } }","title":"456. 132 Pattern"},{"location":"problems/0456/#456-132-pattern","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool find132pattern ( vector < int >& nums ) { stack < int > stack ; // max stack int ak = INT_MIN ; // we want to find a seq ai < ak < aj for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { // ai < ak, we're done because ai must also smaller than aj if ( nums [ i ] < ak ) return true ; while ( ! stack . empty () && stack . top () < nums [ i ]) ak = stack . top (), stack . pop (); stack . push ( nums [ i ]); // nums[i] is a candidate of aj } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean find132pattern ( int [] nums ) { Stack < Integer > stack = new Stack <> (); // max stack int ak = Integer . MIN_VALUE ; // we want to find a seq ai < ak < aj for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { if ( nums [ i ] < ak ) // ai < ak, we're done because ai must also smaller than aj return true ; while ( ! stack . isEmpty () && stack . peek () < nums [ i ] ) ak = stack . pop (); stack . push ( nums [ i ] ); // nums[i] is a candidate of aj } return false ; } }","title":"456. 132 Pattern"},{"location":"problems/0457/","text":"457. Circular Array Loop Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False","title":"457. Circular Array Loop"},{"location":"problems/0457/#457-circular-array-loop","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; const int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { const int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; final int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { final int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False","title":"457. Circular Array Loop"},{"location":"problems/0458/","text":"458. Poor Pigs Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } }; Java 1 2 3 4 5 class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( minutesToTest / minutesToDie + 1 )); } } Python 1 2 3 class Solution : def poorPigs ( self , buckets : int , minutesToDie : int , minutesToTest : int ) -> int : return math . ceil ( math . log ( buckets ) / math . log ( minutesToTest // minutesToDie + 1 ))","title":"458. Poor Pigs"},{"location":"problems/0458/#458-poor-pigs","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } }; Java 1 2 3 4 5 class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( minutesToTest / minutesToDie + 1 )); } } Python 1 2 3 class Solution : def poorPigs ( self , buckets : int , minutesToDie : int , minutesToTest : int ) -> int : return math . ceil ( math . log ( buckets ) / math . log ( minutesToTest // minutesToDie + 1 ))","title":"458. Poor Pigs"},{"location":"problems/0459/","text":"459. Repeated Substring Pattern Time: $O(n^2)$, where n = len(s) Space: $O(n)$ C++ 1 2 3 4 5 6 7 class Solution { public : bool repeatedSubstringPattern ( string s ) { const string ss = s + s ; return ss . substr ( 1 , ss . length () - 2 ). find ( s ) != string :: npos ; } }; Java 1 2 3 4 5 6 class Solution { public boolean repeatedSubstringPattern ( String s ) { String ss = s + s ; return ss . substring ( 1 , ss . length () - 1 ). contains ( s ); } } Python 1 2 3 class Solution : def repeatedSubstringPattern ( self , s : str ) -> bool : return s in ( s + s )[ 1 : - 1 ]","title":"459. Repeated Substring Pattern"},{"location":"problems/0459/#459-repeated-substring-pattern","text":"Time: $O(n^2)$, where n = len(s) Space: $O(n)$ C++ 1 2 3 4 5 6 7 class Solution { public : bool repeatedSubstringPattern ( string s ) { const string ss = s + s ; return ss . substr ( 1 , ss . length () - 2 ). find ( s ) != string :: npos ; } }; Java 1 2 3 4 5 6 class Solution { public boolean repeatedSubstringPattern ( String s ) { String ss = s + s ; return ss . substring ( 1 , ss . length () - 1 ). contains ( s ); } } Python 1 2 3 class Solution : def repeatedSubstringPattern ( self , s : str ) -> bool : return s in ( s + s )[ 1 : - 1 ]","title":"459. Repeated Substring Pattern"},{"location":"problems/0460/","text":"460. LFU Cache Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 struct Node { int key ; int value ; int freq ; list < int >:: const_iterator it ; }; class LFUCache { public : LFUCache ( int capacity ) : capacity ( capacity ), minFreq ( 0 ) {} int get ( int key ) { if ( ! keyToNode . count ( key )) return -1 ; Node & node = keyToNode [ key ]; touch ( node ); return node . value ; } void put ( int key , int value ) { if ( capacity == 0 ) return ; if ( keyToNode . count ( key )) { Node & node = keyToNode [ key ]; node . value = value ; touch ( node ); return ; } if ( keyToNode . size () == capacity ) { // evict LRU key from the minFreq list const int keyToEvict = freqToList [ minFreq ]. back (); freqToList [ minFreq ]. pop_back (); keyToNode . erase ( keyToEvict ); } minFreq = 1 ; freqToList [ 1 ]. push_front ( key ); keyToNode [ key ] = { key , value , 1 , cbegin ( freqToList [ 1 ])}; } private : int capacity ; int minFreq ; unordered_map < int , Node > keyToNode ; unordered_map < int , list < int >> freqToList ; void touch ( Node & node ) { // update the node's frequency const int prevFreq = node . freq ; const int newFreq = ++ node . freq ; // remove the iterator from prevFreq's list freqToList [ prevFreq ]. erase ( node . it ); if ( freqToList [ prevFreq ]. empty ()) { freqToList . erase ( prevFreq ); // update minFreq if needed if ( prevFreq == minFreq ) ++ minFreq ; } // insert the key to the front of newFreq's list freqToList [ newFreq ]. push_front ( node . key ); node . it = cbegin ( freqToList [ newFreq ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class LFUCache { public LFUCache ( int capacity ) { this . capacity = capacity ; } public int get ( int key ) { if ( ! keyToVal . containsKey ( key )) return - 1 ; final int freq = keyToFreq . get ( key ); freqToLRUKeys . get ( freq ). remove ( key ); if ( freq == minFreq && freqToLRUKeys . get ( freq ). isEmpty ()) { freqToLRUKeys . remove ( freq ); ++ minFreq ; } // increase key's freq by 1 // add this key to next freq's list putFreq ( key , freq + 1 ); return keyToVal . get ( key ); } public void put ( int key , int value ) { if ( capacity == 0 ) return ; if ( keyToVal . containsKey ( key )) { keyToVal . put ( key , value ); get ( key ); // update key's count return ; } if ( keyToVal . size () == capacity ) { // evict LRU key from the minFreq list final int keyToEvict = freqToLRUKeys . get ( minFreq ). iterator (). next (); freqToLRUKeys . get ( minFreq ). remove ( keyToEvict ); keyToVal . remove ( keyToEvict ); } minFreq = 1 ; putFreq ( key , minFreq ); // add new key and freq keyToVal . put ( key , value ); // add new key and value } private int capacity ; private int minFreq = 0 ; private Map < Integer , Integer > keyToVal = new HashMap <> (); private Map < Integer , Integer > keyToFreq = new HashMap <> (); private Map < Integer , LinkedHashSet < Integer >> freqToLRUKeys = new HashMap <> (); private void putFreq ( int key , int freq ) { keyToFreq . put ( key , freq ); freqToLRUKeys . putIfAbsent ( freq , new LinkedHashSet <> ()); freqToLRUKeys . get ( freq ). add ( key ); } }","title":"460. LFU Cache"},{"location":"problems/0460/#460-lfu-cache","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 struct Node { int key ; int value ; int freq ; list < int >:: const_iterator it ; }; class LFUCache { public : LFUCache ( int capacity ) : capacity ( capacity ), minFreq ( 0 ) {} int get ( int key ) { if ( ! keyToNode . count ( key )) return -1 ; Node & node = keyToNode [ key ]; touch ( node ); return node . value ; } void put ( int key , int value ) { if ( capacity == 0 ) return ; if ( keyToNode . count ( key )) { Node & node = keyToNode [ key ]; node . value = value ; touch ( node ); return ; } if ( keyToNode . size () == capacity ) { // evict LRU key from the minFreq list const int keyToEvict = freqToList [ minFreq ]. back (); freqToList [ minFreq ]. pop_back (); keyToNode . erase ( keyToEvict ); } minFreq = 1 ; freqToList [ 1 ]. push_front ( key ); keyToNode [ key ] = { key , value , 1 , cbegin ( freqToList [ 1 ])}; } private : int capacity ; int minFreq ; unordered_map < int , Node > keyToNode ; unordered_map < int , list < int >> freqToList ; void touch ( Node & node ) { // update the node's frequency const int prevFreq = node . freq ; const int newFreq = ++ node . freq ; // remove the iterator from prevFreq's list freqToList [ prevFreq ]. erase ( node . it ); if ( freqToList [ prevFreq ]. empty ()) { freqToList . erase ( prevFreq ); // update minFreq if needed if ( prevFreq == minFreq ) ++ minFreq ; } // insert the key to the front of newFreq's list freqToList [ newFreq ]. push_front ( node . key ); node . it = cbegin ( freqToList [ newFreq ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class LFUCache { public LFUCache ( int capacity ) { this . capacity = capacity ; } public int get ( int key ) { if ( ! keyToVal . containsKey ( key )) return - 1 ; final int freq = keyToFreq . get ( key ); freqToLRUKeys . get ( freq ). remove ( key ); if ( freq == minFreq && freqToLRUKeys . get ( freq ). isEmpty ()) { freqToLRUKeys . remove ( freq ); ++ minFreq ; } // increase key's freq by 1 // add this key to next freq's list putFreq ( key , freq + 1 ); return keyToVal . get ( key ); } public void put ( int key , int value ) { if ( capacity == 0 ) return ; if ( keyToVal . containsKey ( key )) { keyToVal . put ( key , value ); get ( key ); // update key's count return ; } if ( keyToVal . size () == capacity ) { // evict LRU key from the minFreq list final int keyToEvict = freqToLRUKeys . get ( minFreq ). iterator (). next (); freqToLRUKeys . get ( minFreq ). remove ( keyToEvict ); keyToVal . remove ( keyToEvict ); } minFreq = 1 ; putFreq ( key , minFreq ); // add new key and freq keyToVal . put ( key , value ); // add new key and value } private int capacity ; private int minFreq = 0 ; private Map < Integer , Integer > keyToVal = new HashMap <> (); private Map < Integer , Integer > keyToFreq = new HashMap <> (); private Map < Integer , LinkedHashSet < Integer >> freqToLRUKeys = new HashMap <> (); private void putFreq ( int key , int freq ) { keyToFreq . put ( key , freq ); freqToLRUKeys . putIfAbsent ( freq , new LinkedHashSet <> ()); freqToLRUKeys . get ( freq ). add ( key ); } }","title":"460. LFU Cache"},{"location":"problems/0461/","text":"461. Hamming Distance Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x & 1 ) ^ ( y & 1 ); x >>= 1 ; y >>= 1 ; } return ans ; } };","title":"461. Hamming Distance"},{"location":"problems/0461/#461-hamming-distance","text":"Time: $O(32)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x & 1 ) ^ ( y & 1 ); x >>= 1 ; y >>= 1 ; } return ans ; } };","title":"461. Hamming Distance"},{"location":"problems/0462/","text":"462. Minimum Moves to Equal Array Elements II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minMoves2 ( vector < int >& nums ) { const int n = nums . size (); nth_element ( begin ( nums ), begin ( nums ) + n / 2 , end ( nums )); const int median = nums [ n / 2 ]; return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + abs ( b - median ); }); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int minMoves2 ( int [] nums ) { Arrays . sort ( nums ); int median = nums [ nums . length / 2 ] ; int ans = 0 ; for ( int num : nums ) ans += Math . abs ( num - median ); return ans ; } } Python 1 2 3 4 5 6 7 8 import statistics class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : median = int ( statistics . median ( nums )) return sum ( abs ( num - median ) for num in nums )","title":"462. Minimum Moves to Equal Array Elements II"},{"location":"problems/0462/#462-minimum-moves-to-equal-array-elements-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minMoves2 ( vector < int >& nums ) { const int n = nums . size (); nth_element ( begin ( nums ), begin ( nums ) + n / 2 , end ( nums )); const int median = nums [ n / 2 ]; return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + abs ( b - median ); }); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int minMoves2 ( int [] nums ) { Arrays . sort ( nums ); int median = nums [ nums . length / 2 ] ; int ans = 0 ; for ( int num : nums ) ans += Math . abs ( num - median ); return ans ; } } Python 1 2 3 4 5 6 7 8 import statistics class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : median = int ( statistics . median ( nums )) return sum ( abs ( num - median ) for num in nums )","title":"462. Minimum Moves to Equal Array Elements II"},{"location":"problems/0463/","text":"463. Island Perimeter Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int islandPerimeter ( vector < vector < int >>& grid ) { int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ]) { ++ islands ; if ( i - 1 >= 0 && grid [ i - 1 ][ j ]) ++ neighbors ; if ( j - 1 >= 0 && grid [ i ][ j - 1 ]) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int islandPerimeter ( int [][] grid ) { int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ islands ; if ( i - 1 >= 0 && grid [ i - 1 ][ j ] == 1 ) ++ neighbors ; if ( j - 1 >= 0 && grid [ i ][ j - 1 ] == 1 ) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def islandPerimeter ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) islands = 0 neighbors = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : islands += 1 if i + 1 < m and grid [ i + 1 ][ j ] == 1 : neighbors += 1 if j + 1 < n and grid [ i ][ j + 1 ] == 1 : neighbors += 1 return islands * 4 - neighbors * 2","title":"463. Island Perimeter"},{"location":"problems/0463/#463-island-perimeter","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int islandPerimeter ( vector < vector < int >>& grid ) { int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ]) { ++ islands ; if ( i - 1 >= 0 && grid [ i - 1 ][ j ]) ++ neighbors ; if ( j - 1 >= 0 && grid [ i ][ j - 1 ]) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int islandPerimeter ( int [][] grid ) { int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ islands ; if ( i - 1 >= 0 && grid [ i - 1 ][ j ] == 1 ) ++ neighbors ; if ( j - 1 >= 0 && grid [ i ][ j - 1 ] == 1 ) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def islandPerimeter ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) islands = 0 neighbors = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : islands += 1 if i + 1 < m and grid [ i + 1 ][ j ] == 1 : neighbors += 1 if j + 1 < n and grid [ i ][ j + 1 ] == 1 : neighbors += 1 return islands * 4 - neighbors * 2","title":"463. Island Perimeter"},{"location":"problems/0464/","text":"464. Can I Win Time: $O(n \\codt turns)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool canIWin ( int maxChoosableInteger , int desiredTotal ) { if ( desiredTotal <= 0 ) return true ; const int sum = maxChoosableInteger * ( maxChoosableInteger + 1 ) / 2 ; if ( sum < desiredTotal ) return false ; unordered_map < int , bool > memo ; // true: can win, false: can't win // state: record integers that have been chosen function < bool ( int , int ) > dp = [ & ]( int total , int state ) { if ( total <= 0 ) return false ; if ( memo . count ( state )) return memo [ state ]; for ( int i = 1 ; i <= maxChoosableInteger ; ++ i ) { if ( state & ( 1 << i )) continue ; // integer i is used if ( ! dp ( total - i , state | ( 1 << i ))) return true ; } return memo [ state ] = false ; }; return dp ( desiredTotal , 0 ); } };","title":"464. Can I Win"},{"location":"problems/0464/#464-can-i-win","text":"Time: $O(n \\codt turns)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool canIWin ( int maxChoosableInteger , int desiredTotal ) { if ( desiredTotal <= 0 ) return true ; const int sum = maxChoosableInteger * ( maxChoosableInteger + 1 ) / 2 ; if ( sum < desiredTotal ) return false ; unordered_map < int , bool > memo ; // true: can win, false: can't win // state: record integers that have been chosen function < bool ( int , int ) > dp = [ & ]( int total , int state ) { if ( total <= 0 ) return false ; if ( memo . count ( state )) return memo [ state ]; for ( int i = 1 ; i <= maxChoosableInteger ; ++ i ) { if ( state & ( 1 << i )) continue ; // integer i is used if ( ! dp ( total - i , state | ( 1 << i ))) return true ; } return memo [ state ] = false ; }; return dp ( desiredTotal , 0 ); } };","title":"464. Can I Win"},{"location":"problems/0465/","text":"465. Optimal Account Balancing \ud83d\udd12","title":"465. Optimal Account Balancing"},{"location":"problems/0465/#465-optimal-account-balancing","text":"","title":"465. Optimal Account Balancing \ud83d\udd12"},{"location":"problems/0466/","text":"466. Count The Repetitions Time: $O(|s1||s2|)$ Space: $O(|s2|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 struct Record { int count ; int nextIndex ; }; class Solution { public : int getMaxRepetitions ( string s1 , int n1 , string s2 , int n2 ) { vector < Record > records ; // {count(s1 matches s2[i:]), next index of s2[i:]} for ( int i = 0 ; i < s2 . length (); ++ i ) { int count = 0 ; int nextIndex = i ; for ( int j = 0 ; j < s1 . length (); ++ j ) if ( s2 [ nextIndex ] == s1 [ j ]) if ( ++ nextIndex == s2 . length ()) { // have a match ++ count ; nextIndex = 0 ; } records . push_back ({ count , nextIndex }); } int matches = 0 ; // S1 matches s2 int index = 0 ; while ( n1 -- ) { matches += records [ index ]. count ; index = records [ index ]. nextIndex ; } return matches / n2 ; // S1 matches S2 } };","title":"466. Count The Repetitions"},{"location":"problems/0466/#466-count-the-repetitions","text":"Time: $O(|s1||s2|)$ Space: $O(|s2|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 struct Record { int count ; int nextIndex ; }; class Solution { public : int getMaxRepetitions ( string s1 , int n1 , string s2 , int n2 ) { vector < Record > records ; // {count(s1 matches s2[i:]), next index of s2[i:]} for ( int i = 0 ; i < s2 . length (); ++ i ) { int count = 0 ; int nextIndex = i ; for ( int j = 0 ; j < s1 . length (); ++ j ) if ( s2 [ nextIndex ] == s1 [ j ]) if ( ++ nextIndex == s2 . length ()) { // have a match ++ count ; nextIndex = 0 ; } records . push_back ({ count , nextIndex }); } int matches = 0 ; // S1 matches s2 int index = 0 ; while ( n1 -- ) { matches += records [ index ]. count ; index = records [ index ]. nextIndex ; } return matches / n2 ; // S1 matches S2 } };","title":"466. Count The Repetitions"},{"location":"problems/0467/","text":"467. Unique Substrings in Wraparound String Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findSubstringInWraproundString ( string p ) { int maxLength = 1 ; vector < int > count ( 26 ); // substrings end at i for ( int i = 0 ; i < p . length (); ++ i ) { if ( i > 0 && ( p [ i ] - p [ i - 1 ] == 1 || p [ i - 1 ] - p [ i ] == 25 )) ++ maxLength ; else maxLength = 1 ; const int index = p [ i ] - 'a' ; count [ index ] = max ( count [ index ], maxLength ); } return accumulate ( begin ( count ), end ( count ), 0 ); } };","title":"467. Unique Substrings in Wraparound String"},{"location":"problems/0467/#467-unique-substrings-in-wraparound-string","text":"Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findSubstringInWraproundString ( string p ) { int maxLength = 1 ; vector < int > count ( 26 ); // substrings end at i for ( int i = 0 ; i < p . length (); ++ i ) { if ( i > 0 && ( p [ i ] - p [ i - 1 ] == 1 || p [ i - 1 ] - p [ i ] == 25 )) ++ maxLength ; else maxLength = 1 ; const int index = p [ i ] - 'a' ; count [ index ] = max ( count [ index ], maxLength ); } return accumulate ( begin ( count ), end ( count ), 0 ); } };","title":"467. Unique Substrings in Wraparound String"},{"location":"problems/0468/","text":"468. Validate IP Address Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : string validIPAddress ( string IP ) { string digit ; stringstream ss ( IP ); if ( count ( begin ( IP ), end ( IP ), '.' ) == 3 ) { for ( int i = 0 ; i < 4 ; ++ i ) // make sure we have 4 parts if ( ! getline ( ss , digit , '.' ) || ! isIPv4 ( digit )) return \"Neither\" ; return \"IPv4\" ; } if ( count ( begin ( IP ), end ( IP ), ':' ) == 7 ) { for ( int i = 0 ; i < 8 ; ++ i ) // make sure we have 8 parts if ( ! getline ( ss , digit , ':' ) || ! isIPv6 ( digit )) return \"Neither\" ; return \"IPv6\" ; } return \"Neither\" ; } private : static inline string validIPv6Chars = \"0123456789abcdefABCDEF\" ; bool isIPv4 ( const string & digit ) { if ( digit . empty () || digit . length () > 3 ) return false ; if ( digit . length () > 1 && digit [ 0 ] == '0' ) return false ; for ( const char c : digit ) if ( c < '0' || c > '9' ) return false ; const int num = stoi ( digit ); return 0 <= num && num <= 255 ; } bool isIPv6 ( const string & digit ) { if ( digit . empty () || digit . length () > 4 ) return false ; for ( const char c : digit ) if ( validIPv6Chars . find ( c ) == string :: npos ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public String validIPAddress ( String IP ) { if ( IP . chars (). filter ( c -> c == '.' ). count () == 3 ) { for ( final String digit : IP . split ( \"\\\\.\" , - 1 )) if ( ! isIPv4 ( digit )) return \"Neither\" ; return \"IPv4\" ; } if ( IP . chars (). filter ( c -> c == ':' ). count () == 7 ) { for ( final String digit : IP . split ( \"\\\\:\" , - 1 )) if ( ! isIPv6 ( digit )) return \"Neither\" ; return \"IPv6\" ; } return \"Neither\" ; } static private final String validIPv6Chars = \"0123456789abcdefABCDEF\" ; private boolean isIPv4 ( final String digit ) { if ( digit . length () == 0 || digit . length () > 3 ) return false ; if ( digit . length () > 1 && digit . charAt ( 0 ) == '0' ) return false ; for ( char c : digit . toCharArray ()) if ( c < '0' || c > '9' ) return false ; int num = Integer . valueOf ( digit ); return 0 <= num && num <= 255 ; } private boolean isIPv6 ( final String digit ) { if ( digit . length () == 0 || digit . length () > 4 ) return false ; for ( char c : digit . toCharArray ()) if ( ! validIPv6Chars . contains ( \"\" + c )) return false ; return true ; } }","title":"468. Validate IP Address"},{"location":"problems/0468/#468-validate-ip-address","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : string validIPAddress ( string IP ) { string digit ; stringstream ss ( IP ); if ( count ( begin ( IP ), end ( IP ), '.' ) == 3 ) { for ( int i = 0 ; i < 4 ; ++ i ) // make sure we have 4 parts if ( ! getline ( ss , digit , '.' ) || ! isIPv4 ( digit )) return \"Neither\" ; return \"IPv4\" ; } if ( count ( begin ( IP ), end ( IP ), ':' ) == 7 ) { for ( int i = 0 ; i < 8 ; ++ i ) // make sure we have 8 parts if ( ! getline ( ss , digit , ':' ) || ! isIPv6 ( digit )) return \"Neither\" ; return \"IPv6\" ; } return \"Neither\" ; } private : static inline string validIPv6Chars = \"0123456789abcdefABCDEF\" ; bool isIPv4 ( const string & digit ) { if ( digit . empty () || digit . length () > 3 ) return false ; if ( digit . length () > 1 && digit [ 0 ] == '0' ) return false ; for ( const char c : digit ) if ( c < '0' || c > '9' ) return false ; const int num = stoi ( digit ); return 0 <= num && num <= 255 ; } bool isIPv6 ( const string & digit ) { if ( digit . empty () || digit . length () > 4 ) return false ; for ( const char c : digit ) if ( validIPv6Chars . find ( c ) == string :: npos ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public String validIPAddress ( String IP ) { if ( IP . chars (). filter ( c -> c == '.' ). count () == 3 ) { for ( final String digit : IP . split ( \"\\\\.\" , - 1 )) if ( ! isIPv4 ( digit )) return \"Neither\" ; return \"IPv4\" ; } if ( IP . chars (). filter ( c -> c == ':' ). count () == 7 ) { for ( final String digit : IP . split ( \"\\\\:\" , - 1 )) if ( ! isIPv6 ( digit )) return \"Neither\" ; return \"IPv6\" ; } return \"Neither\" ; } static private final String validIPv6Chars = \"0123456789abcdefABCDEF\" ; private boolean isIPv4 ( final String digit ) { if ( digit . length () == 0 || digit . length () > 3 ) return false ; if ( digit . length () > 1 && digit . charAt ( 0 ) == '0' ) return false ; for ( char c : digit . toCharArray ()) if ( c < '0' || c > '9' ) return false ; int num = Integer . valueOf ( digit ); return 0 <= num && num <= 255 ; } private boolean isIPv6 ( final String digit ) { if ( digit . length () == 0 || digit . length () > 4 ) return false ; for ( char c : digit . toCharArray ()) if ( ! validIPv6Chars . contains ( \"\" + c )) return false ; return true ; } }","title":"468. Validate IP Address"},{"location":"problems/0469/","text":"469. Convex Polygon \ud83d\udd12","title":"469. Convex Polygon"},{"location":"problems/0469/#469-convex-polygon","text":"","title":"469. Convex Polygon \ud83d\udd12"},{"location":"problems/0470/","text":"470. Implement Rand10() Using Rand7() Time: $O(1)$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int rand10 () { int num = 40 ; while ( num >= 40 ) num = ( rand7 () - 1 ) * 7 + rand7 () - 1 ; return num % 10 + 1 ; } };","title":"470. Implement Rand10() Using Rand7()"},{"location":"problems/0470/#470-implement-rand10-using-rand7","text":"Time: $O(1)$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int rand10 () { int num = 40 ; while ( num >= 40 ) num = ( rand7 () - 1 ) * 7 + rand7 () - 1 ; return num % 10 + 1 ; } };","title":"470. Implement Rand10() Using Rand7()"},{"location":"problems/0471/","text":"471. Encode String with Shortest Length \ud83d\udd12","title":"471. Encode String with Shortest Length"},{"location":"problems/0471/#471-encode-string-with-shortest-length","text":"","title":"471. Encode String with Shortest Length \ud83d\udd12"},{"location":"problems/0472/","text":"472. Concatenated Words Time: $O(nl^3)$, where n = len(words) and l = max length of words Space: $O(nl)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; unordered_set < string > wordsSet { begin ( words ), end ( words )}; unordered_map < string , bool > memo ; function < bool ( const string & ) > isConcat = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; for ( int i = 1 ; i < s . length (); ++ i ) { const string prefix = s . substr ( 0 , i ); const string suffix = s . substr ( i ); if ( wordsSet . count ( prefix ) && ( wordsSet . count ( suffix ) || isConcat ( suffix ))) return memo [ s ] = true ; } return memo [ s ] = false ; }; for ( const string & word : words ) if ( isConcat ( word )) ans . push_back ( word ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public List < String > findAllConcatenatedWordsInADict ( String [] words ) { List < String > ans = new ArrayList <> (); Set < String > wordSet = new HashSet <> (); for ( final String word : words ) wordSet . add ( word ); for ( final String word : words ) if ( wordBreak ( word , wordSet )) ans . add ( word ); return ans ; } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String word , Set < String > wordSet ) { if ( memo . containsKey ( word )) return memo . get ( word ); for ( int i = 1 ; i < word . length (); ++ i ) { String prefix = word . substring ( 0 , i ); String suffix = word . substring ( i ); if ( wordSet . contains ( prefix ) && ( wordSet . contains ( suffix ) || wordBreak ( suffix , wordSet ))) { memo . put ( word , true ); return true ; } } memo . put ( word , false ); return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def findAllConcatenatedWordsInADict ( self , words : List [ str ]) -> List [ str ]: def isConcat ( word : str ) -> bool : if word in memo : return memo [ word ] for i in range ( 1 , len ( word )): prefix = word [: i ] suffix = word [ i :] if prefix in wordSet and ( suffix in wordSet or isConcat ( suffix )): memo [ word ] = True return True memo [ word ] = False return False wordSet = set ( words ) memo = {} return [ word for word in words if isConcat ( word )]","title":"472. Concatenated Words"},{"location":"problems/0472/#472-concatenated-words","text":"Time: $O(nl^3)$, where n = len(words) and l = max length of words Space: $O(nl)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; unordered_set < string > wordsSet { begin ( words ), end ( words )}; unordered_map < string , bool > memo ; function < bool ( const string & ) > isConcat = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; for ( int i = 1 ; i < s . length (); ++ i ) { const string prefix = s . substr ( 0 , i ); const string suffix = s . substr ( i ); if ( wordsSet . count ( prefix ) && ( wordsSet . count ( suffix ) || isConcat ( suffix ))) return memo [ s ] = true ; } return memo [ s ] = false ; }; for ( const string & word : words ) if ( isConcat ( word )) ans . push_back ( word ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public List < String > findAllConcatenatedWordsInADict ( String [] words ) { List < String > ans = new ArrayList <> (); Set < String > wordSet = new HashSet <> (); for ( final String word : words ) wordSet . add ( word ); for ( final String word : words ) if ( wordBreak ( word , wordSet )) ans . add ( word ); return ans ; } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String word , Set < String > wordSet ) { if ( memo . containsKey ( word )) return memo . get ( word ); for ( int i = 1 ; i < word . length (); ++ i ) { String prefix = word . substring ( 0 , i ); String suffix = word . substring ( i ); if ( wordSet . contains ( prefix ) && ( wordSet . contains ( suffix ) || wordBreak ( suffix , wordSet ))) { memo . put ( word , true ); return true ; } } memo . put ( word , false ); return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def findAllConcatenatedWordsInADict ( self , words : List [ str ]) -> List [ str ]: def isConcat ( word : str ) -> bool : if word in memo : return memo [ word ] for i in range ( 1 , len ( word )): prefix = word [: i ] suffix = word [ i :] if prefix in wordSet and ( suffix in wordSet or isConcat ( suffix )): memo [ word ] = True return True memo [ word ] = False return False wordSet = set ( words ) memo = {} return [ word for word in words if isConcat ( word )]","title":"472. Concatenated Words"},{"location":"problems/0473/","text":"473. Matchsticks to Square Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool makesquare ( vector < int >& nums ) { if ( nums . size () < 4 ) return false ; const int perimeter = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( perimeter % 4 != 0 ) return false ; vector < int > edges ( 4 , perimeter / 4 ); sort ( begin ( nums ), end ( nums ), greater < int > ()); function < bool ( int ) > dfs = [ & ]( int selected ) { if ( selected == nums . size ()) return all_of ( begin ( edges ), end ( edges ), []( int edge ) { return edge == 0 ; }); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( nums [ selected ] > edges [ i ]) continue ; edges [ i ] -= nums [ selected ]; if ( dfs ( selected + 1 )) return true ; edges [ i ] += nums [ selected ]; } return false ; }; return dfs ( 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean makesquare ( int [] nums ) { if ( nums . length < 4 ) return false ; int perimeter = Arrays . stream ( nums ). sum (); if ( perimeter % 4 != 0 ) return false ; int [] edges = new int [ 4 ] ; Arrays . fill ( edges , perimeter / 4 ); Arrays . sort ( edges ); return dfs ( nums , nums . length - 1 , edges ); } private boolean dfs ( int [] nums , int selected , int [] edges ) { if ( selected == - 1 ) return edges [ 0 ] == edges [ 1 ] && edges [ 1 ] == edges [ 2 ] && edges [ 2 ] == edges [ 3 ] ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( nums [ selected ] > edges [ i ] ) continue ; edges [ i ] -= nums [ selected ] ; if ( dfs ( nums , selected - 1 , edges )) return true ; edges [ i ] += nums [ selected ] ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def makesquare ( self , nums : List [ int ]) -> bool : def dfs ( selected : int , edges : List [ int ]) -> bool : if selected == len ( nums ): return all ( edge == edges [ 0 ] for edge in edges ) for i , edge in enumerate ( edges ): if nums [ selected ] > edge : continue edges [ i ] -= nums [ selected ] if dfs ( selected + 1 , edges ): return True edges [ i ] += nums [ selected ] return False if len ( nums ) < 4 : return False perimeter = sum ( nums ) if perimeter % 4 != 0 : return False nums = sorted ( nums )[:: - 1 ] return dfs ( 0 , [ perimeter // 4 ] * 4 )","title":"473. Matchsticks to Square"},{"location":"problems/0473/#473-matchsticks-to-square","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool makesquare ( vector < int >& nums ) { if ( nums . size () < 4 ) return false ; const int perimeter = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( perimeter % 4 != 0 ) return false ; vector < int > edges ( 4 , perimeter / 4 ); sort ( begin ( nums ), end ( nums ), greater < int > ()); function < bool ( int ) > dfs = [ & ]( int selected ) { if ( selected == nums . size ()) return all_of ( begin ( edges ), end ( edges ), []( int edge ) { return edge == 0 ; }); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( nums [ selected ] > edges [ i ]) continue ; edges [ i ] -= nums [ selected ]; if ( dfs ( selected + 1 )) return true ; edges [ i ] += nums [ selected ]; } return false ; }; return dfs ( 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean makesquare ( int [] nums ) { if ( nums . length < 4 ) return false ; int perimeter = Arrays . stream ( nums ). sum (); if ( perimeter % 4 != 0 ) return false ; int [] edges = new int [ 4 ] ; Arrays . fill ( edges , perimeter / 4 ); Arrays . sort ( edges ); return dfs ( nums , nums . length - 1 , edges ); } private boolean dfs ( int [] nums , int selected , int [] edges ) { if ( selected == - 1 ) return edges [ 0 ] == edges [ 1 ] && edges [ 1 ] == edges [ 2 ] && edges [ 2 ] == edges [ 3 ] ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( nums [ selected ] > edges [ i ] ) continue ; edges [ i ] -= nums [ selected ] ; if ( dfs ( nums , selected - 1 , edges )) return true ; edges [ i ] += nums [ selected ] ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def makesquare ( self , nums : List [ int ]) -> bool : def dfs ( selected : int , edges : List [ int ]) -> bool : if selected == len ( nums ): return all ( edge == edges [ 0 ] for edge in edges ) for i , edge in enumerate ( edges ): if nums [ selected ] > edge : continue edges [ i ] -= nums [ selected ] if dfs ( selected + 1 , edges ): return True edges [ i ] += nums [ selected ] return False if len ( nums ) < 4 : return False perimeter = sum ( nums ) if perimeter % 4 != 0 : return False nums = sorted ( nums )[:: - 1 ] return dfs ( 0 , [ perimeter // 4 ] * 4 )","title":"473. Matchsticks to Square"},{"location":"problems/0474/","text":"474. Ones and Zeroes Time: $O(kl \\cdot mn)$, where k = len(strs) and l = max length of strs Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findMaxForm ( vector < string >& strs , int m , int n ) { vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( const string & s : strs ) { const int count0 = count ( begin ( s ), end ( s ), '0' ); const int count1 = s . length () - count0 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findMaxForm ( String [] strs , int m , int n ) { int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( final String s : strs ) { int count0 = 0 ; int count1 = 0 ; for ( char c : s . toCharArray ()) if ( c == '0' ) ++ count0 ; else ++ count1 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findMaxForm ( self , strs : List [ str ], m : int , n : int ) -> int : dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for s in strs : count0 = s . count ( '0' ) count1 = len ( s ) - count0 for i in range ( m , count0 - 1 , - 1 ): for j in range ( n , count1 - 1 , - 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ) return dp [ m ][ n ]","title":"474. Ones and Zeroes"},{"location":"problems/0474/#474-ones-and-zeroes","text":"Time: $O(kl \\cdot mn)$, where k = len(strs) and l = max length of strs Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findMaxForm ( vector < string >& strs , int m , int n ) { vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( const string & s : strs ) { const int count0 = count ( begin ( s ), end ( s ), '0' ); const int count1 = s . length () - count0 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findMaxForm ( String [] strs , int m , int n ) { int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( final String s : strs ) { int count0 = 0 ; int count1 = 0 ; for ( char c : s . toCharArray ()) if ( c == '0' ) ++ count0 ; else ++ count1 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findMaxForm ( self , strs : List [ str ], m : int , n : int ) -> int : dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for s in strs : count0 = s . count ( '0' ) count1 = len ( s ) - count0 for i in range ( m , count0 - 1 , - 1 ): for j in range ( n , count1 - 1 , - 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ) return dp [ m ][ n ]","title":"474. Ones and Zeroes"},{"location":"problems/0475/","text":"475. Heaters Time: $\\max(O(m\\log m), O(n\\log n))$, where m = len(houses) and n = len(heaters) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findRadius ( vector < int >& houses , vector < int >& heaters ) { sort ( begin ( houses ), end ( houses )); sort ( begin ( heaters ), end ( heaters )); int ans = 0 ; int i = 0 ; // point to the heater that currently used for ( const int house : houses ) { while ( i + 1 < heaters . size () && house - heaters [ i ] > heaters [ i + 1 ] - house ) ++ i ; // next heater is better ans = max ( ans , abs ( heaters [ i ] - house )); } return ans ; } };","title":"475. Heaters"},{"location":"problems/0475/#475-heaters","text":"Time: $\\max(O(m\\log m), O(n\\log n))$, where m = len(houses) and n = len(heaters) Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findRadius ( vector < int >& houses , vector < int >& heaters ) { sort ( begin ( houses ), end ( houses )); sort ( begin ( heaters ), end ( heaters )); int ans = 0 ; int i = 0 ; // point to the heater that currently used for ( const int house : houses ) { while ( i + 1 < heaters . size () && house - heaters [ i ] > heaters [ i + 1 ] - house ) ++ i ; // next heater is better ans = max ( ans , abs ( heaters [ i ] - house )); } return ans ; } };","title":"475. Heaters"},{"location":"problems/0476/","text":"476. Number Complement Time: $O(32) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int findComplement ( long num ) { for ( long i = 1 ; i <= num ; i <<= 1 ) num ^= i ; return num ; } };","title":"476. Number Complement"},{"location":"problems/0476/#476-number-complement","text":"Time: $O(32) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int findComplement ( long num ) { for ( long i = 1 ; i <= num ; i <<= 1 ) num ^= i ; return num ; } };","title":"476. Number Complement"},{"location":"problems/0477/","text":"477. Total Hamming Distance Time: $O(30n) = O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { const int onesCount = count_if ( begin ( nums ), end ( nums ), [ & mask ]( int num ) { return num & mask ; }); const int zerosCount = nums . size () - onesCount ; ans += onesCount * zerosCount ; mask <<= 1 ; } return ans ; } };","title":"477. Total Hamming Distance"},{"location":"problems/0477/#477-total-hamming-distance","text":"Time: $O(30n) = O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { const int onesCount = count_if ( begin ( nums ), end ( nums ), [ & mask ]( int num ) { return num & mask ; }); const int zerosCount = nums . size () - onesCount ; ans += onesCount * zerosCount ; mask <<= 1 ; } return ans ; } };","title":"477. Total Hamming Distance"},{"location":"problems/0478/","text":"478. Generate Random Point in a Circle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : Solution ( double radius , double x_center , double y_center ) { this -> radius = radius ; this -> x_center = x_center ; this -> y_center = y_center ; distribution = uniform_real_distribution < double > ( 0.0 , 1.0 ); } vector < double > randPoint () { const double length = sqrt ( distribution ( generator )) * radius ; const double degree = distribution ( generator ) * 2 * M_PI ; const double x = x_center + length * cos ( degree ); const double y = y_center + length * sin ( degree ); return { x , y }; } private : double radius ; double x_center ; double y_center ; default_random_engine generator ; uniform_real_distribution < double > distribution ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public Solution ( double radius , double x_center , double y_center ) { this . radius = radius ; this . x_center = x_center ; this . y_center = y_center ; } public double [] randPoint () { double length = Math . sqrt ( Math . random ()) * radius ; double degree = Math . random () * 2 * Math . PI ; double x = x_center + length * Math . cos ( degree ); double y = y_center + length * Math . sin ( degree ); return new double [] { x , y }; } private double radius ; private double x_center ; private double y_center ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def __init__ ( self , radius : float , x_center : float , y_center : float ): self . radius = radius self . x_center = x_center self . y_center = y_center def randPoint ( self ) -> List [ float ]: length = sqrt ( random . uniform ( 0 , 1 )) * self . radius degree = random . uniform ( 0 , 1 ) * 2 * math . pi x = self . x_center + length * math . cos ( degree ) y = self . y_center + length * math . sin ( degree ) return [ x , y ]","title":"478. Generate Random Point in a Circle"},{"location":"problems/0478/#478-generate-random-point-in-a-circle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : Solution ( double radius , double x_center , double y_center ) { this -> radius = radius ; this -> x_center = x_center ; this -> y_center = y_center ; distribution = uniform_real_distribution < double > ( 0.0 , 1.0 ); } vector < double > randPoint () { const double length = sqrt ( distribution ( generator )) * radius ; const double degree = distribution ( generator ) * 2 * M_PI ; const double x = x_center + length * cos ( degree ); const double y = y_center + length * sin ( degree ); return { x , y }; } private : double radius ; double x_center ; double y_center ; default_random_engine generator ; uniform_real_distribution < double > distribution ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public Solution ( double radius , double x_center , double y_center ) { this . radius = radius ; this . x_center = x_center ; this . y_center = y_center ; } public double [] randPoint () { double length = Math . sqrt ( Math . random ()) * radius ; double degree = Math . random () * 2 * Math . PI ; double x = x_center + length * Math . cos ( degree ); double y = y_center + length * Math . sin ( degree ); return new double [] { x , y }; } private double radius ; private double x_center ; private double y_center ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def __init__ ( self , radius : float , x_center : float , y_center : float ): self . radius = radius self . x_center = x_center self . y_center = y_center def randPoint ( self ) -> List [ float ]: length = sqrt ( random . uniform ( 0 , 1 )) * self . radius degree = random . uniform ( 0 , 1 ) * 2 * math . pi x = self . x_center + length * math . cos ( degree ) y = self . y_center + length * math . sin ( degree ) return [ x , y ]","title":"478. Generate Random Point in a Circle"},{"location":"problems/0479/","text":"479. Largest Palindrome Product","title":"479. Largest Palindrome Product"},{"location":"problems/0479/#479-largest-palindrome-product","text":"","title":"479. Largest Palindrome Product"},{"location":"problems/0480/","text":"480. Sliding Window Median Time: $O((n - k + 1)\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < double > medianSlidingWindow ( vector < int >& nums , int k ) { vector < double > ans ; multiset < double > window ( begin ( nums ), begin ( nums ) + k ); auto it = next ( begin ( window ), ( k - 1 ) / 2 ); for ( int i = k ;; ++ i ) { const double median = k & 1 ? * it : ( * it + * next ( it )) / 2.0 ; ans . push_back ( median ); if ( i == nums . size ()) break ; window . insert ( nums [ i ]); if ( nums [ i ] < * it ) -- it ; if ( nums [ i - k ] <= * it ) ++ it ; window . erase ( window . lower_bound ( nums [ i - k ])); } return ans ; } };","title":"480. Sliding Window Median"},{"location":"problems/0480/#480-sliding-window-median","text":"Time: $O((n - k + 1)\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < double > medianSlidingWindow ( vector < int >& nums , int k ) { vector < double > ans ; multiset < double > window ( begin ( nums ), begin ( nums ) + k ); auto it = next ( begin ( window ), ( k - 1 ) / 2 ); for ( int i = k ;; ++ i ) { const double median = k & 1 ? * it : ( * it + * next ( it )) / 2.0 ; ans . push_back ( median ); if ( i == nums . size ()) break ; window . insert ( nums [ i ]); if ( nums [ i ] < * it ) -- it ; if ( nums [ i - k ] <= * it ) ++ it ; window . erase ( window . lower_bound ( nums [ i - k ])); } return ans ; } };","title":"480. Sliding Window Median"},{"location":"problems/0481/","text":"481. Magical String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int magicalString ( int n ) { string s = \" 122\" ; for ( int i = 3 ; i <= n ; ++ i ) if ( i & 1 ) s . append ( s [ i ] - '0' , '1' ); else s . append ( s [ i ] - '0' , '2' ); return count ( begin ( s ), begin ( s ) + n + 1 , '1' ); } };","title":"481. Magical String"},{"location":"problems/0481/#481-magical-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int magicalString ( int n ) { string s = \" 122\" ; for ( int i = 3 ; i <= n ; ++ i ) if ( i & 1 ) s . append ( s [ i ] - '0' , '1' ); else s . append ( s [ i ] - '0' , '2' ); return count ( begin ( s ), begin ( s ) + n + 1 , '1' ); } };","title":"481. Magical String"},{"location":"problems/0482/","text":"482. License Key Formatting Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string licenseKeyFormatting ( string S , int K ) { string ans ; int length = 0 ; for ( int i = S . length () - 1 ; i >= 0 ; -- i ) { if ( S [ i ] == '-' ) continue ; if ( length > 0 && length % K == 0 ) ans += \"-\" ; ans += toupper ( S [ i ]); ++ length ; } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"482. License Key Formatting"},{"location":"problems/0482/#482-license-key-formatting","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string licenseKeyFormatting ( string S , int K ) { string ans ; int length = 0 ; for ( int i = S . length () - 1 ; i >= 0 ; -- i ) { if ( S [ i ] == '-' ) continue ; if ( length > 0 && length % K == 0 ) ans += \"-\" ; ans += toupper ( S [ i ]); ++ length ; } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"482. License Key Formatting"},{"location":"problems/0483/","text":"483. Smallest Good Base Time: $O(\\log^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string smallestGoodBase ( string n ) { unsigned long long num = stoll ( n ); for ( int m = log2 ( num ); m >= 2 ; -- m ) { const int k = pow ( num , 1.0 / m ); unsigned long long sum = 1 ; unsigned long long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return to_string ( k ); } return to_string ( num - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String smallestGoodBase ( String n ) { long num = Long . valueOf ( n ); for ( int m = ( int ) ( Math . log ( num ) / Math . log ( 2 )); m >= 2 ; -- m ) { int k = ( int ) Math . floor ( Math . pow ( num , 1.0 / m )); long sum = 1 ; long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return String . valueOf ( k ); } return String . valueOf ( num - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def smallestGoodBase ( self , n : str ) -> str : n = int ( n ) for m in range ( int ( math . log ( n , 2 )), 1 , - 1 ): k = int ( n ** m **- 1 ) if ( k ** ( m + 1 ) - 1 ) // ( k - 1 ) == n : return str ( k ) return str ( n - 1 )","title":"483. Smallest Good Base"},{"location":"problems/0483/#483-smallest-good-base","text":"Time: $O(\\log^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : string smallestGoodBase ( string n ) { unsigned long long num = stoll ( n ); for ( int m = log2 ( num ); m >= 2 ; -- m ) { const int k = pow ( num , 1.0 / m ); unsigned long long sum = 1 ; unsigned long long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return to_string ( k ); } return to_string ( num - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String smallestGoodBase ( String n ) { long num = Long . valueOf ( n ); for ( int m = ( int ) ( Math . log ( num ) / Math . log ( 2 )); m >= 2 ; -- m ) { int k = ( int ) Math . floor ( Math . pow ( num , 1.0 / m )); long sum = 1 ; long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return String . valueOf ( k ); } return String . valueOf ( num - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def smallestGoodBase ( self , n : str ) -> str : n = int ( n ) for m in range ( int ( math . log ( n , 2 )), 1 , - 1 ): k = int ( n ** m **- 1 ) if ( k ** ( m + 1 ) - 1 ) // ( k - 1 ) == n : return str ( k ) return str ( n - 1 )","title":"483. Smallest Good Base"},{"location":"problems/0484/","text":"484. Find Permutation \ud83d\udd12","title":"484. Find Permutation"},{"location":"problems/0484/#484-find-permutation","text":"","title":"484. Find Permutation \ud83d\udd12"},{"location":"problems/0485/","text":"485. Max Consecutive Ones Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( const int num : nums ) if ( num == 1 ) ans = max ( ans , ++ sum ); else sum = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans","title":"485. Max Consecutive Ones"},{"location":"problems/0485/#485-max-consecutive-ones","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( const int num : nums ) if ( num == 1 ) ans = max ( ans , ++ sum ); else sum = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans","title":"485. Max Consecutive Ones"},{"location":"problems/0486/","text":"486. Predict the Winner Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool PredictTheWinner ( vector < int >& nums ) { const int n = nums . size (); vector < int > dp = nums ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = n - 1 ; i - length + 1 >= 0 ; -- i ) dp [ i ] = max ( nums [ i ] - dp [ i - 1 ], // pick right num nums [ i - length + 1 ] - dp [ i ]); // pick left num return dp . back () >= 0 ; } };","title":"486. Predict the Winner"},{"location":"problems/0486/#486-predict-the-winner","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool PredictTheWinner ( vector < int >& nums ) { const int n = nums . size (); vector < int > dp = nums ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = n - 1 ; i - length + 1 >= 0 ; -- i ) dp [ i ] = max ( nums [ i ] - dp [ i - 1 ], // pick right num nums [ i - length + 1 ] - dp [ i ]); // pick left num return dp . back () >= 0 ; } };","title":"486. Predict the Winner"},{"location":"problems/0487/","text":"487. Max Consecutive Ones II \ud83d\udd12","title":"487. Max Consecutive Ones II"},{"location":"problems/0487/#487-max-consecutive-ones-ii","text":"","title":"487. Max Consecutive Ones II \ud83d\udd12"},{"location":"problems/0488/","text":"488. Zuma Game","title":"488. Zuma Game"},{"location":"problems/0488/#488-zuma-game","text":"","title":"488. Zuma Game"},{"location":"problems/0489/","text":"489. Robot Room Cleaner \ud83d\udd12","title":"489. Robot Room Cleaner"},{"location":"problems/0489/#489-robot-room-cleaner","text":"","title":"489. Robot Room Cleaner \ud83d\udd12"},{"location":"problems/0490/","text":"490. The Maze \ud83d\udd12","title":"490. The Maze"},{"location":"problems/0490/#490-the-maze","text":"","title":"490. The Maze \ud83d\udd12"},{"location":"problems/0491/","text":"491. Increasing Subsequences Time: $O(n2^n)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> findSubsequences ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { if ( path . size () > 1 ) ans . push_back ( path ); unordered_set < int > used ; for ( int i = s ; i < nums . size (); ++ i ) { if ( used . count ( nums [ i ])) continue ; if ( path . empty () || nums [ i ] >= path . back ()) { used . insert ( nums [ i ]); path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < List < Integer >> findSubsequences ( int [] nums ) { List < List < Integer >> ans = new LinkedList <> (); dfs ( nums , 0 , new LinkedList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , LinkedList < Integer > path , List < List < Integer >> ans ) { if ( path . size () > 1 ) ans . add ( new LinkedList <> ( path )); Set < Integer > used = new HashSet <> (); for ( int i = s ; i < nums . length ; ++ i ) { if ( used . contains ( nums [ i ] )) continue ; if ( path . isEmpty () || nums [ i ] >= path . getLast ()) { used . add ( nums [ i ] ); path . addLast ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . removeLast (); } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def findSubsequences ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : if len ( path ) > 1 : ans . append ( path ) used = set () for i in range ( s , len ( nums )): if nums [ i ] in used : continue if not path or nums [ i ] >= path [ - 1 ]: used . add ( nums [ i ]) dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"491. Increasing Subsequences"},{"location":"problems/0491/#491-increasing-subsequences","text":"Time: $O(n2^n)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> findSubsequences ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { if ( path . size () > 1 ) ans . push_back ( path ); unordered_set < int > used ; for ( int i = s ; i < nums . size (); ++ i ) { if ( used . count ( nums [ i ])) continue ; if ( path . empty () || nums [ i ] >= path . back ()) { used . insert ( nums [ i ]); path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public List < List < Integer >> findSubsequences ( int [] nums ) { List < List < Integer >> ans = new LinkedList <> (); dfs ( nums , 0 , new LinkedList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , LinkedList < Integer > path , List < List < Integer >> ans ) { if ( path . size () > 1 ) ans . add ( new LinkedList <> ( path )); Set < Integer > used = new HashSet <> (); for ( int i = s ; i < nums . length ; ++ i ) { if ( used . contains ( nums [ i ] )) continue ; if ( path . isEmpty () || nums [ i ] >= path . getLast ()) { used . add ( nums [ i ] ); path . addLast ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . removeLast (); } } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def findSubsequences ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : if len ( path ) > 1 : ans . append ( path ) used = set () for i in range ( s , len ( nums )): if nums [ i ] in used : continue if not path or nums [ i ] >= path [ - 1 ]: used . add ( nums [ i ]) dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"491. Increasing Subsequences"},{"location":"problems/0492/","text":"492. Construct the Rectangle Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > constructRectangle ( int area ) { int width = sqrt ( area ); while ( area % width ) -- width ; return { area / width , width }; } };","title":"492. Construct the Rectangle"},{"location":"problems/0492/#492-construct-the-rectangle","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > constructRectangle ( int area ) { int width = sqrt ( area ); while ( area % width ) -- width ; return { area / width , width }; } };","title":"492. Construct the Rectangle"},{"location":"problems/0493/","text":"493. Reverse Pairs","title":"493. Reverse Pairs"},{"location":"problems/0493/#493-reverse-pairs","text":"","title":"493. Reverse Pairs"},{"location":"problems/0494/","text":"494. Target Sum Time: $O(n(sum + S) / 2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findTargetSumWays ( vector < int >& nums , int S ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum < S || ( sum + S ) & 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private : int subsetSum ( const vector < int >& nums , int target ) { vector < int > dp ( target + 1 ); // dp[i] := # of ways to sum to i dp [ 0 ] = 1 ; for ( const int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] += dp [ w - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findTargetSumWays ( int [] nums , int S ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum < S || ( sum + S ) % 2 == 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private int subsetSum ( final int [] nums , int target ) { int [] dp = new int [ target + 1 ] ; // dp[i] := # of ways to sum to i dp [ 0 ] = 1 ; for ( final int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] += dp [ w - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def findTargetSumWays ( self , nums : List [ int ], S : int ) -> int : summ = sum ( nums ) if summ < S or ( summ + S ) & 1 : return 0 def subsetSum ( s : int ) -> int : dp = [ 1 ] + [ 0 ] * summ for num in nums : for w in range ( summ , num - 1 , - 1 ): dp [ w ] += dp [ w - num ] return dp [ s ] return subsetSum (( summ + S ) // 2 )","title":"494. Target Sum"},{"location":"problems/0494/#494-target-sum","text":"Time: $O(n(sum + S) / 2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findTargetSumWays ( vector < int >& nums , int S ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum < S || ( sum + S ) & 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private : int subsetSum ( const vector < int >& nums , int target ) { vector < int > dp ( target + 1 ); // dp[i] := # of ways to sum to i dp [ 0 ] = 1 ; for ( const int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] += dp [ w - num ]; return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findTargetSumWays ( int [] nums , int S ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum < S || ( sum + S ) % 2 == 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private int subsetSum ( final int [] nums , int target ) { int [] dp = new int [ target + 1 ] ; // dp[i] := # of ways to sum to i dp [ 0 ] = 1 ; for ( final int num : nums ) for ( int w = target ; w >= num ; -- w ) dp [ w ] += dp [ w - num ] ; return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def findTargetSumWays ( self , nums : List [ int ], S : int ) -> int : summ = sum ( nums ) if summ < S or ( summ + S ) & 1 : return 0 def subsetSum ( s : int ) -> int : dp = [ 1 ] + [ 0 ] * summ for num in nums : for w in range ( summ , num - 1 , - 1 ): dp [ w ] += dp [ w - num ] return dp [ s ] return subsetSum (( summ + S ) // 2 )","title":"494. Target Sum"},{"location":"problems/0495/","text":"495. Teemo Attacking Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; ++ i ) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ); return ans + duration ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration","title":"495. Teemo Attacking"},{"location":"problems/0495/#495-teemo-attacking","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; ++ i ) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ); return ans + duration ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration","title":"495. Teemo Attacking"},{"location":"problems/0496/","text":"496. Next Greater Element I Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > nextGreaterElement ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > numToNextGreater ; stack < int > stack ; // decreasing stack for ( const int num : nums2 ) { while ( ! stack . empty () && stack . top () < num ) numToNextGreater [ stack . top ()] = num , stack . pop (); stack . push ( num ); } for ( const int num : nums1 ) if ( numToNextGreater . count ( num )) ans . push_back ( numToNextGreater [ num ]); else ans . push_back ( -1 ); return ans ; } };","title":"496. Next Greater Element I"},{"location":"problems/0496/#496-next-greater-element-i","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > nextGreaterElement ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > numToNextGreater ; stack < int > stack ; // decreasing stack for ( const int num : nums2 ) { while ( ! stack . empty () && stack . top () < num ) numToNextGreater [ stack . top ()] = num , stack . pop (); stack . push ( num ); } for ( const int num : nums1 ) if ( numToNextGreater . count ( num )) ans . push_back ( numToNextGreater [ num ]); else ans . push_back ( -1 ); return ans ; } };","title":"496. Next Greater Element I"},{"location":"problems/0497/","text":"497. Random Point in Non-overlapping Rectangles","title":"497. Random Point in Non-overlapping Rectangles"},{"location":"problems/0497/#497-random-point-in-non-overlapping-rectangles","text":"","title":"497. Random Point in Non-overlapping Rectangles"},{"location":"problems/0498/","text":"498. Diagonal Traverse Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > ans ( m * n ); int d = 1 ; // left-bottom -> right-top int row = 0 ; int col = 0 ; for ( int i = 0 ; i < m * n ; ++ i ) { ans [ i ] = matrix [ row ][ col ]; row -= d ; col += d ; // out-of-bounds if ( row == m ) row = m - 1 , col += 2 , d = - d ; if ( col == n ) col = n - 1 , row += 2 , d = - d ; if ( row < 0 ) row = 0 , d = - d ; if ( col < 0 ) col = 0 , d = - d ; } return ans ; } };","title":"498. Diagonal Traverse"},{"location":"problems/0498/#498-diagonal-traverse","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > ans ( m * n ); int d = 1 ; // left-bottom -> right-top int row = 0 ; int col = 0 ; for ( int i = 0 ; i < m * n ; ++ i ) { ans [ i ] = matrix [ row ][ col ]; row -= d ; col += d ; // out-of-bounds if ( row == m ) row = m - 1 , col += 2 , d = - d ; if ( col == n ) col = n - 1 , row += 2 , d = - d ; if ( row < 0 ) row = 0 , d = - d ; if ( col < 0 ) col = 0 , d = - d ; } return ans ; } };","title":"498. Diagonal Traverse"},{"location":"problems/0499/","text":"499. The Maze III \ud83d\udd12","title":"499. The Maze III"},{"location":"problems/0499/#499-the-maze-iii","text":"","title":"499. The Maze III \ud83d\udd12"},{"location":"problems/0500/","text":"500. Keyboard Row Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < string > findWords ( vector < string >& words ) { vector < string > ans ; const vector < int > rows { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( const string & word : words ) { string lowerWord = word ; transform ( begin ( lowerWord ), end ( lowerWord ), begin ( lowerWord ), :: tolower ); const int row = rows [ lowerWord [ 0 ] - 'a' ]; const bool isValid = all_of ( begin ( lowerWord ), end ( lowerWord ), [ & ]( int c ) { return rows [ c - 'a' ] == row ; }); if ( isValid ) ans . push_back ( word ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String [] findWords ( String [] words ) { List < String > ans = new ArrayList <> (); int [] rows = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( final String word : words ) { String lowerWord = word . toLowerCase (); int row = rows [ lowerWord . charAt ( 0 ) - 'a' ] ; boolean isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord . charAt ( i ) - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . add ( word ); } return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findWords ( self , words : List [ str ]) -> List [ str ]: ans = [] rows = [ set ( 'qwertyuiop' ), set ( 'asdfghjkl' ), set ( 'zxcvbnm' )] for word in words : lowerWord = set ( word . lower ()) if any ( lowerWord <= row for row in rows ): ans . append ( word ) return ans","title":"500. Keyboard Row"},{"location":"problems/0500/#500-keyboard-row","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < string > findWords ( vector < string >& words ) { vector < string > ans ; const vector < int > rows { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( const string & word : words ) { string lowerWord = word ; transform ( begin ( lowerWord ), end ( lowerWord ), begin ( lowerWord ), :: tolower ); const int row = rows [ lowerWord [ 0 ] - 'a' ]; const bool isValid = all_of ( begin ( lowerWord ), end ( lowerWord ), [ & ]( int c ) { return rows [ c - 'a' ] == row ; }); if ( isValid ) ans . push_back ( word ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String [] findWords ( String [] words ) { List < String > ans = new ArrayList <> (); int [] rows = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( final String word : words ) { String lowerWord = word . toLowerCase (); int row = rows [ lowerWord . charAt ( 0 ) - 'a' ] ; boolean isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord . charAt ( i ) - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . add ( word ); } return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findWords ( self , words : List [ str ]) -> List [ str ]: ans = [] rows = [ set ( 'qwertyuiop' ), set ( 'asdfghjkl' ), set ( 'zxcvbnm' )] for word in words : lowerWord = set ( word . lower ()) if any ( lowerWord <= row for row in rows ): ans . append ( word ) return ans","title":"500. Keyboard Row"},{"location":"problems/0501/","text":"501. Find Mode in Binary Search Tree Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > findMode ( TreeNode * root ) { vector < int > ans ; TreeNode * pred ; int count = 0 ; int maxCount = 0 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( pred && pred -> val == root -> val ) ++ count ; else count = 1 ; if ( count > maxCount ) { maxCount = count ; ans = { root -> val }; } else if ( count == maxCount ) { ans . push_back ( root -> val ); } pred = root ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"501. Find Mode in Binary Search Tree"},{"location":"problems/0501/#501-find-mode-in-binary-search-tree","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > findMode ( TreeNode * root ) { vector < int > ans ; TreeNode * pred ; int count = 0 ; int maxCount = 0 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( pred && pred -> val == root -> val ) ++ count ; else count = 1 ; if ( count > maxCount ) { maxCount = count ; ans = { root -> val }; } else if ( count == maxCount ) { ans . push_back ( root -> val ); } pred = root ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"501. Find Mode in Binary Search Tree"},{"location":"problems/0502/","text":"502. IPO Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Item { int profit ; int capital ; }; class Solution { public : int findMaximizedCapital ( int k , int W , vector < int >& Profits , vector < int >& Capital ) { auto compareC = []( const Item & a , const Item & b ) { return a . capital > b . capital ; }; auto compareP = []( const Item & a , const Item & b ) { return a . profit < b . profit ; }; priority_queue < Item , vector < Item > , decltype ( compareC ) > pqCap ( compareC ); priority_queue < Item , vector < Item > , decltype ( compareP ) > pqPro ( compareP ); for ( int i = 0 ; i < Capital . size (); ++ i ) pqCap . push ({ Profits [ i ], Capital [ i ]}); while ( k -- ) { while ( ! pqCap . empty () && pqCap . top (). capital <= W ) pqPro . push ( pqCap . top ()), pqCap . pop (); if ( pqPro . empty ()) break ; W += pqPro . top (). profit , pqPro . pop (); } return W ; } };","title":"502. IPO"},{"location":"problems/0502/#502-ipo","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Item { int profit ; int capital ; }; class Solution { public : int findMaximizedCapital ( int k , int W , vector < int >& Profits , vector < int >& Capital ) { auto compareC = []( const Item & a , const Item & b ) { return a . capital > b . capital ; }; auto compareP = []( const Item & a , const Item & b ) { return a . profit < b . profit ; }; priority_queue < Item , vector < Item > , decltype ( compareC ) > pqCap ( compareC ); priority_queue < Item , vector < Item > , decltype ( compareP ) > pqPro ( compareP ); for ( int i = 0 ; i < Capital . size (); ++ i ) pqCap . push ({ Profits [ i ], Capital [ i ]}); while ( k -- ) { while ( ! pqCap . empty () && pqCap . top (). capital <= W ) pqPro . push ( pqCap . top ()), pqCap . pop (); if ( pqPro . empty ()) break ; W += pqPro . top (). profit , pqPro . pop (); } return W ; } };","title":"502. IPO"},{"location":"problems/0503/","text":"503. Next Greater Element II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { vector < int > ans ( nums . size (), -1 ); stack < int > stack ; // decreasing stack storing indices for ( int i = 0 ; i < nums . size () * 2 ; ++ i ) { const int num = nums [ i % nums . size ()]; while ( ! stack . empty () && nums [ stack . top ()] < num ) ans [ stack . top ()] = num , stack . pop (); if ( i < nums . size ()) stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] nextGreaterElements ( int [] nums ) { int [] ans = new int [ nums . length ] ; Arrays . fill ( ans , - 1 ); Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < nums . length * 2 ; ++ i ) { int num = nums [ i % nums . length ] ; while ( ! stack . isEmpty () && nums [ stack . peek () ] < num ) ans [ stack . pop () ] = num ; if ( i < nums . length ) stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def nextGreaterElements ( self , nums : List [ int ]) -> List [ int ]: ans = [ - 1 ] * len ( nums ) stack = [] for i in range ( len ( nums ) * 2 ): num = nums [ i % len ( nums )] while stack and nums [ stack [ - 1 ]] < num : ans [ stack . pop ()] = num if i < len ( nums ): stack . append ( i ) return ans","title":"503. Next Greater Element II"},{"location":"problems/0503/#503-next-greater-element-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { vector < int > ans ( nums . size (), -1 ); stack < int > stack ; // decreasing stack storing indices for ( int i = 0 ; i < nums . size () * 2 ; ++ i ) { const int num = nums [ i % nums . size ()]; while ( ! stack . empty () && nums [ stack . top ()] < num ) ans [ stack . top ()] = num , stack . pop (); if ( i < nums . size ()) stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] nextGreaterElements ( int [] nums ) { int [] ans = new int [ nums . length ] ; Arrays . fill ( ans , - 1 ); Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < nums . length * 2 ; ++ i ) { int num = nums [ i % nums . length ] ; while ( ! stack . isEmpty () && nums [ stack . peek () ] < num ) ans [ stack . pop () ] = num ; if ( i < nums . length ) stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def nextGreaterElements ( self , nums : List [ int ]) -> List [ int ]: ans = [ - 1 ] * len ( nums ) stack = [] for i in range ( len ( nums ) * 2 ): num = nums [ i % len ( nums )] while stack and nums [ stack [ - 1 ]] < num : ans [ stack . pop ()] = num if i < len ( nums ): stack . append ( i ) return ans","title":"503. Next Greater Element II"},{"location":"problems/0504/","text":"504. Base 7 Time: $O(\\log_7 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : string convertToBase7 ( int num ) { if ( num < 0 ) return \"-\" + convertToBase7 ( - num ); if ( num < 7 ) return to_string ( num ); return convertToBase7 ( num / 7 ) + to_string ( num % 7 ); } };","title":"504. Base 7"},{"location":"problems/0504/#504-base-7","text":"Time: $O(\\log_7 n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : string convertToBase7 ( int num ) { if ( num < 0 ) return \"-\" + convertToBase7 ( - num ); if ( num < 7 ) return to_string ( num ); return convertToBase7 ( num / 7 ) + to_string ( num % 7 ); } };","title":"504. Base 7"},{"location":"problems/0505/","text":"505. The Maze II \ud83d\udd12","title":"505. The Maze II"},{"location":"problems/0505/#505-the-maze-ii","text":"","title":"505. The Maze II \ud83d\udd12"},{"location":"problems/0506/","text":"506. Relative Ranks Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > findRelativeRanks ( vector < int >& nums ) { const int n = nums . size (); vector < string > ans ( n ); vector < int > indices ( n ); for ( int i = 0 ; i < n ; ++ i ) indices [ i ] = i ; sort ( begin ( indices ), end ( indices ), [ & ]( const int a , const int b ) { return nums [ a ] > nums [ b ]; }); for ( int i = 0 ; i < n ; ++ i ) if ( i == 0 ) ans [ indices [ 0 ]] = \"Gold Medal\" ; else if ( i == 1 ) ans [ indices [ 1 ]] = \"Silver Medal\" ; else if ( i == 2 ) ans [ indices [ 2 ]] = \"Bronze Medal\" ; else ans [ indices [ i ]] = to_string ( i + 1 ); return ans ; } };","title":"506. Relative Ranks"},{"location":"problems/0506/#506-relative-ranks","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > findRelativeRanks ( vector < int >& nums ) { const int n = nums . size (); vector < string > ans ( n ); vector < int > indices ( n ); for ( int i = 0 ; i < n ; ++ i ) indices [ i ] = i ; sort ( begin ( indices ), end ( indices ), [ & ]( const int a , const int b ) { return nums [ a ] > nums [ b ]; }); for ( int i = 0 ; i < n ; ++ i ) if ( i == 0 ) ans [ indices [ 0 ]] = \"Gold Medal\" ; else if ( i == 1 ) ans [ indices [ 1 ]] = \"Silver Medal\" ; else if ( i == 2 ) ans [ indices [ 2 ]] = \"Bronze Medal\" ; else ans [ indices [ i ]] = to_string ( i + 1 ); return ans ; } };","title":"506. Relative Ranks"},{"location":"problems/0507/","text":"507. Perfect Number Time: $O(\\sqrt n) \\to O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } } Python 1 2 3 class Solution : def checkPerfectNumber ( self , num : int ) -> bool : return num in { 6 , 28 , 496 , 8128 , 33550336 }","title":"507. Perfect Number"},{"location":"problems/0507/#507-perfect-number","text":"Time: $O(\\sqrt n) \\to O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } } Python 1 2 3 class Solution : def checkPerfectNumber ( self , num : int ) -> bool : return num in { 6 , 28 , 496 , 8128 , 33550336 }","title":"507. Perfect Number"},{"location":"problems/0508/","text":"508. Most Frequent Subtree Sum Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < int > ans ; unordered_map < int , int > count ; int maxCount = 0 ; function < int ( TreeNode * ) > sumDownFrom = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int sum = root -> val + sumDownFrom ( root -> left ) + sumDownFrom ( root -> right ); ++ count [ sum ]; return sum ; }; sumDownFrom ( root ); for ( const auto & [ _ , freq ] : count ) maxCount = max ( maxCount , freq ); for ( const auto & [ sum , freq ] : count ) if ( freq == maxCount ) ans . push_back ( sum ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [] findFrequentTreeSum ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); int maxFreq = 0 ; dfs ( root , count ); for ( int freq : count . values ()) maxFreq = Math . max ( maxFreq , freq ); for ( int sum : count . keySet ()) if ( count . get ( sum ) == maxFreq ) ans . add ( sum ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int dfs ( TreeNode root , Map < Integer , Integer > count ) { if ( root == null ) return 0 ; int sum = root . val + dfs ( root . left , count ) + dfs ( root . right , count ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); return sum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def findFrequentTreeSum ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode ) -> int : if root is None : return 0 sum = root . val + dfs ( root . left ) + dfs ( root . right ) count [ sum ] += 1 return sum if root is None : return [] count = collections . Counter () dfs ( root ) maxFreq = max ( count . values ()) return [ sum for sum in count if count [ sum ] == maxFreq ]","title":"508. Most Frequent Subtree Sum"},{"location":"problems/0508/#508-most-frequent-subtree-sum","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < int > ans ; unordered_map < int , int > count ; int maxCount = 0 ; function < int ( TreeNode * ) > sumDownFrom = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int sum = root -> val + sumDownFrom ( root -> left ) + sumDownFrom ( root -> right ); ++ count [ sum ]; return sum ; }; sumDownFrom ( root ); for ( const auto & [ _ , freq ] : count ) maxCount = max ( maxCount , freq ); for ( const auto & [ sum , freq ] : count ) if ( freq == maxCount ) ans . push_back ( sum ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [] findFrequentTreeSum ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); int maxFreq = 0 ; dfs ( root , count ); for ( int freq : count . values ()) maxFreq = Math . max ( maxFreq , freq ); for ( int sum : count . keySet ()) if ( count . get ( sum ) == maxFreq ) ans . add ( sum ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int dfs ( TreeNode root , Map < Integer , Integer > count ) { if ( root == null ) return 0 ; int sum = root . val + dfs ( root . left , count ) + dfs ( root . right , count ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); return sum ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def findFrequentTreeSum ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode ) -> int : if root is None : return 0 sum = root . val + dfs ( root . left ) + dfs ( root . right ) count [ sum ] += 1 return sum if root is None : return [] count = collections . Counter () dfs ( root ) maxFreq = max ( count . values ()) return [ sum for sum in count if count [ sum ] == maxFreq ]","title":"508. Most Frequent Subtree Sum"},{"location":"problems/0509/","text":"509. Fibonacci Number Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; vector < int > dp { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ] ; dp [ 1 ] = dp [ 2 ] ; dp [ 2 ] = dp [ 0 ] + dp [ 1 ] ; } return dp [ 2 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ]","title":"509. Fibonacci Number"},{"location":"problems/0509/#509-fibonacci-number","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; vector < int > dp { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ] ; dp [ 1 ] = dp [ 2 ] ; dp [ 2 ] = dp [ 0 ] + dp [ 1 ] ; } return dp [ 2 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ]","title":"509. Fibonacci Number"},{"location":"problems/0510/","text":"510. Inorder Successor in BST II \ud83d\udd12","title":"510. Inorder Successor in BST II"},{"location":"problems/0510/#510-inorder-successor-in-bst-ii","text":"","title":"510. Inorder Successor in BST II \ud83d\udd12"},{"location":"problems/0511/","text":"511. Game Play Analysis I \ud83d\udd12","title":"511. Game Play Analysis I"},{"location":"problems/0511/#511-game-play-analysis-i","text":"","title":"511. Game Play Analysis I \ud83d\udd12"},{"location":"problems/0512/","text":"512. Game Play Analysis II \ud83d\udd12","title":"512. Game Play Analysis II"},{"location":"problems/0512/#512-game-play-analysis-ii","text":"","title":"512. Game Play Analysis II \ud83d\udd12"},{"location":"problems/0513/","text":"513. Find Bottom Left Tree Value Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findBottomLeftValue ( TreeNode * root ) { queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { root = q . front (), q . pop (); if ( root -> right ) q . push ( root -> right ); if ( root -> left ) q . push ( root -> left ); } return root -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findBottomLeftValue ( TreeNode root ) { Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { root = queue . poll (); if ( root . right != null ) queue . add ( root . right ); if ( root . left != null ) queue . add ( root . left ); } return root . val ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findBottomLeftValue ( self , root : TreeNode ) -> int : queue = collections . deque ([ root ]) while queue : root = queue . popleft () if root . right : queue . append ( root . right ) if root . left : queue . append ( root . left ) return root . val","title":"513. Find Bottom Left Tree Value"},{"location":"problems/0513/#513-find-bottom-left-tree-value","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findBottomLeftValue ( TreeNode * root ) { queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { root = q . front (), q . pop (); if ( root -> right ) q . push ( root -> right ); if ( root -> left ) q . push ( root -> left ); } return root -> val ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findBottomLeftValue ( TreeNode root ) { Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { root = queue . poll (); if ( root . right != null ) queue . add ( root . right ); if ( root . left != null ) queue . add ( root . left ); } return root . val ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findBottomLeftValue ( self , root : TreeNode ) -> int : queue = collections . deque ([ root ]) while queue : root = queue . popleft () if root . right : queue . append ( root . right ) if root . left : queue . append ( root . left ) return root . val","title":"513. Find Bottom Left Tree Value"},{"location":"problems/0514/","text":"514. Freedom Trail Time: $O(kr^2)$, where k = len(key) and r = len(ring) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int findRotateSteps ( string ring , string key ) { unordered_map < string , int > memo ; function < int ( const string & , int ) > dfs = [ & ]( const string & ring , int s ) { if ( s == key . length ()) return 0 ; // add the index to prevent duplicate const string hashKey = ring + to_string ( s ); if ( memo . count ( hashKey )) return memo [ hashKey ]; int ans = INT_MAX ; for ( size_t i = 0 ; i < ring . length (); ++ i ) if ( ring [ i ] == key [ s ]) { // #rotates of the ring to match key[s] const int diff = min ( i , ring . length () - i ); // match next index const int step = dfs ( ring . substr ( i ) + ring . substr ( 0 , i ), s + 1 ); ans = min ( ans , diff + step ); } return memo [ hashKey ] = ans ; }; return dfs ( ring , 0 ) + key . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int findRotateSteps ( String ring , String key ) { Map < String , Integer > memo = new HashMap <> (); return dfs ( ring , key , 0 , memo ) + key . length (); } private int dfs ( final String ring , final String key , int index , Map < String , Integer > memo ) { if ( index == key . length ()) return 0 ; final String hashKey = ring + index ; if ( memo . containsKey ( hashKey )) return memo . get ( hashKey ); int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring . charAt ( i ) == key . charAt ( index )) { int diff = Math . min ( i , ring . length () - i ); int step = dfs ( ring . substring ( i ) + ring . substring ( 0 , i ), key , index + 1 , memo ); ans = Math . min ( ans , diff + step ); } memo . put ( hashKey , ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def findRotateSteps ( self , ring : str , key : str ) -> int : def dfs ( ring : str , index : int ) -> int : if index == len ( key ): return 0 if ( ring , index ) in memo : return memo [( ring , index )] ans = float ( 'inf' ) for i , r in enumerate ( ring ): if r == key [ index ]: diff = min ( i , len ( ring ) - i ) step = dfs ( ring [ i :] + ring [: i ], index + 1 ) ans = min ( ans , diff + step ) memo [( ring , index )] = ans return ans memo = {} return dfs ( ring , 0 ) + len ( key )","title":"514. Freedom Trail"},{"location":"problems/0514/#514-freedom-trail","text":"Time: $O(kr^2)$, where k = len(key) and r = len(ring) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int findRotateSteps ( string ring , string key ) { unordered_map < string , int > memo ; function < int ( const string & , int ) > dfs = [ & ]( const string & ring , int s ) { if ( s == key . length ()) return 0 ; // add the index to prevent duplicate const string hashKey = ring + to_string ( s ); if ( memo . count ( hashKey )) return memo [ hashKey ]; int ans = INT_MAX ; for ( size_t i = 0 ; i < ring . length (); ++ i ) if ( ring [ i ] == key [ s ]) { // #rotates of the ring to match key[s] const int diff = min ( i , ring . length () - i ); // match next index const int step = dfs ( ring . substr ( i ) + ring . substr ( 0 , i ), s + 1 ); ans = min ( ans , diff + step ); } return memo [ hashKey ] = ans ; }; return dfs ( ring , 0 ) + key . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int findRotateSteps ( String ring , String key ) { Map < String , Integer > memo = new HashMap <> (); return dfs ( ring , key , 0 , memo ) + key . length (); } private int dfs ( final String ring , final String key , int index , Map < String , Integer > memo ) { if ( index == key . length ()) return 0 ; final String hashKey = ring + index ; if ( memo . containsKey ( hashKey )) return memo . get ( hashKey ); int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring . charAt ( i ) == key . charAt ( index )) { int diff = Math . min ( i , ring . length () - i ); int step = dfs ( ring . substring ( i ) + ring . substring ( 0 , i ), key , index + 1 , memo ); ans = Math . min ( ans , diff + step ); } memo . put ( hashKey , ans ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def findRotateSteps ( self , ring : str , key : str ) -> int : def dfs ( ring : str , index : int ) -> int : if index == len ( key ): return 0 if ( ring , index ) in memo : return memo [( ring , index )] ans = float ( 'inf' ) for i , r in enumerate ( ring ): if r == key [ index ]: diff = min ( i , len ( ring ) - i ) step = dfs ( ring [ i :] + ring [: i ], index + 1 ) ans = min ( ans , diff + step ) memo [( ring , index )] = ans return ans memo = {} return dfs ( ring , 0 ) + len ( key )","title":"514. Freedom Trail"},{"location":"problems/0515/","text":"515. Find Largest Value in Each Tree Row Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > largestValues ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { int maxi = INT_MIN ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); maxi = max ( maxi , root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( maxi ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < Integer > largestValues ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { int max = Integer . MIN_VALUE ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . poll (); max = Math . max ( max , root . val ); if ( root . left != null ) queue . add ( root . left ); if ( root . right != null ) queue . add ( root . right ); } ans . add ( max ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def largestValues ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : maxi = float ( '-inf' ) for _ in range ( len ( queue )): root = queue . popleft () maxi = max ( maxi , root . val ) if root . left : queue . append ( root . left ) if root . right : queue . append ( root . right ) ans . append ( maxi ) return ans","title":"515. Find Largest Value in Each Tree Row"},{"location":"problems/0515/#515-find-largest-value-in-each-tree-row","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > largestValues ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { int maxi = INT_MIN ; for ( int i = q . size (); i > 0 ; -- i ) { root = q . front (), q . pop (); maxi = max ( maxi , root -> val ); if ( root -> left ) q . push ( root -> left ); if ( root -> right ) q . push ( root -> right ); } ans . push_back ( maxi ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < Integer > largestValues ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { int max = Integer . MIN_VALUE ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . poll (); max = Math . max ( max , root . val ); if ( root . left != null ) queue . add ( root . left ); if ( root . right != null ) queue . add ( root . right ); } ans . add ( max ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def largestValues ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : maxi = float ( '-inf' ) for _ in range ( len ( queue )): root = queue . popleft () maxi = max ( maxi , root . val ) if root . left : queue . append ( root . left ) if root . right : queue . append ( root . right ) ans . append ( maxi ) return ans","title":"515. Find Largest Value in Each Tree Row"},{"location":"problems/0516/","text":"516. Longest Palindromic Subsequence Approach 1: Bottom-up Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int longestPalindromeSubseq ( string s ) { const int n = s . length (); // dp[i][j] := LPS's length in s[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( s [ i ] == s [ j ]) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int longestPalindromeSubseq ( String s ) { final int n = s . length (); // dp[i][j] := LPS's length in s[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( s . charAt ( i ) == s . charAt ( j )) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i + 1 ][ j ] , dp [ i ][ j - 1 ] ); } return dp [ 0 ][ n - 1 ] ; } } Approach 2: Top-down Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int longestPalindromeSubseq ( string s ) { const int n = s . length (); vector < vector < int >> memo ( n , vector < int > ( n )); // dp(i, j) := LPS's length in s[i..j] function < int ( int , int ) > dp = [ & ]( int i , int j ) { if ( i > j ) return 0 ; if ( i == j ) return 1 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; if ( s [ i ] == s [ j ]) return ans = 2 + dp ( i + 1 , j - 1 ); return ans = max ( dp ( i + 1 , j ), dp ( i , j - 1 )); }; return dp ( 0 , n - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int longestPalindromeSubseq ( String s ) { final int n = s . length (); memo = new int [ n ][ n ] ; return dp ( s , 0 , n - 1 ); } private int [][] memo ; // dp(s, i, j) := LPS's length in s[i..j] private int dp ( final String s , int i , int j ) { if ( i > j ) return 0 ; if ( i == j ) return 1 ; if ( memo [ i ][ j ] > 0 ) return memo [ i ][ j ] ; if ( s . charAt ( i ) == s . charAt ( j )) return memo [ i ][ j ] = 2 + dp ( s , i + 1 , j - 1 ); return memo [ i ][ j ] = Math . max ( dp ( s , i + 1 , j ), dp ( s , i , j - 1 )); } }","title":"516. Longest Palindromic Subsequence"},{"location":"problems/0516/#516-longest-palindromic-subsequence","text":"","title":"516. Longest Palindromic Subsequence"},{"location":"problems/0516/#approach-1-bottom-up","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int longestPalindromeSubseq ( string s ) { const int n = s . length (); // dp[i][j] := LPS's length in s[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( s [ i ] == s [ j ]) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int longestPalindromeSubseq ( String s ) { final int n = s . length (); // dp[i][j] := LPS's length in s[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( s . charAt ( i ) == s . charAt ( j )) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i + 1 ][ j ] , dp [ i ][ j - 1 ] ); } return dp [ 0 ][ n - 1 ] ; } }","title":"Approach 1: Bottom-up"},{"location":"problems/0516/#approach-2-top-down","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int longestPalindromeSubseq ( string s ) { const int n = s . length (); vector < vector < int >> memo ( n , vector < int > ( n )); // dp(i, j) := LPS's length in s[i..j] function < int ( int , int ) > dp = [ & ]( int i , int j ) { if ( i > j ) return 0 ; if ( i == j ) return 1 ; int & ans = memo [ i ][ j ]; if ( ans ) return ans ; if ( s [ i ] == s [ j ]) return ans = 2 + dp ( i + 1 , j - 1 ); return ans = max ( dp ( i + 1 , j ), dp ( i , j - 1 )); }; return dp ( 0 , n - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int longestPalindromeSubseq ( String s ) { final int n = s . length (); memo = new int [ n ][ n ] ; return dp ( s , 0 , n - 1 ); } private int [][] memo ; // dp(s, i, j) := LPS's length in s[i..j] private int dp ( final String s , int i , int j ) { if ( i > j ) return 0 ; if ( i == j ) return 1 ; if ( memo [ i ][ j ] > 0 ) return memo [ i ][ j ] ; if ( s . charAt ( i ) == s . charAt ( j )) return memo [ i ][ j ] = 2 + dp ( s , i + 1 , j - 1 ); return memo [ i ][ j ] = Math . max ( dp ( s , i + 1 , j ), dp ( s , i , j - 1 )); } }","title":"Approach 2: Top-down"},{"location":"problems/0517/","text":"517. Super Washing Machines Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMinMoves ( vector < int >& machines ) { const int dresses = accumulate ( begin ( machines ), end ( machines ), 0 ); if ( dresses % machines . size () != 0 ) return -1 ; int ans = 0 ; int inout = 0 ; const int average = dresses / machines . size (); for ( const int dress : machines ) { inout += dress - average ; ans = max ({ ans , abs ( inout ), dress - average }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findMinMoves ( int [] machines ) { int dresses = Arrays . stream ( machines ). sum (); if ( dresses % machines . length != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . length ; int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = Math . max ( ans , Math . max ( Math . abs ( inout ), dress - average )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findMinMoves ( self , machines : List [ int ]) -> int : dresses = sum ( machines ) if dresses % len ( machines ) != 0 : return - 1 ans = 0 average = dresses // len ( machines ) inout = 0 for dress in machines : inout += dress - average ans = max ( ans , abs ( inout ), dress - average ) return ans","title":"517. Super Washing Machines"},{"location":"problems/0517/#517-super-washing-machines","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMinMoves ( vector < int >& machines ) { const int dresses = accumulate ( begin ( machines ), end ( machines ), 0 ); if ( dresses % machines . size () != 0 ) return -1 ; int ans = 0 ; int inout = 0 ; const int average = dresses / machines . size (); for ( const int dress : machines ) { inout += dress - average ; ans = max ({ ans , abs ( inout ), dress - average }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findMinMoves ( int [] machines ) { int dresses = Arrays . stream ( machines ). sum (); if ( dresses % machines . length != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . length ; int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = Math . max ( ans , Math . max ( Math . abs ( inout ), dress - average )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findMinMoves ( self , machines : List [ int ]) -> int : dresses = sum ( machines ) if dresses % len ( machines ) != 0 : return - 1 ans = 0 average = dresses // len ( machines ) inout = 0 for dress in machines : inout += dress - average ans = max ( ans , abs ( inout ), dress - average ) return ans","title":"517. Super Washing Machines"},{"location":"problems/0518/","text":"518. Coin Change 2 Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int change ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 ); dp [ 0 ] = 1 ; for ( const int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ]; return dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int change ( int amount , int [] coins ) { int [] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ] ; return dp [ amount ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def change ( self , amount : int , coins : List [ int ]) -> int : dp = [ 1 ] + [ 0 ] * amount for coin in coins : for i in range ( coin , amount + 1 ): dp [ i ] += dp [ i - coin ] return dp [ amount ]","title":"518. Coin Change 2"},{"location":"problems/0518/#518-coin-change-2","text":"Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int change ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 ); dp [ 0 ] = 1 ; for ( const int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ]; return dp [ amount ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int change ( int amount , int [] coins ) { int [] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ] ; return dp [ amount ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def change ( self , amount : int , coins : List [ int ]) -> int : dp = [ 1 ] + [ 0 ] * amount for coin in coins : for i in range ( coin , amount + 1 ): dp [ i ] += dp [ i - coin ] return dp [ amount ]","title":"518. Coin Change 2"},{"location":"problems/0519/","text":"519. Random Flip Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : Solution ( int n_rows , int n_cols ) : rows ( n_rows ), cols ( n_cols ), total ( n_rows * n_cols ) {} vector < int > flip () { // all candidates are used out if ( used . size () == total ) return {}; int index = rand () % total ; while ( used . count ( index )) index = ++ index % total ; used . insert ( index ); return { index / cols , index % cols }; } void reset () { used = {}; } private : unordered_set < int > used ; int total ; int rows ; int cols ; };","title":"519. Random Flip Matrix"},{"location":"problems/0519/#519-random-flip-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : Solution ( int n_rows , int n_cols ) : rows ( n_rows ), cols ( n_cols ), total ( n_rows * n_cols ) {} vector < int > flip () { // all candidates are used out if ( used . size () == total ) return {}; int index = rand () % total ; while ( used . count ( index )) index = ++ index % total ; used . insert ( index ); return { index / cols , index % cols }; } void reset () { used = {}; } private : unordered_set < int > used ; int total ; int rows ; int cols ; };","title":"519. Random Flip Matrix"},{"location":"problems/0520/","text":"520. Detect Capital Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool detectCapitalUse ( string word ) { for ( int i = 1 ; i < word . length (); ++ i ) if ( isupper ( word [ 1 ]) != isupper ( word [ i ]) || islower ( word [ 0 ]) && isupper ( word [ i ])) return false ; return true ; } }; Java 1 2 3 4 5 class Solution { public boolean detectCapitalUse ( String word ) { return word . equals ( word . toUpperCase ()) || word . substring ( 1 ). equals ( word . substring ( 1 ). toLowerCase ()); } } Python 1 2 3 class Solution : def detectCapitalUse ( self , word : str ) -> bool : return word . isupper () or word . islower () or word . istitle ()","title":"520. Detect Capital"},{"location":"problems/0520/#520-detect-capital","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool detectCapitalUse ( string word ) { for ( int i = 1 ; i < word . length (); ++ i ) if ( isupper ( word [ 1 ]) != isupper ( word [ i ]) || islower ( word [ 0 ]) && isupper ( word [ i ])) return false ; return true ; } }; Java 1 2 3 4 5 class Solution { public boolean detectCapitalUse ( String word ) { return word . equals ( word . toUpperCase ()) || word . substring ( 1 ). equals ( word . substring ( 1 ). toLowerCase ()); } } Python 1 2 3 class Solution : def detectCapitalUse ( self , word : str ) -> bool : return word . isupper () or word . islower () or word . istitle ()","title":"520. Detect Capital"},{"location":"problems/0521/","text":"521. Longest Uncommon Subsequence I Time: $O(\\max(|a|, |b|))$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int findLUSlength ( string a , string b ) { return a == b ? -1 : max ( a . length (), b . length ()); } }; Java 1 2 3 4 5 class Solution { public int findLUSlength ( String a , String b ) { return a . equals ( b ) ? - 1 : Math . max ( a . length (), b . length ()); } } Python 1 2 3 class Solution : def findLUSlength ( self , a : str , b : str ) -> int : return - 1 if a == b else max ( len ( a ), len ( b ))","title":"521. Longest Uncommon Subsequence I"},{"location":"problems/0521/#521-longest-uncommon-subsequence-i","text":"Time: $O(\\max(|a|, |b|))$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int findLUSlength ( string a , string b ) { return a == b ? -1 : max ( a . length (), b . length ()); } }; Java 1 2 3 4 5 class Solution { public int findLUSlength ( String a , String b ) { return a . equals ( b ) ? - 1 : Math . max ( a . length (), b . length ()); } } Python 1 2 3 class Solution : def findLUSlength ( self , a : str , b : str ) -> int : return - 1 if a == b else max ( len ( a ), len ( b ))","title":"521. Longest Uncommon Subsequence I"},{"location":"problems/0522/","text":"522. Longest Uncommon Subsequence II Time: $O(n^2l)$, where n = len(strs) and l = max length of strs Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int findLUSlength ( vector < string >& strs ) { unordered_set < string > seen ; unordered_set < string > duplicates ; for ( const string & str : strs ) if ( seen . count ( str )) duplicates . insert ( str ); else seen . insert ( str ); sort ( begin ( strs ), end ( strs ), []( const auto & a , const auto & b ) { return a . length () > b . length (); }); // check if a is a subsequence of b auto isSubsequence = []( const string & a , const string & b ) { int i = 0 ; for ( const char c : b ) if ( c == a [ i ]) ++ i ; return i == a . length (); }; for ( int i = 0 ; i < strs . size (); ++ i ) { if ( duplicates . count ( strs [ i ])) continue ; bool isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]); if ( ! isASubsequence ) return strs [ i ]. length (); } return -1 ; } private : }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int findLUSlength ( String [] strs ) { Set < String > seen = new HashSet <> (); Set < String > duplicates = new HashSet <> (); for ( final String str : strs ) { if ( seen . contains ( str )) duplicates . add ( str ); seen . add ( str ); } Arrays . sort ( strs , ( a , b ) -> b . length () - a . length ()); for ( int i = 0 ; i < strs . length ; ++ i ) { if ( duplicates . contains ( strs [ i ] )) continue ; boolean isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ); if ( ! isASubsequence ) return strs [ i ] . length (); } return - 1 ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a . charAt ( i ) == b . charAt ( j )) ++ i ; return i == a . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def findLUSlength ( self , strs : List [ str ]) -> int : def isSubsequence ( a : str , b : str ) -> bool : i = 0 j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] == b [ j ]: i += 1 j += 1 return i == len ( a ) seen = set () duplicates = set () for s in strs : if s in seen : duplicates . add ( s ) seen . add ( s ) strs . sort ( key = lambda s : - len ( s )) for i in range ( len ( strs )): if strs [ i ] in duplicates : continue isASubsequence = False for j in range ( i ): isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]) if not isASubsequence : return len ( strs [ i ]) return - 1","title":"522. Longest Uncommon Subsequence II"},{"location":"problems/0522/#522-longest-uncommon-subsequence-ii","text":"Time: $O(n^2l)$, where n = len(strs) and l = max length of strs Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int findLUSlength ( vector < string >& strs ) { unordered_set < string > seen ; unordered_set < string > duplicates ; for ( const string & str : strs ) if ( seen . count ( str )) duplicates . insert ( str ); else seen . insert ( str ); sort ( begin ( strs ), end ( strs ), []( const auto & a , const auto & b ) { return a . length () > b . length (); }); // check if a is a subsequence of b auto isSubsequence = []( const string & a , const string & b ) { int i = 0 ; for ( const char c : b ) if ( c == a [ i ]) ++ i ; return i == a . length (); }; for ( int i = 0 ; i < strs . size (); ++ i ) { if ( duplicates . count ( strs [ i ])) continue ; bool isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]); if ( ! isASubsequence ) return strs [ i ]. length (); } return -1 ; } private : }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int findLUSlength ( String [] strs ) { Set < String > seen = new HashSet <> (); Set < String > duplicates = new HashSet <> (); for ( final String str : strs ) { if ( seen . contains ( str )) duplicates . add ( str ); seen . add ( str ); } Arrays . sort ( strs , ( a , b ) -> b . length () - a . length ()); for ( int i = 0 ; i < strs . length ; ++ i ) { if ( duplicates . contains ( strs [ i ] )) continue ; boolean isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ); if ( ! isASubsequence ) return strs [ i ] . length (); } return - 1 ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a . charAt ( i ) == b . charAt ( j )) ++ i ; return i == a . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def findLUSlength ( self , strs : List [ str ]) -> int : def isSubsequence ( a : str , b : str ) -> bool : i = 0 j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] == b [ j ]: i += 1 j += 1 return i == len ( a ) seen = set () duplicates = set () for s in strs : if s in seen : duplicates . add ( s ) seen . add ( s ) strs . sort ( key = lambda s : - len ( s )) for i in range ( len ( strs )): if strs [ i ] in duplicates : continue isASubsequence = False for j in range ( i ): isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]) if not isASubsequence : return len ( strs [ i ]) return - 1","title":"522. Longest Uncommon Subsequence II"},{"location":"problems/0523/","text":"523. Continuous Subarray Sum Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool checkSubarraySum ( vector < int >& nums , int k ) { unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . count ( prefixSum )) { if ( i - prefixSumToIndex [ prefixSum ] > 1 ) return true ; } else { // only add if absent, because the previous index is better prefixSumToIndex [ prefixSum ] = i ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean checkSubarraySum ( int [] nums , int k ) { int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . containsKey ( prefixSum )) { if ( i - prefixSumToIndex . get ( prefixSum ) > 1 ) return true ; } else prefixSumToIndex . put ( prefixSum , i ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def checkSubarraySum ( self , nums : List [ int ], k : int ) -> bool : prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += num if k != 0 : prefixSum %= k if prefixSum in prefixSumToIndex : if i - prefixSumToIndex [ prefixSum ] > 1 : return True else : prefixSumToIndex [ prefixSum ] = i return False","title":"523. Continuous Subarray Sum"},{"location":"problems/0523/#523-continuous-subarray-sum","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool checkSubarraySum ( vector < int >& nums , int k ) { unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . count ( prefixSum )) { if ( i - prefixSumToIndex [ prefixSum ] > 1 ) return true ; } else { // only add if absent, because the previous index is better prefixSumToIndex [ prefixSum ] = i ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean checkSubarraySum ( int [] nums , int k ) { int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . containsKey ( prefixSum )) { if ( i - prefixSumToIndex . get ( prefixSum ) > 1 ) return true ; } else prefixSumToIndex . put ( prefixSum , i ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def checkSubarraySum ( self , nums : List [ int ], k : int ) -> bool : prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += num if k != 0 : prefixSum %= k if prefixSum in prefixSumToIndex : if i - prefixSumToIndex [ prefixSum ] > 1 : return True else : prefixSumToIndex [ prefixSum ] = i return False","title":"523. Continuous Subarray Sum"},{"location":"problems/0524/","text":"524. Longest Word in Dictionary through Deleting Time: $O(|d||s|)$ Space: $O(|s|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : string findLongestWord ( string s , vector < string >& d ) { string ans ; // check if a is a subsequence of b auto isSubsequence = []( const string & a , const string & b ) { int i = 0 ; for ( const char c : b ) if ( c == a [ i ]) ++ i ; return i == a . length (); }; for ( const string & word : d ) if ( isSubsequence ( word , s )) if ( word . length () > ans . length () || word . length () == ans . length () && word . compare ( ans ) < 0 ) ans = word ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String findLongestWord ( String s , List < String > d ) { String ans = \"\" ; for ( final String word : d ) { int i = 0 ; for ( char c : s . toCharArray ()) if ( i < word . length () && c == word . charAt ( i )) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compareTo ( ans ) < 0 ) ans = word ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def findLongestWord ( self , s : str , d : List [ str ]) -> str : ans = '' for word in d : i = 0 for c in s : if i < len ( word ) and c == word [ i ]: i += 1 if i == len ( word ): if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : ans = word return ans","title":"524. Longest Word in Dictionary through Deleting"},{"location":"problems/0524/#524-longest-word-in-dictionary-through-deleting","text":"Time: $O(|d||s|)$ Space: $O(|s|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : string findLongestWord ( string s , vector < string >& d ) { string ans ; // check if a is a subsequence of b auto isSubsequence = []( const string & a , const string & b ) { int i = 0 ; for ( const char c : b ) if ( c == a [ i ]) ++ i ; return i == a . length (); }; for ( const string & word : d ) if ( isSubsequence ( word , s )) if ( word . length () > ans . length () || word . length () == ans . length () && word . compare ( ans ) < 0 ) ans = word ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String findLongestWord ( String s , List < String > d ) { String ans = \"\" ; for ( final String word : d ) { int i = 0 ; for ( char c : s . toCharArray ()) if ( i < word . length () && c == word . charAt ( i )) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compareTo ( ans ) < 0 ) ans = word ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def findLongestWord ( self , s : str , d : List [ str ]) -> str : ans = '' for word in d : i = 0 for c in s : if i < len ( word ) and c == word [ i ]: i += 1 if i == len ( word ): if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : ans = word return ans","title":"524. Longest Word in Dictionary through Deleting"},{"location":"problems/0525/","text":"525. Contiguous Array Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxLength ( vector < int >& nums ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ] ? 1 : -1 ; if ( prefixSumToIndex . count ( prefixSum )) ans = max ( ans , i - prefixSumToIndex [ prefixSum ]); else prefixSumToIndex [ prefixSum ] = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMaxLength ( int [] nums ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] == 1 ? 1 : - 1 ; if ( prefixSumToIndex . containsKey ( prefixSum )) ans = Math . max ( ans , i - prefixSumToIndex . get ( prefixSum )); else prefixSumToIndex . put ( prefixSum , i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : ans = 0 prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += 1 if num else - 1 if prefixSum in prefixSumToIndex : ans = max ( ans , i - prefixSumToIndex [ prefixSum ]) else : prefixSumToIndex [ prefixSum ] = i return ans","title":"525. Contiguous Array"},{"location":"problems/0525/#525-contiguous-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxLength ( vector < int >& nums ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , -1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ] ? 1 : -1 ; if ( prefixSumToIndex . count ( prefixSum )) ans = max ( ans , i - prefixSumToIndex [ prefixSum ]); else prefixSumToIndex [ prefixSum ] = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMaxLength ( int [] nums ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] == 1 ? 1 : - 1 ; if ( prefixSumToIndex . containsKey ( prefixSum )) ans = Math . max ( ans , i - prefixSumToIndex . get ( prefixSum )); else prefixSumToIndex . put ( prefixSum , i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : ans = 0 prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += 1 if num else - 1 if prefixSum in prefixSumToIndex : ans = max ( ans , i - prefixSumToIndex [ prefixSum ]) else : prefixSumToIndex [ prefixSum ] = i return ans","title":"525. Contiguous Array"},{"location":"problems/0526/","text":"526. Beautiful Arrangement Time: $O(n2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int countArrangement ( int N ) { string filled ( N + 1 , 'x' ); // positions are filled unordered_map < string , int > memo ; function < int ( int ) > dfs = [ & ]( int num ) { if ( num == N + 1 ) return 1 ; if ( memo . count ( filled )) return memo [ filled ]; int count = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( filled [ i ] == 'x' && ( num % i == 0 || i % num == 0 )) { filled [ i ] = 'o' ; count += dfs ( num + 1 ); filled [ i ] = 'x' ; } return memo [ filled ] = count ; }; return dfs ( 1 ); } };","title":"526. Beautiful Arrangement"},{"location":"problems/0526/#526-beautiful-arrangement","text":"Time: $O(n2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int countArrangement ( int N ) { string filled ( N + 1 , 'x' ); // positions are filled unordered_map < string , int > memo ; function < int ( int ) > dfs = [ & ]( int num ) { if ( num == N + 1 ) return 1 ; if ( memo . count ( filled )) return memo [ filled ]; int count = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( filled [ i ] == 'x' && ( num % i == 0 || i % num == 0 )) { filled [ i ] = 'o' ; count += dfs ( num + 1 ); filled [ i ] = 'x' ; } return memo [ filled ] = count ; }; return dfs ( 1 ); } };","title":"526. Beautiful Arrangement"},{"location":"problems/0527/","text":"527. Word Abbreviation \ud83d\udd12","title":"527. Word Abbreviation"},{"location":"problems/0527/#527-word-abbreviation","text":"","title":"527. Word Abbreviation \ud83d\udd12"},{"location":"problems/0528/","text":"528. Random Pick with Weight Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : Solution ( vector < int >& w ) : accumulated ( move ( w )) { for ( int i = 1 ; i < accumulated . size (); ++ i ) accumulated [ i ] += accumulated [ i - 1 ]; } int pickIndex () { const int target = rand () % accumulated . back (); int l = 0 ; int r = accumulated . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( accumulated [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } private : vector < int > accumulated ; };","title":"528. Random Pick with Weight"},{"location":"problems/0528/#528-random-pick-with-weight","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : Solution ( vector < int >& w ) : accumulated ( move ( w )) { for ( int i = 1 ; i < accumulated . size (); ++ i ) accumulated [ i ] += accumulated [ i - 1 ]; } int pickIndex () { const int target = rand () % accumulated . back (); int l = 0 ; int r = accumulated . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( accumulated [ m ] > target ) r = m ; else l = m + 1 ; } return l ; } private : vector < int > accumulated ; };","title":"528. Random Pick with Weight"},{"location":"problems/0529/","text":"529. Minesweeper Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < vector < char >> updateBoard ( vector < vector < char >>& board , vector < int >& click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } const int m = board . size (); const int n = board [ 0 ]. size (); const vector < pair < int , int >> dirs {{ -1 , -1 }, { -1 , 0 }, { -1 , 1 }, { 0 , -1 }, { 0 , 1 }, { 1 , -1 }, { 1 , 0 }, { 1 , 1 }}; auto getMinesCount = [ & ]( int i , int j ) { int minesCount = 0 ; for ( const auto & [ dx , dy ] : dirs ) { const int x = i + dx ; const int y = j + dy ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] == 'M' ) ++ minesCount ; } return minesCount ; }; function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'E' ) return ; const int minesCount = getMinesCount ( i , j ); board [ i ][ j ] = minesCount == 0 ? 'B' : '0' + minesCount ; if ( minesCount == 0 ) for ( const auto & [ dx , dy ] : dirs ) dfs ( i + dx , j + dy ); }; dfs ( click [ 0 ], click [ 1 ]); return board ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public char [][] updateBoard ( char [][] board , int [] click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ] , click [ 1 ] ); return board ; } private final int [][] dirs = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] != 'E' ) return ; final int minesCount = getMinesCount ( board , i , j ); board [ i ][ j ] = minesCount == 0 ? 'B' : ( char ) ( '0' + minesCount ); if ( minesCount == 0 ) for ( final int [] dir : dirs ) dfs ( board , i + dir [ 0 ] , j + dir [ 1 ] ); } private int getMinesCount ( char [][] board , int i , int j ) { int minesCount = 0 ; for ( final int [] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x == board . length || y < 0 || y == board [ 0 ] . length ) continue ; if ( board [ x ][ y ] == 'M' ) ++ minesCount ; } return minesCount ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def updateBoard ( self , board : List [ List [ str ]], click : List [ int ]) -> List [ List [ str ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'E' : return minesCount = 0 for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < len ( board ) and 0 <= y < len ( board [ 0 ]) and board [ x ][ y ] == 'M' : minesCount += 1 board [ i ][ j ] = str ( minesCount ) if minesCount > 0 else 'B' if minesCount == 0 : for dx , dy in dirs : dfs ( i + dx , j + dy ) if board [ click [ 0 ]][ click [ 1 ]] == 'M' : board [ click [ 0 ]][ click [ 1 ]] = 'X' return board dirs = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] dfs ( click [ 0 ], click [ 1 ]) return board","title":"529. Minesweeper"},{"location":"problems/0529/#529-minesweeper","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < vector < char >> updateBoard ( vector < vector < char >>& board , vector < int >& click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } const int m = board . size (); const int n = board [ 0 ]. size (); const vector < pair < int , int >> dirs {{ -1 , -1 }, { -1 , 0 }, { -1 , 1 }, { 0 , -1 }, { 0 , 1 }, { 1 , -1 }, { 1 , 0 }, { 1 , 1 }}; auto getMinesCount = [ & ]( int i , int j ) { int minesCount = 0 ; for ( const auto & [ dx , dy ] : dirs ) { const int x = i + dx ; const int y = j + dy ; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( board [ x ][ y ] == 'M' ) ++ minesCount ; } return minesCount ; }; function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'E' ) return ; const int minesCount = getMinesCount ( i , j ); board [ i ][ j ] = minesCount == 0 ? 'B' : '0' + minesCount ; if ( minesCount == 0 ) for ( const auto & [ dx , dy ] : dirs ) dfs ( i + dx , j + dy ); }; dfs ( click [ 0 ], click [ 1 ]); return board ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public char [][] updateBoard ( char [][] board , int [] click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ] , click [ 1 ] ); return board ; } private final int [][] dirs = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i == board . length || j < 0 || j == board [ 0 ] . length ) return ; if ( board [ i ][ j ] != 'E' ) return ; final int minesCount = getMinesCount ( board , i , j ); board [ i ][ j ] = minesCount == 0 ? 'B' : ( char ) ( '0' + minesCount ); if ( minesCount == 0 ) for ( final int [] dir : dirs ) dfs ( board , i + dir [ 0 ] , j + dir [ 1 ] ); } private int getMinesCount ( char [][] board , int i , int j ) { int minesCount = 0 ; for ( final int [] dir : dirs ) { final int x = i + dir [ 0 ] ; final int y = j + dir [ 1 ] ; if ( x < 0 || x == board . length || y < 0 || y == board [ 0 ] . length ) continue ; if ( board [ x ][ y ] == 'M' ) ++ minesCount ; } return minesCount ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def updateBoard ( self , board : List [ List [ str ]], click : List [ int ]) -> List [ List [ str ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'E' : return minesCount = 0 for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < len ( board ) and 0 <= y < len ( board [ 0 ]) and board [ x ][ y ] == 'M' : minesCount += 1 board [ i ][ j ] = str ( minesCount ) if minesCount > 0 else 'B' if minesCount == 0 : for dx , dy in dirs : dfs ( i + dx , j + dy ) if board [ click [ 0 ]][ click [ 1 ]] == 'M' : board [ click [ 0 ]][ click [ 1 ]] = 'X' return board dirs = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] dfs ( click [ 0 ], click [ 1 ]) return board","title":"529. Minesweeper"},{"location":"problems/0530/","text":"530. Minimum Absolute Difference in BST Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int getMinimumDifference ( TreeNode * root ) { int ans = INT_MAX ; int prev = -1 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( prev >= 0 ) ans = min ( ans , root -> val - prev ); prev = root -> val ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"530. Minimum Absolute Difference in BST"},{"location":"problems/0530/#530-minimum-absolute-difference-in-bst","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int getMinimumDifference ( TreeNode * root ) { int ans = INT_MAX ; int prev = -1 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( prev >= 0 ) ans = min ( ans , root -> val - prev ); prev = root -> val ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"530. Minimum Absolute Difference in BST"},{"location":"problems/0531/","text":"531. Lonely Pixel I \ud83d\udd12","title":"531. Lonely Pixel I"},{"location":"problems/0531/#531-lonely-pixel-i","text":"","title":"531. Lonely Pixel I \ud83d\udd12"},{"location":"problems/0532/","text":"532. K-diff Pairs in an Array Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) numToIndex [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int target = nums [ i ] + k ; if ( numToIndex . count ( target ) && numToIndex [ target ] != i ) { ++ ans ; numToIndex . erase ( target ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) map . put ( nums [ i ] , i ); for ( int i = 0 ; i < nums . length ; ++ i ) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ++ ans ; map . remove ( target ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans","title":"532. K-diff Pairs in an Array"},{"location":"problems/0532/#532-k-diff-pairs-in-an-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) numToIndex [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int target = nums [ i ] + k ; if ( numToIndex . count ( target ) && numToIndex [ target ] != i ) { ++ ans ; numToIndex . erase ( target ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) map . put ( nums [ i ] , i ); for ( int i = 0 ; i < nums . length ; ++ i ) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ++ ans ; map . remove ( target ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans","title":"532. K-diff Pairs in an Array"},{"location":"problems/0533/","text":"533. Lonely Pixel II \ud83d\udd12","title":"533. Lonely Pixel II"},{"location":"problems/0533/#533-lonely-pixel-ii","text":"","title":"533. Lonely Pixel II \ud83d\udd12"},{"location":"problems/0534/","text":"534. Game Play Analysis III \ud83d\udd12","title":"534. Game Play Analysis III"},{"location":"problems/0534/#534-game-play-analysis-iii","text":"","title":"534. Game Play Analysis III \ud83d\udd12"},{"location":"problems/0535/","text":"535. Encode and Decode TinyURL Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string encode ( string longUrl ) { while ( ! urlToCode . count ( longUrl )) { string code ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets [ rand () % alphabets . size ()]; if ( ! codeToUrl . count ( code )) { codeToUrl [ code ] = longUrl ; urlToCode [ longUrl ] = code ; return \"http://tinyurl.com/\" + code ; } } throw ; } string decode ( string shortUrl ) { return codeToUrl [ shortUrl . substr ( 19 )]; } private : const string alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; unordered_map < string , string > urlToCode ; unordered_map < string , string > codeToUrl ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Codec { public String encode ( String longUrl ) { while ( ! urlToCode . containsKey ( longUrl )) { String code = \"\" ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets . charAt ( rand . nextInt ( alphabets . length ())); if ( ! codeToUrl . containsKey ( code )) { codeToUrl . put ( code , longUrl ); urlToCode . put ( longUrl , code ); return \"http://tinyurl.com/\" + code ; } } throw new IllegalArgumentException (); } public String decode ( String shortUrl ) { return codeToUrl . get ( shortUrl . substring ( 19 )); } private final String alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; private Map < String , String > urlToCode = new HashMap <> (); private Map < String , String > codeToUrl = new HashMap <> (); private Random rand = new Random (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Codec : alphabets = string . ascii_letters + '0123456789' urlToCode = {} codeToUrl = {} def encode ( self , longUrl : str ) -> str : while longUrl not in self . urlToCode : code = '' . join ( random . choice ( self . alphabets ) for _ in range ( 6 )) if code not in self . codeToUrl : self . codeToUrl [ code ] = longUrl self . urlToCode [ longUrl ] = code return 'http://tinyurl.com/' + self . urlToCode [ longUrl ] def decode ( self , shortUrl : str ) -> str : return self . codeToUrl [ shortUrl [ - 6 :]]","title":"535. Encode and Decode TinyURL"},{"location":"problems/0535/#535-encode-and-decode-tinyurl","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string encode ( string longUrl ) { while ( ! urlToCode . count ( longUrl )) { string code ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets [ rand () % alphabets . size ()]; if ( ! codeToUrl . count ( code )) { codeToUrl [ code ] = longUrl ; urlToCode [ longUrl ] = code ; return \"http://tinyurl.com/\" + code ; } } throw ; } string decode ( string shortUrl ) { return codeToUrl [ shortUrl . substr ( 19 )]; } private : const string alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; unordered_map < string , string > urlToCode ; unordered_map < string , string > codeToUrl ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Codec { public String encode ( String longUrl ) { while ( ! urlToCode . containsKey ( longUrl )) { String code = \"\" ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets . charAt ( rand . nextInt ( alphabets . length ())); if ( ! codeToUrl . containsKey ( code )) { codeToUrl . put ( code , longUrl ); urlToCode . put ( longUrl , code ); return \"http://tinyurl.com/\" + code ; } } throw new IllegalArgumentException (); } public String decode ( String shortUrl ) { return codeToUrl . get ( shortUrl . substring ( 19 )); } private final String alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; private Map < String , String > urlToCode = new HashMap <> (); private Map < String , String > codeToUrl = new HashMap <> (); private Random rand = new Random (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Codec : alphabets = string . ascii_letters + '0123456789' urlToCode = {} codeToUrl = {} def encode ( self , longUrl : str ) -> str : while longUrl not in self . urlToCode : code = '' . join ( random . choice ( self . alphabets ) for _ in range ( 6 )) if code not in self . codeToUrl : self . codeToUrl [ code ] = longUrl self . urlToCode [ longUrl ] = code return 'http://tinyurl.com/' + self . urlToCode [ longUrl ] def decode ( self , shortUrl : str ) -> str : return self . codeToUrl [ shortUrl [ - 6 :]]","title":"535. Encode and Decode TinyURL"},{"location":"problems/0536/","text":"536. Construct Binary Tree from String \ud83d\udd12 Approach 1: Recursive Time: $(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : TreeNode * str2tree ( string s ) { if ( s . empty ()) return nullptr ; int i = -1 ; return str2tree ( s , i ); } private : TreeNode * str2tree ( const string & s , int & i ) { const int l = i + 1 ; const int r = getRight ( s , l + 1 ); const int val = stoi ( s . substr ( l , r - l )); TreeNode * root = new TreeNode ( val ); i = r ; if ( s [ i ] == '(' ) { root -> left = str2tree ( s , i ); if ( s [ i ] == '(' ) root -> right = str2tree ( s , i ); } ++ i ; return root ; } int getRight ( const string & s , int r ) { while ( r < s . length () && isdigit ( s [ r ])) ++ r ; return r ; } }; Approach 2: Iterative Time: $(n)$ Space: $O(h)$","title":"536. Construct Binary Tree from String"},{"location":"problems/0536/#536-construct-binary-tree-from-string","text":"","title":"536. Construct Binary Tree from String \ud83d\udd12"},{"location":"problems/0536/#approach-1-recursive","text":"Time: $(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : TreeNode * str2tree ( string s ) { if ( s . empty ()) return nullptr ; int i = -1 ; return str2tree ( s , i ); } private : TreeNode * str2tree ( const string & s , int & i ) { const int l = i + 1 ; const int r = getRight ( s , l + 1 ); const int val = stoi ( s . substr ( l , r - l )); TreeNode * root = new TreeNode ( val ); i = r ; if ( s [ i ] == '(' ) { root -> left = str2tree ( s , i ); if ( s [ i ] == '(' ) root -> right = str2tree ( s , i ); } ++ i ; return root ; } int getRight ( const string & s , int r ) { while ( r < s . length () && isdigit ( s [ r ])) ++ r ; return r ; } };","title":"Approach 1: Recursive"},{"location":"problems/0536/#approach-2-iterative","text":"Time: $(n)$ Space: $O(h)$","title":"Approach 2: Iterative"},{"location":"problems/0537/","text":"537. Complex Number Multiplication Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string complexNumberMultiply ( string a , string b ) { auto getRealAndImag = []( const string & s ) -> pair < int , int > { const string real = s . substr ( 0 , s . find_first_of ( '+' )); const string imag = s . substr ( s . find_first_of ( '+' ) + 1 ); return { stoi ( real ), stoi ( imag )}; }; const auto & [ A , B ] = getRealAndImag ( a ); const auto & [ C , D ] = getRealAndImag ( b ); return to_string ( A * C - B * D ) + \"+\" + to_string ( A * D + B * C ) + \"i\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String complexNumberMultiply ( String a , String b ) { int [] A = getRealAndImag ( a ); int [] B = getRealAndImag ( b ); return String . valueOf ( A [ 0 ] * B [ 0 ] - A [ 1 ] * B [ 1 ] ) + \"+\" + String . valueOf ( A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 0 ] ) + \"i\" ; } private int [] getRealAndImag ( final String s ) { String real = s . substring ( 0 , s . indexOf ( '+' )); String imag = s . substring ( s . indexOf ( '+' ) + 1 , s . length () - 1 ); return new int [] { Integer . valueOf ( real ), Integer . valueOf ( imag ) }; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def complexNumberMultiply ( self , a : str , b : str ) -> str : def getRealAndImag ( s : str ) -> tuple : return int ( s [: s . index ( '+' )]), int ( s [ s . index ( '+' ) + 1 : - 1 ]) A , B = getRealAndImag ( a ) C , D = getRealAndImag ( b ) return str ( A * C - B * D ) + '+' + str ( A * D + B * C ) + 'i'","title":"537. Complex Number Multiplication"},{"location":"problems/0537/#537-complex-number-multiplication","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string complexNumberMultiply ( string a , string b ) { auto getRealAndImag = []( const string & s ) -> pair < int , int > { const string real = s . substr ( 0 , s . find_first_of ( '+' )); const string imag = s . substr ( s . find_first_of ( '+' ) + 1 ); return { stoi ( real ), stoi ( imag )}; }; const auto & [ A , B ] = getRealAndImag ( a ); const auto & [ C , D ] = getRealAndImag ( b ); return to_string ( A * C - B * D ) + \"+\" + to_string ( A * D + B * C ) + \"i\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String complexNumberMultiply ( String a , String b ) { int [] A = getRealAndImag ( a ); int [] B = getRealAndImag ( b ); return String . valueOf ( A [ 0 ] * B [ 0 ] - A [ 1 ] * B [ 1 ] ) + \"+\" + String . valueOf ( A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 0 ] ) + \"i\" ; } private int [] getRealAndImag ( final String s ) { String real = s . substring ( 0 , s . indexOf ( '+' )); String imag = s . substring ( s . indexOf ( '+' ) + 1 , s . length () - 1 ); return new int [] { Integer . valueOf ( real ), Integer . valueOf ( imag ) }; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def complexNumberMultiply ( self , a : str , b : str ) -> str : def getRealAndImag ( s : str ) -> tuple : return int ( s [: s . index ( '+' )]), int ( s [ s . index ( '+' ) + 1 : - 1 ]) A , B = getRealAndImag ( a ) C , D = getRealAndImag ( b ) return str ( A * C - B * D ) + '+' + str ( A * D + B * C ) + 'i'","title":"537. Complex Number Multiplication"},{"location":"problems/0538/","text":"538. Convert BST to Greater Tree Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : TreeNode * convertBST ( TreeNode * root ) { int prefixSum = 0 ; function < void ( TreeNode * ) > reversedInorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; reversedInorder ( root -> right ); root -> val += prefixSum ; prefixSum = root -> val ; reversedInorder ( root -> left ); }; reversedInorder ( root ); return root ; } };","title":"538. Convert BST to Greater Tree"},{"location":"problems/0538/#538-convert-bst-to-greater-tree","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : TreeNode * convertBST ( TreeNode * root ) { int prefixSum = 0 ; function < void ( TreeNode * ) > reversedInorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; reversedInorder ( root -> right ); root -> val += prefixSum ; prefixSum = root -> val ; reversedInorder ( root -> left ); }; reversedInorder ( root ); return root ; } };","title":"538. Convert BST to Greater Tree"},{"location":"problems/0539/","text":"539. Minimum Time Difference Time: $O(n)$ Space: $O(24 * 60)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int findMinDifference ( vector < string >& timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; vector < bool > bucket ( 24 * 60 , false ); for ( const string & time : timePoints ) { const int num = stoi ( time . substr ( 0 , 2 )) * 60 + stoi ( time . substr ( 3 )); first = min ( first , num ); if ( bucket [ num ]) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . size (); ++ i ) if ( bucket [ i ]) { ans = min ( ans , i - prev ); prev = i ; } return min ( ans , 24 * 60 - prev + first ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int findMinDifference ( List < String > timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; boolean [] bucket = new boolean [ 24 * 60 ] ; for ( final String timePoint : timePoints ) { int num = Integer . valueOf ( timePoint . substring ( 0 , 2 )) * 60 + Integer . valueOf ( timePoint . substring ( 3 )); first = Math . min ( first , num ); if ( bucket [ num ] ) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . length ; ++ i ) if ( bucket [ i ] ) { ans = Math . min ( ans , i - prev ); prev = i ; } return Math . min ( ans , 24 * 60 - prev + first ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findMinDifference ( self , timePoints : List [ str ]) -> int : ans = 24 * 60 nums = sorted ([ int ( timePoint [: 2 ]) * 60 + int ( timePoint [ 3 :]) for timePoint in timePoints ]) for a , b in zip ( nums , nums [ 1 :]): ans = min ( ans , b - a ) return min ( ans , 24 * 60 - nums [ - 1 ] + nums [ 0 ])","title":"539. Minimum Time Difference"},{"location":"problems/0539/#539-minimum-time-difference","text":"Time: $O(n)$ Space: $O(24 * 60)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int findMinDifference ( vector < string >& timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; vector < bool > bucket ( 24 * 60 , false ); for ( const string & time : timePoints ) { const int num = stoi ( time . substr ( 0 , 2 )) * 60 + stoi ( time . substr ( 3 )); first = min ( first , num ); if ( bucket [ num ]) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . size (); ++ i ) if ( bucket [ i ]) { ans = min ( ans , i - prev ); prev = i ; } return min ( ans , 24 * 60 - prev + first ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int findMinDifference ( List < String > timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; boolean [] bucket = new boolean [ 24 * 60 ] ; for ( final String timePoint : timePoints ) { int num = Integer . valueOf ( timePoint . substring ( 0 , 2 )) * 60 + Integer . valueOf ( timePoint . substring ( 3 )); first = Math . min ( first , num ); if ( bucket [ num ] ) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . length ; ++ i ) if ( bucket [ i ] ) { ans = Math . min ( ans , i - prev ); prev = i ; } return Math . min ( ans , 24 * 60 - prev + first ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findMinDifference ( self , timePoints : List [ str ]) -> int : ans = 24 * 60 nums = sorted ([ int ( timePoint [: 2 ]) * 60 + int ( timePoint [ 3 :]) for timePoint in timePoints ]) for a , b in zip ( nums , nums [ 1 :]): ans = min ( ans , b - a ) return min ( ans , 24 * 60 - nums [ - 1 ] + nums [ 0 ])","title":"539. Minimum Time Difference"},{"location":"problems/0540/","text":"540. Single Element in a Sorted Array Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m & 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ]) l = m + 2 ; else r = m ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int singleNonDuplicate ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m % 2 == 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ] ) l = m + 2 ; else r = m ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def singleNonDuplicate ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if m % 2 == 1 : m -= 1 if nums [ m ] == nums [ m + 1 ]: l = m + 2 else : r = m return nums [ l ]","title":"540. Single Element in a Sorted Array"},{"location":"problems/0540/#540-single-element-in-a-sorted-array","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m & 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ]) l = m + 2 ; else r = m ; } return nums [ l ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int singleNonDuplicate ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m % 2 == 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ] ) l = m + 2 ; else r = m ; } return nums [ l ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def singleNonDuplicate ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if m % 2 == 1 : m -= 1 if nums [ m ] == nums [ m + 1 ]: l = m + 2 else : r = m return nums [ l ]","title":"540. Single Element in a Sorted Array"},{"location":"problems/0541/","text":"541. Reverse String II Time: $O(|s|k)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string reverseStr ( string s , int k ) { for ( size_t i = 0 ; i < s . length (); i += 2 * k ) { int l = i ; int r = min ( i + k - 1 , s . length () - 1 ); while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String reverseStr ( String s , int k ) { char [] chars = s . toCharArray (); for ( int i = 0 ; i < chars . length ; i += 2 * k ) { int l = i ; int r = Math . min ( i + k - 1 , chars . length - 1 ); while ( l < r ) { char temp = chars [ l ] ; chars [ l ++] = chars [ r ] ; chars [ r --] = temp ; } } return new String ( chars ); } } Python 1 2 3 class Solution : def reverseStr ( self , s : str , k : int ) -> str : return s [: k ][:: - 1 ] + s [ k : 2 * k ] + self . reverseStr ( s [ 2 * k :], k ) if s else \"\"","title":"541. Reverse String II"},{"location":"problems/0541/#541-reverse-string-ii","text":"Time: $O(|s|k)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string reverseStr ( string s , int k ) { for ( size_t i = 0 ; i < s . length (); i += 2 * k ) { int l = i ; int r = min ( i + k - 1 , s . length () - 1 ); while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String reverseStr ( String s , int k ) { char [] chars = s . toCharArray (); for ( int i = 0 ; i < chars . length ; i += 2 * k ) { int l = i ; int r = Math . min ( i + k - 1 , chars . length - 1 ); while ( l < r ) { char temp = chars [ l ] ; chars [ l ++] = chars [ r ] ; chars [ r --] = temp ; } } return new String ( chars ); } } Python 1 2 3 class Solution : def reverseStr ( self , s : str , k : int ) -> str : return s [: k ][:: - 1 ] + s [ k : 2 * k ] + self . reverseStr ( s [ 2 * k :], k ) if s else \"\"","title":"541. Reverse String II"},{"location":"problems/0542/","text":"542. 01 Matrix Approach 1: w/ boolean array Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < vector < bool >> seen ( m , vector < bool > ( n , false )); queue < pair < int , int >> queue ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { queue . push ({ i , j }); seen [ i ][ j ] = true ; } while ( ! queue . empty ()) { const auto [ i , j ] = queue . front (); queue . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; queue . push ({ x , y }); seen [ x ][ y ] = true ; } } return matrix ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] updateMatrix ( int [][] matrix ) { final int [] dirs = new int [] { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> queue = new LinkedList <> (); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . add ( new int [] { i , j }); else matrix [ i ][ j ] = Integer . MAX_VALUE ; while ( ! queue . isEmpty ()) { int [] cell = queue . poll (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = cell [ 0 ] + dirs [ k ] ; int y = cell [ 1 ] + dirs [ k + 1 ] ; if ( x < 0 || x >= matrix . length || y < 0 || y >= matrix [ 0 ] . length || matrix [ x ][ y ] <= matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ) continue ; queue . add ( new int [] { x , y }); matrix [ x ][ y ] = matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ; } } return matrix ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def updateMatrix ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: dirs = [ 0 , 1 , 0 , - 1 , 0 ] queue = collections . deque () for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : queue . append ([ i , j ]) else : matrix [ i ][ j ] = float ( 'inf' ) while queue : i , j = queue . popleft () for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if x < 0 or x >= len ( matrix ) or y < 0 or y >= len ( matrix [ 0 ]) or matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 : continue queue . append ([ x , y ]) matrix [ x ][ y ] = matrix [ i ][ j ] + 1 return matrix Approach 2: w/o boolean array Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) q . push ({ i , j }); else matrix [ i ][ j ] = INT_MAX ; while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 ) continue ; q . push ({ x , y }); matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; } } return matrix ; } };","title":"542. 01 Matrix"},{"location":"problems/0542/#542-01-matrix","text":"","title":"542. 01 Matrix"},{"location":"problems/0542/#approach-1-w-boolean-array","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; vector < vector < bool >> seen ( m , vector < bool > ( n , false )); queue < pair < int , int >> queue ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { queue . push ({ i , j }); seen [ i ][ j ] = true ; } while ( ! queue . empty ()) { const auto [ i , j ] = queue . front (); queue . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; queue . push ({ x , y }); seen [ x ][ y ] = true ; } } return matrix ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] updateMatrix ( int [][] matrix ) { final int [] dirs = new int [] { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> queue = new LinkedList <> (); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . add ( new int [] { i , j }); else matrix [ i ][ j ] = Integer . MAX_VALUE ; while ( ! queue . isEmpty ()) { int [] cell = queue . poll (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = cell [ 0 ] + dirs [ k ] ; int y = cell [ 1 ] + dirs [ k + 1 ] ; if ( x < 0 || x >= matrix . length || y < 0 || y >= matrix [ 0 ] . length || matrix [ x ][ y ] <= matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ) continue ; queue . add ( new int [] { x , y }); matrix [ x ][ y ] = matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ; } } return matrix ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def updateMatrix ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: dirs = [ 0 , 1 , 0 , - 1 , 0 ] queue = collections . deque () for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : queue . append ([ i , j ]) else : matrix [ i ][ j ] = float ( 'inf' ) while queue : i , j = queue . popleft () for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if x < 0 or x >= len ( matrix ) or y < 0 or y >= len ( matrix [ 0 ]) or matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 : continue queue . append ([ x , y ]) matrix [ x ][ y ] = matrix [ i ][ j ] + 1 return matrix","title":"Approach 1: w/ boolean array"},{"location":"problems/0542/#approach-2-wo-boolean-array","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) q . push ({ i , j }); else matrix [ i ][ j ] = INT_MAX ; while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 ) continue ; q . push ({ x , y }); matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; } } return matrix ; } };","title":"Approach 2: w/o boolean array"},{"location":"problems/0543/","text":"543. Diameter of Binary Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int ans = 0 ; // longest path from root to leaf function < int ( TreeNode * ) > maxDepth = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int l = maxDepth ( root -> left ); const int r = maxDepth ( root -> right ); ans = max ( ans , l + r ); return max ( l , r ) + 1 ; }; maxDepth ( root ); return ans ; } };","title":"543. Diameter of Binary Tree"},{"location":"problems/0543/#543-diameter-of-binary-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int diameterOfBinaryTree ( TreeNode * root ) { int ans = 0 ; // longest path from root to leaf function < int ( TreeNode * ) > maxDepth = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int l = maxDepth ( root -> left ); const int r = maxDepth ( root -> right ); ans = max ( ans , l + r ); return max ( l , r ) + 1 ; }; maxDepth ( root ); return ans ; } };","title":"543. Diameter of Binary Tree"},{"location":"problems/0544/","text":"544. Output Contest Matches \ud83d\udd12","title":"544. Output Contest Matches"},{"location":"problems/0544/#544-output-contest-matches","text":"","title":"544. Output Contest Matches \ud83d\udd12"},{"location":"problems/0545/","text":"545. Boundary of Binary Tree \ud83d\udd12","title":"545. Boundary of Binary Tree"},{"location":"problems/0545/#545-boundary-of-binary-tree","text":"","title":"545. Boundary of Binary Tree \ud83d\udd12"},{"location":"problems/0546/","text":"546. Remove Boxes Time: $O(n^4)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int removeBoxes ( vector < int >& boxes ) { const int n = boxes . size (); // dp[i][j][k] := max score of boxes[i..j] // if k boxes having same color as boxes[j] vector < vector < vector < int >>> memo ( n , vector < vector < int >> ( n , vector < int > ( n ))); function < int ( int , int , int ) > dp = [ & ]( int i , int j , int k ) { if ( i > j ) return 0 ; if ( memo [ i ][ j ][ k ]) return memo [ i ][ j ][ k ]; memo [ i ][ j ][ k ] = dp ( i , j - 1 , 0 ) + ( k + 1 ) * ( k + 1 ); for ( int p = i ; p < j ; ++ p ) if ( boxes [ p ] == boxes [ j ]) memo [ i ][ j ][ k ] = max ( memo [ i ][ j ][ k ], dp ( i , p , k + 1 ) + dp ( p + 1 , j - 1 , 0 )); return memo [ i ][ j ][ k ]; }; return dp ( 0 , n - 1 , 0 ); } };","title":"546. Remove Boxes"},{"location":"problems/0546/#546-remove-boxes","text":"Time: $O(n^4)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int removeBoxes ( vector < int >& boxes ) { const int n = boxes . size (); // dp[i][j][k] := max score of boxes[i..j] // if k boxes having same color as boxes[j] vector < vector < vector < int >>> memo ( n , vector < vector < int >> ( n , vector < int > ( n ))); function < int ( int , int , int ) > dp = [ & ]( int i , int j , int k ) { if ( i > j ) return 0 ; if ( memo [ i ][ j ][ k ]) return memo [ i ][ j ][ k ]; memo [ i ][ j ][ k ] = dp ( i , j - 1 , 0 ) + ( k + 1 ) * ( k + 1 ); for ( int p = i ; p < j ; ++ p ) if ( boxes [ p ] == boxes [ j ]) memo [ i ][ j ][ k ] = max ( memo [ i ][ j ][ k ], dp ( i , p , k + 1 ) + dp ( p + 1 , j - 1 , 0 )); return memo [ i ][ j ][ k ]; }; return dp ( 0 , n - 1 , 0 ); } };","title":"546. Remove Boxes"},{"location":"problems/0547/","text":"547. Friend Circles Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int findCircleNum ( vector < vector < int >>& M ) { const int n = M . size (); UF uf ( n ); unordered_set < int > friendCircles ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union_ ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircles . insert ( uf . find ( i )); return friendCircles . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public int findCircleNum ( int [][] M ) { final int n = M . length ; UF uf = new UF ( n ); Set < Integer > friendCircle = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircle . add ( uf . find ( i )); return friendCircle . size (); } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def findCircleNum ( self , M : List [ List [ int ]]) -> int : n = len ( M ) uf = UF ( n ) friendCircle = set () for i in range ( n ): for j in range ( i , n ): if M [ i ][ j ] == 1 : uf . union ( i , j ) for i in range ( n ): friendCircle . add ( uf . find ( i )) return len ( friendCircle ) class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"547. Friend Circles"},{"location":"problems/0547/#547-friend-circles","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int findCircleNum ( vector < vector < int >>& M ) { const int n = M . size (); UF uf ( n ); unordered_set < int > friendCircles ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union_ ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircles . insert ( uf . find ( i )); return friendCircles . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public int findCircleNum ( int [][] M ) { final int n = M . length ; UF uf = new UF ( n ); Set < Integer > friendCircle = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircle . add ( uf . find ( i )); return friendCircle . size (); } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def findCircleNum ( self , M : List [ List [ int ]]) -> int : n = len ( M ) uf = UF ( n ) friendCircle = set () for i in range ( n ): for j in range ( i , n ): if M [ i ][ j ] == 1 : uf . union ( i , j ) for i in range ( n ): friendCircle . add ( uf . find ( i )) return len ( friendCircle ) class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"547. Friend Circles"},{"location":"problems/0548/","text":"548. Split Array with Equal Sum \ud83d\udd12","title":"548. Split Array with Equal Sum"},{"location":"problems/0548/#548-split-array-with-equal-sum","text":"","title":"548. Split Array with Equal Sum \ud83d\udd12"},{"location":"problems/0549/","text":"549. Binary Tree Longest Consecutive Sequence II \ud83d\udd12","title":"549. Binary Tree Longest Consecutive Sequence II"},{"location":"problems/0549/#549-binary-tree-longest-consecutive-sequence-ii","text":"","title":"549. Binary Tree Longest Consecutive Sequence II \ud83d\udd12"},{"location":"problems/0550/","text":"550. Game Play Analysis IV \ud83d\udd12","title":"550. Game Play Analysis IV"},{"location":"problems/0550/#550-game-play-analysis-iv","text":"","title":"550. Game Play Analysis IV \ud83d\udd12"},{"location":"problems/0551/","text":"551. Student Attendance Record I Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool checkRecord ( string s ) { int countA = 0 ; int countL = 0 ; for ( const char c : s ) { if ( c == 'A' && ++ countA > 1 ) return false ; if ( c != 'L' ) countL = 0 ; else if ( ++ countL > 2 ) return false ; } return true ; } }; Java 1 2 3 4 5 class Solution { public boolean checkRecord ( String s ) { return s . indexOf ( \"A\" ) == s . lastIndexOf ( \"A\" ) && ! s . contains ( \"LLL\" ); } } Python 1 2 3 class Solution : def checkRecord ( self , s : str ) -> bool : return s . count ( 'A' ) <= 1 and 'LLL' not in s","title":"551. Student Attendance Record I"},{"location":"problems/0551/#551-student-attendance-record-i","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool checkRecord ( string s ) { int countA = 0 ; int countL = 0 ; for ( const char c : s ) { if ( c == 'A' && ++ countA > 1 ) return false ; if ( c != 'L' ) countL = 0 ; else if ( ++ countL > 2 ) return false ; } return true ; } }; Java 1 2 3 4 5 class Solution { public boolean checkRecord ( String s ) { return s . indexOf ( \"A\" ) == s . lastIndexOf ( \"A\" ) && ! s . contains ( \"LLL\" ); } } Python 1 2 3 class Solution : def checkRecord ( self , s : str ) -> bool : return s . count ( 'A' ) <= 1 and 'LLL' not in s","title":"551. Student Attendance Record I"},{"location":"problems/0552/","text":"552. Student Attendance Record II","title":"552. Student Attendance Record II"},{"location":"problems/0552/#552-student-attendance-record-ii","text":"","title":"552. Student Attendance Record II"},{"location":"problems/0553/","text":"553. Optimal Division Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string optimalDivision ( vector < int >& nums ) { string ans = to_string ( nums [ 0 ]); if ( nums . size () == 1 ) return ans ; if ( nums . size () == 2 ) return ans + \"/\" + to_string ( nums [ 1 ]); ans += \"/(\" + to_string ( nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) ans += \"/\" + to_string ( nums [ i ]); ans += \")\" ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String optimalDivision ( int [] nums ) { String ans = String . valueOf ( nums [ 0 ] ); if ( nums . length == 1 ) return ans ; if ( nums . length == 2 ) return ans + \"/\" + String . valueOf ( nums [ 1 ] ); ans += \"/(\" + String . valueOf ( nums [ 1 ] ); for ( int i = 2 ; i < nums . length ; ++ i ) ans += \"/\" + String . valueOf ( nums [ i ] ); ans += \")\" ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def optimalDivision ( self , nums : List [ int ]) -> str : ans = str ( nums [ 0 ]) if len ( nums ) == 1 : return ans if len ( nums ) == 2 : return ans + '/' + str ( nums [ 1 ]) ans += '/(' + str ( nums [ 1 ]) for i in range ( 2 , len ( nums )): ans += '/' + str ( nums [ i ]) ans += ')' return ans","title":"553. Optimal Division"},{"location":"problems/0553/#553-optimal-division","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string optimalDivision ( vector < int >& nums ) { string ans = to_string ( nums [ 0 ]); if ( nums . size () == 1 ) return ans ; if ( nums . size () == 2 ) return ans + \"/\" + to_string ( nums [ 1 ]); ans += \"/(\" + to_string ( nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) ans += \"/\" + to_string ( nums [ i ]); ans += \")\" ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String optimalDivision ( int [] nums ) { String ans = String . valueOf ( nums [ 0 ] ); if ( nums . length == 1 ) return ans ; if ( nums . length == 2 ) return ans + \"/\" + String . valueOf ( nums [ 1 ] ); ans += \"/(\" + String . valueOf ( nums [ 1 ] ); for ( int i = 2 ; i < nums . length ; ++ i ) ans += \"/\" + String . valueOf ( nums [ i ] ); ans += \")\" ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def optimalDivision ( self , nums : List [ int ]) -> str : ans = str ( nums [ 0 ]) if len ( nums ) == 1 : return ans if len ( nums ) == 2 : return ans + '/' + str ( nums [ 1 ]) ans += '/(' + str ( nums [ 1 ]) for i in range ( 2 , len ( nums )): ans += '/' + str ( nums [ i ]) ans += ')' return ans","title":"553. Optimal Division"},{"location":"problems/0554/","text":"554. Brick Wall Time: $O(n)$, where n = # of bricks Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int maxCount = 0 ; unordered_map < int , int > count ; for ( const vector < int >& row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row [ i ]; maxCount = max ( maxCount , ++ count [ prefixSum ]); } } return wall . size () - maxCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int leastBricks ( List < List < Integer >> wall ) { int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( List < Integer > row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row . get ( i ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( prefixSum )); } } return wall . size () - maxFreq ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def leastBricks ( self , wall : List [ List [ int ]]) -> int : maxFreq = 0 count = collections . defaultdict ( int ) for row in wall : prefixSum = 0 for i in range ( len ( row ) - 1 ): prefixSum += row [ i ] count [ prefixSum ] += 1 maxFreq = max ( maxFreq , count [ prefixSum ]) return len ( wall ) - maxFreq","title":"554. Brick Wall"},{"location":"problems/0554/#554-brick-wall","text":"Time: $O(n)$, where n = # of bricks Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int maxCount = 0 ; unordered_map < int , int > count ; for ( const vector < int >& row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row [ i ]; maxCount = max ( maxCount , ++ count [ prefixSum ]); } } return wall . size () - maxCount ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int leastBricks ( List < List < Integer >> wall ) { int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( List < Integer > row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row . get ( i ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( prefixSum )); } } return wall . size () - maxFreq ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def leastBricks ( self , wall : List [ List [ int ]]) -> int : maxFreq = 0 count = collections . defaultdict ( int ) for row in wall : prefixSum = 0 for i in range ( len ( row ) - 1 ): prefixSum += row [ i ] count [ prefixSum ] += 1 maxFreq = max ( maxFreq , count [ prefixSum ]) return len ( wall ) - maxFreq","title":"554. Brick Wall"},{"location":"problems/0555/","text":"555. Split Concatenated Strings \ud83d\udd12","title":"555. Split Concatenated Strings"},{"location":"problems/0555/#555-split-concatenated-strings","text":"","title":"555. Split Concatenated Strings \ud83d\udd12"},{"location":"problems/0556/","text":"556. Next Greater Element III Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int nextGreaterElement ( int n ) { string s = nextPermutation ( to_string ( n )); long ans = stol ( s ); return ans > INT_MAX || ans <= n ? -1 : ans ; } private : string nextPermutation ( string s ) { int i ; for ( i = s . length () - 2 ; i >= 0 ; -- i ) if ( s [ i ] < s [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = s . length () - 1 ; j > i ; -- j ) if ( s [ j ] > s [ i ]) break ; swap ( s [ i ], s [ j ]); } reverse ( s , i + 1 , s . length () - 1 ); return s ; } void reverse ( string & s , int l , int r ) { while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int nextGreaterElement ( int n ) { String s = nextPermutation ( String . valueOf ( n ). toCharArray ()); long ans = Long . valueOf ( s ); return ans > Integer . MAX_VALUE || ans <= ( long ) n ? - 1 : ( int ) ans ; } private String nextPermutation ( char [] chars ) { int i ; for ( i = chars . length - 2 ; i >= 0 ; -- i ) if ( chars [ i ] < chars [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = chars . length - 1 ; j > i ; -- j ) if ( chars [ j ] > chars [ i ] ) break ; swap ( chars , i , j ); } reverse ( chars , i + 1 , chars . length - 1 ); return new String ( chars ); } private void reverse ( char [] chars , int l , int r ) { while ( l < r ) swap ( chars , l ++ , r -- ); } private void swap ( char [] chars , int i , int j ) { char temp = chars [ i ] ; chars [ i ] = chars [ j ] ; chars [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def nextGreaterElement ( self , n : int ) -> int : def nextPermutation ( s : List [ chr ]) -> str : i = len ( s ) - 2 while i >= 0 : if s [ i ] < s [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( s ) - 1 , i , - 1 ): if s [ j ] > s [ i ]: break s [ i ], s [ j ] = s [ j ], s [ i ] reverse ( s , i + 1 , len ( s ) - 1 ) return '' . join ( s ) def reverse ( s : List [ chr ], l : int , r : int ): while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1 s = nextPermutation ( list ( str ( n ))) ans = int ( s ) return - 1 if ans > 2 ** 31 - 1 or ans <= n else ans","title":"556. Next Greater Element III"},{"location":"problems/0556/#556-next-greater-element-iii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int nextGreaterElement ( int n ) { string s = nextPermutation ( to_string ( n )); long ans = stol ( s ); return ans > INT_MAX || ans <= n ? -1 : ans ; } private : string nextPermutation ( string s ) { int i ; for ( i = s . length () - 2 ; i >= 0 ; -- i ) if ( s [ i ] < s [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = s . length () - 1 ; j > i ; -- j ) if ( s [ j ] > s [ i ]) break ; swap ( s [ i ], s [ j ]); } reverse ( s , i + 1 , s . length () - 1 ); return s ; } void reverse ( string & s , int l , int r ) { while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int nextGreaterElement ( int n ) { String s = nextPermutation ( String . valueOf ( n ). toCharArray ()); long ans = Long . valueOf ( s ); return ans > Integer . MAX_VALUE || ans <= ( long ) n ? - 1 : ( int ) ans ; } private String nextPermutation ( char [] chars ) { int i ; for ( i = chars . length - 2 ; i >= 0 ; -- i ) if ( chars [ i ] < chars [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = chars . length - 1 ; j > i ; -- j ) if ( chars [ j ] > chars [ i ] ) break ; swap ( chars , i , j ); } reverse ( chars , i + 1 , chars . length - 1 ); return new String ( chars ); } private void reverse ( char [] chars , int l , int r ) { while ( l < r ) swap ( chars , l ++ , r -- ); } private void swap ( char [] chars , int i , int j ) { char temp = chars [ i ] ; chars [ i ] = chars [ j ] ; chars [ j ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def nextGreaterElement ( self , n : int ) -> int : def nextPermutation ( s : List [ chr ]) -> str : i = len ( s ) - 2 while i >= 0 : if s [ i ] < s [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( s ) - 1 , i , - 1 ): if s [ j ] > s [ i ]: break s [ i ], s [ j ] = s [ j ], s [ i ] reverse ( s , i + 1 , len ( s ) - 1 ) return '' . join ( s ) def reverse ( s : List [ chr ], l : int , r : int ): while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1 s = nextPermutation ( list ( str ( n ))) ans = int ( s ) return - 1 if ans > 2 ** 31 - 1 or ans <= n else ans","title":"556. Next Greater Element III"},{"location":"problems/0557/","text":"557. Reverse Words in a String III Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } return s ; } };","title":"557. Reverse Words in a String III"},{"location":"problems/0557/#557-reverse-words-in-a-string-iii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } return s ; } };","title":"557. Reverse Words in a String III"},{"location":"problems/0558/","text":"558. Logical OR of Two Binary Grids Represented as Quad-Trees Time: $O(n^2 \\log_4 n)$ Space: $O(\\log_4 n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : Node * intersect ( Node * quadTree1 , Node * quadTree2 ) { if ( quadTree1 -> isLeaf ) return quadTree1 -> val ? quadTree1 : quadTree2 ; if ( quadTree2 -> isLeaf ) return quadTree2 -> val ? quadTree2 : quadTree1 ; Node * topLeft = intersect ( quadTree1 -> topLeft , quadTree2 -> topLeft ); Node * topRight = intersect ( quadTree1 -> topRight , quadTree2 -> topRight ); Node * bottomLeft = intersect ( quadTree1 -> bottomLeft , quadTree2 -> bottomLeft ); Node * bottomRight = intersect ( quadTree1 -> bottomRight , quadTree2 -> bottomRight ); if ( topLeft -> val == topRight -> val && topLeft -> val == bottomLeft -> val && topLeft -> val == bottomRight -> val && topLeft -> isLeaf && topRight -> isLeaf && bottomLeft -> isLeaf && bottomRight -> isLeaf ) return new Node ( topLeft -> val , true ); return new Node ( false , false , topLeft , topRight , bottomLeft , bottomRight ); } };","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees"},{"location":"problems/0558/#558-logical-or-of-two-binary-grids-represented-as-quad-trees","text":"Time: $O(n^2 \\log_4 n)$ Space: $O(\\log_4 n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : Node * intersect ( Node * quadTree1 , Node * quadTree2 ) { if ( quadTree1 -> isLeaf ) return quadTree1 -> val ? quadTree1 : quadTree2 ; if ( quadTree2 -> isLeaf ) return quadTree2 -> val ? quadTree2 : quadTree1 ; Node * topLeft = intersect ( quadTree1 -> topLeft , quadTree2 -> topLeft ); Node * topRight = intersect ( quadTree1 -> topRight , quadTree2 -> topRight ); Node * bottomLeft = intersect ( quadTree1 -> bottomLeft , quadTree2 -> bottomLeft ); Node * bottomRight = intersect ( quadTree1 -> bottomRight , quadTree2 -> bottomRight ); if ( topLeft -> val == topRight -> val && topLeft -> val == bottomLeft -> val && topLeft -> val == bottomRight -> val && topLeft -> isLeaf && topRight -> isLeaf && bottomLeft -> isLeaf && bottomRight -> isLeaf ) return new Node ( topLeft -> val , true ); return new Node ( false , false , topLeft , topRight , bottomLeft , bottomRight ); } };","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees"},{"location":"problems/0559/","text":"559. Maximum Depth of N-ary Tree Time: $O(\\log n) \\to O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int maxDepth ( Node * root ) { if ( ! root ) return 0 ; int ans = 0 ; for ( Node * child : root -> children ) ans = max ( ans , maxDepth ( child )); return 1 + ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxDepth ( Node root ) { if ( root == null ) return 0 ; int ans = 0 ; for ( Node child : root . children ) ans = Math . max ( ans , maxDepth ( child )); return 1 + ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def maxDepth ( self , root : 'Node' ) -> int : if not root : return 0 if not root . children : return 1 return 1 + max ( self . maxDepth ( child ) for child in root . children )","title":"559. Maximum Depth of N-ary Tree"},{"location":"problems/0559/#559-maximum-depth-of-n-ary-tree","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int maxDepth ( Node * root ) { if ( ! root ) return 0 ; int ans = 0 ; for ( Node * child : root -> children ) ans = max ( ans , maxDepth ( child )); return 1 + ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxDepth ( Node root ) { if ( root == null ) return 0 ; int ans = 0 ; for ( Node child : root . children ) ans = Math . max ( ans , maxDepth ( child )); return 1 + ans ; } } Python 1 2 3 4 5 6 7 8 class Solution : def maxDepth ( self , root : 'Node' ) -> int : if not root : return 0 if not root . children : return 1 return 1 + max ( self . maxDepth ( child ) for child in root . children )","title":"559. Maximum Depth of N-ary Tree"},{"location":"problems/0560/","text":"560. Subarray Sum Equals K Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; // {prefixSum: count} for ( const int num : nums ) { prefixSum += num ; const int target = prefixSum - k ; if ( count . count ( target )) ans += count [ target ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int num : nums ) { prefixSum += num ; ans += count . getOrDefault ( prefixSum - k , 0 ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter () count [ 0 ] = 1 for num in nums : prefixSum += num ans += count [ prefixSum - k ] count [ prefixSum ] += 1 return ans","title":"560. Subarray Sum Equals K"},{"location":"problems/0560/#560-subarray-sum-equals-k","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; // {prefixSum: count} for ( const int num : nums ) { prefixSum += num ; const int target = prefixSum - k ; if ( count . count ( target )) ans += count [ target ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int num : nums ) { prefixSum += num ; ans += count . getOrDefault ( prefixSum - k , 0 ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter () count [ 0 ] = 1 for num in nums : prefixSum += num ans += count [ prefixSum - k ] count [ prefixSum ] += 1 return ans","title":"560. Subarray Sum Equals K"},{"location":"problems/0561/","text":"561. Array Partition I Time: $O(n) \\to O(n\\log n)$$ Space: $O(n) \\to O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ] ; return ans ; } } Python 1 2 3 class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ])","title":"561. Array Partition I"},{"location":"problems/0561/#561-array-partition-i","text":"Time: $O(n) \\to O(n\\log n)$$ Space: $O(n) \\to O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ] ; return ans ; } } Python 1 2 3 class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ])","title":"561. Array Partition I"},{"location":"problems/0562/","text":"562. Longest Line of Consecutive One in Matrix \ud83d\udd12","title":"562. Longest Line of Consecutive One in Matrix"},{"location":"problems/0562/#562-longest-line-of-consecutive-one-in-matrix","text":"","title":"562. Longest Line of Consecutive One in Matrix \ud83d\udd12"},{"location":"problems/0563/","text":"563. Binary Tree Tilt Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findTilt ( TreeNode * root ) { int ans = 0 ; function < int ( TreeNode * ) > sum = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int l = sum ( root -> left ); const int r = sum ( root -> right ); ans += abs ( l - r ); return root -> val + l + r ; }; sum ( root ); return ans ; } };","title":"563. Binary Tree Tilt"},{"location":"problems/0563/#563-binary-tree-tilt","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findTilt ( TreeNode * root ) { int ans = 0 ; function < int ( TreeNode * ) > sum = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int l = sum ( root -> left ); const int r = sum ( root -> right ); ans += abs ( l - r ); return root -> val + l + r ; }; sum ( root ); return ans ; } };","title":"563. Binary Tree Tilt"},{"location":"problems/0564/","text":"564. Find the Closest Palindrome Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : string nearestPalindromic ( string n ) { const auto & [ prevPalindrome , nextPalindrome ] = getPalindromes ( n ); return abs ( prevPalindrome - stoll ( n )) <= abs ( nextPalindrome - stoll ( n )) ? to_string ( prevPalindrome ) : to_string ( nextPalindrome ); } private : pair < long long , long long > getPalindromes ( const string & s ) { const long long num = stoll ( s ); const int n = s . length (); pair < long long , long long > palindromes ; const string half = s . substr ( 0 , ( n + 1 ) / 2 ); const string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); const long long candidate = stoll ( half + reversedHalf ); if ( candidate < num ) palindromes . first = candidate ; else { const string prevHalf = to_string ( stoll ( half ) - 1 ); const string reversedPrevHalf = reversed ( prevHalf . substr ( 0 , n / 2 )); if ( n % 2 == 0 && stoll ( prevHalf ) == 0 ) palindromes . first = 9 ; else if ( n % 2 == 0 && ( stoll ( prevHalf ) + 1 ) % 10 == 0 ) palindromes . first = stoll ( prevHalf + '9' + reversedPrevHalf ); else palindromes . first = stoll ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes . second = candidate ; else { const string nextHalf = to_string ( stoll ( half ) + 1 ); const string reversedNextHalf = reversed ( nextHalf . substr ( 0 , n / 2 )); palindromes . second = stoll ( nextHalf + reversedNextHalf ); } return palindromes ; } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public String nearestPalindromic ( String n ) { final long [] palindromes = getPalindromes ( n ); return Math . abs ( palindromes [ 0 ] - Long . valueOf ( n )) <= Math . abs ( palindromes [ 1 ] - Long . valueOf ( n )) ? String . valueOf ( palindromes [ 0 ] ) : String . valueOf ( palindromes [ 1 ] ); } private long [] getPalindromes ( final String s ) { final long num = Long . valueOf ( s ); final int n = s . length (); long [] palindromes = new long [ 2 ] ; String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate < num ) palindromes [ 0 ] = candidate ; else { String prevHalf = String . valueOf ( Long . valueOf ( half ) - 1 ); String reversedPrevHalf = new StringBuilder ( prevHalf . substring ( 0 , Math . min ( prevHalf . length (), n / 2 ))). reverse () . toString (); if ( n % 2 == 0 && Long . valueOf ( prevHalf ) == 0 ) palindromes [ 0 ] = 9 ; else if ( n % 2 == 0 && ( Long . valueOf ( prevHalf ) + 1 ) % 10 == 0 ) palindromes [ 0 ] = Long . valueOf ( prevHalf + '9' + reversedPrevHalf ); else palindromes [ 0 ] = Long . valueOf ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes [ 1 ] = candidate ; else { String nextHalf = String . valueOf ( Long . valueOf ( half ) + 1 ); String reversedNextHalf = new StringBuilder ( nextHalf . substring ( 0 , n / 2 )). reverse (). toString (); palindromes [ 1 ] = Long . valueOf ( nextHalf + reversedNextHalf ); } return palindromes ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def nearestPalindromic ( self , n : str ) -> str : def getPalindromes ( s : str ) -> tuple : num = int ( s ) k = len ( s ) palindromes = [] half = s [ 0 :( k + 1 ) // 2 ] reversedHalf = half [: k // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate < num : palindromes . append ( candidate ) else : prevHalf = str ( int ( half ) - 1 ) reversedPrevHalf = prevHalf [: k // 2 ][:: - 1 ] if k % 2 == 0 and int ( prevHalf ) == 0 : palindromes . append ( 9 ) elif k % 2 == 0 and ( int ( prevHalf ) + 1 ) % 10 == 0 : palindromes . append ( int ( prevHalf + '9' + reversedPrevHalf )) else : palindromes . append ( int ( prevHalf + reversedPrevHalf )) if candidate > num : palindromes . append ( candidate ) else : nextHalf = str ( int ( half ) + 1 ) reversedNextHalf = nextHalf [: k // 2 ][:: - 1 ] palindromes . append ( int ( nextHalf + reversedNextHalf )) return palindromes prevPalindrome , nextPalindrome = getPalindromes ( n ) return str ( prevPalindrome ) if abs ( prevPalindrome - int ( n )) <= abs ( nextPalindrome - int ( n )) else str ( nextPalindrome )","title":"564. Find the Closest Palindrome"},{"location":"problems/0564/#564-find-the-closest-palindrome","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : string nearestPalindromic ( string n ) { const auto & [ prevPalindrome , nextPalindrome ] = getPalindromes ( n ); return abs ( prevPalindrome - stoll ( n )) <= abs ( nextPalindrome - stoll ( n )) ? to_string ( prevPalindrome ) : to_string ( nextPalindrome ); } private : pair < long long , long long > getPalindromes ( const string & s ) { const long long num = stoll ( s ); const int n = s . length (); pair < long long , long long > palindromes ; const string half = s . substr ( 0 , ( n + 1 ) / 2 ); const string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); const long long candidate = stoll ( half + reversedHalf ); if ( candidate < num ) palindromes . first = candidate ; else { const string prevHalf = to_string ( stoll ( half ) - 1 ); const string reversedPrevHalf = reversed ( prevHalf . substr ( 0 , n / 2 )); if ( n % 2 == 0 && stoll ( prevHalf ) == 0 ) palindromes . first = 9 ; else if ( n % 2 == 0 && ( stoll ( prevHalf ) + 1 ) % 10 == 0 ) palindromes . first = stoll ( prevHalf + '9' + reversedPrevHalf ); else palindromes . first = stoll ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes . second = candidate ; else { const string nextHalf = to_string ( stoll ( half ) + 1 ); const string reversedNextHalf = reversed ( nextHalf . substr ( 0 , n / 2 )); palindromes . second = stoll ( nextHalf + reversedNextHalf ); } return palindromes ; } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public String nearestPalindromic ( String n ) { final long [] palindromes = getPalindromes ( n ); return Math . abs ( palindromes [ 0 ] - Long . valueOf ( n )) <= Math . abs ( palindromes [ 1 ] - Long . valueOf ( n )) ? String . valueOf ( palindromes [ 0 ] ) : String . valueOf ( palindromes [ 1 ] ); } private long [] getPalindromes ( final String s ) { final long num = Long . valueOf ( s ); final int n = s . length (); long [] palindromes = new long [ 2 ] ; String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate < num ) palindromes [ 0 ] = candidate ; else { String prevHalf = String . valueOf ( Long . valueOf ( half ) - 1 ); String reversedPrevHalf = new StringBuilder ( prevHalf . substring ( 0 , Math . min ( prevHalf . length (), n / 2 ))). reverse () . toString (); if ( n % 2 == 0 && Long . valueOf ( prevHalf ) == 0 ) palindromes [ 0 ] = 9 ; else if ( n % 2 == 0 && ( Long . valueOf ( prevHalf ) + 1 ) % 10 == 0 ) palindromes [ 0 ] = Long . valueOf ( prevHalf + '9' + reversedPrevHalf ); else palindromes [ 0 ] = Long . valueOf ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes [ 1 ] = candidate ; else { String nextHalf = String . valueOf ( Long . valueOf ( half ) + 1 ); String reversedNextHalf = new StringBuilder ( nextHalf . substring ( 0 , n / 2 )). reverse (). toString (); palindromes [ 1 ] = Long . valueOf ( nextHalf + reversedNextHalf ); } return palindromes ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def nearestPalindromic ( self , n : str ) -> str : def getPalindromes ( s : str ) -> tuple : num = int ( s ) k = len ( s ) palindromes = [] half = s [ 0 :( k + 1 ) // 2 ] reversedHalf = half [: k // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate < num : palindromes . append ( candidate ) else : prevHalf = str ( int ( half ) - 1 ) reversedPrevHalf = prevHalf [: k // 2 ][:: - 1 ] if k % 2 == 0 and int ( prevHalf ) == 0 : palindromes . append ( 9 ) elif k % 2 == 0 and ( int ( prevHalf ) + 1 ) % 10 == 0 : palindromes . append ( int ( prevHalf + '9' + reversedPrevHalf )) else : palindromes . append ( int ( prevHalf + reversedPrevHalf )) if candidate > num : palindromes . append ( candidate ) else : nextHalf = str ( int ( half ) + 1 ) reversedNextHalf = nextHalf [: k // 2 ][:: - 1 ] palindromes . append ( int ( nextHalf + reversedNextHalf )) return palindromes prevPalindrome , nextPalindrome = getPalindromes ( n ) return str ( prevPalindrome ) if abs ( prevPalindrome - int ( n )) <= abs ( nextPalindrome - int ( n )) else str ( nextPalindrome )","title":"564. Find the Closest Palindrome"},{"location":"problems/0565/","text":"565. Array Nesting Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) { if ( num == -1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != -1 ) { // not yet seen const int cache = index ; index = nums [ index ]; // get next index nums [ cache ] = -1 ; // already seen ++ count ; } ans = max ( ans , count ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ] ; nums [ temp ] = - 1 ; ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans","title":"565. Array Nesting"},{"location":"problems/0565/#565-array-nesting","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) { if ( num == -1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != -1 ) { // not yet seen const int cache = index ; index = nums [ index ]; // get next index nums [ cache ] = -1 ; // already seen ++ count ; } ans = max ( ans , count ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ] ; nums [ temp ] = - 1 ; ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans","title":"565. Array Nesting"},{"location":"problems/0566/","text":"566. Reshape the Matrix Time: $O(rc)$ Space: $O(rc)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( const vector < int >& row : nums ) for ( const int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ] . length ) return nums ; int [][] ans = new int [ r ][ c ] ; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans","title":"566. Reshape the Matrix"},{"location":"problems/0566/#566-reshape-the-matrix","text":"Time: $O(rc)$ Space: $O(rc)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( const vector < int >& row : nums ) for ( const int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ] . length ) return nums ; int [][] ans = new int [ r ][ c ] ; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans","title":"566. Reshape the Matrix"},{"location":"problems/0567/","text":"567. Permutation in String Approach 1: Classic sliding window Time: $O(|s1| + |s2|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count ( 128 ); int required = s1 . length (); for ( const char c : s1 ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == s1 . length ()) return true ; if ( ++ count [ s2 [ l ++ ]] > 0 ) ++ required ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count = new int [ 128 ] ; int required = s1 . length (); for ( final char c : s1 . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == s1 . length ()) return true ; if ( ++ count [ s2 . charAt ( l ++ ) ] > 0 ) ++ required ; } } return false ; } } Approach 2: Constant-sized moving window Time: $O(|s1| + |s2|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count ( 128 ); int required = s1 . length (); for ( const char c : s1 ) ++ count [ c ]; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 [ r ]] >= 0 ) -- required ; if ( r >= s1 . length ()) // the window is oversized if ( ++ count [ s2 [ r - s1 . length ()]] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count = new int [ 128 ] ; int required = s1 . length (); for ( final char c : s1 . toCharArray ()) ++ count [ c ] ; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 . charAt ( r ) ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count [ s2 . charAt ( r - s1 . length ()) ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : count = collections . Counter ( s1 ) required = len ( s1 ) for r , c in enumerate ( s2 ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( s1 ): count [ s2 [ r - len ( s1 )]] += 1 if count [ s2 [ r - len ( s1 )]] > 0 : required += 1 if required == 0 : return True return False","title":"567. Permutation in String"},{"location":"problems/0567/#567-permutation-in-string","text":"","title":"567. Permutation in String"},{"location":"problems/0567/#approach-1-classic-sliding-window","text":"Time: $O(|s1| + |s2|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count ( 128 ); int required = s1 . length (); for ( const char c : s1 ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == s1 . length ()) return true ; if ( ++ count [ s2 [ l ++ ]] > 0 ) ++ required ; } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count = new int [ 128 ] ; int required = s1 . length (); for ( final char c : s1 . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == s1 . length ()) return true ; if ( ++ count [ s2 . charAt ( l ++ ) ] > 0 ) ++ required ; } } return false ; } }","title":"Approach 1: Classic sliding window"},{"location":"problems/0567/#approach-2-constant-sized-moving-window","text":"Time: $O(|s1| + |s2|)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count ( 128 ); int required = s1 . length (); for ( const char c : s1 ) ++ count [ c ]; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 [ r ]] >= 0 ) -- required ; if ( r >= s1 . length ()) // the window is oversized if ( ++ count [ s2 [ r - s1 . length ()]] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count = new int [ 128 ] ; int required = s1 . length (); for ( final char c : s1 . toCharArray ()) ++ count [ c ] ; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count [ s2 . charAt ( r ) ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count [ s2 . charAt ( r - s1 . length ()) ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : count = collections . Counter ( s1 ) required = len ( s1 ) for r , c in enumerate ( s2 ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( s1 ): count [ s2 [ r - len ( s1 )]] += 1 if count [ s2 [ r - len ( s1 )]] > 0 : required += 1 if required == 0 : return True return False","title":"Approach 2: Constant-sized moving window"},{"location":"problems/0568/","text":"568. Maximum Vacation Days \ud83d\udd12","title":"568. Maximum Vacation Days"},{"location":"problems/0568/#568-maximum-vacation-days","text":"","title":"568. Maximum Vacation Days \ud83d\udd12"},{"location":"problems/0569/","text":"569. Median Employee Salary \ud83d\udd12","title":"569. Median Employee Salary"},{"location":"problems/0569/#569-median-employee-salary","text":"","title":"569. Median Employee Salary \ud83d\udd12"},{"location":"problems/0570/","text":"570. Managers with at Least 5 Direct Reports \ud83d\udd12","title":"570. Managers with at Least 5 Direct Reports"},{"location":"problems/0570/#570-managers-with-at-least-5-direct-reports","text":"","title":"570. Managers with at Least 5 Direct Reports \ud83d\udd12"},{"location":"problems/0571/","text":"571. Find Median Given Frequency of Numbers \ud83d\udd12","title":"571. Find Median Given Frequency of Numbers"},{"location":"problems/0571/#571-find-median-given-frequency-of-numbers","text":"","title":"571. Find Median Given Frequency of Numbers \ud83d\udd12"},{"location":"problems/0572/","text":"572. Subtree of Another Tree Time: $O(mn)$, where m = # of nodes in s and n = # of nodes in t Space: $O(h)$, where h = height of s C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { if ( ! s ) return false ; if ( isSameTree ( s , t )) return true ; return isSubtree ( s -> left , t ) || isSubtree ( s -> right , t ); } private : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"572. Subtree of Another Tree"},{"location":"problems/0572/#572-subtree-of-another-tree","text":"Time: $O(mn)$, where m = # of nodes in s and n = # of nodes in t Space: $O(h)$, where h = height of s C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { if ( ! s ) return false ; if ( isSameTree ( s , t )) return true ; return isSubtree ( s -> left , t ) || isSubtree ( s -> right , t ); } private : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"572. Subtree of Another Tree"},{"location":"problems/0573/","text":"573. Squirrel Simulation \ud83d\udd12","title":"573. Squirrel Simulation"},{"location":"problems/0573/#573-squirrel-simulation","text":"","title":"573. Squirrel Simulation \ud83d\udd12"},{"location":"problems/0574/","text":"574. Winning Candidate \ud83d\udd12","title":"574. Winning Candidate"},{"location":"problems/0574/#574-winning-candidate","text":"","title":"574. Winning Candidate \ud83d\udd12"},{"location":"problems/0575/","text":"575. Distribute Candies Time: $O(n)$ Space: $O(200001)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distributeCandies ( vector < int >& candies ) { bitset < 200001 > bitset ; for ( const int candy : candies ) bitset . set ( candy + 100000 ); return min ( candies . size () / 2 , bitset . count ()); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int distributeCandies ( int [] candies ) { BitSet bitset = new BitSet ( 200001 ); for ( int candy : candies ) bitset . set ( candy + 100000 ); return Math . min ( candies . length / 2 , bitset . cardinality ()); } } Python 1 2 3 class Solution : def distributeCandies ( self , candies : List [ int ]) -> int : return min ( len ( candies ) // 2 , len ( set ( candies )))","title":"575. Distribute Candies"},{"location":"problems/0575/#575-distribute-candies","text":"Time: $O(n)$ Space: $O(200001)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distributeCandies ( vector < int >& candies ) { bitset < 200001 > bitset ; for ( const int candy : candies ) bitset . set ( candy + 100000 ); return min ( candies . size () / 2 , bitset . count ()); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int distributeCandies ( int [] candies ) { BitSet bitset = new BitSet ( 200001 ); for ( int candy : candies ) bitset . set ( candy + 100000 ); return Math . min ( candies . length / 2 , bitset . cardinality ()); } } Python 1 2 3 class Solution : def distributeCandies ( self , candies : List [ int ]) -> int : return min ( len ( candies ) // 2 , len ( set ( candies )))","title":"575. Distribute Candies"},{"location":"problems/0576/","text":"576. Out of Boundary Paths Time: Space:","title":"576. Out of Boundary Paths"},{"location":"problems/0576/#576-out-of-boundary-paths","text":"Time: Space:","title":"576. Out of Boundary Paths"},{"location":"problems/0577/","text":"577. Employee Bonus \ud83d\udd12","title":"577. Employee Bonus"},{"location":"problems/0577/#577-employee-bonus","text":"","title":"577. Employee Bonus \ud83d\udd12"},{"location":"problems/0578/","text":"578. Get Highest Answer Rate Question \ud83d\udd12","title":"578. Get Highest Answer Rate Question"},{"location":"problems/0578/#578-get-highest-answer-rate-question","text":"","title":"578. Get Highest Answer Rate Question \ud83d\udd12"},{"location":"problems/0579/","text":"579. Find Cumulative Salary of an Employee \ud83d\udd12","title":"579. Find Cumulative Salary of an Employee"},{"location":"problems/0579/#579-find-cumulative-salary-of-an-employee","text":"","title":"579. Find Cumulative Salary of an Employee \ud83d\udd12"},{"location":"problems/0580/","text":"580. Count Student Number in Departments \ud83d\udd12","title":"580. Count Student Number in Departments"},{"location":"problems/0580/#580-count-student-number-in-departments","text":"","title":"580. Count Student Number in Departments \ud83d\udd12"},{"location":"problems/0581/","text":"581. Shortest Unsorted Continuous Subarray Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { const int n = nums . size (); int mini = INT_MAX ; int maxi = INT_MIN ; bool meetDecrease = false ; bool meetIncrease = false ; for ( int i = 1 ; i < n ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) meetDecrease = true ; if ( meetDecrease ) mini = min ( mini , nums [ i ]); } for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) meetIncrease = true ; if ( meetIncrease ) maxi = max ( maxi , nums [ i ]); } int l ; for ( l = 0 ; l < n ; ++ l ) if ( nums [ l ] > mini ) break ; int r ; for ( r = n - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < maxi ) break ; return l < r ? r - l + 1 : 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ] ) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ] ); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ] ) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ] ); } int l = 0 ; for ( l = 0 ; l < nums . length ; ++ l ) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : mini = min ( mini , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : maxi = max ( maxi , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > mini : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < maxi : break return 0 if l >= r else r - l + 1","title":"581. Shortest Unsorted Continuous Subarray"},{"location":"problems/0581/#581-shortest-unsorted-continuous-subarray","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { const int n = nums . size (); int mini = INT_MAX ; int maxi = INT_MIN ; bool meetDecrease = false ; bool meetIncrease = false ; for ( int i = 1 ; i < n ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) meetDecrease = true ; if ( meetDecrease ) mini = min ( mini , nums [ i ]); } for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) meetIncrease = true ; if ( meetIncrease ) maxi = max ( maxi , nums [ i ]); } int l ; for ( l = 0 ; l < n ; ++ l ) if ( nums [ l ] > mini ) break ; int r ; for ( r = n - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < maxi ) break ; return l < r ? r - l + 1 : 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ] ) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ] ); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ] ) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ] ); } int l = 0 ; for ( l = 0 ; l < nums . length ; ++ l ) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : mini = min ( mini , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : maxi = max ( maxi , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > mini : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < maxi : break return 0 if l >= r else r - l + 1","title":"581. Shortest Unsorted Continuous Subarray"},{"location":"problems/0582/","text":"582. Kill Process \ud83d\udd12","title":"582. Kill Process"},{"location":"problems/0582/#582-kill-process","text":"","title":"582. Kill Process \ud83d\udd12"},{"location":"problems/0583/","text":"583. Delete Operation for Two Strings Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { const int k = lcs ( word1 , word2 ); return ( word1 . length () - k ) + ( word2 . length () - k ); } private : int lcs ( const string & A , const string & B ) { const int m = A . length (); const int n = B . length (); // dp[i][j] := LCS's length of A[0..i) and B[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A [ i - 1 ] == B [ j - 1 ]) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minDistance ( String word1 , String word2 ) { final int k = lcs ( word1 , word2 ); return ( word1 . length () - k ) + ( word2 . length () - k ); } private int lcs ( final String A , final String B ) { final int m = A . length (); final int n = B . length (); // dp[i][j] := LCS's length of A[0..i) and B[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [ 0 ] * ( n + 1 ) for j in range ( n + 1 ): dp [ j ] = j for i in range ( 1 , m + 1 ): newDp = [ i ] + [ 0 ] * n for j in range ( 1 , n + 1 ): if word1 [ i - 1 ] == word2 [ j - 1 ]: newDp [ j ] = dp [ j - 1 ] else : newDp [ j ] = min ( newDp [ j - 1 ], dp [ j ]) + 1 dp = newDp return dp [ n ]","title":"583. Delete Operation for Two Strings"},{"location":"problems/0583/#583-delete-operation-for-two-strings","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { const int k = lcs ( word1 , word2 ); return ( word1 . length () - k ) + ( word2 . length () - k ); } private : int lcs ( const string & A , const string & B ) { const int m = A . length (); const int n = B . length (); // dp[i][j] := LCS's length of A[0..i) and B[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A [ i - 1 ] == B [ j - 1 ]) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minDistance ( String word1 , String word2 ) { final int k = lcs ( word1 , word2 ); return ( word1 . length () - k ) + ( word2 . length () - k ); } private int lcs ( final String A , final String B ) { final int m = A . length (); final int n = B . length (); // dp[i][j] := LCS's length of A[0..i) and B[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [ 0 ] * ( n + 1 ) for j in range ( n + 1 ): dp [ j ] = j for i in range ( 1 , m + 1 ): newDp = [ i ] + [ 0 ] * n for j in range ( 1 , n + 1 ): if word1 [ i - 1 ] == word2 [ j - 1 ]: newDp [ j ] = dp [ j - 1 ] else : newDp [ j ] = min ( newDp [ j - 1 ], dp [ j ]) + 1 dp = newDp return dp [ n ]","title":"583. Delete Operation for Two Strings"},{"location":"problems/0584/","text":"584. Find Customer Referee \ud83d\udd12","title":"584. Find Customer Referee"},{"location":"problems/0584/#584-find-customer-referee","text":"","title":"584. Find Customer Referee \ud83d\udd12"},{"location":"problems/0585/","text":"585. Investments in 2016 \ud83d\udd12","title":"585. Investments in 2016"},{"location":"problems/0585/#585-investments-in-2016","text":"","title":"585. Investments in 2016 \ud83d\udd12"},{"location":"problems/0586/","text":"586. Customer Placing the Largest Number of Orders \ud83d\udd12","title":"586. Customer Placing the Largest Number of Orders"},{"location":"problems/0586/#586-customer-placing-the-largest-number-of-orders","text":"","title":"586. Customer Placing the Largest Number of Orders \ud83d\udd12"},{"location":"problems/0587/","text":"587. Erect the Fence","title":"587. Erect the Fence"},{"location":"problems/0587/#587-erect-the-fence","text":"","title":"587. Erect the Fence"},{"location":"problems/0588/","text":"588. Design In-Memory File System \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 struct TrieNode { TrieNode () : isFile ( false ), content ( \"\" ) {} map < string , TrieNode *> children ; // map: lexicographical bool isFile ; string content ; }; class FileSystem { public : vector < string > ls ( string path ) { auto [ node , lastDir ] = createDirAndGetPair ( path ); if ( node -> isFile ) return { lastDir }; vector < string > ans ; for ( const auto & [ file , _ ] : node -> children ) ans . push_back ( file ); return ans ; } void mkdir ( string path ) { createDirAndGetPair ( path ); } void addContentToFile ( string filePath , string content ) { TrieNode * node = createDirAndGetPair ( filePath ). first ; node -> isFile = true ; node -> content += content ; } string readContentFromFile ( string filePath ) { TrieNode * node = createDirAndGetPair ( filePath ). first ; return node -> content ; } private : TrieNode root ; // createDirAndGetPair(\"/a//b\") -> {TrieNode b, string \"b\"} pair < TrieNode * , string > createDirAndGetPair ( const string & path ) { const vector < string > dirs = getDirs ( path ); TrieNode * node = & root ; for ( const string & dir : dirs ) { if ( ! node -> children . count ( dir )) node -> children [ dir ] = new TrieNode ; node = node -> children [ dir ]; } return { node , dirs . empty () ? \"\" : dirs . back ()}; } // getDirs(\"/a//b\") -> [\"a\", \"b\"] vector < string > getDirs ( const string & path ) { vector < string > dirs ; istringstream iss ( path ); for ( string dir ; getline ( iss , dir , '/' );) if ( ! dir . empty ()) // \"/a//b\" == \"/a/b\" dirs . push_back ( dir ); return dirs ; } };","title":"588. Design In-Memory File System"},{"location":"problems/0588/#588-design-in-memory-file-system","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 struct TrieNode { TrieNode () : isFile ( false ), content ( \"\" ) {} map < string , TrieNode *> children ; // map: lexicographical bool isFile ; string content ; }; class FileSystem { public : vector < string > ls ( string path ) { auto [ node , lastDir ] = createDirAndGetPair ( path ); if ( node -> isFile ) return { lastDir }; vector < string > ans ; for ( const auto & [ file , _ ] : node -> children ) ans . push_back ( file ); return ans ; } void mkdir ( string path ) { createDirAndGetPair ( path ); } void addContentToFile ( string filePath , string content ) { TrieNode * node = createDirAndGetPair ( filePath ). first ; node -> isFile = true ; node -> content += content ; } string readContentFromFile ( string filePath ) { TrieNode * node = createDirAndGetPair ( filePath ). first ; return node -> content ; } private : TrieNode root ; // createDirAndGetPair(\"/a//b\") -> {TrieNode b, string \"b\"} pair < TrieNode * , string > createDirAndGetPair ( const string & path ) { const vector < string > dirs = getDirs ( path ); TrieNode * node = & root ; for ( const string & dir : dirs ) { if ( ! node -> children . count ( dir )) node -> children [ dir ] = new TrieNode ; node = node -> children [ dir ]; } return { node , dirs . empty () ? \"\" : dirs . back ()}; } // getDirs(\"/a//b\") -> [\"a\", \"b\"] vector < string > getDirs ( const string & path ) { vector < string > dirs ; istringstream iss ( path ); for ( string dir ; getline ( iss , dir , '/' );) if ( ! dir . empty ()) // \"/a//b\" == \"/a/b\" dirs . push_back ( dir ); return dirs ; } };","title":"588. Design In-Memory File System \ud83d\udd12"},{"location":"problems/0589/","text":"589. N-ary Tree Preorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > preorder ( Node * root ) { if ( ! root ) return {}; vector < int > ans ; stack < Node *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); for ( auto it = rbegin ( root -> children ); it != rend ( root -> children ); ++ it ) if ( * it ) stack . push ( * it ); } return ans ; } };","title":"589. N-ary Tree Preorder Traversal"},{"location":"problems/0589/#589-n-ary-tree-preorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > preorder ( Node * root ) { if ( ! root ) return {}; vector < int > ans ; stack < Node *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); for ( auto it = rbegin ( root -> children ); it != rend ( root -> children ); ++ it ) if ( * it ) stack . push ( * it ); } return ans ; } };","title":"589. N-ary Tree Preorder Traversal"},{"location":"problems/0590/","text":"590. N-ary Tree Postorder Traversal Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > postorder ( Node * root ) { if ( ! root ) return {}; vector < int > ans ; stack < Node *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); for ( Node * child : root -> children ) if ( child ) stack . push ( child ); } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"590. N-ary Tree Postorder Traversal"},{"location":"problems/0590/#590-n-ary-tree-postorder-traversal","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > postorder ( Node * root ) { if ( ! root ) return {}; vector < int > ans ; stack < Node *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); for ( Node * child : root -> children ) if ( child ) stack . push ( child ); } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"590. N-ary Tree Postorder Traversal"},{"location":"problems/0591/","text":"591. Tag Validator","title":"591. Tag Validator"},{"location":"problems/0591/#591-tag-validator","text":"","title":"591. Tag Validator"},{"location":"problems/0592/","text":"592. Fraction Addition and Subtraction Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string fractionAddition ( string expression ) { istringstream iss ( expression ); char _ ; int a ; int b ; int A = 0 ; int B = 1 ; // init: A / B = 0 / 1 // A / B + a / b = (Ab + aB) / Bb // so, each round set A = Ab + aB, B = Bb while ( iss >> a >> _ >> b ) { A = A * b + a * B ; B *= b ; const int g = abs ( __gcd ( A , B )); A /= g ; B /= g ; } return to_string ( A ) + \"/\" + to_string ( B ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String fractionAddition ( String expression ) { Scanner sc = new Scanner ( expression ). useDelimiter ( \"/|(?=[+-])\" ); int A = 0 ; int B = 1 ; while ( sc . hasNext ()) { int a = sc . nextInt (); int b = sc . nextInt (); A = A * b + a * B ; B *= b ; int g = gcd ( A , B ); A /= g ; B /= g ; } return A + \"/\" + B ; } private int gcd ( int a , int b ) { return a == 0 ? Math . abs ( b ) : gcd ( b % a , a ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def fractionAddition ( self , expression : str ) -> str : ints = list ( map ( int , re . findall ( '[+-]?[0-9]+' , expression ))) A = 0 B = 1 for a , b in zip ( ints [:: 2 ], ints [ 1 :: 2 ]): A = A * b + a * B B *= b g = math . gcd ( A , B ) A //= g B //= g return str ( A ) + '/' + str ( B )","title":"592. Fraction Addition and Subtraction"},{"location":"problems/0592/#592-fraction-addition-and-subtraction","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string fractionAddition ( string expression ) { istringstream iss ( expression ); char _ ; int a ; int b ; int A = 0 ; int B = 1 ; // init: A / B = 0 / 1 // A / B + a / b = (Ab + aB) / Bb // so, each round set A = Ab + aB, B = Bb while ( iss >> a >> _ >> b ) { A = A * b + a * B ; B *= b ; const int g = abs ( __gcd ( A , B )); A /= g ; B /= g ; } return to_string ( A ) + \"/\" + to_string ( B ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String fractionAddition ( String expression ) { Scanner sc = new Scanner ( expression ). useDelimiter ( \"/|(?=[+-])\" ); int A = 0 ; int B = 1 ; while ( sc . hasNext ()) { int a = sc . nextInt (); int b = sc . nextInt (); A = A * b + a * B ; B *= b ; int g = gcd ( A , B ); A /= g ; B /= g ; } return A + \"/\" + B ; } private int gcd ( int a , int b ) { return a == 0 ? Math . abs ( b ) : gcd ( b % a , a ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def fractionAddition ( self , expression : str ) -> str : ints = list ( map ( int , re . findall ( '[+-]?[0-9]+' , expression ))) A = 0 B = 1 for a , b in zip ( ints [:: 2 ], ints [ 1 :: 2 ]): A = A * b + a * B B *= b g = math . gcd ( A , B ) A //= g B //= g return str ( A ) + '/' + str ( B )","title":"592. Fraction Addition and Subtraction"},{"location":"problems/0593/","text":"593. Valid Square Time: $O(4^2) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool validSquare ( vector < int >& p1 , vector < int >& p2 , vector < int >& p3 , vector < int >& p4 ) { set < int > distSet ; vector < vector < int >> points { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . insert ( dist ( points [ i ], points [ j ])); return ! distSet . count ( 0 ) && distSet . size () == 2 ; } private : int dist ( vector < int >& p1 , vector < int >& p2 ) { return ( p1 [ 0 ] - p2 [ 0 ]) * ( p1 [ 0 ] - p2 [ 0 ]) + ( p1 [ 1 ] - p2 [ 1 ]) * ( p1 [ 1 ] - p2 [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validSquare ( int [] p1 , int [] p2 , int [] p3 , int [] p4 ) { Set < Integer > distSet = new HashSet <> (); int [][] points = new int [][] { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . add ( dist ( points [ i ] , points [ j ] )); return ! distSet . contains ( 0 ) && distSet . size () == 2 ; } private int dist ( int [] p1 , int [] p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def validSquare ( self , p1 : List [ int ], p2 : List [ int ], p3 : List [ int ], p4 : List [ int ]) -> bool : def dist ( p1 : List [ int ], p2 : List [ int ]) -> int : return ( p1 [ 0 ] - p2 [ 0 ]) ** 2 + ( p1 [ 1 ] - p2 [ 1 ]) ** 2 distSet = set () points = [ p1 , p2 , p3 , p4 ] for i in range ( 4 ): for j in range ( i + 1 , 4 ): distSet . add ( dist ( points [ i ], points [ j ])) return 0 not in distSet and len ( distSet ) == 2","title":"593. Valid Square"},{"location":"problems/0593/#593-valid-square","text":"Time: $O(4^2) = O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool validSquare ( vector < int >& p1 , vector < int >& p2 , vector < int >& p3 , vector < int >& p4 ) { set < int > distSet ; vector < vector < int >> points { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . insert ( dist ( points [ i ], points [ j ])); return ! distSet . count ( 0 ) && distSet . size () == 2 ; } private : int dist ( vector < int >& p1 , vector < int >& p2 ) { return ( p1 [ 0 ] - p2 [ 0 ]) * ( p1 [ 0 ] - p2 [ 0 ]) + ( p1 [ 1 ] - p2 [ 1 ]) * ( p1 [ 1 ] - p2 [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validSquare ( int [] p1 , int [] p2 , int [] p3 , int [] p4 ) { Set < Integer > distSet = new HashSet <> (); int [][] points = new int [][] { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . add ( dist ( points [ i ] , points [ j ] )); return ! distSet . contains ( 0 ) && distSet . size () == 2 ; } private int dist ( int [] p1 , int [] p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def validSquare ( self , p1 : List [ int ], p2 : List [ int ], p3 : List [ int ], p4 : List [ int ]) -> bool : def dist ( p1 : List [ int ], p2 : List [ int ]) -> int : return ( p1 [ 0 ] - p2 [ 0 ]) ** 2 + ( p1 [ 1 ] - p2 [ 1 ]) ** 2 distSet = set () points = [ p1 , p2 , p3 , p4 ] for i in range ( 4 ): for j in range ( i + 1 , 4 ): distSet . add ( dist ( points [ i ], points [ j ])) return 0 not in distSet and len ( distSet ) == 2","title":"593. Valid Square"},{"location":"problems/0594/","text":"594. Longest Harmonious Subsequence Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findLHS ( vector < int >& nums ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) if ( count . count ( num + 1 )) ans = max ( ans , freq + count [ num + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int findLHS ( int [] nums ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) if ( count . containsKey ( num + 1 )) ans = Math . max ( ans , count . get ( num ) + count . get ( num + 1 )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findLHS ( self , nums : List [ int ]) -> int : ans = 0 count = collections . Counter ( nums ) for num , freq in count . items (): if num + 1 in count : ans = max ( ans , freq + count [ num + 1 ]) return ans","title":"594. Longest Harmonious Subsequence"},{"location":"problems/0594/#594-longest-harmonious-subsequence","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findLHS ( vector < int >& nums ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) if ( count . count ( num + 1 )) ans = max ( ans , freq + count [ num + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int findLHS ( int [] nums ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) if ( count . containsKey ( num + 1 )) ans = Math . max ( ans , count . get ( num ) + count . get ( num + 1 )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findLHS ( self , nums : List [ int ]) -> int : ans = 0 count = collections . Counter ( nums ) for num , freq in count . items (): if num + 1 in count : ans = max ( ans , freq + count [ num + 1 ]) return ans","title":"594. Longest Harmonious Subsequence"},{"location":"problems/0595/","text":"595. Big Countries","title":"595. Big Countries"},{"location":"problems/0595/#595-big-countries","text":"","title":"595. Big Countries"},{"location":"problems/0596/","text":"596. Classes More Than 5 Students","title":"596. Classes More Than 5 Students"},{"location":"problems/0596/#596-classes-more-than-5-students","text":"","title":"596. Classes More Than 5 Students"},{"location":"problems/0597/","text":"597. Friend Requests I: Overall Acceptance Rate \ud83d\udd12","title":"597. Friend Requests I: Overall Acceptance Rate"},{"location":"problems/0597/#597-friend-requests-i-overall-acceptance-rate","text":"","title":"597. Friend Requests I: Overall Acceptance Rate \ud83d\udd12"},{"location":"problems/0598/","text":"598. Range Addition II Time: $O(N)$, where N = len(ops) Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxCount ( int m , int n , vector < vector < int >>& ops ) { int minY = m ; int minX = n ; for ( const vector < int >& op : ops ) { minY = min ( minY , op [ 0 ]); minX = min ( minX , op [ 1 ]); } return minX * minY ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxCount ( int m , int n , int [][] ops ) { int minY = m ; int minX = n ; for ( int [] op : ops ) { minY = Math . min ( minY , op [ 0 ] ); minX = Math . min ( minX , op [ 1 ] ); } return minX * minY ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxCount ( self , m : int , n : int , ops : List [ List [ int ]]) -> int : minY = m minX = n for y , x in ops : minY = min ( minY , y ) minX = min ( minX , x ) return minX * minY","title":"598. Range Addition II"},{"location":"problems/0598/#598-range-addition-ii","text":"Time: $O(N)$, where N = len(ops) Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxCount ( int m , int n , vector < vector < int >>& ops ) { int minY = m ; int minX = n ; for ( const vector < int >& op : ops ) { minY = min ( minY , op [ 0 ]); minX = min ( minX , op [ 1 ]); } return minX * minY ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxCount ( int m , int n , int [][] ops ) { int minY = m ; int minX = n ; for ( int [] op : ops ) { minY = Math . min ( minY , op [ 0 ] ); minX = Math . min ( minX , op [ 1 ] ); } return minX * minY ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxCount ( self , m : int , n : int , ops : List [ List [ int ]]) -> int : minY = m minX = n for y , x in ops : minY = min ( minY , y ) minX = min ( minX , x ) return minX * minY","title":"598. Range Addition II"},{"location":"problems/0599/","text":"599. Minimum Index Sum of Two Lists Time: $O(m + n)$, where m = len(list1) * max length in list1 and n = len(list2) * max length in list2 Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > restaurantToIndex ; int minSum = INT_MAX ; for ( int i = 0 ; i < list1 . size (); ++ i ) restaurantToIndex [ list1 [ i ]] = i ; for ( int i = 0 ; i < list2 . size (); ++ i ) { const string restaurant = list2 [ i ]; if ( restaurantToIndex . count ( restaurant )) { const int sum = restaurantToIndex [ restaurant ] + i ; if ( sum < minSum ) { minSum = sum ; ans = { restaurant }; } else if ( sum == minSum ) { ans . push_back ( restaurant ); } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public String [] findRestaurant ( String [] list1 , String [] list2 ) { List < String > ans = new LinkedList <> (); Map < String , Integer > restaurantToIndex = new HashMap <> (); int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < list1 . length ; ++ i ) restaurantToIndex . put ( list1 [ i ] , i ); for ( int i = 0 ; i < list2 . length ; ++ i ) { if ( restaurantToIndex . containsKey ( list2 [ i ] )) { int sum = restaurantToIndex . get ( list2 [ i ] ) + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . add ( list2 [ i ] ); minSum = sum ; } } } return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def findRestaurant ( self , list1 : List [ str ], list2 : List [ str ]) -> List [ str ]: ans = [] restaurantToIndex = { restaurant : i for i , restaurant in enumerate ( list1 )} minSum = float ( 'inf' ) for i , restaurant in enumerate ( list2 ): if restaurant in restaurantToIndex : sum = restaurantToIndex [ restaurant ] + i if sum < minSum : ans . clear () if sum <= minSum : ans . append ( restaurant ) minSum = sum return ans","title":"599. Minimum Index Sum of Two Lists"},{"location":"problems/0599/#599-minimum-index-sum-of-two-lists","text":"Time: $O(m + n)$, where m = len(list1) * max length in list1 and n = len(list2) * max length in list2 Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > restaurantToIndex ; int minSum = INT_MAX ; for ( int i = 0 ; i < list1 . size (); ++ i ) restaurantToIndex [ list1 [ i ]] = i ; for ( int i = 0 ; i < list2 . size (); ++ i ) { const string restaurant = list2 [ i ]; if ( restaurantToIndex . count ( restaurant )) { const int sum = restaurantToIndex [ restaurant ] + i ; if ( sum < minSum ) { minSum = sum ; ans = { restaurant }; } else if ( sum == minSum ) { ans . push_back ( restaurant ); } } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public String [] findRestaurant ( String [] list1 , String [] list2 ) { List < String > ans = new LinkedList <> (); Map < String , Integer > restaurantToIndex = new HashMap <> (); int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < list1 . length ; ++ i ) restaurantToIndex . put ( list1 [ i ] , i ); for ( int i = 0 ; i < list2 . length ; ++ i ) { if ( restaurantToIndex . containsKey ( list2 [ i ] )) { int sum = restaurantToIndex . get ( list2 [ i ] ) + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . add ( list2 [ i ] ); minSum = sum ; } } } return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def findRestaurant ( self , list1 : List [ str ], list2 : List [ str ]) -> List [ str ]: ans = [] restaurantToIndex = { restaurant : i for i , restaurant in enumerate ( list1 )} minSum = float ( 'inf' ) for i , restaurant in enumerate ( list2 ): if restaurant in restaurantToIndex : sum = restaurantToIndex [ restaurant ] + i if sum < minSum : ans . clear () if sum <= minSum : ans . append ( restaurant ) minSum = sum return ans","title":"599. Minimum Index Sum of Two Lists"},{"location":"problems/0600/","text":"600. Non-negative Integers without Consecutive Ones Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int findIntegers ( int num ) { string bits ; for (; num ; num >>= 1 ) bits += to_string ( num & 1 ); const int n = bits . length (); vector < int > zero ( n , 1 ); vector < int > one ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) { zero [ i ] = zero [ i - 1 ] + one [ i - 1 ]; one [ i ] = zero [ i - 1 ]; } int ans = zero [ n - 1 ] + one [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; -- i ) { // numbers greater than num and <= 2^n - 1 are invalid if ( bits [ i ] == '1' && bits [ i + 1 ] == '1' ) break ; if ( bits [ i ] == '0' && bits [ i + 1 ] == '0' ) ans -= one [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int findIntegers ( int num ) { StringBuilder bits = new StringBuilder (); for (; num > 0 ; num >>= 1 ) bits . append ( num & 1 ); final int n = bits . length (); int [] zero = new int [ n ] ; int [] one = new int [ n ] ; zero [ 0 ] = 1 ; one [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { zero [ i ] = zero [ i - 1 ] + one [ i - 1 ] ; one [ i ] = zero [ i - 1 ] ; } int ans = zero [ n - 1 ] + one [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { // numbers greater than num and <= 2^n - 1 are invalid if ( bits . charAt ( i ) == '1' && bits . charAt ( i + 1 ) == '1' ) break ; if ( bits . charAt ( i ) == '0' && bits . charAt ( i + 1 ) == '0' ) ans -= one [ i ] ; } return ans ; } }","title":"600. Non-negative Integers without Consecutive Ones"},{"location":"problems/0600/#600-non-negative-integers-without-consecutive-ones","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int findIntegers ( int num ) { string bits ; for (; num ; num >>= 1 ) bits += to_string ( num & 1 ); const int n = bits . length (); vector < int > zero ( n , 1 ); vector < int > one ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) { zero [ i ] = zero [ i - 1 ] + one [ i - 1 ]; one [ i ] = zero [ i - 1 ]; } int ans = zero [ n - 1 ] + one [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; -- i ) { // numbers greater than num and <= 2^n - 1 are invalid if ( bits [ i ] == '1' && bits [ i + 1 ] == '1' ) break ; if ( bits [ i ] == '0' && bits [ i + 1 ] == '0' ) ans -= one [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public int findIntegers ( int num ) { StringBuilder bits = new StringBuilder (); for (; num > 0 ; num >>= 1 ) bits . append ( num & 1 ); final int n = bits . length (); int [] zero = new int [ n ] ; int [] one = new int [ n ] ; zero [ 0 ] = 1 ; one [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) { zero [ i ] = zero [ i - 1 ] + one [ i - 1 ] ; one [ i ] = zero [ i - 1 ] ; } int ans = zero [ n - 1 ] + one [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { // numbers greater than num and <= 2^n - 1 are invalid if ( bits . charAt ( i ) == '1' && bits . charAt ( i + 1 ) == '1' ) break ; if ( bits . charAt ( i ) == '0' && bits . charAt ( i + 1 ) == '0' ) ans -= one [ i ] ; } return ans ; } }","title":"600. Non-negative Integers without Consecutive Ones"},{"location":"problems/0601/","text":"601. Human Traffic of Stadium","title":"601. Human Traffic of Stadium"},{"location":"problems/0601/#601-human-traffic-of-stadium","text":"","title":"601. Human Traffic of Stadium"},{"location":"problems/0602/","text":"602. Friend Requests II: Who Has the Most Friends \ud83d\udd12","title":"602. Friend Requests II: Who Has the Most Friends"},{"location":"problems/0602/#602-friend-requests-ii-who-has-the-most-friends","text":"","title":"602. Friend Requests II: Who Has the Most Friends \ud83d\udd12"},{"location":"problems/0603/","text":"603. Consecutive Available Seats \ud83d\udd12","title":"603. Consecutive Available Seats"},{"location":"problems/0603/#603-consecutive-available-seats","text":"","title":"603. Consecutive Available Seats \ud83d\udd12"},{"location":"problems/0604/","text":"604. Design Compressed String Iterator \ud83d\udd12","title":"604. Design Compressed String Iterator"},{"location":"problems/0604/#604-design-compressed-string-iterator","text":"","title":"604. Design Compressed String Iterator \ud83d\udd12"},{"location":"problems/0605/","text":"605. Can Place Flowers Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { if ( n == 0 ) return true ; for ( int i = 0 ; i < flowerbed . size (); ++ i ) if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; if ( -- n == 0 ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False","title":"605. Can Place Flowers"},{"location":"problems/0605/#605-can-place-flowers","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { if ( n == 0 ) return true ; for ( int i = 0 ; i < flowerbed . size (); ++ i ) if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; if ( -- n == 0 ) return true ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False","title":"605. Can Place Flowers"},{"location":"problems/0606/","text":"606. Construct String from Binary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string tree2str ( TreeNode * t ) { string ans ; function < void ( TreeNode * ) > dfs = [ & ]( TreeNode * root ) { ans += to_string ( root -> val ); if ( ! root -> left && ! root -> right ) return ; // left node ans += \"(\" ; if ( root -> left ) dfs ( root -> left ); ans += \")\" ; // right node if ( root -> right ) { ans += \"(\" ; dfs ( root -> right ); ans += \")\" ; } }; if ( ! t ) return \"\" ; dfs ( t ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String tree2str ( TreeNode t ) { return dfs ( t ); } private String dfs ( TreeNode root ) { if ( root == null ) return \"\" ; if ( root . right != null ) return root . val + \"(\" + dfs ( root . left ) + \")(\" + dfs ( root . right ) + \")\" ; if ( root . left != null ) return root . val + \"(\" + dfs ( root . left ) + \")\" ; return root . val + \"\" ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def tree2str ( self , t : TreeNode ) -> str : def dfs ( root : TreeNode ) -> str : if not root : return '' if root . right : return str ( root . val ) + '(' + dfs ( root . left ) + ')(' + dfs ( root . right ) + ')' if root . left : return str ( root . val ) + '(' + dfs ( root . left ) + ')' return str ( root . val ) return dfs ( t )","title":"606. Construct String from Binary Tree"},{"location":"problems/0606/#606-construct-string-from-binary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string tree2str ( TreeNode * t ) { string ans ; function < void ( TreeNode * ) > dfs = [ & ]( TreeNode * root ) { ans += to_string ( root -> val ); if ( ! root -> left && ! root -> right ) return ; // left node ans += \"(\" ; if ( root -> left ) dfs ( root -> left ); ans += \")\" ; // right node if ( root -> right ) { ans += \"(\" ; dfs ( root -> right ); ans += \")\" ; } }; if ( ! t ) return \"\" ; dfs ( t ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String tree2str ( TreeNode t ) { return dfs ( t ); } private String dfs ( TreeNode root ) { if ( root == null ) return \"\" ; if ( root . right != null ) return root . val + \"(\" + dfs ( root . left ) + \")(\" + dfs ( root . right ) + \")\" ; if ( root . left != null ) return root . val + \"(\" + dfs ( root . left ) + \")\" ; return root . val + \"\" ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def tree2str ( self , t : TreeNode ) -> str : def dfs ( root : TreeNode ) -> str : if not root : return '' if root . right : return str ( root . val ) + '(' + dfs ( root . left ) + ')(' + dfs ( root . right ) + ')' if root . left : return str ( root . val ) + '(' + dfs ( root . left ) + ')' return str ( root . val ) return dfs ( t )","title":"606. Construct String from Binary Tree"},{"location":"problems/0607/","text":"607. Sales Person \ud83d\udd12","title":"607. Sales Person"},{"location":"problems/0607/#607-sales-person","text":"","title":"607. Sales Person \ud83d\udd12"},{"location":"problems/0608/","text":"608. Tree Node \ud83d\udd12","title":"608. Tree Node"},{"location":"problems/0608/#608-tree-node","text":"","title":"608. Tree Node \ud83d\udd12"},{"location":"problems/0609/","text":"609. Find Duplicate File in System Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < string >> findDuplicate ( vector < string >& paths ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> files ; // {content: {path}} for ( const string & path : paths ) { istringstream iss ( path ); string rootPath ; iss >> rootPath ; // \"root/d1/d2...\" string fileContent ; while ( iss >> fileContent ) { // \"fn.txt(fn_content)\" const int l = fileContent . find ( '(' ); const int r = fileContent . find ( ')' ); // \"fn.txt\" const string file = fileContent . substr ( 0 , l ); // \"root/d1/d2/.../fn.txt\" const string filePath = rootPath + '/' + file ; // \"fn_content\" const string content = fileContent . substr ( l + 1 , r - l - 1 ); files [ content ]. push_back ( filePath ); } } for ( const auto & [ _ , filePath ] : files ) if ( filePath . size () > 1 ) ans . push_back ( filePath ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < String >> findDuplicate ( String [] paths ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> files = new HashMap <> (); for ( final String path : paths ) { String [] words = path . split ( \" \" ); String root = words [ 0 ] ; for ( int i = 1 ; i < words . length ; ++ i ) { final String s = words [ i ] ; String filePath = root + '/' + s . substring ( 0 , s . indexOf ( '(' )); String fileContent = s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' )); if ( ! files . containsKey ( fileContent )) files . put ( fileContent , new ArrayList <> ()); files . get ( fileContent ). add ( filePath ); } } for ( List < String > filePath : files . values ()) if ( filePath . size () > 1 ) ans . add ( filePath ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , paths : List [ str ]) -> List [ List [ str ]]: files = {} for path in paths : words = path . split ( ' ' ) root = words [ 0 ] for i in range ( 1 , len ( words )): s = words [ i ] filePath = root + '/' + s [ 0 : s . find ( '(' )] fileContent = s [ s . find ( '(' ) + 1 : s . find ( ')' )] if fileContent not in files : files [ fileContent ] = [] files [ fileContent ] . append ( filePath ) return [ filePath for filePath in files . values () if len ( filePath ) > 1 ]","title":"609. Find Duplicate File in System"},{"location":"problems/0609/#609-find-duplicate-file-in-system","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < string >> findDuplicate ( vector < string >& paths ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> files ; // {content: {path}} for ( const string & path : paths ) { istringstream iss ( path ); string rootPath ; iss >> rootPath ; // \"root/d1/d2...\" string fileContent ; while ( iss >> fileContent ) { // \"fn.txt(fn_content)\" const int l = fileContent . find ( '(' ); const int r = fileContent . find ( ')' ); // \"fn.txt\" const string file = fileContent . substr ( 0 , l ); // \"root/d1/d2/.../fn.txt\" const string filePath = rootPath + '/' + file ; // \"fn_content\" const string content = fileContent . substr ( l + 1 , r - l - 1 ); files [ content ]. push_back ( filePath ); } } for ( const auto & [ _ , filePath ] : files ) if ( filePath . size () > 1 ) ans . push_back ( filePath ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < String >> findDuplicate ( String [] paths ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> files = new HashMap <> (); for ( final String path : paths ) { String [] words = path . split ( \" \" ); String root = words [ 0 ] ; for ( int i = 1 ; i < words . length ; ++ i ) { final String s = words [ i ] ; String filePath = root + '/' + s . substring ( 0 , s . indexOf ( '(' )); String fileContent = s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' )); if ( ! files . containsKey ( fileContent )) files . put ( fileContent , new ArrayList <> ()); files . get ( fileContent ). add ( filePath ); } } for ( List < String > filePath : files . values ()) if ( filePath . size () > 1 ) ans . add ( filePath ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , paths : List [ str ]) -> List [ List [ str ]]: files = {} for path in paths : words = path . split ( ' ' ) root = words [ 0 ] for i in range ( 1 , len ( words )): s = words [ i ] filePath = root + '/' + s [ 0 : s . find ( '(' )] fileContent = s [ s . find ( '(' ) + 1 : s . find ( ')' )] if fileContent not in files : files [ fileContent ] = [] files [ fileContent ] . append ( filePath ) return [ filePath for filePath in files . values () if len ( filePath ) > 1 ]","title":"609. Find Duplicate File in System"},{"location":"problems/0610/","text":"610. Triangle Judgement \ud83d\udd12","title":"610. Triangle Judgement"},{"location":"problems/0610/#610-triangle-judgement","text":"","title":"610. Triangle Judgement \ud83d\udd12"},{"location":"problems/0611/","text":"611. Valid Triangle Number Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int triangleNumber ( vector < int >& nums ) { if ( nums . size () < 3 ) return 0 ; int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) { int i = 0 ; int j = k - 1 ; while ( i < j ) if ( nums [ i ] + nums [ j ] > nums [ k ]) { // (nums[i], nums[j], nums[k]) // (nums[i + 1], nums[j], nums[k]) // ... // (nums[j - 1], nums[j], nums[k]) ans += j - i ; -- j ; } else { ++ i ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int triangleNumber ( int [] nums ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; -- k ) { int i = 0 ; int j = k - 1 ; while ( i < j ) if ( nums [ i ] + nums [ j ] > nums [ k ] ) { // (nums[i], nums[j], nums[k]) // (nums[i + 1], nums[j], nums[k]) // ... // (nums[j - 1], nums[j], nums[k]) ans += j - i ; -- j ; } else { ++ i ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans","title":"611. Valid Triangle Number"},{"location":"problems/0611/#611-valid-triangle-number","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int triangleNumber ( vector < int >& nums ) { if ( nums . size () < 3 ) return 0 ; int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) { int i = 0 ; int j = k - 1 ; while ( i < j ) if ( nums [ i ] + nums [ j ] > nums [ k ]) { // (nums[i], nums[j], nums[k]) // (nums[i + 1], nums[j], nums[k]) // ... // (nums[j - 1], nums[j], nums[k]) ans += j - i ; -- j ; } else { ++ i ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int triangleNumber ( int [] nums ) { if ( nums . length < 3 ) return 0 ; int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; -- k ) { int i = 0 ; int j = k - 1 ; while ( i < j ) if ( nums [ i ] + nums [ j ] > nums [ k ] ) { // (nums[i], nums[j], nums[k]) // (nums[i + 1], nums[j], nums[k]) // ... // (nums[j - 1], nums[j], nums[k]) ans += j - i ; -- j ; } else { ++ i ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans","title":"611. Valid Triangle Number"},{"location":"problems/0612/","text":"612. Shortest Distance in a Plane \ud83d\udd12","title":"612. Shortest Distance in a Plane"},{"location":"problems/0612/#612-shortest-distance-in-a-plane","text":"","title":"612. Shortest Distance in a Plane \ud83d\udd12"},{"location":"problems/0613/","text":"613. Shortest Distance in a Line \ud83d\udd12","title":"613. Shortest Distance in a Line"},{"location":"problems/0613/#613-shortest-distance-in-a-line","text":"","title":"613. Shortest Distance in a Line \ud83d\udd12"},{"location":"problems/0614/","text":"614. Second Degree Follower \ud83d\udd12","title":"614. Second Degree Follower"},{"location":"problems/0614/#614-second-degree-follower","text":"","title":"614. Second Degree Follower \ud83d\udd12"},{"location":"problems/0615/","text":"615. Average Salary: Departments VS Company \ud83d\udd12","title":"615. Average Salary: Departments VS Company"},{"location":"problems/0615/#615-average-salary-departments-vs-company","text":"","title":"615. Average Salary: Departments VS Company \ud83d\udd12"},{"location":"problems/0616/","text":"616. Add Bold Tag in String \ud83d\udd12 Approach 1: Intervals Time: $O(|S| + \\Sigma|dict_i|)$ Space: $O(|s|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string addBoldTag ( string s , vector < string >& dict ) { string ans ; vector < pair < int , int >> intervals ; vector < pair < int , int >> merged ; for ( const string & word : dict ) { const int n = word . length (); for ( int i = 0 ; i + n <= s . length (); ++ i ) if ( s . substr ( i , n ) == word ) intervals . push_back ({ i , i + n }); } if ( intervals . empty ()) return s ; sort ( begin ( intervals ), end ( intervals )); for ( const auto & interval : intervals ) if ( merged . empty () || merged . back (). second < interval . first ) merged . push_back ( interval ); else merged . back (). second = max ( merged . back (). second , interval . second ); int prevEnd = 0 ; for ( const auto & [ startIndex , endIndex ] : merged ) { ans += s . substr ( prevEnd , startIndex - prevEnd ); ans += \"<b>\" + s . substr ( startIndex , endIndex - startIndex ) + \"</b>\" ; prevEnd = endIndex ; } if ( ! merged . empty ()) ans += s . substr ( merged . back (). second ); return ans ; } }; Approach 2: Bold boolean array Time: $O(|S| + \\Sigma|word_i|)$ Space: $O(|s| + |dict|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string addBoldTag ( string s , vector < string >& dict ) { string ans ; vector < bool > bold ( s . length ()); size_t end = 0 ; for ( size_t i = 0 ; i < s . length (); ++ i ) { for ( const string & word : dict ) if ( s . substr ( i ). rfind ( word , 0 ) == 0 ) end = max ( end , i + word . length ()); bold [ i ] = end > i ; } for ( int i = 0 ; i < s . length (); ++ i ) { if ( ! bold [ i ]) { ans += s [ i ]; continue ; } int j = i ; while ( j < s . length () && bold [ j ]) ++ j ; ans += \"<b>\" + s . substr ( i , j - i ) + \"</b>\" ; i = j - 1 ; } return ans ; } };","title":"616. Add Bold Tag in String"},{"location":"problems/0616/#616-add-bold-tag-in-string","text":"","title":"616. Add Bold Tag in String \ud83d\udd12"},{"location":"problems/0616/#approach-1-intervals","text":"Time: $O(|S| + \\Sigma|dict_i|)$ Space: $O(|s|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : string addBoldTag ( string s , vector < string >& dict ) { string ans ; vector < pair < int , int >> intervals ; vector < pair < int , int >> merged ; for ( const string & word : dict ) { const int n = word . length (); for ( int i = 0 ; i + n <= s . length (); ++ i ) if ( s . substr ( i , n ) == word ) intervals . push_back ({ i , i + n }); } if ( intervals . empty ()) return s ; sort ( begin ( intervals ), end ( intervals )); for ( const auto & interval : intervals ) if ( merged . empty () || merged . back (). second < interval . first ) merged . push_back ( interval ); else merged . back (). second = max ( merged . back (). second , interval . second ); int prevEnd = 0 ; for ( const auto & [ startIndex , endIndex ] : merged ) { ans += s . substr ( prevEnd , startIndex - prevEnd ); ans += \"<b>\" + s . substr ( startIndex , endIndex - startIndex ) + \"</b>\" ; prevEnd = endIndex ; } if ( ! merged . empty ()) ans += s . substr ( merged . back (). second ); return ans ; } };","title":"Approach 1: Intervals"},{"location":"problems/0616/#approach-2-bold-boolean-array","text":"Time: $O(|S| + \\Sigma|word_i|)$ Space: $O(|s| + |dict|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string addBoldTag ( string s , vector < string >& dict ) { string ans ; vector < bool > bold ( s . length ()); size_t end = 0 ; for ( size_t i = 0 ; i < s . length (); ++ i ) { for ( const string & word : dict ) if ( s . substr ( i ). rfind ( word , 0 ) == 0 ) end = max ( end , i + word . length ()); bold [ i ] = end > i ; } for ( int i = 0 ; i < s . length (); ++ i ) { if ( ! bold [ i ]) { ans += s [ i ]; continue ; } int j = i ; while ( j < s . length () && bold [ j ]) ++ j ; ans += \"<b>\" + s . substr ( i , j - i ) + \"</b>\" ; i = j - 1 ; } return ans ; } };","title":"Approach 2: Bold boolean array"},{"location":"problems/0617/","text":"617. Merge Two Binary Trees Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : TreeNode * mergeTrees ( TreeNode * t1 , TreeNode * t2 ) { if ( ! t1 && ! t2 ) return nullptr ; const int val = ( t1 ? t1 -> val : 0 ) + ( t2 ? t2 -> val : 0 ); TreeNode * root = new TreeNode ( val ); root -> left = mergeTrees ( t1 ? t1 -> left : nullptr , t2 ? t2 -> left : nullptr ); root -> right = mergeTrees ( t1 ? t1 -> right : nullptr , t2 ? t2 -> right : nullptr ); return root ; } };","title":"617. Merge Two Binary Trees"},{"location":"problems/0617/#617-merge-two-binary-trees","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : TreeNode * mergeTrees ( TreeNode * t1 , TreeNode * t2 ) { if ( ! t1 && ! t2 ) return nullptr ; const int val = ( t1 ? t1 -> val : 0 ) + ( t2 ? t2 -> val : 0 ); TreeNode * root = new TreeNode ( val ); root -> left = mergeTrees ( t1 ? t1 -> left : nullptr , t2 ? t2 -> left : nullptr ); root -> right = mergeTrees ( t1 ? t1 -> right : nullptr , t2 ? t2 -> right : nullptr ); return root ; } };","title":"617. Merge Two Binary Trees"},{"location":"problems/0618/","text":"618. Students Report By Geography \ud83d\udd12","title":"618. Students Report By Geography"},{"location":"problems/0618/#618-students-report-by-geography","text":"","title":"618. Students Report By Geography \ud83d\udd12"},{"location":"problems/0619/","text":"619. Biggest Single Number \ud83d\udd12","title":"619. Biggest Single Number"},{"location":"problems/0619/#619-biggest-single-number","text":"","title":"619. Biggest Single Number \ud83d\udd12"},{"location":"problems/0620/","text":"620. Not Boring Movies","title":"620. Not Boring Movies"},{"location":"problems/0620/#620-not-boring-movies","text":"","title":"620. Not Boring Movies"},{"location":"problems/0621/","text":"621. Task Scheduler Time: $O(N)$, where N = len(tasks) Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { if ( n == 0 ) return tasks . size (); vector < int > count ( 26 ); for ( const char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( begin ( count ), end ( count )); // put tasks w/ maxCount in slot first const int maxTaskOccupy = ( maxCount - 1 ) * ( n + 1 ); // get # of tasks with same count as maxCount, // we'll append them after maxTaskOccupy const int sameCountAsMaxCount = count_if ( begin ( count ), end ( count ), [ maxCount ]( int c ) { return c == maxCount ; }); return max ( maxTaskOccupy + sameCountAsMaxCount , ( int ) tasks . size ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ] ; for ( char task : tasks ) ++ count [ task - 'A' ] ; final int maxCount = Arrays . stream ( count ). max (). getAsInt (); int ans = ( maxCount - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxCount ) ++ ans ; return Math . max ( ans , tasks . length ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : count = collections . Counter ( tasks ) maxFreq = max ( count . values ()) ans = ( maxFreq - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxFreq , count . values ())) return max ( ans , len ( tasks ))","title":"621. Task Scheduler"},{"location":"problems/0621/#621-task-scheduler","text":"Time: $O(N)$, where N = len(tasks) Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { if ( n == 0 ) return tasks . size (); vector < int > count ( 26 ); for ( const char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( begin ( count ), end ( count )); // put tasks w/ maxCount in slot first const int maxTaskOccupy = ( maxCount - 1 ) * ( n + 1 ); // get # of tasks with same count as maxCount, // we'll append them after maxTaskOccupy const int sameCountAsMaxCount = count_if ( begin ( count ), end ( count ), [ maxCount ]( int c ) { return c == maxCount ; }); return max ( maxTaskOccupy + sameCountAsMaxCount , ( int ) tasks . size ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ] ; for ( char task : tasks ) ++ count [ task - 'A' ] ; final int maxCount = Arrays . stream ( count ). max (). getAsInt (); int ans = ( maxCount - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxCount ) ++ ans ; return Math . max ( ans , tasks . length ); } } Python 1 2 3 4 5 6 7 8 9 class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : count = collections . Counter ( tasks ) maxFreq = max ( count . values ()) ans = ( maxFreq - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxFreq , count . values ())) return max ( ans , len ( tasks ))","title":"621. Task Scheduler"},{"location":"problems/0622/","text":"622. Design Circular Queue Time: $O(1)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class MyCircularQueue { public : MyCircularQueue ( int k ) : k ( k ), q ( k , 0 ), rear ( k - 1 ) {} bool enQueue ( int value ) { if ( isFull ()) return false ; rear = ++ rear % k ; q [ rear ] = value ; ++ length ; return true ; } bool deQueue () { if ( isEmpty ()) return false ; front = ++ front % k ; -- length ; return true ; } int Front () { return isEmpty () ? -1 : q [ front ]; } int Rear () { return isEmpty () ? -1 : q [ rear ]; } bool isEmpty () { return length == 0 ; } bool isFull () { return length == k ; } private : const int k ; vector < int > q ; int front = 0 ; int rear ; int length = 0 ; };","title":"622. Design Circular Queue"},{"location":"problems/0622/#622-design-circular-queue","text":"Time: $O(1)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class MyCircularQueue { public : MyCircularQueue ( int k ) : k ( k ), q ( k , 0 ), rear ( k - 1 ) {} bool enQueue ( int value ) { if ( isFull ()) return false ; rear = ++ rear % k ; q [ rear ] = value ; ++ length ; return true ; } bool deQueue () { if ( isEmpty ()) return false ; front = ++ front % k ; -- length ; return true ; } int Front () { return isEmpty () ? -1 : q [ front ]; } int Rear () { return isEmpty () ? -1 : q [ rear ]; } bool isEmpty () { return length == 0 ; } bool isFull () { return length == k ; } private : const int k ; vector < int > q ; int front = 0 ; int rear ; int length = 0 ; };","title":"622. Design Circular Queue"},{"location":"problems/0623/","text":"623. Add One Row to Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : TreeNode * addOneRow ( TreeNode * root , int v , int d ) { if ( d == 1 ) { TreeNode * newRoot = new TreeNode ( v ); newRoot -> left = root ; return newRoot ; } int depth = 0 ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { TreeNode * node = q . front (); q . pop (); if ( node -> left ) q . push ( node -> left ); if ( node -> right ) q . push ( node -> right ); if ( depth == d - 1 ) { TreeNode * cachedLeft = node -> left ; TreeNode * cachedRight = node -> right ; node -> left = new TreeNode ( v ); node -> right = new TreeNode ( v ); node -> left -> left = cachedLeft ; node -> right -> right = cachedRight ; } } if ( depth == d - 1 ) break ; } return root ; } };","title":"623. Add One Row to Tree"},{"location":"problems/0623/#623-add-one-row-to-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : TreeNode * addOneRow ( TreeNode * root , int v , int d ) { if ( d == 1 ) { TreeNode * newRoot = new TreeNode ( v ); newRoot -> left = root ; return newRoot ; } int depth = 0 ; queue < TreeNode *> q {{ root }}; while ( ! q . empty ()) { ++ depth ; for ( int i = q . size (); i > 0 ; -- i ) { TreeNode * node = q . front (); q . pop (); if ( node -> left ) q . push ( node -> left ); if ( node -> right ) q . push ( node -> right ); if ( depth == d - 1 ) { TreeNode * cachedLeft = node -> left ; TreeNode * cachedRight = node -> right ; node -> left = new TreeNode ( v ); node -> right = new TreeNode ( v ); node -> left -> left = cachedLeft ; node -> right -> right = cachedRight ; } } if ( depth == d - 1 ) break ; } return root ; } };","title":"623. Add One Row to Tree"},{"location":"problems/0624/","text":"624. Maximum Distance in Arrays \ud83d\udd12","title":"624. Maximum Distance in Arrays"},{"location":"problems/0624/#624-maximum-distance-in-arrays","text":"","title":"624. Maximum Distance in Arrays \ud83d\udd12"},{"location":"problems/0625/","text":"625. Minimum Factorization \ud83d\udd12","title":"625. Minimum Factorization"},{"location":"problems/0625/#625-minimum-factorization","text":"","title":"625. Minimum Factorization \ud83d\udd12"},{"location":"problems/0626/","text":"626. Exchange Seats","title":"626. Exchange Seats"},{"location":"problems/0626/#626-exchange-seats","text":"","title":"626. Exchange Seats"},{"location":"problems/0627/","text":"627. Swap Salary","title":"627. Swap Salary"},{"location":"problems/0627/#627-swap-salary","text":"","title":"627. Swap Salary"},{"location":"problems/0628/","text":"628. Maximum Product of Three Numbers Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min1 = INT_MAX ; // the minimum int min2 = INT_MAX ; // 2nd minimum int max1 = INT_MIN ; // the maximum int max2 = INT_MIN ; // 2nd maximum int max3 = INT_MIN ; // 3rd maximum for ( const int num : nums ) { if ( num <= min1 ) { min2 = min1 ; min1 = num ; } else if ( num <= min2 ) { min2 = num ; } if ( num >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( num >= max2 ) { max3 = max2 ; max2 = num ; } else if ( num >= max3 ) { max3 = num ; } } return max ( min1 * min2 * max1 , max1 * max2 * max3 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int maximumProduct ( int [] nums ) { int min1 = Integer . MAX_VALUE ; // the minimum int min2 = Integer . MAX_VALUE ; // 2nd minimum int max1 = Integer . MIN_VALUE ; // the maximum int max2 = Integer . MIN_VALUE ; // 2nd maximum int max3 = Integer . MIN_VALUE ; // 3rd maximum for ( final int num : nums ) { if ( num <= min1 ) { min2 = min1 ; min1 = num ; } else if ( num <= min2 ) { min2 = num ; } if ( num >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( num >= max2 ) { max3 = max2 ; max2 = num ; } else if ( num >= max3 ) { max3 = num ; } } return Math . max ( min1 * min2 * max1 , max1 * max2 * max3 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) secondMin = float ( 'inf' ) maxi = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= mini : secondMin = mini mini = num elif num <= secondMin : secondMin = num if num >= maxi : thirdMax = secondMax secondMax = maxi maxi = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( mini * secondMin * maxi , maxi * secondMax * thirdMax )","title":"628. Maximum Product of Three Numbers"},{"location":"problems/0628/#628-maximum-product-of-three-numbers","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min1 = INT_MAX ; // the minimum int min2 = INT_MAX ; // 2nd minimum int max1 = INT_MIN ; // the maximum int max2 = INT_MIN ; // 2nd maximum int max3 = INT_MIN ; // 3rd maximum for ( const int num : nums ) { if ( num <= min1 ) { min2 = min1 ; min1 = num ; } else if ( num <= min2 ) { min2 = num ; } if ( num >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( num >= max2 ) { max3 = max2 ; max2 = num ; } else if ( num >= max3 ) { max3 = num ; } } return max ( min1 * min2 * max1 , max1 * max2 * max3 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public int maximumProduct ( int [] nums ) { int min1 = Integer . MAX_VALUE ; // the minimum int min2 = Integer . MAX_VALUE ; // 2nd minimum int max1 = Integer . MIN_VALUE ; // the maximum int max2 = Integer . MIN_VALUE ; // 2nd maximum int max3 = Integer . MIN_VALUE ; // 3rd maximum for ( final int num : nums ) { if ( num <= min1 ) { min2 = min1 ; min1 = num ; } else if ( num <= min2 ) { min2 = num ; } if ( num >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = num ; } else if ( num >= max2 ) { max3 = max2 ; max2 = num ; } else if ( num >= max3 ) { max3 = num ; } } return Math . max ( min1 * min2 * max1 , max1 * max2 * max3 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) secondMin = float ( 'inf' ) maxi = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= mini : secondMin = mini mini = num elif num <= secondMin : secondMin = num if num >= maxi : thirdMax = secondMax secondMax = maxi maxi = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( mini * secondMin * maxi , maxi * secondMax * thirdMax )","title":"628. Maximum Product of Three Numbers"},{"location":"problems/0629/","text":"629. K Inverse Pairs Array Time: $O(nk)$ Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int kInversePairs ( int n , int k ) { constexpr int kMod = 1e9 + 7 ; // dp[i][j] := # of permutations of numbers 1..i with j inverse pairs vector < vector < int >> dp ( n + 1 , vector < int > ( k + 1 )); // if there's no inverse pair, the permutation is unique \"123..i\" for ( int i = 0 ; i <= n ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= k ; ++ j ) { dp [ i ][ j ] = ( dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ]) % kMod ; if ( j - i >= 0 ) dp [ i ][ j ] = ( dp [ i ][ j ] - dp [ i - 1 ][ j - i ] + kMod ) % kMod ; } return dp [ n ][ k ]; } };","title":"629. K Inverse Pairs Array"},{"location":"problems/0629/#629-k-inverse-pairs-array","text":"Time: $O(nk)$ Space: $O(nk)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int kInversePairs ( int n , int k ) { constexpr int kMod = 1e9 + 7 ; // dp[i][j] := # of permutations of numbers 1..i with j inverse pairs vector < vector < int >> dp ( n + 1 , vector < int > ( k + 1 )); // if there's no inverse pair, the permutation is unique \"123..i\" for ( int i = 0 ; i <= n ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= k ; ++ j ) { dp [ i ][ j ] = ( dp [ i ][ j - 1 ] + dp [ i - 1 ][ j ]) % kMod ; if ( j - i >= 0 ) dp [ i ][ j ] = ( dp [ i ][ j ] - dp [ i - 1 ][ j - i ] + kMod ) % kMod ; } return dp [ n ][ k ]; } };","title":"629. K Inverse Pairs Array"},{"location":"problems/0630/","text":"630. Course Schedule III","title":"630. Course Schedule III"},{"location":"problems/0630/#630-course-schedule-iii","text":"","title":"630. Course Schedule III"},{"location":"problems/0631/","text":"631. Design Excel Sum Formula \ud83d\udd12","title":"631. Design Excel Sum Formula"},{"location":"problems/0631/#631-design-excel-sum-formula","text":"","title":"631. Design Excel Sum Formula \ud83d\udd12"},{"location":"problems/0632/","text":"632. Smallest Range Covering Elements from K Lists Time: $O(n^2\\log k)$, where n = len(nums) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Item { int i ; int j ; int num ; // nums[i][j] }; class Solution { public : vector < int > smallestRange ( vector < vector < int >>& nums ) { auto compare = [ & ]( const Item & a , const Item & b ) { return a . num > b . num ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); int mini = INT_MAX ; int maxi = INT_MIN ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int num = nums [ i ][ 0 ]; pq . push ({ i , 0 , num }); mini = min ( mini , num ); maxi = max ( maxi , num ); } int minRange = mini ; int maxRange = maxi ; while ( pq . size () == nums . size ()) { const auto [ i , j , _ ] = pq . top (); pq . pop (); if ( j + 1 < nums [ i ]. size ()) { pq . push ({ i , j + 1 , nums [ i ][ j + 1 ]}); maxi = max ( maxi , nums [ i ][ j + 1 ]); mini = pq . top (). num ; if ( maxi - mini < maxRange - minRange ) { minRange = mini ; maxRange = maxi ; } } } return { minRange , maxRange }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Item { public int i ; public int j ; public int num ; // nums[i][j] public Item ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int [] smallestRange ( List < List < Integer >> nums ) { PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . num - b . num ); int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < nums . size (); ++ i ) { final int num = nums . get ( i ). get ( 0 ); pq . offer ( new Item ( i , 0 , num )); min = Math . min ( min , num ); max = Math . max ( max , num ); } int minRange = min ; int maxRange = max ; while ( pq . size () == nums . size ()) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; if ( j + 1 < nums . get ( i ). size ()) { pq . offer ( new Item ( i , j + 1 , nums . get ( i ). get ( j + 1 ))); max = Math . max ( max , nums . get ( i ). get ( j + 1 )); min = pq . peek (). num ; } if ( max - min < maxRange - minRange ) { minRange = min ; maxRange = max ; } } return new int [] { minRange , maxRange }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def smallestRange ( self , nums : List [ List [ int ]]) -> List [ int ]: pq = [( row [ 0 ], i , 0 ) for i , row in enumerate ( nums )] heapq . heapify ( pq ) maxRange = max ( row [ 0 ] for row in nums ) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] ans = [ minRange , maxRange ] while len ( pq ) == len ( nums ): num , r , c = heapq . heappop ( pq ) if c + 1 < len ( nums [ r ]): heapq . heappush ( pq , ( nums [ r ][ c + 1 ], r , c + 1 )) maxRange = max ( maxRange , nums [ r ][ c + 1 ]) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] if maxRange - minRange < ans [ 1 ] - ans [ 0 ]: ans [ 0 ], ans [ 1 ] = minRange , maxRange return ans","title":"632. Smallest Range Covering Elements from K Lists"},{"location":"problems/0632/#632-smallest-range-covering-elements-from-k-lists","text":"Time: $O(n^2\\log k)$, where n = len(nums) Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 struct Item { int i ; int j ; int num ; // nums[i][j] }; class Solution { public : vector < int > smallestRange ( vector < vector < int >>& nums ) { auto compare = [ & ]( const Item & a , const Item & b ) { return a . num > b . num ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); int mini = INT_MAX ; int maxi = INT_MIN ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int num = nums [ i ][ 0 ]; pq . push ({ i , 0 , num }); mini = min ( mini , num ); maxi = max ( maxi , num ); } int minRange = mini ; int maxRange = maxi ; while ( pq . size () == nums . size ()) { const auto [ i , j , _ ] = pq . top (); pq . pop (); if ( j + 1 < nums [ i ]. size ()) { pq . push ({ i , j + 1 , nums [ i ][ j + 1 ]}); maxi = max ( maxi , nums [ i ][ j + 1 ]); mini = pq . top (). num ; if ( maxi - mini < maxRange - minRange ) { minRange = mini ; maxRange = maxi ; } } } return { minRange , maxRange }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Item { public int i ; public int j ; public int num ; // nums[i][j] public Item ( int i , int j , int num ) { this . i = i ; this . j = j ; this . num = num ; } } class Solution { public int [] smallestRange ( List < List < Integer >> nums ) { PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . num - b . num ); int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < nums . size (); ++ i ) { final int num = nums . get ( i ). get ( 0 ); pq . offer ( new Item ( i , 0 , num )); min = Math . min ( min , num ); max = Math . max ( max , num ); } int minRange = min ; int maxRange = max ; while ( pq . size () == nums . size ()) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; if ( j + 1 < nums . get ( i ). size ()) { pq . offer ( new Item ( i , j + 1 , nums . get ( i ). get ( j + 1 ))); max = Math . max ( max , nums . get ( i ). get ( j + 1 )); min = pq . peek (). num ; } if ( max - min < maxRange - minRange ) { minRange = min ; maxRange = max ; } } return new int [] { minRange , maxRange }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def smallestRange ( self , nums : List [ List [ int ]]) -> List [ int ]: pq = [( row [ 0 ], i , 0 ) for i , row in enumerate ( nums )] heapq . heapify ( pq ) maxRange = max ( row [ 0 ] for row in nums ) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] ans = [ minRange , maxRange ] while len ( pq ) == len ( nums ): num , r , c = heapq . heappop ( pq ) if c + 1 < len ( nums [ r ]): heapq . heappush ( pq , ( nums [ r ][ c + 1 ], r , c + 1 )) maxRange = max ( maxRange , nums [ r ][ c + 1 ]) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] if maxRange - minRange < ans [ 1 ] - ans [ 0 ]: ans [ 0 ], ans [ 1 ] = minRange , maxRange return ans","title":"632. Smallest Range Covering Elements from K Lists"},{"location":"problems/0633/","text":"633. Sum of Square Numbers Time: $O(\\sqrt c)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 ; long r = sqrt ( c ); while ( l <= r ) { const long sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean judgeSquareSum ( int c ) { int l = 0 ; int r = ( int ) Math . sqrt ( c ); while ( l <= r ) { int sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def judgeSquareSum ( self , c : int ) -> bool : l = 0 r = int ( sqrt ( c )) while l <= r : summ = l * l + r * r if summ == c : return True if summ < c : l += 1 else : r -= 1 return False","title":"633. Sum of Square Numbers"},{"location":"problems/0633/#633-sum-of-square-numbers","text":"Time: $O(\\sqrt c)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 ; long r = sqrt ( c ); while ( l <= r ) { const long sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean judgeSquareSum ( int c ) { int l = 0 ; int r = ( int ) Math . sqrt ( c ); while ( l <= r ) { int sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def judgeSquareSum ( self , c : int ) -> bool : l = 0 r = int ( sqrt ( c )) while l <= r : summ = l * l + r * r if summ == c : return True if summ < c : l += 1 else : r -= 1 return False","title":"633. Sum of Square Numbers"},{"location":"problems/0634/","text":"634. Find the Derangement of An Array \ud83d\udd12","title":"634. Find the Derangement of An Array"},{"location":"problems/0634/#634-find-the-derangement-of-an-array","text":"","title":"634. Find the Derangement of An Array \ud83d\udd12"},{"location":"problems/0635/","text":"635. Design Log Storage System \ud83d\udd12","title":"635. Design Log Storage System"},{"location":"problems/0635/#635-design-log-storage-system","text":"","title":"635. Design Log Storage System \ud83d\udd12"},{"location":"problems/0636/","text":"636. Exclusive Time of Functions Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > exclusiveTime ( int n , vector < string >& logs ) { vector < int > ans ( n ); stack < int > stack ; int prevTime ; for ( const string & log : logs ) { // get seperators' indices const int colon1 = log . find_first_of ( ':' ); const int colon2 = log . find_last_of ( ':' ); // get function_id, label, and timestamp const int id = stoi ( log . substr ( 0 , colon1 )); // {function_id} const char label = log [ colon1 + 1 ]; // {\"s\" (\"start\") | \"e\" (\"end\") } const int timestamp = stoi ( log . substr ( colon2 + 1 )); // {timestamp} if ( label == 's' ) { if ( ! stack . empty ()) ans [ stack . top ()] += timestamp - prevTime ; stack . push ( id ); prevTime = timestamp ; } else { ans [ stack . top ()] += timestamp - prevTime + 1 , stack . pop (); prevTime = timestamp + 1 ; } } return ans ; } };","title":"636. Exclusive Time of Functions"},{"location":"problems/0636/#636-exclusive-time-of-functions","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < int > exclusiveTime ( int n , vector < string >& logs ) { vector < int > ans ( n ); stack < int > stack ; int prevTime ; for ( const string & log : logs ) { // get seperators' indices const int colon1 = log . find_first_of ( ':' ); const int colon2 = log . find_last_of ( ':' ); // get function_id, label, and timestamp const int id = stoi ( log . substr ( 0 , colon1 )); // {function_id} const char label = log [ colon1 + 1 ]; // {\"s\" (\"start\") | \"e\" (\"end\") } const int timestamp = stoi ( log . substr ( colon2 + 1 )); // {timestamp} if ( label == 's' ) { if ( ! stack . empty ()) ans [ stack . top ()] += timestamp - prevTime ; stack . push ( id ); prevTime = timestamp ; } else { ans [ stack . top ()] += timestamp - prevTime + 1 , stack . pop (); prevTime = timestamp + 1 ; } } return ans ; } };","title":"636. Exclusive Time of Functions"},{"location":"problems/0637/","text":"637. Average of Levels in Binary Tree","title":"637. Average of Levels in Binary Tree"},{"location":"problems/0637/#637-average-of-levels-in-binary-tree","text":"","title":"637. Average of Levels in Binary Tree"},{"location":"problems/0638/","text":"638. Shopping Offers Time: $O(|special||needs|k)$, where k = max of needs = 6 Space: $O(6)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int shoppingOffers ( vector < int >& price , vector < vector < int >>& special , vector < int >& needs ) { const int n = needs . size (); function < int ( int ) > dfs = [ & ]( int s ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans += price [ i ] * needs [ i ]; for ( int i = s ; i < special . size (); ++ i ) if ( isValid ( special [ i ], needs )) { // use special[i] for ( int j = 0 ; j < n ; ++ j ) needs [ j ] -= special [ i ][ j ]; ans = min ( ans , special [ i ]. back () + dfs ( i )); // backtracking - unuse special[i] for ( int j = 0 ; j < n ; ++ j ) needs [ j ] += special [ i ][ j ]; } return ans ; }; return dfs ( 0 ); } private : // check if this special offer is a valid one bool isValid ( const vector < int >& offer , const vector < int >& needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( needs [ i ] < offer [ i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int shoppingOffers ( List < Integer > price , List < List < Integer >> special , List < Integer > needs ) { return dfs ( price , special , needs , 0 ); } private int dfs ( List < Integer > price , List < List < Integer >> special , List < Integer > needs , int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs . get ( i ) * price . get ( i ); for ( int i = s ; i < special . size (); ++ i ) { List < Integer > offer = special . get ( i ); if ( isValid ( offer , needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) - offer . get ( j )); ans = Math . min ( ans , offer . get ( offer . size () - 1 ) + dfs ( price , special , needs , i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) + offer . get ( j )); } } return ans ; } private boolean isValid ( List < Integer > offer , List < Integer > needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer . get ( i ) > needs . get ( i )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def shoppingOffers ( self , price : List [ int ], special : List [ List [ int ]], needs : List [ int ]) -> int : def dfs ( s : int ) -> int : ans = 0 for i , need in enumerate ( needs ): ans += need * price [ i ] for i in range ( s , len ( special )): if all ( special [ i ][ j ] <= need for j , need in enumerate ( needs )): for j , need in enumerate ( needs ): needs [ j ] -= special [ i ][ j ] ans = min ( ans , special [ i ][ - 1 ] + dfs ( i )) for j , need in enumerate ( needs ): needs [ j ] += special [ i ][ j ] return ans return dfs ( 0 )","title":"638. Shopping Offers"},{"location":"problems/0638/#638-shopping-offers","text":"Time: $O(|special||needs|k)$, where k = max of needs = 6 Space: $O(6)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int shoppingOffers ( vector < int >& price , vector < vector < int >>& special , vector < int >& needs ) { const int n = needs . size (); function < int ( int ) > dfs = [ & ]( int s ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans += price [ i ] * needs [ i ]; for ( int i = s ; i < special . size (); ++ i ) if ( isValid ( special [ i ], needs )) { // use special[i] for ( int j = 0 ; j < n ; ++ j ) needs [ j ] -= special [ i ][ j ]; ans = min ( ans , special [ i ]. back () + dfs ( i )); // backtracking - unuse special[i] for ( int j = 0 ; j < n ; ++ j ) needs [ j ] += special [ i ][ j ]; } return ans ; }; return dfs ( 0 ); } private : // check if this special offer is a valid one bool isValid ( const vector < int >& offer , const vector < int >& needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( needs [ i ] < offer [ i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int shoppingOffers ( List < Integer > price , List < List < Integer >> special , List < Integer > needs ) { return dfs ( price , special , needs , 0 ); } private int dfs ( List < Integer > price , List < List < Integer >> special , List < Integer > needs , int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs . get ( i ) * price . get ( i ); for ( int i = s ; i < special . size (); ++ i ) { List < Integer > offer = special . get ( i ); if ( isValid ( offer , needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) - offer . get ( j )); ans = Math . min ( ans , offer . get ( offer . size () - 1 ) + dfs ( price , special , needs , i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) + offer . get ( j )); } } return ans ; } private boolean isValid ( List < Integer > offer , List < Integer > needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer . get ( i ) > needs . get ( i )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def shoppingOffers ( self , price : List [ int ], special : List [ List [ int ]], needs : List [ int ]) -> int : def dfs ( s : int ) -> int : ans = 0 for i , need in enumerate ( needs ): ans += need * price [ i ] for i in range ( s , len ( special )): if all ( special [ i ][ j ] <= need for j , need in enumerate ( needs )): for j , need in enumerate ( needs ): needs [ j ] -= special [ i ][ j ] ans = min ( ans , special [ i ][ - 1 ] + dfs ( i )) for j , need in enumerate ( needs ): needs [ j ] += special [ i ][ j ] return ans return dfs ( 0 )","title":"638. Shopping Offers"},{"location":"problems/0639/","text":"639. Decode Ways II Approach 1: 2D DP Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int numDecodings ( string s ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] vector < long > dp ( n + 1 , 0 ); dp . back () = 1 ; dp [ n - 1 ] = count ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { dp [ i ] += count ( s [ i ], s [ i + 1 ]) * dp [ i + 2 ]; dp [ i ] += count ( s [ i ]) * dp [ i + 1 ]; dp [ i ] %= kMod ; } return dp [ 0 ]; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; // c1c2: [11-19, 21-26] if ( c1 == '*' ) { if ( '0' <= c2 && c2 <= '6' ) return 2 ; // c1: [1-2] else return 1 ; // c1: [1] } if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; // c2: [1-9] if ( c1 == '2' ) return 6 ; // c2: [1-6] return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; Approach 2: 1D DP Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : int numDecodings ( string s ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); long prev2 = 1 ; long prev1 = count ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { long dp = count ( s [ i ], s [ i + 1 ]) * prev2 + count ( s [ i ]) * prev1 ; dp %= kMod ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; // c1c2: [11-19, 21-26] if ( c1 == '*' ) { if ( '0' <= c2 && c2 <= '6' ) return 2 ; // c1: [1-2] else return 1 ; // c1: [1] } if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; // c2: [1-9] if ( c1 == '2' ) return 6 ; // c2: [1-6] return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"639. Decode Ways II"},{"location":"problems/0639/#639-decode-ways-ii","text":"","title":"639. Decode Ways II"},{"location":"problems/0639/#approach-1-2d-dp","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : int numDecodings ( string s ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); // dp[i] := # of ways to decode s[i..n - 1] vector < long > dp ( n + 1 , 0 ); dp . back () = 1 ; dp [ n - 1 ] = count ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { dp [ i ] += count ( s [ i ], s [ i + 1 ]) * dp [ i + 2 ]; dp [ i ] += count ( s [ i ]) * dp [ i + 1 ]; dp [ i ] %= kMod ; } return dp [ 0 ]; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; // c1c2: [11-19, 21-26] if ( c1 == '*' ) { if ( '0' <= c2 && c2 <= '6' ) return 2 ; // c1: [1-2] else return 1 ; // c1: [1] } if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; // c2: [1-9] if ( c1 == '2' ) return 6 ; // c2: [1-6] return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"Approach 1: 2D DP"},{"location":"problems/0639/#approach-2-1d-dp","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : int numDecodings ( string s ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); long prev2 = 1 ; long prev1 = count ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { long dp = count ( s [ i ], s [ i + 1 ]) * prev2 + count ( s [ i ]) * prev1 ; dp %= kMod ; prev2 = prev1 ; prev1 = dp ; } return prev1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; // c1c2: [11-19, 21-26] if ( c1 == '*' ) { if ( '0' <= c2 && c2 <= '6' ) return 2 ; // c1: [1-2] else return 1 ; // c1: [1] } if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; // c2: [1-9] if ( c1 == '2' ) return 6 ; // c2: [1-6] return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"Approach 2: 1D DP"},{"location":"problems/0640/","text":"640. Solve the Equation Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string solveEquation ( string equation ) { const string lhsEquation = equation . substr ( 0 , equation . find ( '=' )); const string rhsEquation = equation . substr ( equation . find ( '=' ) + 1 ); const auto & [ lhsCoefficient , lhsConstant ] = calculate ( lhsEquation ); const auto & [ rhsCoefficient , rhsConstant ] = calculate ( rhsEquation ); const int coefficient = lhsCoefficient - rhsCoefficient ; const int constant = rhsConstant - lhsConstant ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + to_string ( constant / coefficient ); } private : pair < int , int > calculate ( const string & s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : -1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s [ i - 1 ] == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return { coefficient , constant + sign * num }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String solveEquation ( String equation ) { String [] equations = equation . split ( \"=\" ); int [] lhs = calculate ( equations [ 0 ] ); int [] rhs = calculate ( equations [ 1 ] ); int coefficient = lhs [ 0 ] - rhs [ 0 ] ; int constant = rhs [ 1 ] - lhs [ 1 ] ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + constant / coefficient ; } private int [] calculate ( final String s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s . charAt ( i - 1 ) == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return new int [] { coefficient , constant + sign * num }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def solveEquation ( self , equation : str ) -> str : def calculate ( s : str ) -> tuple : coefficient = 0 constant = 0 num = 0 sign = 1 for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : constant += sign * num sign = 1 if c == '+' else - 1 num = 0 else : if i > 0 and num == 0 and s [ i - 1 ] == '0' : continue coefficient += sign if num == 0 else sign * num num = 0 return coefficient , constant + sign * num lhsEquation , rhsEquation = equation . split ( '=' ) lhsCoefficient , lhsConstant = calculate ( lhsEquation ) rhsCoefficient , rhsConstant = calculate ( rhsEquation ) coefficient = lhsCoefficient - rhsCoefficient constant = rhsConstant - lhsConstant if coefficient == 0 and constant == 0 : return \"Infinite solutions\" if coefficient == 0 and constant != 0 : return \"No solution\" return \"x=\" + str ( constant // coefficient )","title":"640. Solve the Equation"},{"location":"problems/0640/#640-solve-the-equation","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string solveEquation ( string equation ) { const string lhsEquation = equation . substr ( 0 , equation . find ( '=' )); const string rhsEquation = equation . substr ( equation . find ( '=' ) + 1 ); const auto & [ lhsCoefficient , lhsConstant ] = calculate ( lhsEquation ); const auto & [ rhsCoefficient , rhsConstant ] = calculate ( rhsEquation ); const int coefficient = lhsCoefficient - rhsCoefficient ; const int constant = rhsConstant - lhsConstant ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + to_string ( constant / coefficient ); } private : pair < int , int > calculate ( const string & s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : -1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s [ i - 1 ] == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return { coefficient , constant + sign * num }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public String solveEquation ( String equation ) { String [] equations = equation . split ( \"=\" ); int [] lhs = calculate ( equations [ 0 ] ); int [] rhs = calculate ( equations [ 1 ] ); int coefficient = lhs [ 0 ] - rhs [ 0 ] ; int constant = rhs [ 1 ] - lhs [ 1 ] ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + constant / coefficient ; } private int [] calculate ( final String s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s . charAt ( i - 1 ) == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return new int [] { coefficient , constant + sign * num }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def solveEquation ( self , equation : str ) -> str : def calculate ( s : str ) -> tuple : coefficient = 0 constant = 0 num = 0 sign = 1 for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : constant += sign * num sign = 1 if c == '+' else - 1 num = 0 else : if i > 0 and num == 0 and s [ i - 1 ] == '0' : continue coefficient += sign if num == 0 else sign * num num = 0 return coefficient , constant + sign * num lhsEquation , rhsEquation = equation . split ( '=' ) lhsCoefficient , lhsConstant = calculate ( lhsEquation ) rhsCoefficient , rhsConstant = calculate ( rhsEquation ) coefficient = lhsCoefficient - rhsCoefficient constant = rhsConstant - lhsConstant if coefficient == 0 and constant == 0 : return \"Infinite solutions\" if coefficient == 0 and constant != 0 : return \"No solution\" return \"x=\" + str ( constant // coefficient )","title":"640. Solve the Equation"},{"location":"problems/0641/","text":"641. Design Circular Deque Time: $O(1)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MyCircularDeque { public : MyCircularDeque ( int k ) : k ( k ), q ( k , 0 ), rear ( k - 1 ) {} bool insertFront ( int value ) { if ( isFull ()) return false ; front = ( -- front + k ) % k ; q [ front ] = value ; ++ length ; return true ; } bool insertLast ( int value ) { if ( isFull ()) return false ; rear = ++ rear % k ; q [ rear ] = value ; ++ length ; return true ; } bool deleteFront () { if ( isEmpty ()) return false ; front = ++ front % k ; -- length ; return true ; } bool deleteLast () { if ( isEmpty ()) return false ; rear = ( -- rear + k ) % k ; -- length ; return true ; } int getFront () { return isEmpty () ? -1 : q [ front ]; } int getRear () { return isEmpty () ? -1 : q [ rear ]; } bool isEmpty () { return length == 0 ; } bool isFull () { return length == k ; } private : const int k ; vector < int > q ; int front = 0 ; int rear ; int length = 0 ; };","title":"641. Design Circular Deque"},{"location":"problems/0641/#641-design-circular-deque","text":"Time: $O(1)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MyCircularDeque { public : MyCircularDeque ( int k ) : k ( k ), q ( k , 0 ), rear ( k - 1 ) {} bool insertFront ( int value ) { if ( isFull ()) return false ; front = ( -- front + k ) % k ; q [ front ] = value ; ++ length ; return true ; } bool insertLast ( int value ) { if ( isFull ()) return false ; rear = ++ rear % k ; q [ rear ] = value ; ++ length ; return true ; } bool deleteFront () { if ( isEmpty ()) return false ; front = ++ front % k ; -- length ; return true ; } bool deleteLast () { if ( isEmpty ()) return false ; rear = ( -- rear + k ) % k ; -- length ; return true ; } int getFront () { return isEmpty () ? -1 : q [ front ]; } int getRear () { return isEmpty () ? -1 : q [ rear ]; } bool isEmpty () { return length == 0 ; } bool isFull () { return length == k ; } private : const int k ; vector < int > q ; int front = 0 ; int rear ; int length = 0 ; };","title":"641. Design Circular Deque"},{"location":"problems/0642/","text":"642. Design Search Autocomplete System \ud83d\udd12","title":"642. Design Search Autocomplete System"},{"location":"problems/0642/#642-design-search-autocomplete-system","text":"","title":"642. Design Search Autocomplete System \ud83d\udd12"},{"location":"problems/0643/","text":"643. Maximum Average Subarray I Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( begin ( nums ), begin ( nums ) + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += nums [ i ] ; double ans = sum ; for ( int i = k ; i < nums . length ; ++ i ) { sum += nums [ i ] - nums [ i - k ] ; ans = Math . max ( ans , sum ); } return ans / k ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : summ = sum ( nums [: k ]) ans = summ for i in range ( k , len ( nums )): summ += nums [ i ] - nums [ i - k ] ans = max ( ans , summ ) return ans / k","title":"643. Maximum Average Subarray I"},{"location":"problems/0643/#643-maximum-average-subarray-i","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( begin ( nums ), begin ( nums ) + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += nums [ i ] ; double ans = sum ; for ( int i = k ; i < nums . length ; ++ i ) { sum += nums [ i ] - nums [ i - k ] ; ans = Math . max ( ans , sum ); } return ans / k ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : summ = sum ( nums [: k ]) ans = summ for i in range ( k , len ( nums )): summ += nums [ i ] - nums [ i - k ] ans = max ( ans , summ ) return ans / k","title":"643. Maximum Average Subarray I"},{"location":"problems/0644/","text":"644. Maximum Average Subarray II \ud83d\udd12","title":"644. Maximum Average Subarray II"},{"location":"problems/0644/#644-maximum-average-subarray-ii","text":"","title":"644. Maximum Average Subarray II \ud83d\udd12"},{"location":"problems/0645/","text":"645. Set Mismatch Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > findErrorNums ( vector < int >& nums ) { int duplicate ; for ( const int num : nums ) if ( nums [ abs ( num ) - 1 ] < 0 ) duplicate = abs ( num ); else nums [ abs ( num ) - 1 ] *= -1 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) return { duplicate , i + 1 }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] findErrorNums ( int [] nums ) { int duplicate = 0 ; for ( int num : nums ) { if ( nums [ Math . abs ( num ) - 1 ] < 0 ) duplicate = Math . abs ( num ); else nums [ Math . abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) return new int [] { duplicate , i + 1 }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findErrorNums ( self , nums : List [ int ]) -> List [ int ]: for num in nums : if nums [ abs ( num ) - 1 ] < 0 : duplicate = abs ( num ) else : nums [ abs ( num ) - 1 ] *= - 1 for i , num in enumerate ( nums ): if num > 0 : return [ duplicate , i + 1 ]","title":"645. Set Mismatch"},{"location":"problems/0645/#645-set-mismatch","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > findErrorNums ( vector < int >& nums ) { int duplicate ; for ( const int num : nums ) if ( nums [ abs ( num ) - 1 ] < 0 ) duplicate = abs ( num ); else nums [ abs ( num ) - 1 ] *= -1 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) return { duplicate , i + 1 }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] findErrorNums ( int [] nums ) { int duplicate = 0 ; for ( int num : nums ) { if ( nums [ Math . abs ( num ) - 1 ] < 0 ) duplicate = Math . abs ( num ); else nums [ Math . abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) return new int [] { duplicate , i + 1 }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findErrorNums ( self , nums : List [ int ]) -> List [ int ]: for num in nums : if nums [ abs ( num ) - 1 ] < 0 : duplicate = abs ( num ) else : nums [ abs ( num ) - 1 ] *= - 1 for i , num in enumerate ( nums ): if num > 0 : return [ duplicate , i + 1 ]","title":"645. Set Mismatch"},{"location":"problems/0646/","text":"646. Maximum Length of Pair Chain Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findLongestChain ( vector < vector < int >>& pairs ) { int ans = 0 ; int prev = INT_MIN ; sort ( begin ( pairs ), end ( pairs ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& pair : pairs ) if ( pair [ 0 ] > prev ) { ++ ans ; prev = pair [ 1 ]; } return ans ; } };","title":"646. Maximum Length of Pair Chain"},{"location":"problems/0646/#646-maximum-length-of-pair-chain","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findLongestChain ( vector < vector < int >>& pairs ) { int ans = 0 ; int prev = INT_MIN ; sort ( begin ( pairs ), end ( pairs ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& pair : pairs ) if ( pair [ 0 ] > prev ) { ++ ans ; prev = pair [ 1 ]; } return ans ; } };","title":"646. Maximum Length of Pair Chain"},{"location":"problems/0647/","text":"647. Palindromic Substrings Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int countSubstrings ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private : int extendPalindromes ( const string & s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s [ l ] == s [ r ]) { ++ count ; -- l ; ++ r ; } return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int countSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private int extendPalindromes ( final String s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s . charAt ( l ) == s . charAt ( r )) { ++ count ; -- l ; ++ r ; } return count ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def countSubstrings ( self , s : str ) -> int : def extendPalindromes ( l : int , r : int ) -> int : count = 0 while l >= 0 and r < len ( s ) and s [ l ] == s [ r ]: count += 1 l -= 1 r += 1 return count ans = 0 for i in range ( len ( s )): ans += extendPalindromes ( i , i ) ans += extendPalindromes ( i , i + 1 ) return ans","title":"647. Palindromic Substrings"},{"location":"problems/0647/#647-palindromic-substrings","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int countSubstrings ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private : int extendPalindromes ( const string & s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s [ l ] == s [ r ]) { ++ count ; -- l ; ++ r ; } return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int countSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private int extendPalindromes ( final String s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s . charAt ( l ) == s . charAt ( r )) { ++ count ; -- l ; ++ r ; } return count ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def countSubstrings ( self , s : str ) -> int : def extendPalindromes ( l : int , r : int ) -> int : count = 0 while l >= 0 and r < len ( s ) and s [ l ] == s [ r ]: count += 1 l -= 1 r += 1 return count ans = 0 for i in range ( len ( s )): ans += extendPalindromes ( i , i ) ans += extendPalindromes ( i , i + 1 ) return ans","title":"647. Palindromic Substrings"},{"location":"problems/0648/","text":"648. Replace Words Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; class Solution { public : string replaceWords ( vector < string >& dict , string sentence ) { for ( const string & word : dict ) insert ( word ); string ans ; istringstream iss ( sentence ); for ( string s ; iss >> s ;) ans += search ( s ) + ' ' ; ans . pop_back (); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } string search ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( node -> word ) return * node -> word ; if ( ! node -> children [ c - 'a' ]) return word ; node = node -> children [ c - 'a' ]; } return word ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public String replaceWords ( List < String > dict , String sentence ) { String ans = \"\" ; for ( final String word : dict ) insert ( word ); final String [] words = sentence . split ( \" \" ); for ( final String word : words ) ans += ' ' + search ( word ); return ans . substring ( 1 ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String search ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { if ( node . word != null ) return node . word ; int index = c - 'a' ; if ( node . children [ index ] == null ) return word ; node = node . children [ index ] ; } return word ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word def search ( self , word : str ) -> str : node = self . root for c in word : if 'word' in node : return node [ 'word' ] if c not in node : return word node = node [ c ] return word def replaceWords ( self , dict : List [ str ], sentence : str ) -> str : for word in dict : self . insert ( word ) words = sentence . split ( ' ' ) return ' ' . join ([ self . search ( word ) for word in words ])","title":"648. Replace Words"},{"location":"problems/0648/#648-replace-words","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; class Solution { public : string replaceWords ( vector < string >& dict , string sentence ) { for ( const string & word : dict ) insert ( word ); string ans ; istringstream iss ( sentence ); for ( string s ; iss >> s ;) ans += search ( s ) + ' ' ; ans . pop_back (); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } string search ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( node -> word ) return * node -> word ; if ( ! node -> children [ c - 'a' ]) return word ; node = node -> children [ c - 'a' ]; } return word ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public String replaceWords ( List < String > dict , String sentence ) { String ans = \"\" ; for ( final String word : dict ) insert ( word ); final String [] words = sentence . split ( \" \" ); for ( final String word : words ) ans += ' ' + search ( word ); return ans . substring ( 1 ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String search ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { if ( node . word != null ) return node . word ; int index = c - 'a' ; if ( node . children [ index ] == null ) return word ; node = node . children [ index ] ; } return word ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word def search ( self , word : str ) -> str : node = self . root for c in word : if 'word' in node : return node [ 'word' ] if c not in node : return word node = node [ c ] return word def replaceWords ( self , dict : List [ str ], sentence : str ) -> str : for word in dict : self . insert ( word ) words = sentence . split ( ' ' ) return ' ' . join ([ self . search ( word ) for word in words ])","title":"648. Replace Words"},{"location":"problems/0649/","text":"649. Dota2 Senate Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string predictPartyVictory ( string senate ) { const int n = senate . length (); queue < int > qR ; queue < int > qD ; for ( int i = 0 ; i < n ; ++ i ) if ( senate [ i ] == 'R' ) qR . push ( i ); else qD . push ( i ); while ( ! qR . empty () && ! qD . empty ()) { const int indexR = qR . front (); qR . pop (); const int indexD = qD . front (); qD . pop (); if ( indexR < indexD ) qR . push ( indexR + n ); else qD . push ( indexD + n ); } return qR . empty () ? \"Dire\" : \"Radiant\" ; } };","title":"649. Dota2 Senate"},{"location":"problems/0649/#649-dota2-senate","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string predictPartyVictory ( string senate ) { const int n = senate . length (); queue < int > qR ; queue < int > qD ; for ( int i = 0 ; i < n ; ++ i ) if ( senate [ i ] == 'R' ) qR . push ( i ); else qD . push ( i ); while ( ! qR . empty () && ! qD . empty ()) { const int indexR = qR . front (); qR . pop (); const int indexD = qD . front (); qD . pop (); if ( indexR < indexD ) qR . push ( indexR + n ); else qD . push ( indexD + n ); } return qR . empty () ? \"Dire\" : \"Radiant\" ; } };","title":"649. Dota2 Senate"},{"location":"problems/0650/","text":"650. 2 Keys Keyboard Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minSteps ( int n ) { // dp[i] := min steps to get i 'A' vector < int > dp ( n + 1 ); for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; // copy 'A', then paste 'A' i - 1 times for ( int j = i / 2 ; i > 1 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; // paste dp[j] i / j times break ; } } return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSteps ( int n ) { int [] dp = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; j > 2 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def minSteps ( self , n : int ) -> int : dp = [ i for i in range ( n + 1 )] for i in range ( 2 , n + 1 ): for j in range ( i // 2 , 2 , - 1 ): if i % j == 0 : dp [ i ] = dp [ j ] + i // j break return dp [ n ] if n > 1 else 0","title":"650. 2 Keys Keyboard"},{"location":"problems/0650/#650-2-keys-keyboard","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minSteps ( int n ) { // dp[i] := min steps to get i 'A' vector < int > dp ( n + 1 ); for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; // copy 'A', then paste 'A' i - 1 times for ( int j = i / 2 ; i > 1 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; // paste dp[j] i / j times break ; } } return dp [ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minSteps ( int n ) { int [] dp = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; j > 2 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def minSteps ( self , n : int ) -> int : dp = [ i for i in range ( n + 1 )] for i in range ( 2 , n + 1 ): for j in range ( i // 2 , 2 , - 1 ): if i % j == 0 : dp [ i ] = dp [ j ] + i // j break return dp [ n ] if n > 1 else 0","title":"650. 2 Keys Keyboard"},{"location":"problems/0651/","text":"651. 4 Keys Keyboard \ud83d\udd12","title":"651. 4 Keys Keyboard"},{"location":"problems/0651/#651-4-keys-keyboard","text":"","title":"651. 4 Keys Keyboard \ud83d\udd12"},{"location":"problems/0652/","text":"652. Find Duplicate Subtrees Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < TreeNode *> findDuplicateSubtrees ( TreeNode * root ) { vector < TreeNode *> ans ; unordered_map < string , int > count ; function < string ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) -> string { if ( ! root ) return \"#\" ; string hashed = to_string ( root -> val ) + \",\" + preorder ( root -> left ) + \",\" + preorder ( root -> right ); if ( count [ hashed ] == 1 ) ans . push_back ( root ); ++ count [ hashed ]; return hashed ; }; preorder ( root ); return ans ; } };","title":"652. Find Duplicate Subtrees"},{"location":"problems/0652/#652-find-duplicate-subtrees","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < TreeNode *> findDuplicateSubtrees ( TreeNode * root ) { vector < TreeNode *> ans ; unordered_map < string , int > count ; function < string ( TreeNode * ) > preorder = [ & ]( TreeNode * root ) -> string { if ( ! root ) return \"#\" ; string hashed = to_string ( root -> val ) + \",\" + preorder ( root -> left ) + \",\" + preorder ( root -> right ); if ( count [ hashed ] == 1 ) ans . push_back ( root ); ++ count [ hashed ]; return hashed ; }; preorder ( root ); return ans ; } };","title":"652. Find Duplicate Subtrees"},{"location":"problems/0653/","text":"653. Two Sum IV - Input is a BST Time: $O(n)$ Space: $O(h) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class BSTIterator { public : BSTIterator ( TreeNode * root , bool forward ) : forward ( forward ) { while ( root ) { stack . push ( root ); root = forward ? root -> left : root -> right ; } } int next () { TreeNode * node = stack . top (); stack . pop (); const int res = node -> val ; node = forward ? node -> right : node -> left ; while ( node ) { stack . push ( node ); node = forward ? node -> left : node -> right ; } return res ; } private : stack < TreeNode *> stack ; bool forward ; }; class Solution { public : bool findTarget ( TreeNode * root , int k ) { if ( ! root ) return false ; BSTIterator left ( root , true ); BSTIterator right ( root , false ); for ( int l = left . next (), r = right . next (); l < r ;) { const int sum = l + r ; if ( sum == k ) return true ; if ( sum < k ) l = left . next (); else r = right . next (); } return false ; } };","title":"653. Two Sum IV - Input is a BST"},{"location":"problems/0653/#653-two-sum-iv-input-is-a-bst","text":"Time: $O(n)$ Space: $O(h) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class BSTIterator { public : BSTIterator ( TreeNode * root , bool forward ) : forward ( forward ) { while ( root ) { stack . push ( root ); root = forward ? root -> left : root -> right ; } } int next () { TreeNode * node = stack . top (); stack . pop (); const int res = node -> val ; node = forward ? node -> right : node -> left ; while ( node ) { stack . push ( node ); node = forward ? node -> left : node -> right ; } return res ; } private : stack < TreeNode *> stack ; bool forward ; }; class Solution { public : bool findTarget ( TreeNode * root , int k ) { if ( ! root ) return false ; BSTIterator left ( root , true ); BSTIterator right ( root , false ); for ( int l = left . next (), r = right . next (); l < r ;) { const int sum = l + r ; if ( sum == k ) return true ; if ( sum < k ) l = left . next (); else r = right . next (); } return false ; } };","title":"653. Two Sum IV - Input is a BST"},{"location":"problems/0654/","text":"654. Maximum Binary Tree","title":"654. Maximum Binary Tree"},{"location":"problems/0654/#654-maximum-binary-tree","text":"","title":"654. Maximum Binary Tree"},{"location":"problems/0655/","text":"655. Print Binary Tree","title":"655. Print Binary Tree"},{"location":"problems/0655/#655-print-binary-tree","text":"","title":"655. Print Binary Tree"},{"location":"problems/0656/","text":"656. Coin Path \ud83d\udd12","title":"656. Coin Path"},{"location":"problems/0656/#656-coin-path","text":"","title":"656. Coin Path \ud83d\udd12"},{"location":"problems/0657/","text":"657. Robot Return to Origin Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool judgeCircle ( string moves ) { int right = 0 ; int up = 0 ; for ( const char move : moves ) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean judgeCircle ( String moves ) { int right = 0 ; int up = 0 ; for ( char move : moves . toCharArray ()) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } } Python 1 2 3 class Solution : def judgeCircle ( self , moves : str ) -> bool : return moves . count ( 'R' ) == moves . count ( 'L' ) and moves . count ( 'U' ) == moves . count ( 'D' )","title":"657. Robot Return to Origin"},{"location":"problems/0657/#657-robot-return-to-origin","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool judgeCircle ( string moves ) { int right = 0 ; int up = 0 ; for ( const char move : moves ) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean judgeCircle ( String moves ) { int right = 0 ; int up = 0 ; for ( char move : moves . toCharArray ()) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } } Python 1 2 3 class Solution : def judgeCircle ( self , moves : str ) -> bool : return moves . count ( 'R' ) == moves . count ( 'L' ) and moves . count ( 'U' ) == moves . count ( 'D' )","title":"657. Robot Return to Origin"},{"location":"problems/0658/","text":"658. Find K Closest Elements Time: $O(\\log(n - k))$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { int l = 0 ; int r = arr . size () - k ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( x - arr [ m ] > arr [ m + k ] - x ) l = m + 1 ; else r = m ; } return { begin ( arr ) + l , begin ( arr ) + l + k }; } };","title":"658. Find K Closest Elements"},{"location":"problems/0658/#658-find-k-closest-elements","text":"Time: $O(\\log(n - k))$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { int l = 0 ; int r = arr . size () - k ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( x - arr [ m ] > arr [ m + k ] - x ) l = m + 1 ; else r = m ; } return { begin ( arr ) + l , begin ( arr ) + l + k }; } };","title":"658. Find K Closest Elements"},{"location":"problems/0659/","text":"659. Split Array into Consecutive Subsequences Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool isPossible ( vector < int >& nums ) { unordered_map < int , int > count ; vector < int > starts ; vector < int > ends ; for ( const int num : nums ) ++ count [ num ]; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; const int num = nums [ i ]; const int currCount = count [ num ]; const int prevCount = count . count ( num - 1 ) ? count [ num - 1 ] : 0 ; const int nextCount = count . count ( num + 1 ) ? count [ num + 1 ] : 0 ; for ( int j = 0 ; j < currCount - prevCount ; ++ j ) starts . push_back ( num ); for ( int j = 0 ; j < currCount - nextCount ; ++ j ) ends . push_back ( num ); } for ( int i = 0 ; i < starts . size (); ++ i ) if ( ends [ i ] - starts [ i ] < 2 ) return false ; return true ; } };","title":"659. Split Array into Consecutive Subsequences"},{"location":"problems/0659/#659-split-array-into-consecutive-subsequences","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool isPossible ( vector < int >& nums ) { unordered_map < int , int > count ; vector < int > starts ; vector < int > ends ; for ( const int num : nums ) ++ count [ num ]; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; const int num = nums [ i ]; const int currCount = count [ num ]; const int prevCount = count . count ( num - 1 ) ? count [ num - 1 ] : 0 ; const int nextCount = count . count ( num + 1 ) ? count [ num + 1 ] : 0 ; for ( int j = 0 ; j < currCount - prevCount ; ++ j ) starts . push_back ( num ); for ( int j = 0 ; j < currCount - nextCount ; ++ j ) ends . push_back ( num ); } for ( int i = 0 ; i < starts . size (); ++ i ) if ( ends [ i ] - starts [ i ] < 2 ) return false ; return true ; } };","title":"659. Split Array into Consecutive Subsequences"},{"location":"problems/0660/","text":"660. Remove 9 \ud83d\udd12","title":"660. Remove 9"},{"location":"problems/0660/#660-remove-9","text":"","title":"660. Remove 9 \ud83d\udd12"},{"location":"problems/0661/","text":"661. Image Smoother Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int x = max ( 0 , i - 1 ); x < min ( m , i + 2 ); ++ x ) for ( int y = max ( 0 , j - 1 ); y < min ( n , j + 2 ); ++ y ) { ones += M [ x ][ y ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ] . length ; int ans [][] = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ] ; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans","title":"661. Image Smoother"},{"location":"problems/0661/#661-image-smoother","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int x = max ( 0 , i - 1 ); x < min ( m , i + 2 ); ++ x ) for ( int y = max ( 0 , j - 1 ); y < min ( n , j + 2 ); ++ y ) { ones += M [ x ][ y ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ] . length ; int ans [][] = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ] ; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans","title":"661. Image Smoother"},{"location":"problems/0662/","text":"662. Maximum Width of Binary Tree Approach 1: BFS Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < pair < TreeNode * , int >> q {{{ root , 1 }}}; // {node, index} while ( ! q . empty ()) { const int offset = q . front (). second * 2 ; ans = max ( ans , q . back (). second - q . front (). second + 1 ); for ( int i = q . size (); i > 0 ; -- i ) { const auto [ node , index ] = q . front (); q . pop (); if ( node -> left ) q . push ({ node -> left , index * 2 - offset }); if ( node -> right ) q . push ({ node -> right , index * 2 + 1 - offset }); } } return ans ; } }; Approach 2: DFS (Overflow) Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; long ans = 0 ; vector < long > startOfLevel ; function < void ( TreeNode * , int , long ) > dfs = [ & ]( TreeNode * root , int level , long index ) { if ( ! root ) return ; if ( startOfLevel . size () == level ) startOfLevel . push_back ( index ); ans = max ( ans , index - startOfLevel [ level ] + 1 ); dfs ( root -> left , level + 1 , index * 2 ); dfs ( root -> right , level + 1 , index * 2 + 1 ); }; dfs ( root , 0 , 1 ); return ans ; } };","title":"662. Maximum Width of Binary Tree"},{"location":"problems/0662/#662-maximum-width-of-binary-tree","text":"","title":"662. Maximum Width of Binary Tree"},{"location":"problems/0662/#approach-1-bfs","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < pair < TreeNode * , int >> q {{{ root , 1 }}}; // {node, index} while ( ! q . empty ()) { const int offset = q . front (). second * 2 ; ans = max ( ans , q . back (). second - q . front (). second + 1 ); for ( int i = q . size (); i > 0 ; -- i ) { const auto [ node , index ] = q . front (); q . pop (); if ( node -> left ) q . push ({ node -> left , index * 2 - offset }); if ( node -> right ) q . push ({ node -> right , index * 2 + 1 - offset }); } } return ans ; } };","title":"Approach 1: BFS"},{"location":"problems/0662/#approach-2-dfs-overflow","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int widthOfBinaryTree ( TreeNode * root ) { if ( ! root ) return 0 ; long ans = 0 ; vector < long > startOfLevel ; function < void ( TreeNode * , int , long ) > dfs = [ & ]( TreeNode * root , int level , long index ) { if ( ! root ) return ; if ( startOfLevel . size () == level ) startOfLevel . push_back ( index ); ans = max ( ans , index - startOfLevel [ level ] + 1 ); dfs ( root -> left , level + 1 , index * 2 ); dfs ( root -> right , level + 1 , index * 2 + 1 ); }; dfs ( root , 0 , 1 ); return ans ; } };","title":"Approach 2: DFS (Overflow)"},{"location":"problems/0663/","text":"663. Equal Tree Partition \ud83d\udd12","title":"663. Equal Tree Partition"},{"location":"problems/0663/#663-equal-tree-partition","text":"","title":"663. Equal Tree Partition \ud83d\udd12"},{"location":"problems/0664/","text":"664. Strange Printer","title":"664. Strange Printer"},{"location":"problems/0664/#664-strange-printer","text":"","title":"664. Strange Printer"},{"location":"problems/0665/","text":"665. Non-decreasing Array Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool checkPossibility ( vector < int >& nums ) { bool modified = false ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] < nums [ i - 1 ]) { if ( modified ) return false ; if ( i == 1 || nums [ i ] >= nums [ i - 2 ]) nums [ i - 1 ] = nums [ i ]; // decrease previous value else nums [ i ] = nums [ i - 1 ]; // increase current value modified = true ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] > nums [ i + 1 ] ) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ]","title":"665. Non-decreasing Array"},{"location":"problems/0665/#665-non-decreasing-array","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool checkPossibility ( vector < int >& nums ) { bool modified = false ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] < nums [ i - 1 ]) { if ( modified ) return false ; if ( i == 1 || nums [ i ] >= nums [ i - 2 ]) nums [ i - 1 ] = nums [ i ]; // decrease previous value else nums [ i ] = nums [ i - 1 ]; // increase current value modified = true ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] > nums [ i + 1 ] ) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ]","title":"665. Non-decreasing Array"},{"location":"problems/0666/","text":"666. Path Sum IV \ud83d\udd12","title":"666. Path Sum IV"},{"location":"problems/0666/#666-path-sum-iv","text":"","title":"666. Path Sum IV \ud83d\udd12"},{"location":"problems/0667/","text":"667. Beautiful Arrangement II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n - k ; ++ i ) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans","title":"667. Beautiful Arrangement II"},{"location":"problems/0667/#667-beautiful-arrangement-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n - k ; ++ i ) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans","title":"667. Beautiful Arrangement II"},{"location":"problems/0668/","text":"668. Kth Smallest Number in Multiplication Table Time: $O(m\\log mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int findKthNumber ( int m , int n , int k ) { int l = 1 ; int r = m * n ; auto numsNoGreaterThan = [ & ]( int target ) { int count = 0 ; // for each row i, count numbers that are no greater than m for ( int i = 1 ; i <= m ; ++ i ) count += min ( target / i , n ); return count ; }; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( mid ) < k ) l = mid + 1 ; else r = mid ; } return l ; } };","title":"668. Kth Smallest Number in Multiplication Table"},{"location":"problems/0668/#668-kth-smallest-number-in-multiplication-table","text":"Time: $O(m\\log mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int findKthNumber ( int m , int n , int k ) { int l = 1 ; int r = m * n ; auto numsNoGreaterThan = [ & ]( int target ) { int count = 0 ; // for each row i, count numbers that are no greater than m for ( int i = 1 ; i <= m ; ++ i ) count += min ( target / i , n ); return count ; }; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; if ( numsNoGreaterThan ( mid ) < k ) l = mid + 1 ; else r = mid ; } return l ; } };","title":"668. Kth Smallest Number in Multiplication Table"},{"location":"problems/0669/","text":"669. Trim a Binary Search Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * trimBST ( TreeNode * root , int L , int R ) { if ( ! root ) return nullptr ; if ( root -> val < L ) return trimBST ( root -> right , L , R ); if ( root -> val > R ) return trimBST ( root -> left , L , R ); root -> left = trimBST ( root -> left , L , R ); root -> right = trimBST ( root -> right , L , R ); return root ; } };","title":"669. Trim a Binary Search Tree"},{"location":"problems/0669/#669-trim-a-binary-search-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * trimBST ( TreeNode * root , int L , int R ) { if ( ! root ) return nullptr ; if ( root -> val < L ) return trimBST ( root -> right , L , R ); if ( root -> val > R ) return trimBST ( root -> left , L , R ); root -> left = trimBST ( root -> left , L , R ); root -> right = trimBST ( root -> right , L , R ); return root ; } };","title":"669. Trim a Binary Search Tree"},{"location":"problems/0670/","text":"670. Maximum Swap Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); vector < int > digitToIndex ( 10 ); for ( int i = 0 ; i < s . length (); ++ i ) digitToIndex [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char d = '9' ; d > s [ i ]; -- d ) if ( digitToIndex [ d - '0' ] > i ) { swap ( s [ i ], s [ digitToIndex [ d - '0' ]]); return stoi ( s ); } return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] digitToIndex = new int [ 10 ] ; for ( int i = 0 ; i < s . length ; ++ i ) digitToIndex [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; ++ i ) for ( char digit = '9' ; digit > s [ i ] ; -- digit ) if ( digitToIndex [ digit - '0' ] > i ) { s [ digitToIndex [ digit - '0' ]] = s [ i ] ; s [ i ] = digit ; return Integer . valueOf ( new String ( s )); } return num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"670. Maximum Swap"},{"location":"problems/0670/#670-maximum-swap","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); vector < int > digitToIndex ( 10 ); for ( int i = 0 ; i < s . length (); ++ i ) digitToIndex [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char d = '9' ; d > s [ i ]; -- d ) if ( digitToIndex [ d - '0' ] > i ) { swap ( s [ i ], s [ digitToIndex [ d - '0' ]]); return stoi ( s ); } return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] digitToIndex = new int [ 10 ] ; for ( int i = 0 ; i < s . length ; ++ i ) digitToIndex [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; ++ i ) for ( char digit = '9' ; digit > s [ i ] ; -- digit ) if ( digitToIndex [ digit - '0' ] > i ) { s [ digitToIndex [ digit - '0' ]] = s [ i ] ; s [ i ] = digit ; return Integer . valueOf ( new String ( s )); } return num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"670. Maximum Swap"},{"location":"problems/0671/","text":"671. Second Minimum Node In a Binary Tree Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findSecondMinimumValue ( TreeNode * root ) { if ( ! root || ! root -> left ) return -1 ; int l = root -> left -> val ; int r = root -> right -> val ; // check if left/right child's value == parent's value if ( l == root -> val ) l = findSecondMinimumValue ( root -> left ); if ( r == root -> val ) r = findSecondMinimumValue ( root -> right ); if ( l > -1 && r > -1 ) return min ( l , r ); if ( l > -1 ) return l ; return r ; } };","title":"671. Second Minimum Node In a Binary Tree"},{"location":"problems/0671/#671-second-minimum-node-in-a-binary-tree","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findSecondMinimumValue ( TreeNode * root ) { if ( ! root || ! root -> left ) return -1 ; int l = root -> left -> val ; int r = root -> right -> val ; // check if left/right child's value == parent's value if ( l == root -> val ) l = findSecondMinimumValue ( root -> left ); if ( r == root -> val ) r = findSecondMinimumValue ( root -> right ); if ( l > -1 && r > -1 ) return min ( l , r ); if ( l > -1 ) return l ; return r ; } };","title":"671. Second Minimum Node In a Binary Tree"},{"location":"problems/0672/","text":"672. Bulb Switcher II Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return vector < int > { 2 , 3 , 4 }[ n - 1 ]; if ( m == 2 ) return vector < int > { 2 , 4 , 7 }[ n - 1 ]; return pow ( 2 , n ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int flipLights ( int n , int m ) { n = Math . min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return new int [] { 2 , 3 , 4 } [ n - 1 ] ; if ( m == 2 ) return new int [] { 2 , 4 , 7 } [ n - 1 ] ; return ( int ) Math . pow ( 2 , n ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ]","title":"672. Bulb Switcher II"},{"location":"problems/0672/#672-bulb-switcher-ii","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return vector < int > { 2 , 3 , 4 }[ n - 1 ]; if ( m == 2 ) return vector < int > { 2 , 4 , 7 }[ n - 1 ]; return pow ( 2 , n ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int flipLights ( int n , int m ) { n = Math . min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return new int [] { 2 , 3 , 4 } [ n - 1 ] ; if ( m == 2 ) return new int [] { 2 , 4 , 7 } [ n - 1 ] ; return ( int ) Math . pow ( 2 , n ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ]","title":"672. Bulb Switcher II"},{"location":"problems/0673/","text":"673. Number of Longest Increasing Subsequence Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int findNumberOfLIS ( vector < int >& nums ) { const int n = nums . size (); int ans = 0 ; int maxLength = 0 ; vector < int > length ( n , 1 ); // length[i] := LIS's length ending w/ nums[i] vector < int > count ( n , 1 ); // count[i] := # of the LIS ending w/ nums[i] // calculate length and count arrays for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ]; } else if ( length [ i ] == length [ j ] + 1 ) { count [ i ] += count [ j ]; } // get # of LIS for ( int i = 0 ; i < n ; ++ i ) if ( length [ i ] > maxLength ) { maxLength = length [ i ]; ans = count [ i ]; } else if ( length [ i ] == maxLength ) { ans += count [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.util.Arrays ; class Solution { public int findNumberOfLIS ( int [] nums ) { final int n = nums . length ; int ans = 0 ; int maxLength = 0 ; int [] length = new int [ n ] ; // length[i] := LIS's length ending w/ nums[i] int [] count = new int [ n ] ; // count[i] := # of the LIS ending w/ nums[i] Arrays . fill ( length , 1 ); Arrays . fill ( count , 1 ); // calculate length and count arrays for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ] ; } else if ( length [ i ] == length [ j ] + 1 ) { count [ i ] += count [ j ] ; } // get # of LIS for ( int i = 0 ; i < n ; ++ i ) if ( length [ i ] > maxLength ) { maxLength = length [ i ] ; ans = count [ i ] ; } else if ( length [ i ] == maxLength ) { ans += count [ i ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def findNumberOfLIS ( self , nums : List [ int ]) -> int : ans = 0 maxLength = 0 length = [ 1 ] * len ( nums ) count = [ 1 ] * len ( nums ) for i , num in enumerate ( nums ): for j in range ( i ): if nums [ j ] < num : if length [ i ] == length [ j ] + 1 : count [ i ] += count [ j ] elif length [ i ] < length [ j ] + 1 : length [ i ] = length [ j ] + 1 count [ i ] = count [ j ] if maxLength == length [ i ]: ans += count [ i ] elif maxLength < length [ i ]: maxLength = length [ i ] ans = count [ i ] return ans","title":"673. Number of Longest Increasing Subsequence"},{"location":"problems/0673/#673-number-of-longest-increasing-subsequence","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int findNumberOfLIS ( vector < int >& nums ) { const int n = nums . size (); int ans = 0 ; int maxLength = 0 ; vector < int > length ( n , 1 ); // length[i] := LIS's length ending w/ nums[i] vector < int > count ( n , 1 ); // count[i] := # of the LIS ending w/ nums[i] // calculate length and count arrays for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ]; } else if ( length [ i ] == length [ j ] + 1 ) { count [ i ] += count [ j ]; } // get # of LIS for ( int i = 0 ; i < n ; ++ i ) if ( length [ i ] > maxLength ) { maxLength = length [ i ]; ans = count [ i ]; } else if ( length [ i ] == maxLength ) { ans += count [ i ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.util.Arrays ; class Solution { public int findNumberOfLIS ( int [] nums ) { final int n = nums . length ; int ans = 0 ; int maxLength = 0 ; int [] length = new int [ n ] ; // length[i] := LIS's length ending w/ nums[i] int [] count = new int [ n ] ; // count[i] := # of the LIS ending w/ nums[i] Arrays . fill ( length , 1 ); Arrays . fill ( count , 1 ); // calculate length and count arrays for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ] ; } else if ( length [ i ] == length [ j ] + 1 ) { count [ i ] += count [ j ] ; } // get # of LIS for ( int i = 0 ; i < n ; ++ i ) if ( length [ i ] > maxLength ) { maxLength = length [ i ] ; ans = count [ i ] ; } else if ( length [ i ] == maxLength ) { ans += count [ i ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def findNumberOfLIS ( self , nums : List [ int ]) -> int : ans = 0 maxLength = 0 length = [ 1 ] * len ( nums ) count = [ 1 ] * len ( nums ) for i , num in enumerate ( nums ): for j in range ( i ): if nums [ j ] < num : if length [ i ] == length [ j ] + 1 : count [ i ] += count [ j ] elif length [ i ] < length [ j ] + 1 : length [ i ] = length [ j ] + 1 count [ i ] = count [ j ] if maxLength == length [ i ]: ans += count [ i ] elif maxLength < length [ i ]: maxLength = length [ i ] ans = count [ i ] return ans","title":"673. Number of Longest Increasing Subsequence"},{"location":"problems/0674/","text":"674. Longest Continuous Increasing Subsequence Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { if ( r > 0 && nums [ r ] <= nums [ r - 1 ]) l = r ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { if ( r > 0 && nums [ r ] <= nums [ r - 1 ] ) l = r ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans","title":"674. Longest Continuous Increasing Subsequence"},{"location":"problems/0674/#674-longest-continuous-increasing-subsequence","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { if ( r > 0 && nums [ r ] <= nums [ r - 1 ]) l = r ; ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { if ( r > 0 && nums [ r ] <= nums [ r - 1 ] ) l = r ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans","title":"674. Longest Continuous Increasing Subsequence"},{"location":"problems/0675/","text":"675. Cut Off Trees for Golf Event Time: $O(m^2n^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : int cutOffTree ( vector < vector < int >>& forest ) { const int m = forest . size (); const int n = forest [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return forest [ a . first ][ a . second ] > forest [ b . first ][ b . second ]; // sorted by tree's height }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( forest [ i ][ j ] > 0 ) pq . push ({ i , j }); auto bfs = [ & ]( int si , int sj , int ei , int ej ) { int steps = 0 ; queue < pair < int , int >> q {{{ si , sj }}}; vector < vector < bool >> seen ( m , vector < bool > ( n )); seen [ si ][ sj ] = true ; while ( ! q . empty ()) { for ( int s = q . size (); s > 0 ; -- s ) { const auto [ i , j ] = q . front (); q . pop (); if ( i == ei && j == ej ) return steps ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] || forest [ x ][ y ] == 0 ) continue ; q . push ({ x , y }); seen [ x ][ y ] = true ; } } ++ steps ; } return -1 ; }; int ans = 0 ; int i = 0 ; int j = 0 ; while ( ! pq . empty ()) { const auto [ row , col ] = pq . top (); pq . pop (); // walk from (i, j) to (row, col) const int steps = bfs ( i , j , row , col ); if ( steps < 0 ) return -1 ; ans += steps ; i = row ; j = col ; } return ans ; } };","title":"675. Cut Off Trees for Golf Event"},{"location":"problems/0675/#675-cut-off-trees-for-golf-event","text":"Time: $O(m^2n^2)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : int cutOffTree ( vector < vector < int >>& forest ) { const int m = forest . size (); const int n = forest [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return forest [ a . first ][ a . second ] > forest [ b . first ][ b . second ]; // sorted by tree's height }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( forest [ i ][ j ] > 0 ) pq . push ({ i , j }); auto bfs = [ & ]( int si , int sj , int ei , int ej ) { int steps = 0 ; queue < pair < int , int >> q {{{ si , sj }}}; vector < vector < bool >> seen ( m , vector < bool > ( n )); seen [ si ][ sj ] = true ; while ( ! q . empty ()) { for ( int s = q . size (); s > 0 ; -- s ) { const auto [ i , j ] = q . front (); q . pop (); if ( i == ei && j == ej ) return steps ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( seen [ x ][ y ] || forest [ x ][ y ] == 0 ) continue ; q . push ({ x , y }); seen [ x ][ y ] = true ; } } ++ steps ; } return -1 ; }; int ans = 0 ; int i = 0 ; int j = 0 ; while ( ! pq . empty ()) { const auto [ row , col ] = pq . top (); pq . pop (); // walk from (i, j) to (row, col) const int steps = bfs ( i , j , row , col ); if ( steps < 0 ) return -1 ; ans += steps ; i = row ; j = col ; } return ans ; } };","title":"675. Cut Off Trees for Golf Event"},{"location":"problems/0676/","text":"676. Implement Magic Dictionary Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class MagicDictionary { public : void buildDict ( vector < string > dict ) { for ( const string & word : dict ) insert ( word ); } bool search ( string word ) { TrieNode * node = & root ; for ( int i = 0 ; i < word . length (); ++ i ) { const char c = word [ i ]; for ( int j = 0 ; j < 26 ; ++ j ) { if ( 'a' + j == c ) continue ; // current branch exists if ( ! node -> children [ j ]) continue ; // no branch j if ( find ( word , i + 1 , node -> children [ j ])) return true ; } if ( ! node -> children [ c - 'a' ]) return false ; node = node -> children [ c - 'a' ]; } return false ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool find ( const string & word , int s , TrieNode * node ) { for ( int i = s ; i < word . length (); ++ i ) { const char c = word [ i ]; if ( ! node -> children [ c - 'a' ]) return false ; node = node -> children [ c - 'a' ]; } return node -> isWord ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MagicDictionary { public void buildDict ( String [] dict ) { for ( final String word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( ! map . containsKey ( modifiedWord )) map . put ( modifiedWord , word . charAt ( i )); else if ( map . get ( modifiedWord ) != word . charAt ( i )) map . put ( modifiedWord , '*' ); } } public boolean search ( String word ) { for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( map . containsKey ( modifiedWord ) && map . get ( modifiedWord ) != word . charAt ( i )) return true ; } return false ; } private Map < String , Character > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MagicDictionary : def __init__ ( self ): self . dict = {} def buildDict ( self , dict : List [ str ]) -> None : for word in dict : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord not in self . dict : self . dict [ modifiedWord ] = c elif self . dict [ modifiedWord ] != c : self . dict [ modifiedWord ] = '*' def search ( self , word : str ) -> bool : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord in self . dict and self . dict [ modifiedWord ] != c : return True return False","title":"676. Implement Magic Dictionary"},{"location":"problems/0676/#676-implement-magic-dictionary","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class MagicDictionary { public : void buildDict ( vector < string > dict ) { for ( const string & word : dict ) insert ( word ); } bool search ( string word ) { TrieNode * node = & root ; for ( int i = 0 ; i < word . length (); ++ i ) { const char c = word [ i ]; for ( int j = 0 ; j < 26 ; ++ j ) { if ( 'a' + j == c ) continue ; // current branch exists if ( ! node -> children [ j ]) continue ; // no branch j if ( find ( word , i + 1 , node -> children [ j ])) return true ; } if ( ! node -> children [ c - 'a' ]) return false ; node = node -> children [ c - 'a' ]; } return false ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool find ( const string & word , int s , TrieNode * node ) { for ( int i = s ; i < word . length (); ++ i ) { const char c = word [ i ]; if ( ! node -> children [ c - 'a' ]) return false ; node = node -> children [ c - 'a' ]; } return node -> isWord ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MagicDictionary { public void buildDict ( String [] dict ) { for ( final String word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( ! map . containsKey ( modifiedWord )) map . put ( modifiedWord , word . charAt ( i )); else if ( map . get ( modifiedWord ) != word . charAt ( i )) map . put ( modifiedWord , '*' ); } } public boolean search ( String word ) { for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( map . containsKey ( modifiedWord ) && map . get ( modifiedWord ) != word . charAt ( i )) return true ; } return false ; } private Map < String , Character > map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MagicDictionary : def __init__ ( self ): self . dict = {} def buildDict ( self , dict : List [ str ]) -> None : for word in dict : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord not in self . dict : self . dict [ modifiedWord ] = c elif self . dict [ modifiedWord ] != c : self . dict [ modifiedWord ] = '*' def search ( self , word : str ) -> bool : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord in self . dict and self . dict [ modifiedWord ] != c : return True return False","title":"676. Implement Magic Dictionary"},{"location":"problems/0677/","text":"677. Map Sum Pairs","title":"677. Map Sum Pairs"},{"location":"problems/0677/#677-map-sum-pairs","text":"","title":"677. Map Sum Pairs"},{"location":"problems/0678/","text":"678. Valid Parenthesis String Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool checkValidString ( const string & s ) { int low = 0 ; // lower bound of valid '(' count int high = 0 ; // upper bound of valid '(' count for ( const char c : s ) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = max ( 0 , -- low ); -- high ; break ; case '*' : low = max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean checkValidString ( final String s ) { int low = 0 ; // lower bound of valid '(' count int high = 0 ; // upper bound of valid '(' count for ( final char c : s . toCharArray ()) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = Math . max ( 0 , -- low ); -- high ; break ; case '*' : low = Math . max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def checkValidString ( self , s : str ) -> bool : low = 0 high = 0 for c in s : if c == '(' : low += 1 high += 1 elif c == ')' : if low > 0 : low -= 1 high -= 1 else : if low > 0 : low -= 1 high += 1 if high < 0 : return False return low == 0","title":"678. Valid Parenthesis String"},{"location":"problems/0678/#678-valid-parenthesis-string","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool checkValidString ( const string & s ) { int low = 0 ; // lower bound of valid '(' count int high = 0 ; // upper bound of valid '(' count for ( const char c : s ) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = max ( 0 , -- low ); -- high ; break ; case '*' : low = max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean checkValidString ( final String s ) { int low = 0 ; // lower bound of valid '(' count int high = 0 ; // upper bound of valid '(' count for ( final char c : s . toCharArray ()) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = Math . max ( 0 , -- low ); -- high ; break ; case '*' : low = Math . max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def checkValidString ( self , s : str ) -> bool : low = 0 high = 0 for c in s : if c == '(' : low += 1 high += 1 elif c == ')' : if low > 0 : low -= 1 high -= 1 else : if low > 0 : low -= 1 high += 1 if high < 0 : return False return low == 0","title":"678. Valid Parenthesis String"},{"location":"problems/0679/","text":"679. 24 Game Time: $O(2^n)$, where n = 4 Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : bool judgePoint24 ( vector < int >& nums ) { vector < double > doubleNums ; for ( const int num : nums ) doubleNums . push_back ( num ); return dfs ( doubleNums ); } private : bool dfs ( vector < double >& nums ) { if ( nums . size () == 1 ) return abs ( nums [ 0 ] - 24 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { for ( double num : generate ( nums [ i ], nums [ j ])) { vector < double > nextRound { num }; for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; // used in generate() nextRound . push_back ( nums [ k ]); } if ( dfs ( nextRound )) return true ; } } return false ; } vector < double > generate ( double a , double b ) { return { a * b , a / b , b / a , a + b , a - b , b - a }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public boolean judgePoint24 ( int [] nums ) { List < Double > doubleNums = new ArrayList <> (); for ( int num : nums ) doubleNums . add (( double ) num ); return dfs ( doubleNums ); } private boolean dfs ( List < Double > nums ) { if ( nums . size () == 1 ) return Math . abs ( nums . get ( 0 ) - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums . get ( i ), nums . get ( j ))) { List < Double > nextRound = new ArrayList <> ( Arrays . asList ( num )); for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . add ( nums . get ( k )); } if ( dfs ( nextRound )) return true ; } return false ; } private List < Double > generate ( double a , double b ) { return new ArrayList <> ( Arrays . asList ( a * b , a / b , b / a , a + b , a - b , b - a )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def judgePoint24 ( self , nums : List [ int ]) -> bool : def generate ( a : float , b : float ) -> List [ float ]: return [ a * b , float ( 'inf' ) if b == 0 else a / b , float ( 'inf' ) if a == 0 else b / a , a + b , a - b , b - a ] def dfs ( nums : List [ float ]) -> bool : if len ( nums ) == 1 : return abs ( nums [ 0 ] - 24.0 ) < 0.001 for i in range ( len ( nums )): for j in range ( i + 1 , len ( nums )): for num in generate ( nums [ i ], nums [ j ]): nextRound = [ num ] for k in range ( len ( nums )): if k == i or k == j : continue nextRound . append ( nums [ k ]) if dfs ( nextRound ): return True return False return dfs ( nums )","title":"679. 24 Game"},{"location":"problems/0679/#679-24-game","text":"Time: $O(2^n)$, where n = 4 Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : bool judgePoint24 ( vector < int >& nums ) { vector < double > doubleNums ; for ( const int num : nums ) doubleNums . push_back ( num ); return dfs ( doubleNums ); } private : bool dfs ( vector < double >& nums ) { if ( nums . size () == 1 ) return abs ( nums [ 0 ] - 24 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { for ( double num : generate ( nums [ i ], nums [ j ])) { vector < double > nextRound { num }; for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; // used in generate() nextRound . push_back ( nums [ k ]); } if ( dfs ( nextRound )) return true ; } } return false ; } vector < double > generate ( double a , double b ) { return { a * b , a / b , b / a , a + b , a - b , b - a }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public boolean judgePoint24 ( int [] nums ) { List < Double > doubleNums = new ArrayList <> (); for ( int num : nums ) doubleNums . add (( double ) num ); return dfs ( doubleNums ); } private boolean dfs ( List < Double > nums ) { if ( nums . size () == 1 ) return Math . abs ( nums . get ( 0 ) - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums . get ( i ), nums . get ( j ))) { List < Double > nextRound = new ArrayList <> ( Arrays . asList ( num )); for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . add ( nums . get ( k )); } if ( dfs ( nextRound )) return true ; } return false ; } private List < Double > generate ( double a , double b ) { return new ArrayList <> ( Arrays . asList ( a * b , a / b , b / a , a + b , a - b , b - a )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def judgePoint24 ( self , nums : List [ int ]) -> bool : def generate ( a : float , b : float ) -> List [ float ]: return [ a * b , float ( 'inf' ) if b == 0 else a / b , float ( 'inf' ) if a == 0 else b / a , a + b , a - b , b - a ] def dfs ( nums : List [ float ]) -> bool : if len ( nums ) == 1 : return abs ( nums [ 0 ] - 24.0 ) < 0.001 for i in range ( len ( nums )): for j in range ( i + 1 , len ( nums )): for num in generate ( nums [ i ], nums [ j ]): nextRound = [ num ] for k in range ( len ( nums )): if k == i or k == j : continue nextRound . append ( nums [ k ]) if dfs ( nextRound ): return True return False return dfs ( nums )","title":"679. 24 Game"},{"location":"problems/0680/","text":"680. Valid Palindrome II Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool validPalindrome ( string s ) { for ( int l = 0 , r = s . length () - 1 ; l < r ; ++ l , -- r ) if ( s [ l ] != s [ r ]) return validPalindrome ( s , l + 1 , r ) || validPalindrome ( s , l , r - 1 ); return true ; } private : bool validPalindrome ( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"680. Valid Palindrome II"},{"location":"problems/0680/#680-valid-palindrome-ii","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool validPalindrome ( string s ) { for ( int l = 0 , r = s . length () - 1 ; l < r ; ++ l , -- r ) if ( s [ l ] != s [ r ]) return validPalindrome ( s , l + 1 , r ) || validPalindrome ( s , l , r - 1 ); return true ; } private : bool validPalindrome ( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"680. Valid Palindrome II"},{"location":"problems/0681/","text":"681. Next Closest Time \ud83d\udd12","title":"681. Next Closest Time"},{"location":"problems/0681/#681-next-closest-time","text":"","title":"681. Next Closest Time \ud83d\udd12"},{"location":"problems/0682/","text":"682. Baseball Game","title":"682. Baseball Game"},{"location":"problems/0682/#682-baseball-game","text":"","title":"682. Baseball Game"},{"location":"problems/0683/","text":"683. K Empty Slots \ud83d\udd12","title":"683. K Empty Slots"},{"location":"problems/0683/#683-k-empty-slots","text":"","title":"683. K Empty Slots \ud83d\udd12"},{"location":"problems/0684/","text":"684. Redundant Connection Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } private : int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { UF uf ( edges . size () + 1 ); for ( const vector < int >& edge : edges ) if ( ! uf . union_ ( edge [ 0 ], edge [ 1 ])) return edge ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public int [] findRedundantConnection ( int [][] edges ) { UF uf = new UF ( edges . length ); for ( int [] edge : edges ) if ( ! uf . union ( edge [ 0 ] , edge [ 1 ] )) return edge ; throw new IllegalArgumentException (); } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def findRedundantConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: uf = UF ( len ( edges )) for edge in edges : if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"684. Redundant Connection"},{"location":"problems/0684/#684-redundant-connection","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } private : int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { UF uf ( edges . size () + 1 ); for ( const vector < int >& edge : edges ) if ( ! uf . union_ ( edge [ 0 ], edge [ 1 ])) return edge ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public int [] findRedundantConnection ( int [][] edges ) { UF uf = new UF ( edges . length ); for ( int [] edge : edges ) if ( ! uf . union ( edge [ 0 ] , edge [ 1 ] )) return edge ; throw new IllegalArgumentException (); } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def findRedundantConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: uf = UF ( len ( edges )) for edge in edges : if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"684. Redundant Connection"},{"location":"problems/0685/","text":"685. Redundant Connection II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } private : int find ( int u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges ) { vector < int > parents ( edges . size () + 1 ); int nodeWithTwoParents = 0 ; for ( const vector < int >& edge : edges ) { const int v = edge [ 1 ]; if ( ++ parents [ v ] == 2 ) { nodeWithTwoParents = v ; break ; } } // if there is no edge with two parents // we don't have to skip any edge if ( ! nodeWithTwoParents ) return findRedundantDirectedConnection ( edges , -1 ); for ( int i = edges . size () - 1 ; i >= 0 ; -- i ) if ( edges [ i ][ 1 ] == nodeWithTwoParents ) // try to delete edges[i] if ( findRedundantDirectedConnection ( edges , i ). empty ()) return edges [ i ]; throw ; } vector < int > findRedundantDirectedConnection ( const vector < vector < int >>& edges , int skippedEdgeIndex ) { UF uf ( edges . size () + 1 ); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union_ ( edges [ i ][ 0 ], edges [ i ][ 1 ])) return edges [ i ]; } return {}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Solution { public int [] findRedundantDirectedConnection ( int [][] edges ) { int [] parents = new int [ edges . length + 1 ] ; int nodeWithTwoParents = 0 ; for ( int [] edge : edges ) { int u = edge [ 0 ] ; int v = edge [ 1 ] ; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( nodeWithTwoParents == 0 ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . length - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ] ; int v = edges [ i ][ 1 ] ; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). length == 0 ) return edges [ i ] ; } throw new IllegalArgumentException (); } private int [] findRedundantDirectedConnection ( int [][] edges , int skippedEdgeIndex ) { UF uf = new UF ( edges . length ); for ( int i = 0 ; i < edges . length ; ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union ( edges [ i ][ 0 ] , edges [ i ][ 1 ] )) return edges [ i ] ; } return new int [] {}; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution : def findRedundantDirectedConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: def findRedundantDirectedConnection ( skippedEdgeIndex : int ) -> List [ int ]: uf = UF ( len ( edges ) + 1 ) for i , edge in enumerate ( edges ): if i == skippedEdgeIndex : continue if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge return [] parents = [ 0 ] * ( len ( edges ) + 1 ) nodeWithTwoParents = 0 for u , v in edges : parents [ v ] += 1 if parents [ v ] == 2 : nodeWithTwoParents = v if nodeWithTwoParents == 0 : return findRedundantDirectedConnection ( - 1 ) for i in range ( len ( edges ))[:: - 1 ]: u , v = edges [ i ] if v == nodeWithTwoParents : if findRedundantDirectedConnection ( i ) == []: return edges [ i ] class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"685. Redundant Connection II"},{"location":"problems/0685/#685-redundant-connection-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } private : int find ( int u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges ) { vector < int > parents ( edges . size () + 1 ); int nodeWithTwoParents = 0 ; for ( const vector < int >& edge : edges ) { const int v = edge [ 1 ]; if ( ++ parents [ v ] == 2 ) { nodeWithTwoParents = v ; break ; } } // if there is no edge with two parents // we don't have to skip any edge if ( ! nodeWithTwoParents ) return findRedundantDirectedConnection ( edges , -1 ); for ( int i = edges . size () - 1 ; i >= 0 ; -- i ) if ( edges [ i ][ 1 ] == nodeWithTwoParents ) // try to delete edges[i] if ( findRedundantDirectedConnection ( edges , i ). empty ()) return edges [ i ]; throw ; } vector < int > findRedundantDirectedConnection ( const vector < vector < int >>& edges , int skippedEdgeIndex ) { UF uf ( edges . size () + 1 ); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union_ ( edges [ i ][ 0 ], edges [ i ][ 1 ])) return edges [ i ]; } return {}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Solution { public int [] findRedundantDirectedConnection ( int [][] edges ) { int [] parents = new int [ edges . length + 1 ] ; int nodeWithTwoParents = 0 ; for ( int [] edge : edges ) { int u = edge [ 0 ] ; int v = edge [ 1 ] ; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( nodeWithTwoParents == 0 ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . length - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ] ; int v = edges [ i ][ 1 ] ; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). length == 0 ) return edges [ i ] ; } throw new IllegalArgumentException (); } private int [] findRedundantDirectedConnection ( int [][] edges , int skippedEdgeIndex ) { UF uf = new UF ( edges . length ); for ( int i = 0 ; i < edges . length ; ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union ( edges [ i ][ 0 ] , edges [ i ][ 1 ] )) return edges [ i ] ; } return new int [] {}; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution : def findRedundantDirectedConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: def findRedundantDirectedConnection ( skippedEdgeIndex : int ) -> List [ int ]: uf = UF ( len ( edges ) + 1 ) for i , edge in enumerate ( edges ): if i == skippedEdgeIndex : continue if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge return [] parents = [ 0 ] * ( len ( edges ) + 1 ) nodeWithTwoParents = 0 for u , v in edges : parents [ v ] += 1 if parents [ v ] == 2 : nodeWithTwoParents = v if nodeWithTwoParents == 0 : return findRedundantDirectedConnection ( - 1 ) for i in range ( len ( edges ))[:: - 1 ]: u , v = edges [ i ] if v == nodeWithTwoParents : if findRedundantDirectedConnection ( i ) == []: return edges [ i ] class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"685. Redundant Connection II"},{"location":"problems/0686/","text":"686. Repeated String Match Time: $O(|A| + |B|)$ Space: $O(|A| + |B|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int repeatedStringMatch ( string A , string B ) { const int n = ceil (( double ) B . length () / A . length ()); string s ; for ( int i = 0 ; i < n ; ++ i ) s += A ; if ( s . find ( B ) != string :: npos ) return n ; if (( s + A ). find ( B ) != string :: npos ) return n + 1 ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int repeatedStringMatch ( String A , String B ) { final int n = ( int ) Math . ceil (( double ) B . length () / ( double ) A . length ()); String s = String . join ( \"\" , Collections . nCopies ( n , A )); if ( s . contains ( B )) return n ; if (( s + A ). contains ( B )) return n + 1 ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def repeatedStringMatch ( self , A : str , B : str ) -> int : n = math . ceil ( len ( B ) / len ( A )) s = A * n if B in s : return n if B in s + A : return n + 1 return - 1","title":"686. Repeated String Match"},{"location":"problems/0686/#686-repeated-string-match","text":"Time: $O(|A| + |B|)$ Space: $O(|A| + |B|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int repeatedStringMatch ( string A , string B ) { const int n = ceil (( double ) B . length () / A . length ()); string s ; for ( int i = 0 ; i < n ; ++ i ) s += A ; if ( s . find ( B ) != string :: npos ) return n ; if (( s + A ). find ( B ) != string :: npos ) return n + 1 ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int repeatedStringMatch ( String A , String B ) { final int n = ( int ) Math . ceil (( double ) B . length () / ( double ) A . length ()); String s = String . join ( \"\" , Collections . nCopies ( n , A )); if ( s . contains ( B )) return n ; if (( s + A ). contains ( B )) return n + 1 ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def repeatedStringMatch ( self , A : str , B : str ) -> int : n = math . ceil ( len ( B ) / len ( A )) s = A * n if B in s : return n if B in s + A : return n + 1 return - 1","title":"686. Repeated String Match"},{"location":"problems/0687/","text":"687. Longest Univalue Path","title":"687. Longest Univalue Path"},{"location":"problems/0687/#687-longest-univalue-path","text":"","title":"687. Longest Univalue Path"},{"location":"problems/0688/","text":"688. Knight Probability in Chessboard Time: $O(KN^2)$ Space: $O(N^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double knightProbability ( int N , int K , int r , int c ) { constexpr double kProb = 0.125 ; const vector < pair < int , int >> dirs {{ -2 , 1 }, { -1 , 2 }, { 1 , 2 }, { 2 , 1 }, { 2 , -1 }, { 1 , -2 }, { -1 , -2 }, { -2 , -1 }}; vector < vector < double >> dp ( N , vector < double > ( N )); dp [ r ][ c ] = 1 ; for ( int k = 0 ; k < K ; ++ k ) { vector < vector < double >> newDp ( N , vector < double > ( N )); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) if ( dp [ i ][ j ] > 0.0 ) { for ( const auto & [ dx , dy ] : dirs ) { const int x = i + dx ; const int y = j + dy ; if ( x < 0 || x >= N || y < 0 || y >= N ) continue ; newDp [ x ][ y ] += dp [ i ][ j ] * kProb ; } } swap ( dp , newDp ); } double ans = 0 ; for ( const vector < double >& row : dp ) ans += accumulate ( begin ( row ), end ( row ), 0.0 ); return ans ; } };","title":"688. Knight Probability in Chessboard"},{"location":"problems/0688/#688-knight-probability-in-chessboard","text":"Time: $O(KN^2)$ Space: $O(N^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double knightProbability ( int N , int K , int r , int c ) { constexpr double kProb = 0.125 ; const vector < pair < int , int >> dirs {{ -2 , 1 }, { -1 , 2 }, { 1 , 2 }, { 2 , 1 }, { 2 , -1 }, { 1 , -2 }, { -1 , -2 }, { -2 , -1 }}; vector < vector < double >> dp ( N , vector < double > ( N )); dp [ r ][ c ] = 1 ; for ( int k = 0 ; k < K ; ++ k ) { vector < vector < double >> newDp ( N , vector < double > ( N )); for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) if ( dp [ i ][ j ] > 0.0 ) { for ( const auto & [ dx , dy ] : dirs ) { const int x = i + dx ; const int y = j + dy ; if ( x < 0 || x >= N || y < 0 || y >= N ) continue ; newDp [ x ][ y ] += dp [ i ][ j ] * kProb ; } } swap ( dp , newDp ); } double ans = 0 ; for ( const vector < double >& row : dp ) ans += accumulate ( begin ( row ), end ( row ), 0.0 ); return ans ; } };","title":"688. Knight Probability in Chessboard"},{"location":"problems/0689/","text":"689. Maximum Sum of 3 Non-Overlapping Subarrays Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { const int n = nums . size () - k + 1 ; vector < int > sums ( n ); // sums[i] := sum(nums[i..i + k)) vector < int > l ( n ); // l[i] := index in [0..i] having max sums[i] vector < int > r ( n ); // r[i] := index in [i..m - 1] having max sums[i] int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) sums [ i - k + 1 ] = sum ; } int maxIndex = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( sums [ i ] > sums [ maxIndex ]) maxIndex = i ; l [ i ] = maxIndex ; } maxIndex = n - 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( sums [ i ] >= sums [ maxIndex ]) maxIndex = i ; r [ i ] = maxIndex ; } vector < int > ans { -1 , -1 , -1 }; for ( int i = k ; i < n - k ; ++ i ) if ( ans [ 0 ] == -1 || sums [ ans [ 0 ]] + sums [ ans [ 1 ]] + sums [ ans [ 2 ]] < sums [ l [ i - k ]] + sums [ i ] + sums [ r [ i + k ]]) { ans [ 0 ] = l [ i - k ]; ans [ 1 ] = i ; ans [ 2 ] = r [ i + k ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ] ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( i >= k ) sum -= nums [ i - k ] ; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ] ; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ] ) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ] ; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ] ) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]] ) { ans [ 0 ] = left [ i - k ] ; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays"},{"location":"problems/0689/#689-maximum-sum-of-3-non-overlapping-subarrays","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { const int n = nums . size () - k + 1 ; vector < int > sums ( n ); // sums[i] := sum(nums[i..i + k)) vector < int > l ( n ); // l[i] := index in [0..i] having max sums[i] vector < int > r ( n ); // r[i] := index in [i..m - 1] having max sums[i] int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) sums [ i - k + 1 ] = sum ; } int maxIndex = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( sums [ i ] > sums [ maxIndex ]) maxIndex = i ; l [ i ] = maxIndex ; } maxIndex = n - 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( sums [ i ] >= sums [ maxIndex ]) maxIndex = i ; r [ i ] = maxIndex ; } vector < int > ans { -1 , -1 , -1 }; for ( int i = k ; i < n - k ; ++ i ) if ( ans [ 0 ] == -1 || sums [ ans [ 0 ]] + sums [ ans [ 1 ]] + sums [ ans [ 2 ]] < sums [ l [ i - k ]] + sums [ i ] + sums [ r [ i + k ]]) { ans [ 0 ] = l [ i - k ]; ans [ 1 ] = i ; ans [ 2 ] = r [ i + k ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ] ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( i >= k ) sum -= nums [ i - k ] ; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ] ; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ] ) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ] ; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ] ) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]] ) { ans [ 0 ] = left [ i - k ] ; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays"},{"location":"problems/0690/","text":"690. Employee Importance Time: Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , Employee *> idToEmployee ; for ( Employee * employee : employees ) idToEmployee [ employee -> id ] = employee ; function < int ( int ) > dfs = [ & ]( int id ) { int subordinatesImportance = idToEmployee [ id ] -> importance ; for ( const int subordinate : idToEmployee [ id ] -> subordinates ) subordinatesImportance += dfs ( subordinate ); return subordinatesImportance ; }; return dfs ( id ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int getImportance ( List < Employee > employees , int id ) { Map < Integer , Employee > idToEmployee = new HashMap <> (); for ( Employee employee : employees ) idToEmployee . put ( employee . id , employee ); return dfs ( idToEmployee , id ); } private int dfs ( Map < Integer , Employee > idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee . get ( id ). subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee . get ( id ). importance + subordinatesImportance ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def getImportance ( self , employees : List [ 'Employee' ], id : int ) -> int : def dfs ( id : int ) -> int : subordinatesImportance = sum ( dfs ( subordinate ) for subordinate in idToEmployee [ id ] . subordinates ) return idToEmployee [ id ] . importance + subordinatesImportance idToEmployee = { employee . id : employee for employee in employees } return dfs ( id )","title":"690. Employee Importance"},{"location":"problems/0690/#690-employee-importance","text":"Time: Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , Employee *> idToEmployee ; for ( Employee * employee : employees ) idToEmployee [ employee -> id ] = employee ; function < int ( int ) > dfs = [ & ]( int id ) { int subordinatesImportance = idToEmployee [ id ] -> importance ; for ( const int subordinate : idToEmployee [ id ] -> subordinates ) subordinatesImportance += dfs ( subordinate ); return subordinatesImportance ; }; return dfs ( id ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int getImportance ( List < Employee > employees , int id ) { Map < Integer , Employee > idToEmployee = new HashMap <> (); for ( Employee employee : employees ) idToEmployee . put ( employee . id , employee ); return dfs ( idToEmployee , id ); } private int dfs ( Map < Integer , Employee > idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee . get ( id ). subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee . get ( id ). importance + subordinatesImportance ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def getImportance ( self , employees : List [ 'Employee' ], id : int ) -> int : def dfs ( id : int ) -> int : subordinatesImportance = sum ( dfs ( subordinate ) for subordinate in idToEmployee [ id ] . subordinates ) return idToEmployee [ id ] . importance + subordinatesImportance idToEmployee = { employee . id : employee for employee in employees } return dfs ( id )","title":"690. Employee Importance"},{"location":"problems/0691/","text":"691. Stickers to Spell Word","title":"691. Stickers to Spell Word"},{"location":"problems/0691/#691-stickers-to-spell-word","text":"","title":"691. Stickers to Spell Word"},{"location":"problems/0692/","text":"692. Top K Frequent Words Approach 1: Bucket Sort Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { const int n = words . size (); vector < string > ans ; vector < vector < string >> bucket ( n + 1 ); unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) bucket [ freq ]. push_back ( word ); for ( int freq = n ; freq > 0 ; -- freq ) { sort ( begin ( bucket [ freq ]), end ( bucket [ freq ])); for ( const string & word : bucket [ freq ]) { ans . push_back ( word ); if ( ans . size () == k ) return ans ; } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > ans = new ArrayList <> (); List < String >[] bucket = new List [ words . length + 1 ] ; Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) { int freq = count . get ( word ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( word ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) { Collections . sort ( bucket [ freq ] ); for ( final String word : bucket [ freq ] ) { ans . add ( word ); if ( ans . size () == k ) return ans ; } } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def topKFrequent ( self , words : List [ str ], k : int ) -> List [ str ]: ans = [] bucket = [[] for _ in range ( len ( words ) + 1 )] for word , freq in collections . Counter ( words ) . items (): bucket [ freq ] . append ( word ) for b in bucket [:: - 1 ]: for word in sorted ( b ): ans . append ( word ) if len ( ans ) == k : return ans Approach 2: Follow up Time: $O(n\\log k)$ Space: $O(n\\log k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct Item { string word ; int freq ; }; class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { const int n = words . size (); vector < string > ans ; unordered_map < string , int > count ; // words w/ higher frequency and lower alphabetical order are in the bottom // of the heap, because we'll pop words w/ lower frequency and higher // alphabetical order if the heap's size > k auto compare = []( const Item & a , const Item & b ) { return a . freq == b . freq ? a . word < b . word : a . freq > b . freq ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) { pq . push ({ word , freq }); if ( pq . size () > k ) pq . pop (); } while ( ! pq . empty ()) ans . push_back ( pq . top (). word ), pq . pop (); reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"692. Top K Frequent Words"},{"location":"problems/0692/#692-top-k-frequent-words","text":"","title":"692. Top K Frequent Words"},{"location":"problems/0692/#approach-1-bucket-sort","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { const int n = words . size (); vector < string > ans ; vector < vector < string >> bucket ( n + 1 ); unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) bucket [ freq ]. push_back ( word ); for ( int freq = n ; freq > 0 ; -- freq ) { sort ( begin ( bucket [ freq ]), end ( bucket [ freq ])); for ( const string & word : bucket [ freq ]) { ans . push_back ( word ); if ( ans . size () == k ) return ans ; } } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > ans = new ArrayList <> (); List < String >[] bucket = new List [ words . length + 1 ] ; Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) { int freq = count . get ( word ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( word ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) { Collections . sort ( bucket [ freq ] ); for ( final String word : bucket [ freq ] ) { ans . add ( word ); if ( ans . size () == k ) return ans ; } } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def topKFrequent ( self , words : List [ str ], k : int ) -> List [ str ]: ans = [] bucket = [[] for _ in range ( len ( words ) + 1 )] for word , freq in collections . Counter ( words ) . items (): bucket [ freq ] . append ( word ) for b in bucket [:: - 1 ]: for word in sorted ( b ): ans . append ( word ) if len ( ans ) == k : return ans","title":"Approach 1: Bucket Sort"},{"location":"problems/0692/#approach-2-follow-up","text":"Time: $O(n\\log k)$ Space: $O(n\\log k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 struct Item { string word ; int freq ; }; class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { const int n = words . size (); vector < string > ans ; unordered_map < string , int > count ; // words w/ higher frequency and lower alphabetical order are in the bottom // of the heap, because we'll pop words w/ lower frequency and higher // alphabetical order if the heap's size > k auto compare = []( const Item & a , const Item & b ) { return a . freq == b . freq ? a . word < b . word : a . freq > b . freq ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) { pq . push ({ word , freq }); if ( pq . size () > k ) pq . pop (); } while ( ! pq . empty ()) ans . push_back ( pq . top (). word ), pq . pop (); reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"Approach 2: Follow up"},{"location":"problems/0693/","text":"693. Binary Number with Alternating Bits","title":"693. Binary Number with Alternating Bits"},{"location":"problems/0693/#693-binary-number-with-alternating-bits","text":"","title":"693. Binary Number with Alternating Bits"},{"location":"problems/0694/","text":"694. Number of Distinct Islands \ud83d\udd12","title":"694. Number of Distinct Islands"},{"location":"problems/0694/#694-number-of-distinct-islands","text":"","title":"694. Number of Distinct Islands \ud83d\udd12"},{"location":"problems/0695/","text":"695. Max Area of Island Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < int ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( grid [ i ][ j ] != 1 ) return 0 ; grid [ i ][ j ] = 2 ; return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int maxAreaOfIsland ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( grid , i , j )); return ans ; } private int dfs ( final int [][] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return 0 ; if ( grid [ i ][ j ] != 1 ) return 0 ; grid [ i ][ j ] = 2 ; return 1 + dfs ( grid , i + 1 , j ) + dfs ( grid , i - 1 , j ) + dfs ( grid , i , j + 1 ) + dfs ( grid , i , j - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]): return 0 if grid [ i ][ j ] == 0 or seen [ i ][ j ]: return 0 seen [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) ans = 0 seen = [[ False ] * len ( grid [ 0 ]) for _ in range ( len ( grid ))] for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): ans = max ( ans , dfs ( i , j )) return ans","title":"695. Max Area of Island"},{"location":"problems/0695/#695-max-area-of-island","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < int ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( grid [ i ][ j ] != 1 ) return 0 ; grid [ i ][ j ] = 2 ; return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int maxAreaOfIsland ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( grid , i , j )); return ans ; } private int dfs ( final int [][] grid , int i , int j ) { if ( i < 0 || i == grid . length || j < 0 || j == grid [ 0 ] . length ) return 0 ; if ( grid [ i ][ j ] != 1 ) return 0 ; grid [ i ][ j ] = 2 ; return 1 + dfs ( grid , i + 1 , j ) + dfs ( grid , i - 1 , j ) + dfs ( grid , i , j + 1 ) + dfs ( grid , i , j - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]): return 0 if grid [ i ][ j ] == 0 or seen [ i ][ j ]: return 0 seen [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) ans = 0 seen = [[ False ] * len ( grid [ 0 ]) for _ in range ( len ( grid ))] for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): ans = max ( ans , dfs ( i , j )) return ans","title":"695. Max Area of Island"},{"location":"problems/0696/","text":"696. Count Binary Substrings Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int countBinarySubstrings ( string s ) { int ans = 0 ; int prevEquals = 0 ; int currEquals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == s [ i + 1 ]) ++ currEquals ; else { ans += min ( prevEquals , currEquals ); prevEquals = currEquals ; currEquals = 1 ; } return ans + min ( prevEquals , currEquals ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int countBinarySubstrings ( String s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == s . charAt ( i + 1 )) ++ equals ; else { ans += Math . min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + Math . min ( prevCount , equals ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countBinarySubstrings ( self , s : str ) -> int : ans = 0 prevCount = 0 equals = 1 for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: equals += 1 else : ans += min ( prevCount , equals ) prevCount = equals equals = 1 return ans + min ( prevCount , equals )","title":"696. Count Binary Substrings"},{"location":"problems/0696/#696-count-binary-substrings","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int countBinarySubstrings ( string s ) { int ans = 0 ; int prevEquals = 0 ; int currEquals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == s [ i + 1 ]) ++ currEquals ; else { ans += min ( prevEquals , currEquals ); prevEquals = currEquals ; currEquals = 1 ; } return ans + min ( prevEquals , currEquals ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int countBinarySubstrings ( String s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == s . charAt ( i + 1 )) ++ equals ; else { ans += Math . min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + Math . min ( prevCount , equals ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countBinarySubstrings ( self , s : str ) -> int : ans = 0 prevCount = 0 equals = 1 for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: equals += 1 else : ans += min ( prevCount , equals ) prevCount = equals equals = 1 return ans + min ( prevCount , equals )","title":"696. Count Binary Substrings"},{"location":"problems/0697/","text":"697. Degree of an Array Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > debut ; unordered_map < int , int > count ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int num = nums [ i ]; if ( ! debut . count ( num )) debut [ num ] = i ; if ( ++ count [ num ] > degree ) { degree = count [ num ]; ans = i - debut [ num ] + 1 ; } else if ( count [ num ] == degree ) { ans = min ( ans , i - debut [ num ] + 1 ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > debut = new HashMap <> (); Map < Integer , Integer > count = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; debut . putIfAbsent ( num , i ); count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); if ( count . get ( num ) > degree ) { degree = count . get ( num ); ans = i - debut . get ( num ) + 1 ; } else if ( count . get ( num ) == degree ) { ans = Math . min ( ans , i - debut . get ( num ) + 1 ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 debut = {} count = Counter () for i , num in enumerate ( nums ): if num not in debut : debut [ num ] = i count [ num ] += 1 if count [ num ] > degree : degree = count [ num ] ans = i - debut [ num ] + 1 elif count [ num ] == degree : ans = min ( ans , i - debut [ num ] + 1 ) return ans","title":"697. Degree of an Array"},{"location":"problems/0697/#697-degree-of-an-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > debut ; unordered_map < int , int > count ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int num = nums [ i ]; if ( ! debut . count ( num )) debut [ num ] = i ; if ( ++ count [ num ] > degree ) { degree = count [ num ]; ans = i - debut [ num ] + 1 ; } else if ( count [ num ] == degree ) { ans = min ( ans , i - debut [ num ] + 1 ); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > debut = new HashMap <> (); Map < Integer , Integer > count = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { final int num = nums [ i ] ; debut . putIfAbsent ( num , i ); count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); if ( count . get ( num ) > degree ) { degree = count . get ( num ); ans = i - debut . get ( num ) + 1 ; } else if ( count . get ( num ) == degree ) { ans = Math . min ( ans , i - debut . get ( num ) + 1 ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 debut = {} count = Counter () for i , num in enumerate ( nums ): if num not in debut : debut [ num ] = i count [ num ] += 1 if count [ num ] > degree : degree = count [ num ] ans = i - debut [ num ] + 1 elif count [ num ] == degree : ans = min ( ans , i - debut [ num ] + 1 ) return ans","title":"697. Degree of an Array"},{"location":"problems/0698/","text":"698. Partition to K Equal Sum Subsets Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool canPartitionKSubsets ( vector < int >& nums , int k ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum % k != 0 ) return false ; const int t = sum / k ; // each subset's target sum const int n = nums . size (); vector < bool > seen ( n ); function < bool ( int , int , int ) > dfs = [ & ]( int s , int k , int target ) { if ( k == 0 ) return true ; if ( target < 0 ) return false ; if ( target == 0 ) return dfs ( 0 , k - 1 , t ); for ( int i = s ; i < n ; ++ i ) { if ( seen [ i ]) continue ; seen [ i ] = true ; if ( dfs ( i + 1 , k , target - nums [ i ])) return true ; seen [ i ] = false ; } return false ; }; return dfs ( 0 , k , t ); } };","title":"698. Partition to K Equal Sum Subsets"},{"location":"problems/0698/#698-partition-to-k-equal-sum-subsets","text":"Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool canPartitionKSubsets ( vector < int >& nums , int k ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum % k != 0 ) return false ; const int t = sum / k ; // each subset's target sum const int n = nums . size (); vector < bool > seen ( n ); function < bool ( int , int , int ) > dfs = [ & ]( int s , int k , int target ) { if ( k == 0 ) return true ; if ( target < 0 ) return false ; if ( target == 0 ) return dfs ( 0 , k - 1 , t ); for ( int i = s ; i < n ; ++ i ) { if ( seen [ i ]) continue ; seen [ i ] = true ; if ( dfs ( i + 1 , k , target - nums [ i ])) return true ; seen [ i ] = false ; } return false ; }; return dfs ( 0 , k , t ); } };","title":"698. Partition to K Equal Sum Subsets"},{"location":"problems/0699/","text":"699. Falling Squares","title":"699. Falling Squares"},{"location":"problems/0699/#699-falling-squares","text":"","title":"699. Falling Squares"},{"location":"problems/0700/","text":"700. Search in a Binary Search Tree","title":"700. Search in a Binary Search Tree"},{"location":"problems/0700/#700-search-in-a-binary-search-tree","text":"","title":"700. Search in a Binary Search Tree"},{"location":"problems/0701/","text":"701. Insert into a Binary Search Tree Time: $O(\\log n) \\to O(n)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * insertIntoBST ( TreeNode * root , int val ) { if ( ! root ) return new TreeNode ( val ); if ( root -> val < val ) root -> right = insertIntoBST ( root -> right , val ); else root -> left = insertIntoBST ( root -> left , val ); return root ; } };","title":"701. Insert into a Binary Search Tree"},{"location":"problems/0701/#701-insert-into-a-binary-search-tree","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * insertIntoBST ( TreeNode * root , int val ) { if ( ! root ) return new TreeNode ( val ); if ( root -> val < val ) root -> right = insertIntoBST ( root -> right , val ); else root -> left = insertIntoBST ( root -> left , val ); return root ; } };","title":"701. Insert into a Binary Search Tree"},{"location":"problems/0702/","text":"702. Search in a Sorted Array of Unknown Size \ud83d\udd12","title":"702. Search in a Sorted Array of Unknown Size"},{"location":"problems/0702/#702-search-in-a-sorted-array-of-unknown-size","text":"","title":"702. Search in a Sorted Array of Unknown Size \ud83d\udd12"},{"location":"problems/0703/","text":"703. Kth Largest Element in a Stream Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class KthLargest { public : KthLargest ( int k , vector < int >& nums ) : k ( k ) { for ( const int num : nums ) heapify ( num ); } int add ( int val ) { heapify ( val ); return pq . top (); } private : const int k ; priority_queue < int , vector < int > , greater <>> pq ; void heapify ( int val ) { pq . push ( val ); if ( pq . size () > k ) pq . pop (); } };","title":"703. Kth Largest Element in a Stream"},{"location":"problems/0703/#703-kth-largest-element-in-a-stream","text":"Time: $O(n\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class KthLargest { public : KthLargest ( int k , vector < int >& nums ) : k ( k ) { for ( const int num : nums ) heapify ( num ); } int add ( int val ) { heapify ( val ); return pq . top (); } private : const int k ; priority_queue < int , vector < int > , greater <>> pq ; void heapify ( int val ) { pq . push ( val ); if ( pq . size () > k ) pq . pop (); } };","title":"703. Kth Largest Element in a Stream"},{"location":"problems/0704/","text":"704. Binary Search","title":"704. Binary Search"},{"location":"problems/0704/#704-binary-search","text":"","title":"704. Binary Search"},{"location":"problems/0705/","text":"705. Design HashSet Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyHashSet { public : MyHashSet () : set ( 1000001 ) {} void add ( int key ) { set [ key ] = true ; } void remove ( int key ) { set [ key ] = false ; } bool contains ( int key ) { return set [ key ]; } private : vector < bool > set ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyHashSet { public void add ( int key ) { set [ key ] = true ; } public void remove ( int key ) { set [ key ] = false ; } public boolean contains ( int key ) { return set [ key ] ; } private boolean [] set = new boolean [ 1000001 ] ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 class MyHashSet : def __init__ ( self ): self . set = [ False ] * 1000001 def add ( self , key : int ) -> None : self . set [ key ] = True def remove ( self , key : int ) -> None : self . set [ key ] = False def contains ( self , key : int ) -> bool : return self . set [ key ]","title":"705. Design HashSet"},{"location":"problems/0705/#705-design-hashset","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MyHashSet { public : MyHashSet () : set ( 1000001 ) {} void add ( int key ) { set [ key ] = true ; } void remove ( int key ) { set [ key ] = false ; } bool contains ( int key ) { return set [ key ]; } private : vector < bool > set ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyHashSet { public void add ( int key ) { set [ key ] = true ; } public void remove ( int key ) { set [ key ] = false ; } public boolean contains ( int key ) { return set [ key ] ; } private boolean [] set = new boolean [ 1000001 ] ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 class MyHashSet : def __init__ ( self ): self . set = [ False ] * 1000001 def add ( self , key : int ) -> None : self . set [ key ] = True def remove ( self , key : int ) -> None : self . set [ key ] = False def contains ( self , key : int ) -> bool : return self . set [ key ]","title":"705. Design HashSet"},{"location":"problems/0706/","text":"706. Design HashMap Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyHashMap { public : MyHashMap () : lists ( kSize ) {} void put ( int key , int value ) { auto & pairs = lists [ key % kSize ]; for ( auto & [ k , v ] : pairs ) if ( k == key ) { v = value ; return ; } pairs . push_back ({ key , value }); } int get ( int key ) { const auto & pairs = lists [ key % kSize ]; for ( const auto & [ k , v ] : pairs ) if ( k == key ) return v ; return -1 ; } void remove ( int key ) { auto & pairs = lists [ key % kSize ]; for ( auto it = begin ( pairs ); it != end ( pairs ); ++ it ) if ( it -> first == key ) { pairs . erase ( it ); return ; } } private : const int kSize = 10000 ; vector < list < pair < int , int >>> lists ; };","title":"706. Design HashMap"},{"location":"problems/0706/#706-design-hashmap","text":"Time: $O(1)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class MyHashMap { public : MyHashMap () : lists ( kSize ) {} void put ( int key , int value ) { auto & pairs = lists [ key % kSize ]; for ( auto & [ k , v ] : pairs ) if ( k == key ) { v = value ; return ; } pairs . push_back ({ key , value }); } int get ( int key ) { const auto & pairs = lists [ key % kSize ]; for ( const auto & [ k , v ] : pairs ) if ( k == key ) return v ; return -1 ; } void remove ( int key ) { auto & pairs = lists [ key % kSize ]; for ( auto it = begin ( pairs ); it != end ( pairs ); ++ it ) if ( it -> first == key ) { pairs . erase ( it ); return ; } } private : const int kSize = 10000 ; vector < list < pair < int , int >>> lists ; };","title":"706. Design HashMap"},{"location":"problems/0707/","text":"707. Design Linked List Time: Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class MyLinkedList { public : int get ( int index ) { if ( index < 0 || index >= length ) return -1 ; ListNode * curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * head = dummy . next ; ListNode * node = new ListNode ( val ); node -> next = head ; dummy . next = node ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = & dummy ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * cache = curr -> next ; ListNode * node = new ListNode ( val ); node -> next = cache ; curr -> next = node ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * cache = curr -> next ; curr -> next = cache -> next ; -- length ; delete cache ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length = 0 ; ListNode dummy = ListNode ( 0 ); }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class MyLinkedList { public int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; return curr . val ; } public void addAtHead ( int val ) { ListNode curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next . next = curr ; ++ length ; } public void addAtTail ( int val ) { ListNode curr = dummy . next ; while ( curr . next != null ) curr = curr . next ; curr . next = new ListNode ( val ); ++ length ; } public void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = new ListNode ( val ); curr . next . next = temp ; ++ length ; } public void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = temp . next ; -- length ; } private class ListNode { int val ; ListNode next ; public ListNode ( int val ) { this . val = val ; } } int length = 0 ; ListNode dummy = new ListNode ( 0 ); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . length = 0 self . dummy = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . length : return - 1 curr = self . dummy . next for _ in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . dummy . next self . dummy . next = ListNode ( val ) self . dummy . next . next = curr self . length += 1 def addAtTail ( self , val : int ) -> None : curr = self . dummy while curr . next : curr = curr . next curr . next = ListNode ( val ) self . length += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . length += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . length -= 1","title":"707. Design Linked List"},{"location":"problems/0707/#707-design-linked-list","text":"Time: Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class MyLinkedList { public : int get ( int index ) { if ( index < 0 || index >= length ) return -1 ; ListNode * curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * head = dummy . next ; ListNode * node = new ListNode ( val ); node -> next = head ; dummy . next = node ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = & dummy ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * cache = curr -> next ; ListNode * node = new ListNode ( val ); node -> next = cache ; curr -> next = node ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * cache = curr -> next ; curr -> next = cache -> next ; -- length ; delete cache ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length = 0 ; ListNode dummy = ListNode ( 0 ); }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class MyLinkedList { public int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; return curr . val ; } public void addAtHead ( int val ) { ListNode curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next . next = curr ; ++ length ; } public void addAtTail ( int val ) { ListNode curr = dummy . next ; while ( curr . next != null ) curr = curr . next ; curr . next = new ListNode ( val ); ++ length ; } public void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = new ListNode ( val ); curr . next . next = temp ; ++ length ; } public void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = temp . next ; -- length ; } private class ListNode { int val ; ListNode next ; public ListNode ( int val ) { this . val = val ; } } int length = 0 ; ListNode dummy = new ListNode ( 0 ); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . length = 0 self . dummy = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . length : return - 1 curr = self . dummy . next for _ in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . dummy . next self . dummy . next = ListNode ( val ) self . dummy . next . next = curr self . length += 1 def addAtTail ( self , val : int ) -> None : curr = self . dummy while curr . next : curr = curr . next curr . next = ListNode ( val ) self . length += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . length += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . length -= 1","title":"707. Design Linked List"},{"location":"problems/0708/","text":"708. Insert into a Sorted Circular Linked List \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : Node * insert ( Node * head , int insertVal ) { if ( ! head ) { Node * newNode = new Node ( insertVal ); newNode -> next = newNode ; return newNode ; } Node * prev = head ; Node * curr = head -> next ; while ( curr != head ) { // case 1: min <= insertVal <= max // case 2: insertVal >= max or insertVal <= min if (( prev -> val <= insertVal && insertVal <= curr -> val ) || ( prev -> val > curr -> val && // prev is max, curr is min ( insertVal >= prev -> val || insertVal <= curr -> val ))) { // insert the node between prev and curr prev -> next = new Node ( insertVal , curr ); return head ; } prev = prev -> next ; curr = curr -> next ; } // all vals in list are identical prev -> next = new Node ( insertVal , curr ); return head ; } };","title":"708. Insert into a Sorted Circular Linked List"},{"location":"problems/0708/#708-insert-into-a-sorted-circular-linked-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : Node * insert ( Node * head , int insertVal ) { if ( ! head ) { Node * newNode = new Node ( insertVal ); newNode -> next = newNode ; return newNode ; } Node * prev = head ; Node * curr = head -> next ; while ( curr != head ) { // case 1: min <= insertVal <= max // case 2: insertVal >= max or insertVal <= min if (( prev -> val <= insertVal && insertVal <= curr -> val ) || ( prev -> val > curr -> val && // prev is max, curr is min ( insertVal >= prev -> val || insertVal <= curr -> val ))) { // insert the node between prev and curr prev -> next = new Node ( insertVal , curr ); return head ; } prev = prev -> next ; curr = curr -> next ; } // all vals in list are identical prev -> next = new Node ( insertVal , curr ); return head ; } };","title":"708. Insert into a Sorted Circular Linked List \ud83d\udd12"},{"location":"problems/0709/","text":"709. To Lower Case Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string toLowerCase ( string str ) { const int diff = 'A' - 'a' ; for ( char & c : str ) if ( c >= 'A' && c <= 'Z' ) c -= diff ; return str ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String toLowerCase ( String str ) { final int diff = 'a' - 'A' ; char [] ans = str . toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] >= 'A' && ans [ i ] <= 'Z' ) ans [ i ] += diff ; return new String ( ans ); } } Python 1 2 3 class Solution : def toLowerCase ( self , str : str ) -> str : return '' . join ( chr ( ord ( c ) + 32 ) if 'A' <= c <= 'Z' else c for c in str )","title":"709. To Lower Case"},{"location":"problems/0709/#709-to-lower-case","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string toLowerCase ( string str ) { const int diff = 'A' - 'a' ; for ( char & c : str ) if ( c >= 'A' && c <= 'Z' ) c -= diff ; return str ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String toLowerCase ( String str ) { final int diff = 'a' - 'A' ; char [] ans = str . toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] >= 'A' && ans [ i ] <= 'Z' ) ans [ i ] += diff ; return new String ( ans ); } } Python 1 2 3 class Solution : def toLowerCase ( self , str : str ) -> str : return '' . join ( chr ( ord ( c ) + 32 ) if 'A' <= c <= 'Z' else c for c in str )","title":"709. To Lower Case"},{"location":"problems/0710/","text":"710. Random Pick with Blacklist Time: $O(|B|)$ Space: $O(|B|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : Solution ( int N , vector < int >& blacklist ) : validRange ( N - blacklist . size ()) { for ( const int b : blacklist ) map [ b ] = -1 ; int maxAvailable = N - 1 ; for ( const int b : blacklist ) if ( b < validRange ) { while ( map . count ( maxAvailable )) // find the slot that haven't been used -- maxAvailable ; map [ b ] = maxAvailable -- ; } } int pick () { const int num = rand () % validRange ; return map . count ( num ) ? map [ num ] : num ; } private : const int validRange ; unordered_map < int , int > map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public Solution ( int N , int [] blacklist ) { validRange = N - blacklist . length ; for ( int b : blacklist ) map . put ( b , - 1 ); for ( int b : blacklist ) if ( b < validRange ) { while ( map . containsKey ( N - 1 )) -- N ; map . put ( b , -- N ); } } public int pick () { int value = rand . nextInt ( validRange ); return map . getOrDefault ( value , value ); } private int validRange ; private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def __init__ ( self , N : int , blacklist : List [ int ]): self . validRange = N - len ( blacklist ) self . dict = {} for b in blacklist : self . dict [ b ] = - 1 for b in blacklist : if b < self . validRange : while N - 1 in self . dict : N -= 1 self . dict [ b ] = N - 1 N -= 1 def pick ( self ) -> int : value = random . randint ( 0 , self . validRange - 1 ) if value in self . dict : return self . dict [ value ] return value","title":"710. Random Pick with Blacklist"},{"location":"problems/0710/#710-random-pick-with-blacklist","text":"Time: $O(|B|)$ Space: $O(|B|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : Solution ( int N , vector < int >& blacklist ) : validRange ( N - blacklist . size ()) { for ( const int b : blacklist ) map [ b ] = -1 ; int maxAvailable = N - 1 ; for ( const int b : blacklist ) if ( b < validRange ) { while ( map . count ( maxAvailable )) // find the slot that haven't been used -- maxAvailable ; map [ b ] = maxAvailable -- ; } } int pick () { const int num = rand () % validRange ; return map . count ( num ) ? map [ num ] : num ; } private : const int validRange ; unordered_map < int , int > map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public Solution ( int N , int [] blacklist ) { validRange = N - blacklist . length ; for ( int b : blacklist ) map . put ( b , - 1 ); for ( int b : blacklist ) if ( b < validRange ) { while ( map . containsKey ( N - 1 )) -- N ; map . put ( b , -- N ); } } public int pick () { int value = rand . nextInt ( validRange ); return map . getOrDefault ( value , value ); } private int validRange ; private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def __init__ ( self , N : int , blacklist : List [ int ]): self . validRange = N - len ( blacklist ) self . dict = {} for b in blacklist : self . dict [ b ] = - 1 for b in blacklist : if b < self . validRange : while N - 1 in self . dict : N -= 1 self . dict [ b ] = N - 1 N -= 1 def pick ( self ) -> int : value = random . randint ( 0 , self . validRange - 1 ) if value in self . dict : return self . dict [ value ] return value","title":"710. Random Pick with Blacklist"},{"location":"problems/0711/","text":"711. Number of Distinct Islands II \ud83d\udd12","title":"711. Number of Distinct Islands II"},{"location":"problems/0711/#711-number-of-distinct-islands-ii","text":"","title":"711. Number of Distinct Islands II \ud83d\udd12"},{"location":"problems/0712/","text":"712. Minimum ASCII Delete Sum for Two Strings Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int minimumDeleteSum ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); // delete s1[i - 1] for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + s1 [ i - 1 ]; // delete s2[j - 1] for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] + s2 [ j - 1 ]; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s1 [ i - 1 ] == s2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j ] + s1 [ i - 1 ], dp [ i ][ j - 1 ] + s2 [ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minimumDeleteSum ( String s1 , String s2 ) { final int m = s1 . length (); final int n = s2 . length (); // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal int [][] dp = new int [ m + 1 ][ n + 1 ] ; // delete s1.charAt(i - 1) for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + s1 . charAt ( i - 1 ); // delete s2.charAt(j - 1) for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] + s2 . charAt ( j - 1 ); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j ] + s1 . charAt ( i - 1 ), dp [ i ][ j - 1 ] + s2 . charAt ( j - 1 )); return dp [ m ][ n ] ; } }","title":"712. Minimum ASCII Delete Sum for Two Strings"},{"location":"problems/0712/#712-minimum-ascii-delete-sum-for-two-strings","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int minimumDeleteSum ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); // delete s1[i - 1] for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + s1 [ i - 1 ]; // delete s2[j - 1] for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] + s2 [ j - 1 ]; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s1 [ i - 1 ] == s2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j ] + s1 [ i - 1 ], dp [ i ][ j - 1 ] + s2 [ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minimumDeleteSum ( String s1 , String s2 ) { final int m = s1 . length (); final int n = s2 . length (); // dp[i][j] := min cost to make s1[0..i) and s2[0..j) equal int [][] dp = new int [ m + 1 ][ n + 1 ] ; // delete s1.charAt(i - 1) for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] + s1 . charAt ( i - 1 ); // delete s2.charAt(j - 1) for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = dp [ 0 ][ j - 1 ] + s2 . charAt ( j - 1 ); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . min ( dp [ i - 1 ][ j ] + s1 . charAt ( i - 1 ), dp [ i ][ j - 1 ] + s2 . charAt ( j - 1 )); return dp [ m ][ n ] ; } }","title":"712. Minimum ASCII Delete Sum for Two Strings"},{"location":"problems/0713/","text":"713. Subarray Product Less Than K Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { prod *= nums [ r ]; while ( prod >= k ) prod /= nums [ l ++ ]; ans += r - l + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { prod *= nums [ r ] ; while ( prod >= k ) prod /= nums [ l ++] ; ans += r - l + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans","title":"713. Subarray Product Less Than K"},{"location":"problems/0713/#713-subarray-product-less-than-k","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { prod *= nums [ r ]; while ( prod >= k ) prod /= nums [ l ++ ]; ans += r - l + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . length ; ++ r ) { prod *= nums [ r ] ; while ( prod >= k ) prod /= nums [ l ++] ; ans += r - l + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans","title":"713. Subarray Product Less Than K"},{"location":"problems/0714/","text":"714. Best Time to Buy and Sell Stock with Transaction Fee Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell","title":"714. Best Time to Buy and Sell Stock with Transaction Fee"},{"location":"problems/0714/#714-best-time-to-buy-and-sell-stock-with-transaction-fee","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell","title":"714. Best Time to Buy and Sell Stock with Transaction Fee"},{"location":"problems/0715/","text":"715. Range Module Time: $O(n) \\to O(\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class RangeModule { public : void addRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) { // no overlaps ranges [ left ] = right ; // add a new range return ; } auto last = r ; const int newLeft = min ( l -> first , left ); const int newRight = max (( -- last ) -> second , right ); ranges . erase ( l , r ); ranges [ newLeft ] = newRight ; // add a new range } bool queryRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) return false ; // no overlaps return l -> first <= left && right <= l -> second ; } void removeRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) return ; // no overlaps auto last = r ; const int newLeft = min ( l -> first , left ); const int newRight = max (( -- last ) -> second , right ); ranges . erase ( l , r ); // add new ranges if needed if ( newLeft < left ) ranges [ newLeft ] = left ; if ( right < newRight ) ranges [ right ] = newRight ; } private : map < int , int > ranges ; typedef map < int , int >:: iterator IT ; pair < IT , IT > getOverlapRanges ( int left , int right ) { IT l = ranges . upper_bound ( left ); // point to 1st element >= than left IT r = ranges . upper_bound ( right ); // point to 1st element > than right if ( l != begin ( ranges )) if (( -- l ) -> second < left ) ++ l ; return { l , r }; } };","title":"715. Range Module"},{"location":"problems/0715/#715-range-module","text":"Time: $O(n) \\to O(\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class RangeModule { public : void addRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) { // no overlaps ranges [ left ] = right ; // add a new range return ; } auto last = r ; const int newLeft = min ( l -> first , left ); const int newRight = max (( -- last ) -> second , right ); ranges . erase ( l , r ); ranges [ newLeft ] = newRight ; // add a new range } bool queryRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) return false ; // no overlaps return l -> first <= left && right <= l -> second ; } void removeRange ( int left , int right ) { const auto [ l , r ] = getOverlapRanges ( left , right ); if ( l == r ) return ; // no overlaps auto last = r ; const int newLeft = min ( l -> first , left ); const int newRight = max (( -- last ) -> second , right ); ranges . erase ( l , r ); // add new ranges if needed if ( newLeft < left ) ranges [ newLeft ] = left ; if ( right < newRight ) ranges [ right ] = newRight ; } private : map < int , int > ranges ; typedef map < int , int >:: iterator IT ; pair < IT , IT > getOverlapRanges ( int left , int right ) { IT l = ranges . upper_bound ( left ); // point to 1st element >= than left IT r = ranges . upper_bound ( right ); // point to 1st element > than right if ( l != begin ( ranges )) if (( -- l ) -> second < left ) ++ l ; return { l , r }; } };","title":"715. Range Module"},{"location":"problems/0716/","text":"716. Max Stack \ud83d\udd12","title":"716. Max Stack"},{"location":"problems/0716/#716-max-stack","text":"","title":"716. Max Stack \ud83d\udd12"},{"location":"problems/0717/","text":"717. 1-bit and 2-bit Characters Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { const int n = bits . size (); int i = 0 ; while ( i < n - 1 ) if ( bits [ i ] == 0 ) i += 1 ; else i += 2 ; return i == n - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } } Python 1 2 3 4 5 6 7 class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1","title":"717. 1-bit and 2-bit Characters"},{"location":"problems/0717/#717-1-bit-and-2-bit-characters","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { const int n = bits . size (); int i = 0 ; while ( i < n - 1 ) if ( bits [ i ] == 0 ) i += 1 ; else i += 2 ; return i == n - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } } Python 1 2 3 4 5 6 7 class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1","title":"717. 1-bit and 2-bit Characters"},{"location":"problems/0718/","text":"718. Maximum Length of Repeated Subarray Approach 1: 2D DP Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; // dp[i][j] := max length of A[i..m) and B[j..n) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; // dp[i][j] := max length of A[i..m) and B[j..n) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ] ) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; ans = Math . max ( ans , dp [ i ][ j ] ); } return ans ; } } Approach 2: 1D DP Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < int > dp ( n + 1 ); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < n ; ++ j ) { // the order is important dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = max ( ans , dp [ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; int [] dp = new int [ n + 1 ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < n ; ++ j ) { // the order is important dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = Math . max ( ans , dp [ j ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : ans = 0 dp = [ 0 ] * ( len ( B ) + 1 ) for i , a in reversed ( list ( enumerate ( A ))): for j , b in enumerate ( B ): dp [ j ] = dp [ j + 1 ] + 1 if a == b else 0 ans = max ( ans , dp [ j ]) return ans","title":"718. Maximum Length of Repeated Subarray"},{"location":"problems/0718/#718-maximum-length-of-repeated-subarray","text":"","title":"718. Maximum Length of Repeated Subarray"},{"location":"problems/0718/#approach-1-2d-dp","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; // dp[i][j] := max length of A[i..m) and B[j..n) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; ans = max ( ans , dp [ i ][ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; // dp[i][j] := max length of A[i..m) and B[j..n) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ] ) { dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; ans = Math . max ( ans , dp [ i ][ j ] ); } return ans ; } }","title":"Approach 1: 2D DP"},{"location":"problems/0718/#approach-2-1d-dp","text":"Time: $O(mn)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < int > dp ( n + 1 ); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < n ; ++ j ) { // the order is important dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = max ( ans , dp [ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; int [] dp = new int [ n + 1 ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < n ; ++ j ) { // the order is important dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = Math . max ( ans , dp [ j ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : ans = 0 dp = [ 0 ] * ( len ( B ) + 1 ) for i , a in reversed ( list ( enumerate ( A ))): for j , b in enumerate ( B ): dp [ j ] = dp [ j + 1 ] + 1 if a == b else 0 ans = max ( ans , dp [ j ]) return ans","title":"Approach 2: 1D DP"},{"location":"problems/0719/","text":"719. Find K-th Smallest Pair Distance Time: $O(n\\log n) + O(n\\log (\\max - \\min))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( begin ( nums ), end ( nums )); int l = 0 ; int r = nums . back () - nums . front (); auto pairDistancesNoGreaterThan = [ & ]( int m ) { int count = 0 ; // for each index i, find the first index j s.t. nums[j] > nums[i] + m, // so pairDistancesNoGreaterThan for index i will be j - i - 1 for ( int i = 0 , j = 1 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } return count ; }; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( pairDistancesNoGreaterThan ( m ) < k ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ] ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l","title":"719. Find K-th Smallest Pair Distance"},{"location":"problems/0719/#719-find-k-th-smallest-pair-distance","text":"Time: $O(n\\log n) + O(n\\log (\\max - \\min))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( begin ( nums ), end ( nums )); int l = 0 ; int r = nums . back () - nums . front (); auto pairDistancesNoGreaterThan = [ & ]( int m ) { int count = 0 ; // for each index i, find the first index j s.t. nums[j] > nums[i] + m, // so pairDistancesNoGreaterThan for index i will be j - i - 1 for ( int i = 0 , j = 1 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } return count ; }; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( pairDistancesNoGreaterThan ( m ) < k ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ] ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l","title":"719. Find K-th Smallest Pair Distance"},{"location":"problems/0720/","text":"720. Longest Word in Dictionary Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : string longestWord ( vector < string >& words ) { for ( const string & word : words ) insert ( word ); return longestWordFrom ( & root ); } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } string longestWordFrom ( TrieNode * node ) { string ans = node -> word ? * node -> word : \"\" ; for ( TrieNode * child : node -> children ) if ( child && child -> word ) { string childWord = longestWordFrom ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public String longestWord ( String [] words ) { for ( final String word : words ) insert ( word ); return dfs ( root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String dfs ( TrieNode node ) { String ans = node . word == null ? \"\" : node . word ; for ( TrieNode child : node . children ) if ( child != null && child . word != null && child . word . length () > 0 ) { String childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def longestWord ( self , words : List [ str ]) -> str : def dfs ( node : dict ) -> str : ans = node [ 'word' ] if 'word' in node else '' for child in node : if 'word' in node [ child ] and len ( node [ child ][ 'word' ]) > 0 : childWord = dfs ( node [ child ]) if len ( childWord ) > len ( ans ) or ( len ( childWord ) == len ( ans ) and childWord < ans ): ans = childWord return ans self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word return dfs ( self . root )","title":"720. Longest Word in Dictionary"},{"location":"problems/0720/#720-longest-word-in-dictionary","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : string longestWord ( vector < string >& words ) { for ( const string & word : words ) insert ( word ); return longestWordFrom ( & root ); } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } string longestWordFrom ( TrieNode * node ) { string ans = node -> word ? * node -> word : \"\" ; for ( TrieNode * child : node -> children ) if ( child && child -> word ) { string childWord = longestWordFrom ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public String longestWord ( String [] words ) { for ( final String word : words ) insert ( word ); return dfs ( root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String dfs ( TrieNode node ) { String ans = node . word == null ? \"\" : node . word ; for ( TrieNode child : node . children ) if ( child != null && child . word != null && child . word . length () > 0 ) { String childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def longestWord ( self , words : List [ str ]) -> str : def dfs ( node : dict ) -> str : ans = node [ 'word' ] if 'word' in node else '' for child in node : if 'word' in node [ child ] and len ( node [ child ][ 'word' ]) > 0 : childWord = dfs ( node [ child ]) if len ( childWord ) > len ( ans ) or ( len ( childWord ) == len ( ans ) and childWord < ans ): ans = childWord return ans self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word return dfs ( self . root )","title":"720. Longest Word in Dictionary"},{"location":"problems/0721/","text":"721. Accounts Merge Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class UF { public : UF ( const vector < vector < string >>& accounts ) { for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { const string & email = account [ i ]; rank [ email ] = 0 ; parent [ email ] = email ; } } void union_ ( const string & u , const string & v ) { const string & pu = find ( u ); const string & pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } string find ( const string & u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : unordered_map < string , int > rank ; unordered_map < string , string > parent ; }; class Solution { public : vector < vector < string >> accountsMerge ( vector < vector < string >>& accounts ) { vector < vector < string >> ans ; unordered_map < string , string > emailToName ; unordered_map < string , set < string >> groups ; // {parentEmail: {emails}} UF uf ( accounts ); // get {email: name} mapping for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) if ( ! emailToName . count ( account [ i ])) emailToName [ account [ i ]] = account [ 0 ]; // union emails for ( const vector < string >& account : accounts ) for ( int i = 2 ; i < account . size (); ++ i ) uf . union_ ( account [ i ], account [ i - 1 ]); for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { const string & parentEmail = uf . find ( account [ i ]); groups [ parentEmail ]. insert ( account [ i ]); } for ( const auto & [ parentEmail , emails ] : groups ) { const string & name = emailToName [ parentEmail ]; vector < string > row { begin ( emails ), end ( emails )}; row . insert ( begin ( row ), name ); ans . push_back ( row ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Solution { public List < List < String >> accountsMerge ( List < List < String >> accounts ) { List < List < String >> ans = new ArrayList <> (); Map < String , String > emailToName = new HashMap <> (); Map < String , TreeSet < String >> groups = new HashMap <> (); UF uf = new UF ( accounts ); for ( final List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) emailToName . putIfAbsent ( account . get ( i ), account . get ( 0 )); for ( final List < String > account : accounts ) for ( int i = 2 ; i < account . size (); ++ i ) uf . union ( account . get ( i ), account . get ( i - 1 )); for ( final List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { final String parent = uf . find ( account . get ( i )); groups . computeIfAbsent ( parent , k -> new TreeSet <> ()). add ( account . get ( i )); } for ( final String parent : groups . keySet ()) { List < String > emails = new ArrayList <> ( groups . get ( parent )); final String name = emailToName . get ( parent ); emails . add ( 0 , name ); ans . add ( emails ); } return ans ; } } class UF { public UF ( List < List < String >> accounts ) { for ( List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { rank . putIfAbsent ( account . get ( i ), 0 ); parent . putIfAbsent ( account . get ( i ), account . get ( i )); } } public void union ( final String u , final String v ) { final String pu = find ( u ); final String pv = find ( v ); if ( pu == pv ) return ; if ( rank . get ( pu ) < rank . get ( pv )) parent . put ( pu , pv ); else if ( rank . get ( pu ) > rank . get ( pv )) parent . put ( pv , pu ); else { parent . put ( pu , pv ); rank . put ( pv , rank . get ( pv ) + 1 ); } } public String find ( final String u ) { if ( parent . get ( u ) != u ) parent . put ( u , find ( parent . get ( u ))); return parent . get ( u ); } private Map < String , Integer > rank = new HashMap <> (); private Map < String , String > parent = new HashMap <> (); }","title":"721. Accounts Merge"},{"location":"problems/0721/#721-accounts-merge","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class UF { public : UF ( const vector < vector < string >>& accounts ) { for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { const string & email = account [ i ]; rank [ email ] = 0 ; parent [ email ] = email ; } } void union_ ( const string & u , const string & v ) { const string & pu = find ( u ); const string & pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } string find ( const string & u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : unordered_map < string , int > rank ; unordered_map < string , string > parent ; }; class Solution { public : vector < vector < string >> accountsMerge ( vector < vector < string >>& accounts ) { vector < vector < string >> ans ; unordered_map < string , string > emailToName ; unordered_map < string , set < string >> groups ; // {parentEmail: {emails}} UF uf ( accounts ); // get {email: name} mapping for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) if ( ! emailToName . count ( account [ i ])) emailToName [ account [ i ]] = account [ 0 ]; // union emails for ( const vector < string >& account : accounts ) for ( int i = 2 ; i < account . size (); ++ i ) uf . union_ ( account [ i ], account [ i - 1 ]); for ( const vector < string >& account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { const string & parentEmail = uf . find ( account [ i ]); groups [ parentEmail ]. insert ( account [ i ]); } for ( const auto & [ parentEmail , emails ] : groups ) { const string & name = emailToName [ parentEmail ]; vector < string > row { begin ( emails ), end ( emails )}; row . insert ( begin ( row ), name ); ans . push_back ( row ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Solution { public List < List < String >> accountsMerge ( List < List < String >> accounts ) { List < List < String >> ans = new ArrayList <> (); Map < String , String > emailToName = new HashMap <> (); Map < String , TreeSet < String >> groups = new HashMap <> (); UF uf = new UF ( accounts ); for ( final List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) emailToName . putIfAbsent ( account . get ( i ), account . get ( 0 )); for ( final List < String > account : accounts ) for ( int i = 2 ; i < account . size (); ++ i ) uf . union ( account . get ( i ), account . get ( i - 1 )); for ( final List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { final String parent = uf . find ( account . get ( i )); groups . computeIfAbsent ( parent , k -> new TreeSet <> ()). add ( account . get ( i )); } for ( final String parent : groups . keySet ()) { List < String > emails = new ArrayList <> ( groups . get ( parent )); final String name = emailToName . get ( parent ); emails . add ( 0 , name ); ans . add ( emails ); } return ans ; } } class UF { public UF ( List < List < String >> accounts ) { for ( List < String > account : accounts ) for ( int i = 1 ; i < account . size (); ++ i ) { rank . putIfAbsent ( account . get ( i ), 0 ); parent . putIfAbsent ( account . get ( i ), account . get ( i )); } } public void union ( final String u , final String v ) { final String pu = find ( u ); final String pv = find ( v ); if ( pu == pv ) return ; if ( rank . get ( pu ) < rank . get ( pv )) parent . put ( pu , pv ); else if ( rank . get ( pu ) > rank . get ( pv )) parent . put ( pv , pu ); else { parent . put ( pu , pv ); rank . put ( pv , rank . get ( pv ) + 1 ); } } public String find ( final String u ) { if ( parent . get ( u ) != u ) parent . put ( u , find ( parent . get ( u ))); return parent . get ( u ); } private Map < String , Integer > rank = new HashMap <> (); private Map < String , String > parent = new HashMap <> (); }","title":"721. Accounts Merge"},{"location":"problems/0722/","text":"722. Remove Comments Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > removeComments ( vector < string >& source ) { vector < string > ans ; bool commenting = false ; string modified ; for ( const string & line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line [ i ]; ++ i ; break ; } const string & twoChars = line . substr ( i , 2 ); if ( twoChars == \"/*\" && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars == \"*/\" && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars == \"//\" ) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line [ i ]; ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . push_back ( modified ); modified = \"\" ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < String > removeComments ( String [] source ) { List < String > ans = new ArrayList <> (); boolean commenting = false ; String modified = \"\" ; for ( final String line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; break ; } String twoChars = line . substring ( i , i + 2 ); if ( twoChars . equals ( \"/*\" ) && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars . equals ( \"*/\" ) && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars . equals ( \"//\" )) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . add ( modified ); modified = \"\" ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def removeComments ( self , source : List [ str ]) -> List [ str ]: ans = [] commenting = False modified = '' for line in source : i = 0 while i < len ( line ): if i + 1 == len ( line ): if not commenting : modified += line [ i ] i += 1 break twoChars = line [ i : i + 2 ] if twoChars == '/*' and not commenting : commenting = True i += 2 elif twoChars == '*/' and commenting : commenting = False i += 2 elif twoChars == '//' : if not commenting : break else : i += 2 else : if not commenting : modified += line [ i ] i += 1 if modified and not commenting : ans . append ( modified ) modified = '' return ans","title":"722. Remove Comments"},{"location":"problems/0722/#722-remove-comments","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > removeComments ( vector < string >& source ) { vector < string > ans ; bool commenting = false ; string modified ; for ( const string & line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line [ i ]; ++ i ; break ; } const string & twoChars = line . substr ( i , 2 ); if ( twoChars == \"/*\" && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars == \"*/\" && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars == \"//\" ) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line [ i ]; ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . push_back ( modified ); modified = \"\" ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public List < String > removeComments ( String [] source ) { List < String > ans = new ArrayList <> (); boolean commenting = false ; String modified = \"\" ; for ( final String line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; break ; } String twoChars = line . substring ( i , i + 2 ); if ( twoChars . equals ( \"/*\" ) && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars . equals ( \"*/\" ) && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars . equals ( \"//\" )) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . add ( modified ); modified = \"\" ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def removeComments ( self , source : List [ str ]) -> List [ str ]: ans = [] commenting = False modified = '' for line in source : i = 0 while i < len ( line ): if i + 1 == len ( line ): if not commenting : modified += line [ i ] i += 1 break twoChars = line [ i : i + 2 ] if twoChars == '/*' and not commenting : commenting = True i += 2 elif twoChars == '*/' and commenting : commenting = False i += 2 elif twoChars == '//' : if not commenting : break else : i += 2 else : if not commenting : modified += line [ i ] i += 1 if modified and not commenting : ans . append ( modified ) modified = '' return ans","title":"722. Remove Comments"},{"location":"problems/0723/","text":"723. Candy Crush \ud83d\udd12","title":"723. Candy Crush"},{"location":"problems/0723/#723-candy-crush","text":"","title":"723. Candy Crush \ud83d\udd12"},{"location":"problems/0724/","text":"724. Find Pivot Index Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int pivotIndex ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ]) return i ; prefixSum += nums [ i ]; } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int prefixSum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ] ) return i ; prefixSum += nums [ i ] ; } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : summ = sum ( nums ) prefixSum = 0 for i , num in enumerate ( nums ): if prefixSum == summ - prefixSum - num : return i prefixSum += num return - 1","title":"724. Find Pivot Index"},{"location":"problems/0724/#724-find-pivot-index","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int pivotIndex ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ]) return i ; prefixSum += nums [ i ]; } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int prefixSum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ] ) return i ; prefixSum += nums [ i ] ; } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : summ = sum ( nums ) prefixSum = 0 for i , num in enumerate ( nums ): if prefixSum == summ - prefixSum - num : return i prefixSum += num return - 1","title":"724. Find Pivot Index"},{"location":"problems/0725/","text":"725. Split Linked List in Parts Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k ); int length = 0 ; for ( ListNode * curr = root ; curr ; curr = curr -> next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode * prev = nullptr ; ListNode * head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = nullptr ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode [] splitListToParts ( ListNode root , int k ) { ListNode [] ans = new ListNode [ k ] ; int length = 0 ; for ( ListNode curr = root ; curr != null ; curr = curr . next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode prev = null ; ListNode head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ? 1 : 0 ); ++ j ) { prev = head ; head = head . next ; } if ( prev != null ) prev . next = null ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def splitListToParts ( self , root : ListNode , k : int ) -> List [ ListNode ]: ans = [[] for _ in range ( k )] length = 0 curr = root while curr : length += 1 curr = curr . next subLength = length // k remainder = length % k prev = None head = root for i in range ( k ): ans [ i ] = head for j in range ( subLength + ( 1 if remainder > 0 else 0 )): prev = head head = head . next if prev : prev . next = None remainder -= 1 return ans","title":"725. Split Linked List in Parts"},{"location":"problems/0725/#725-split-linked-list-in-parts","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k ); int length = 0 ; for ( ListNode * curr = root ; curr ; curr = curr -> next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode * prev = nullptr ; ListNode * head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = nullptr ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public ListNode [] splitListToParts ( ListNode root , int k ) { ListNode [] ans = new ListNode [ k ] ; int length = 0 ; for ( ListNode curr = root ; curr != null ; curr = curr . next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode prev = null ; ListNode head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ? 1 : 0 ); ++ j ) { prev = head ; head = head . next ; } if ( prev != null ) prev . next = null ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def splitListToParts ( self , root : ListNode , k : int ) -> List [ ListNode ]: ans = [[] for _ in range ( k )] length = 0 curr = root while curr : length += 1 curr = curr . next subLength = length // k remainder = length % k prev = None head = root for i in range ( k ): ans [ i ] = head for j in range ( subLength + ( 1 if remainder > 0 else 0 )): prev = head head = head . next if prev : prev . next = None remainder -= 1 return ans","title":"725. Split Linked List in Parts"},{"location":"problems/0726/","text":"726. Number of Atoms Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : string countOfAtoms ( string formula ) { string ans ; int i = 0 ; for ( const auto & [ elem , freq ] : parse ( formula , i )) { ans += elem ; if ( freq > 1 ) ans += to_string ( freq ); } return ans ; } private : map < string , int > parse ( const string & s , int & i ) { map < string , int > count ; while ( i < s . length ()) if ( s [ i ] == '(' ) { for ( const auto & [ elem , freq ] : parse ( s , ++ i )) count [ elem ] += freq ; } else if ( s [ i ] == ')' ) { const int num = getNum ( s , ++ i ); for ( auto && [ _ , freq ] : count ) freq *= num ; return count ; // return back to previous scope } else { // s[i] must be uppercased const string & elem = getElem ( s , i ); const int num = getNum ( s , i ); count [ elem ] += num ; } return count ; } string getElem ( const string & s , int & i ) { const int elemStart = i ++ ; // s[elemStart] is uppercased while ( i < s . length () && islower ( s [ i ])) ++ i ; return s . substr ( elemStart , i - elemStart ); } int getNum ( const string & s , int & i ) { const int numStart = i ; while ( i < s . length () && isdigit ( s [ i ])) ++ i ; const string & numString = s . substr ( numStart , i - numStart ); return numString . empty () ? 1 : stoi ( numString ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public String countOfAtoms ( String formula ) { String ans = \"\" ; i = 0 ; Map < String , Integer > count = parse ( formula ); for ( String elem : count . keySet ()) ans += elem + ( count . get ( elem ) == 1 ? \"\" : String . valueOf ( count . get ( elem ))); return ans ; } private int i ; private Map < String , Integer > parse ( String formula ) { final int n = formula . length (); Map < String , Integer > count = new TreeMap <> (); while ( i < n ) { if ( formula . charAt ( i ) == '(' ) { ++ i ; for ( Map . Entry < String , Integer > entry : parse ( formula ). entrySet ()) { String elem = entry . getKey (); Integer freq = entry . getValue (); count . put ( elem , count . getOrDefault ( elem , 0 ) + freq ); } } else if ( formula . charAt ( i ) == ')' ) { int numStart = ++ i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; int factor = Integer . valueOf ( formula . substring ( numStart , i )); for ( String elem : count . keySet ()) count . put ( elem , count . get ( elem ) * factor ); return count ; } else if ( Character . isUpperCase ( formula . charAt ( i ))) { int elemStart = i ++ ; while ( i < n && Character . isLowerCase ( formula . charAt ( i ))) ++ i ; String elem = formula . substring ( elemStart , i ); int numStart = i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; String numString = formula . substring ( numStart , i ); Integer num = numString . isEmpty () ? 1 : Integer . valueOf ( numString ); count . put ( elem , count . getOrDefault ( elem , 0 ) + num ); } } return count ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution : def countOfAtoms ( self , formula : str ) -> str : def parse () -> dict : ans = collections . defaultdict ( int ) nonlocal i while i < n : if formula [ i ] == '(' : i += 1 for elem , freq in parse () . items (): ans [ elem ] += freq elif formula [ i ] == ')' : i += 1 numStart = i while i < n and formula [ i ] . isdigit (): i += 1 factor = int ( formula [ numStart : i ]) for elem , freq in ans . items (): ans [ elem ] *= factor return ans elif formula [ i ] . isupper (): elemStart = i i += 1 while i < n and formula [ i ] . islower (): i += 1 elem = formula [ elemStart : i ] numStart = i while i < n and formula [ i ] . isdigit (): i += 1 num = 1 if i == numStart else int ( formula [ numStart : i ]) ans [ elem ] += num return ans n = len ( formula ) ans = \"\" i = 0 count = parse () for elem in sorted ( count . keys ()): ans += elem if count [ elem ] > 1 : ans += str ( count [ elem ]) return ans","title":"726. Number of Atoms"},{"location":"problems/0726/#726-number-of-atoms","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : string countOfAtoms ( string formula ) { string ans ; int i = 0 ; for ( const auto & [ elem , freq ] : parse ( formula , i )) { ans += elem ; if ( freq > 1 ) ans += to_string ( freq ); } return ans ; } private : map < string , int > parse ( const string & s , int & i ) { map < string , int > count ; while ( i < s . length ()) if ( s [ i ] == '(' ) { for ( const auto & [ elem , freq ] : parse ( s , ++ i )) count [ elem ] += freq ; } else if ( s [ i ] == ')' ) { const int num = getNum ( s , ++ i ); for ( auto && [ _ , freq ] : count ) freq *= num ; return count ; // return back to previous scope } else { // s[i] must be uppercased const string & elem = getElem ( s , i ); const int num = getNum ( s , i ); count [ elem ] += num ; } return count ; } string getElem ( const string & s , int & i ) { const int elemStart = i ++ ; // s[elemStart] is uppercased while ( i < s . length () && islower ( s [ i ])) ++ i ; return s . substr ( elemStart , i - elemStart ); } int getNum ( const string & s , int & i ) { const int numStart = i ; while ( i < s . length () && isdigit ( s [ i ])) ++ i ; const string & numString = s . substr ( numStart , i - numStart ); return numString . empty () ? 1 : stoi ( numString ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public String countOfAtoms ( String formula ) { String ans = \"\" ; i = 0 ; Map < String , Integer > count = parse ( formula ); for ( String elem : count . keySet ()) ans += elem + ( count . get ( elem ) == 1 ? \"\" : String . valueOf ( count . get ( elem ))); return ans ; } private int i ; private Map < String , Integer > parse ( String formula ) { final int n = formula . length (); Map < String , Integer > count = new TreeMap <> (); while ( i < n ) { if ( formula . charAt ( i ) == '(' ) { ++ i ; for ( Map . Entry < String , Integer > entry : parse ( formula ). entrySet ()) { String elem = entry . getKey (); Integer freq = entry . getValue (); count . put ( elem , count . getOrDefault ( elem , 0 ) + freq ); } } else if ( formula . charAt ( i ) == ')' ) { int numStart = ++ i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; int factor = Integer . valueOf ( formula . substring ( numStart , i )); for ( String elem : count . keySet ()) count . put ( elem , count . get ( elem ) * factor ); return count ; } else if ( Character . isUpperCase ( formula . charAt ( i ))) { int elemStart = i ++ ; while ( i < n && Character . isLowerCase ( formula . charAt ( i ))) ++ i ; String elem = formula . substring ( elemStart , i ); int numStart = i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; String numString = formula . substring ( numStart , i ); Integer num = numString . isEmpty () ? 1 : Integer . valueOf ( numString ); count . put ( elem , count . getOrDefault ( elem , 0 ) + num ); } } return count ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution : def countOfAtoms ( self , formula : str ) -> str : def parse () -> dict : ans = collections . defaultdict ( int ) nonlocal i while i < n : if formula [ i ] == '(' : i += 1 for elem , freq in parse () . items (): ans [ elem ] += freq elif formula [ i ] == ')' : i += 1 numStart = i while i < n and formula [ i ] . isdigit (): i += 1 factor = int ( formula [ numStart : i ]) for elem , freq in ans . items (): ans [ elem ] *= factor return ans elif formula [ i ] . isupper (): elemStart = i i += 1 while i < n and formula [ i ] . islower (): i += 1 elem = formula [ elemStart : i ] numStart = i while i < n and formula [ i ] . isdigit (): i += 1 num = 1 if i == numStart else int ( formula [ numStart : i ]) ans [ elem ] += num return ans n = len ( formula ) ans = \"\" i = 0 count = parse () for elem in sorted ( count . keys ()): ans += elem if count [ elem ] > 1 : ans += str ( count [ elem ]) return ans","title":"726. Number of Atoms"},{"location":"problems/0727/","text":"727. Minimum Window Subsequence \ud83d\udd12 Time: $O(|S||T|)$ Space: $O(|S||T|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : string minWindow ( string S , string T ) { const int m = T . length (); const int n = S . length (); // dp[i][j] := start index (1-indexed) of // the minimum window of T[0..i] and S[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); // fill in placeholder values for ( int j = 0 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j + 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( T [ i - 1 ] == S [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = dp [ i ][ j - 1 ]; int bestLeft = 0 ; int minLength = INT_MAX ; for ( int j = 1 ; j <= n ; ++ j ) if ( dp [ m ][ j ] > 0 && j - dp [ m ][ j ] + 1 < minLength ) { bestLeft = dp [ m ][ j ] - 1 ; minLength = j - dp [ m ][ j ] + 1 ; } return minLength == INT_MAX ? \"\" : S . substr ( bestLeft , minLength ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public String minWindow ( String S , String T ) { final int m = T . length (); final int n = S . length (); // dp[i][j] := start index (1-indexed) of // the minimum window of T[0..i] and S[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; // fill in placeholder values for ( int j = 0 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j + 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( T . charAt ( i - 1 ) == S . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = dp [ i ][ j - 1 ] ; int bestLeft = 0 ; int minLength = Integer . MAX_VALUE ; for ( int j = 1 ; j <= n ; ++ j ) if ( dp [ m ][ j ] > 0 && j - dp [ m ][ j ] + 1 < minLength ) { bestLeft = dp [ m ][ j ] - 1 ; minLength = j - dp [ m ][ j ] + 1 ; } return minLength == Integer . MAX_VALUE ? \"\" : S . substring ( bestLeft , bestLeft + minLength ); } }","title":"727. Minimum Window Subsequence"},{"location":"problems/0727/#727-minimum-window-subsequence","text":"Time: $O(|S||T|)$ Space: $O(|S||T|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : string minWindow ( string S , string T ) { const int m = T . length (); const int n = S . length (); // dp[i][j] := start index (1-indexed) of // the minimum window of T[0..i] and S[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); // fill in placeholder values for ( int j = 0 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j + 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( T [ i - 1 ] == S [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = dp [ i ][ j - 1 ]; int bestLeft = 0 ; int minLength = INT_MAX ; for ( int j = 1 ; j <= n ; ++ j ) if ( dp [ m ][ j ] > 0 && j - dp [ m ][ j ] + 1 < minLength ) { bestLeft = dp [ m ][ j ] - 1 ; minLength = j - dp [ m ][ j ] + 1 ; } return minLength == INT_MAX ? \"\" : S . substr ( bestLeft , minLength ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public String minWindow ( String S , String T ) { final int m = T . length (); final int n = S . length (); // dp[i][j] := start index (1-indexed) of // the minimum window of T[0..i] and S[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; // fill in placeholder values for ( int j = 0 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j + 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( T . charAt ( i - 1 ) == S . charAt ( j - 1 )) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = dp [ i ][ j - 1 ] ; int bestLeft = 0 ; int minLength = Integer . MAX_VALUE ; for ( int j = 1 ; j <= n ; ++ j ) if ( dp [ m ][ j ] > 0 && j - dp [ m ][ j ] + 1 < minLength ) { bestLeft = dp [ m ][ j ] - 1 ; minLength = j - dp [ m ][ j ] + 1 ; } return minLength == Integer . MAX_VALUE ? \"\" : S . substring ( bestLeft , bestLeft + minLength ); } }","title":"727. Minimum Window Subsequence \ud83d\udd12"},{"location":"problems/0728/","text":"728. Self Dividing Numbers Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > selfDividingNumbers ( int left , int right ) { vector < int > ans ; for ( int num = left ; num <= right ; ++ num ) if ( selfDividingNumbers ( num )) ans . push_back ( num ); return ans ; } private : bool selfDividingNumbers ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { List < Integer > ans = new ArrayList <> (); for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . add ( num ); return ans ; } private boolean dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } } Python 1 2 3 class Solution : def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ]: return [ num for num in range ( left , right + 1 ) if all ( n != 0 and num % n == 0 for n in map ( int , str ( num )))]","title":"728. Self Dividing Numbers"},{"location":"problems/0728/#728-self-dividing-numbers","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > selfDividingNumbers ( int left , int right ) { vector < int > ans ; for ( int num = left ; num <= right ; ++ num ) if ( selfDividingNumbers ( num )) ans . push_back ( num ); return ans ; } private : bool selfDividingNumbers ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { List < Integer > ans = new ArrayList <> (); for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . add ( num ); return ans ; } private boolean dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } } Python 1 2 3 class Solution : def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ]: return [ num for num in range ( left , right + 1 ) if all ( n != 0 and num % n == 0 for n in map ( int , str ( num )))]","title":"728. Self Dividing Numbers"},{"location":"problems/0729/","text":"729. My Calendar I Approach 1: Brute force Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( const auto & [ s , e ] : ranges ) if ( max ( start , s ) < min ( end , e )) return false ; ranges . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> ranges ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ] , start ) < Math . min ( book [ 1 ] , end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False Approach 2: Ordered Map Time: $O(n\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { auto it = ranges . lower_bound ( start ); // the 1st element >= start if ( it != cend ( ranges ) && it -> first < end ) return false ; if ( it != cbegin ( ranges ) && ( -- it ) -> second > start ) return false ; ranges [ start ] = end ; return true ; } private : map < int , int > ranges ; };","title":"729. My Calendar I"},{"location":"problems/0729/#729-my-calendar-i","text":"","title":"729. My Calendar I"},{"location":"problems/0729/#approach-1-brute-force","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( const auto & [ s , e ] : ranges ) if ( max ( start , s ) < min ( end , e )) return false ; ranges . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> ranges ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ] , start ) < Math . min ( book [ 1 ] , end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False","title":"Approach 1: Brute force"},{"location":"problems/0729/#approach-2-ordered-map","text":"Time: $O(n\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { auto it = ranges . lower_bound ( start ); // the 1st element >= start if ( it != cend ( ranges ) && it -> first < end ) return false ; if ( it != cbegin ( ranges ) && ( -- it ) -> second > start ) return false ; ranges [ start ] = end ; return true ; } private : map < int , int > ranges ; };","title":"Approach 2: Ordered Map"},{"location":"problems/0730/","text":"730. Count Different Palindromic Subsequences Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int countPalindromicSubsequences ( string S ) { const int n = S . length (); const int kMod = 1e9 + 7 ; // dp[i][j] := # of different non-empty palindromic subsequences in S[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( S [ i ] == S [ j ]) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S [ lo ] != S [ i ]) ++ lo ; while ( lo <= hi && S [ hi ] != S [ i ]) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ]; } else { dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ]; } dp [ i ][ j ] = ( dp [ i ][ j ] + ( long ) kMod ) % kMod ; } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int countPalindromicSubsequences ( String S ) { final int n = S . length (); final int kMod = ( int ) 1e9 + 7 ; // dp[i][j] := # of different non-empty palindromic subsequences in S[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( S . charAt ( i ) == S . charAt ( j )) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S . charAt ( lo ) != S . charAt ( i )) ++ lo ; while ( lo <= hi && S . charAt ( hi ) != S . charAt ( i )) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ] ; } else { dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ] ; } dp [ i ][ j ] = ( int ) ((( long ) dp [ i ][ j ] + kMod ) % kMod ); } return dp [ 0 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def countPalindromicSubsequences ( self , S : str ) -> int : def count ( l : int , r : int ) -> int : if l > r : return 0 if l == r : return 1 key = l * len ( S ) + r if key in memo : return memo [ key ] if S [ l ] == S [ r ]: lo = l + 1 hi = r - 1 while lo <= hi and S [ lo ] != S [ l ]: lo += 1 while lo <= hi and S [ hi ] != S [ l ]: hi -= 1 if lo > hi : ans = count ( l + 1 , r - 1 ) * 2 + 2 elif lo == hi : ans = count ( l + 1 , r - 1 ) * 2 + 1 else : ans = count ( l + 1 , r - 1 ) * 2 - count ( lo + 1 , hi - 1 ) else : ans = count ( l , r - 1 ) + count ( l + 1 , r ) - count ( l + 1 , r - 1 ) memo [ key ] = ( ans + kMod ) % kMod return memo [ key ] kMod = int ( 1e9 + 7 ) memo = {} return count ( 0 , len ( S ) - 1 )","title":"730. Count Different Palindromic Subsequences"},{"location":"problems/0730/#730-count-different-palindromic-subsequences","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int countPalindromicSubsequences ( string S ) { const int n = S . length (); const int kMod = 1e9 + 7 ; // dp[i][j] := # of different non-empty palindromic subsequences in S[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( S [ i ] == S [ j ]) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S [ lo ] != S [ i ]) ++ lo ; while ( lo <= hi && S [ hi ] != S [ i ]) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ]; } else { dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ]; } dp [ i ][ j ] = ( dp [ i ][ j ] + ( long ) kMod ) % kMod ; } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int countPalindromicSubsequences ( String S ) { final int n = S . length (); final int kMod = ( int ) 1e9 + 7 ; // dp[i][j] := # of different non-empty palindromic subsequences in S[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( S . charAt ( i ) == S . charAt ( j )) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S . charAt ( lo ) != S . charAt ( i )) ++ lo ; while ( lo <= hi && S . charAt ( hi ) != S . charAt ( i )) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ] ; } else { dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ] ; } dp [ i ][ j ] = ( int ) ((( long ) dp [ i ][ j ] + kMod ) % kMod ); } return dp [ 0 ][ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def countPalindromicSubsequences ( self , S : str ) -> int : def count ( l : int , r : int ) -> int : if l > r : return 0 if l == r : return 1 key = l * len ( S ) + r if key in memo : return memo [ key ] if S [ l ] == S [ r ]: lo = l + 1 hi = r - 1 while lo <= hi and S [ lo ] != S [ l ]: lo += 1 while lo <= hi and S [ hi ] != S [ l ]: hi -= 1 if lo > hi : ans = count ( l + 1 , r - 1 ) * 2 + 2 elif lo == hi : ans = count ( l + 1 , r - 1 ) * 2 + 1 else : ans = count ( l + 1 , r - 1 ) * 2 - count ( lo + 1 , hi - 1 ) else : ans = count ( l , r - 1 ) + count ( l + 1 , r ) - count ( l + 1 , r - 1 ) memo [ key ] = ( ans + kMod ) % kMod return memo [ key ] kMod = int ( 1e9 + 7 ) memo = {} return count ( 0 , len ( S ) - 1 )","title":"730. Count Different Palindromic Subsequences"},{"location":"problems/0731/","text":"731. My Calendar II Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : bool book ( int start , int end ) { for ( const auto & [ s , e ] : overlaps ) if ( max ( start , s ) < min ( end , e )) return false ; for ( const auto & [ s , e ] : ranges ) { const int ss = max ( start , s ); const int ee = min ( end , e ); if ( ss < ee ) overlaps . push_back ({ ss , ee }); } ranges . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> ranges ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II"},{"location":"problems/0731/#731-my-calendar-ii","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : bool book ( int start , int end ) { for ( const auto & [ s , e ] : overlaps ) if ( max ( start , s ) < min ( end , e )) return false ; for ( const auto & [ s , e ] : ranges ) { const int ss = max ( start , s ); const int ee = min ( end , e ); if ( ss < ee ) overlaps . push_back ({ ss , ee }); } ranges . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> ranges ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II"},{"location":"problems/0732/","text":"732. My Calendar III Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyCalendarThree { public : int book ( int start , int end ) { ++ timeline [ start ]; -- timeline [ end ]; int ans = 0 ; int k = 0 ; for ( const auto & [ _ , count ] : timeline ) ans = max ( ans , k += count ); return ans ; } private : map < int , int > timeline ; };","title":"732. My Calendar III"},{"location":"problems/0732/#732-my-calendar-iii","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyCalendarThree { public : int book ( int start , int end ) { ++ timeline [ start ]; -- timeline [ end ]; int ans = 0 ; int k = 0 ; for ( const auto & [ _ , count ] : timeline ) ans = max ( ans , k += count ); return ans ; } private : map < int , int > timeline ; };","title":"732. My Calendar III"},{"location":"problems/0733/","text":"733. Flood Fill Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> floodFill ( vector < vector < int >>& image , int sr , int sc , int newColor ) { const int m = image . size (); const int n = image [ 0 ]. size (); const int startColor = image [ sr ][ sc ]; vector < vector < bool >> seen ( m , vector < bool > ( n )); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( seen [ i ][ j ] || image [ i ][ j ] != startColor ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; dfs ( sr , sc ); return image ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [][] floodFill ( int [][] image , int sr , int sc , int newColor ) { boolean [][] seen = new boolean [ image . length ][ image [ 0 ] . length ] ; dfs ( image , sr , sc , seen , image [ sr ][ sc ] , newColor ); return image ; } private void dfs ( int [][] image , int i , int j , boolean [][] seen , int startColor , int newColor ) { if ( i < 0 || i >= image . length || j < 0 || j >= image [ 0 ] . length ) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ] ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( image , i + 1 , j , seen , startColor , newColor ); dfs ( image , i - 1 , j , seen , startColor , newColor ); dfs ( image , i , j + 1 , seen , startColor , newColor ); dfs ( image , i , j - 1 , seen , startColor , newColor ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def floodFill ( self , image : List [ List [ int ]], sr : int , sc : int , newColor : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( image ) or not 0 <= j < len ( image [ 0 ]): return if image [ i ][ j ] != startColor or seen [ i ][ j ]: return image [ i ][ j ] = newColor seen [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) startColor = image [ sr ][ sc ] seen = [[ False ] * len ( image [ 0 ]) for _ in range ( len ( image ))] dfs ( sr , sc ) return image","title":"733. Flood Fill"},{"location":"problems/0733/#733-flood-fill","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> floodFill ( vector < vector < int >>& image , int sr , int sc , int newColor ) { const int m = image . size (); const int n = image [ 0 ]. size (); const int startColor = image [ sr ][ sc ]; vector < vector < bool >> seen ( m , vector < bool > ( n )); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( seen [ i ][ j ] || image [ i ][ j ] != startColor ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; dfs ( sr , sc ); return image ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [][] floodFill ( int [][] image , int sr , int sc , int newColor ) { boolean [][] seen = new boolean [ image . length ][ image [ 0 ] . length ] ; dfs ( image , sr , sc , seen , image [ sr ][ sc ] , newColor ); return image ; } private void dfs ( int [][] image , int i , int j , boolean [][] seen , int startColor , int newColor ) { if ( i < 0 || i >= image . length || j < 0 || j >= image [ 0 ] . length ) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ] ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( image , i + 1 , j , seen , startColor , newColor ); dfs ( image , i - 1 , j , seen , startColor , newColor ); dfs ( image , i , j + 1 , seen , startColor , newColor ); dfs ( image , i , j - 1 , seen , startColor , newColor ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def floodFill ( self , image : List [ List [ int ]], sr : int , sc : int , newColor : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( image ) or not 0 <= j < len ( image [ 0 ]): return if image [ i ][ j ] != startColor or seen [ i ][ j ]: return image [ i ][ j ] = newColor seen [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) startColor = image [ sr ][ sc ] seen = [[ False ] * len ( image [ 0 ]) for _ in range ( len ( image ))] dfs ( sr , sc ) return image","title":"733. Flood Fill"},{"location":"problems/0734/","text":"734. Sentence Similarity \ud83d\udd12","title":"734. Sentence Similarity"},{"location":"problems/0734/#734-sentence-similarity","text":"","title":"734. Sentence Similarity \ud83d\udd12"},{"location":"problems/0735/","text":"735. Asteroid Collision Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > asteroidCollision ( vector < int >& asteroids ) { vector < int > stack ; for ( const int a : asteroids ) if ( a > 0 ) { stack . push_back ( a ); } else { // destroy previous positive one(s) while ( ! stack . empty () && stack . back () > 0 && stack . back () < - a ) stack . pop_back (); if ( stack . empty () || stack . back () < 0 ) stack . push_back ( a ); else if ( stack . back () == - a ) stack . pop_back (); } return stack ; } };","title":"735. Asteroid Collision"},{"location":"problems/0735/#735-asteroid-collision","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > asteroidCollision ( vector < int >& asteroids ) { vector < int > stack ; for ( const int a : asteroids ) if ( a > 0 ) { stack . push_back ( a ); } else { // destroy previous positive one(s) while ( ! stack . empty () && stack . back () > 0 && stack . back () < - a ) stack . pop_back (); if ( stack . empty () || stack . back () < 0 ) stack . push_back ( a ); else if ( stack . back () == - a ) stack . pop_back (); } return stack ; } };","title":"735. Asteroid Collision"},{"location":"problems/0736/","text":"736. Parse Lisp Expression Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int evaluate ( string expression ) { return evaluate ( expression , unordered_map < string , int > ()); } private : int evaluate ( const string & e , unordered_map < string , int > scope ) { if ( isdigit ( e [ 0 ]) || e [ 0 ] == '-' ) return stoi ( e ); if ( scope . count ( e )) return scope [ e ]; const int spaceIndex = e . find_first_of ( ' ' ); const string nextExpression = e . substr ( spaceIndex + 1 , e . length () - spaceIndex - 2 ); // -2: \"()\" const vector < string > tokens = split ( nextExpression ); // note that e[0] == '(' if ( e [ 1 ] == 'm' ) // mult return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ); if ( e [ 1 ] == 'a' ) // add return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ); // let for ( int i = 0 ; i + 1 < tokens . size (); i += 2 ) scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ); return evaluate ( tokens . back (), scope ); }; vector < string > split ( const string & e ) { vector < string > tokens ; string s ; int parenthesis = 0 ; for ( const char c : e ) { if ( c == '(' ) ++ parenthesis ; else if ( c == ' ) ' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . push_back ( s ); s = \"\" ; } else { s += c ; } } if ( ! s . empty ()) tokens . push_back ( s ); return tokens ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public int evaluate ( String expression ) { return evaluate ( expression , new HashMap <> ()); } private int evaluate ( final String e , Map < String , Integer > prevScope ) { if ( Character . isDigit ( e . charAt ( 0 )) || e . charAt ( 0 ) == '-' ) return Integer . parseInt ( e ); if ( prevScope . containsKey ( e )) return prevScope . get ( e ); Map < String , Integer > scope = new HashMap <> (); scope . putAll ( prevScope ); String nextExpression = e . substring ( e . indexOf ( ' ' ) + 1 , e . length () - 1 ); List < String > tokens = parse ( nextExpression ); if ( e . startsWith ( \"(a\" )) return evaluate ( tokens . get ( 0 ), scope ) + evaluate ( tokens . get ( 1 ), scope ); if ( e . startsWith ( \"(m\" )) return evaluate ( tokens . get ( 0 ), scope ) * evaluate ( tokens . get ( 1 ), scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) // let scope . put ( tokens . get ( i ), evaluate ( tokens . get ( i + 1 ), scope )); return evaluate ( tokens . get ( tokens . size () - 1 ), scope ); } private List < String > parse ( final String s ) { List < String > tokens = new ArrayList <> (); StringBuilder sb = new StringBuilder (); int parenthesis = 0 ; for ( char c : s . toCharArray ()) { if ( c == '(' ) ++ parenthesis ; else if ( c == ')' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . add ( new String ( sb )); sb = new StringBuilder (); } else sb . append ( c ); } if ( sb . length () > 0 ) tokens . add ( new String ( sb )); return tokens ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def evaluate ( self , expression : str ) -> int : def evaluate ( e : str , prevScope : dict ) -> int : if e [ 0 ] . isdigit () or e [ 0 ] == '-' : return int ( e ) if e in prevScope : return prevScope [ e ] scope = prevScope . copy () nextExpression = e [ e . index ( ' ' ) + 1 : - 1 ] tokens = parse ( nextExpression ) if e [ 1 ] == 'a' : return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ) if e [ 1 ] == 'm' : return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ) for i in range ( 0 , len ( tokens ) - 2 , 2 ): scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ) return evaluate ( tokens [ - 1 ], scope ) def parse ( e : str ): tokens = [] s = '' parenthesis = 0 for c in e : if c == '(' : parenthesis += 1 elif c == ')' : parenthesis -= 1 if parenthesis == 0 and c == ' ' : tokens . append ( s ) s = '' else : s += c if len ( s ) > 0 : tokens . append ( s ) return tokens return evaluate ( expression , {})","title":"736. Parse Lisp Expression"},{"location":"problems/0736/#736-parse-lisp-expression","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int evaluate ( string expression ) { return evaluate ( expression , unordered_map < string , int > ()); } private : int evaluate ( const string & e , unordered_map < string , int > scope ) { if ( isdigit ( e [ 0 ]) || e [ 0 ] == '-' ) return stoi ( e ); if ( scope . count ( e )) return scope [ e ]; const int spaceIndex = e . find_first_of ( ' ' ); const string nextExpression = e . substr ( spaceIndex + 1 , e . length () - spaceIndex - 2 ); // -2: \"()\" const vector < string > tokens = split ( nextExpression ); // note that e[0] == '(' if ( e [ 1 ] == 'm' ) // mult return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ); if ( e [ 1 ] == 'a' ) // add return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ); // let for ( int i = 0 ; i + 1 < tokens . size (); i += 2 ) scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ); return evaluate ( tokens . back (), scope ); }; vector < string > split ( const string & e ) { vector < string > tokens ; string s ; int parenthesis = 0 ; for ( const char c : e ) { if ( c == '(' ) ++ parenthesis ; else if ( c == ' ) ' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . push_back ( s ); s = \"\" ; } else { s += c ; } } if ( ! s . empty ()) tokens . push_back ( s ); return tokens ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public int evaluate ( String expression ) { return evaluate ( expression , new HashMap <> ()); } private int evaluate ( final String e , Map < String , Integer > prevScope ) { if ( Character . isDigit ( e . charAt ( 0 )) || e . charAt ( 0 ) == '-' ) return Integer . parseInt ( e ); if ( prevScope . containsKey ( e )) return prevScope . get ( e ); Map < String , Integer > scope = new HashMap <> (); scope . putAll ( prevScope ); String nextExpression = e . substring ( e . indexOf ( ' ' ) + 1 , e . length () - 1 ); List < String > tokens = parse ( nextExpression ); if ( e . startsWith ( \"(a\" )) return evaluate ( tokens . get ( 0 ), scope ) + evaluate ( tokens . get ( 1 ), scope ); if ( e . startsWith ( \"(m\" )) return evaluate ( tokens . get ( 0 ), scope ) * evaluate ( tokens . get ( 1 ), scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) // let scope . put ( tokens . get ( i ), evaluate ( tokens . get ( i + 1 ), scope )); return evaluate ( tokens . get ( tokens . size () - 1 ), scope ); } private List < String > parse ( final String s ) { List < String > tokens = new ArrayList <> (); StringBuilder sb = new StringBuilder (); int parenthesis = 0 ; for ( char c : s . toCharArray ()) { if ( c == '(' ) ++ parenthesis ; else if ( c == ')' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . add ( new String ( sb )); sb = new StringBuilder (); } else sb . append ( c ); } if ( sb . length () > 0 ) tokens . add ( new String ( sb )); return tokens ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def evaluate ( self , expression : str ) -> int : def evaluate ( e : str , prevScope : dict ) -> int : if e [ 0 ] . isdigit () or e [ 0 ] == '-' : return int ( e ) if e in prevScope : return prevScope [ e ] scope = prevScope . copy () nextExpression = e [ e . index ( ' ' ) + 1 : - 1 ] tokens = parse ( nextExpression ) if e [ 1 ] == 'a' : return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ) if e [ 1 ] == 'm' : return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ) for i in range ( 0 , len ( tokens ) - 2 , 2 ): scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ) return evaluate ( tokens [ - 1 ], scope ) def parse ( e : str ): tokens = [] s = '' parenthesis = 0 for c in e : if c == '(' : parenthesis += 1 elif c == ')' : parenthesis -= 1 if parenthesis == 0 and c == ' ' : tokens . append ( s ) s = '' else : s += c if len ( s ) > 0 : tokens . append ( s ) return tokens return evaluate ( expression , {})","title":"736. Parse Lisp Expression"},{"location":"problems/0737/","text":"737. Sentence Similarity II \ud83d\udd12","title":"737. Sentence Similarity II"},{"location":"problems/0737/#737-sentence-similarity-ii","text":"","title":"737. Sentence Similarity II \ud83d\udd12"},{"location":"problems/0738/","text":"738. Monotone Increasing Digits Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int monotoneIncreasingDigits ( int N ) { string s = to_string ( N ); const int n = s . length (); int k = n ; // s[k:] -> '9' for ( int i = n - 1 ; i > 0 ; -- i ) if ( s [ i ] < s [ i - 1 ]) { -- s [ i - 1 ]; k = i ; } for ( int i = k ; i < n ; ++ i ) s [ i ] = '9' ; return stoi ( s ); } };","title":"738. Monotone Increasing Digits"},{"location":"problems/0738/#738-monotone-increasing-digits","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int monotoneIncreasingDigits ( int N ) { string s = to_string ( N ); const int n = s . length (); int k = n ; // s[k:] -> '9' for ( int i = n - 1 ; i > 0 ; -- i ) if ( s [ i ] < s [ i - 1 ]) { -- s [ i - 1 ]; k = i ; } for ( int i = k ; i < n ; ++ i ) s [ i ] = '9' ; return stoi ( s ); } };","title":"738. Monotone Increasing Digits"},{"location":"problems/0739/","text":"739. Daily Temperatures Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { vector < int > ans ( T . size ()); stack < int > stack ; // decreasing stack for ( int i = 0 ; i < T . size (); ++ i ) { while ( ! stack . empty () && T [ stack . top ()] < T [ i ]) { const int index = stack . top (); ans [ index ] = i - index ; stack . pop (); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] dailyTemperatures ( int [] T ) { int [] ans = new int [ T . length ] ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < T . length ; ++ i ) { while ( ! stack . isEmpty () && T [ i ] > T [ stack . peek () ] ) { int index = stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def dailyTemperatures ( self , T : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( T ) stack = [] for i , t in enumerate ( T ): while stack != [] and t > T [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = i - index stack . append ( i ) return ans","title":"739. Daily Temperatures"},{"location":"problems/0739/#739-daily-temperatures","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { vector < int > ans ( T . size ()); stack < int > stack ; // decreasing stack for ( int i = 0 ; i < T . size (); ++ i ) { while ( ! stack . empty () && T [ stack . top ()] < T [ i ]) { const int index = stack . top (); ans [ index ] = i - index ; stack . pop (); } stack . push ( i ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] dailyTemperatures ( int [] T ) { int [] ans = new int [ T . length ] ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < T . length ; ++ i ) { while ( ! stack . isEmpty () && T [ i ] > T [ stack . peek () ] ) { int index = stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def dailyTemperatures ( self , T : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( T ) stack = [] for i , t in enumerate ( T ): while stack != [] and t > T [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = i - index stack . append ( i ) return ans","title":"739. Daily Temperatures"},{"location":"problems/0740/","text":"740. Delete and Earn Time: $O(n)$ Space: $O(10001)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int deleteAndEarn ( vector < int >& nums ) { // reduce to 198. House Robber vector < int > bucket ( 10001 ); for ( const int num : nums ) bucket [ num ] += num ; int prev1 = 0 ; int prev2 = 0 ; for ( const int num : bucket ) { const int dp = max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } };","title":"740. Delete and Earn"},{"location":"problems/0740/#740-delete-and-earn","text":"Time: $O(n)$ Space: $O(10001)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int deleteAndEarn ( vector < int >& nums ) { // reduce to 198. House Robber vector < int > bucket ( 10001 ); for ( const int num : nums ) bucket [ num ] += num ; int prev1 = 0 ; int prev2 = 0 ; for ( const int num : bucket ) { const int dp = max ( prev1 , prev2 + num ); prev2 = prev1 ; prev1 = dp ; } return prev1 ; } };","title":"740. Delete and Earn"},{"location":"problems/0741/","text":"741. Cherry Pickup Approach 1: Bottom-up Time: $O(n^3)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int n = grid . size (); // dp[x1][y1][x2] := max cherries we could pick from // g[0][0] -> g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1], // where y2 = x1 + y1 - x2 (reduce states from 4 to 3) vector < vector < vector < int >>> dp ( n + 1 , vector < vector < int >> ( n + 1 , vector < int > ( n + 1 , -1 ))); dp [ 1 ][ 1 ][ 1 ] = grid [ 0 ][ 0 ]; for ( int x1 = 1 ; x1 <= n ; ++ x1 ) for ( int y1 = 1 ; y1 <= n ; ++ y1 ) for ( int x2 = 1 ; x2 <= n ; ++ x2 ) { const int y2 = x1 + y1 - x2 ; if ( y2 < 1 || y2 > n ) continue ; if ( grid [ x1 - 1 ][ y1 - 1 ] == -1 || grid [ x2 - 1 ][ y2 - 1 ] == -1 ) continue ; const int ans = max ({ dp [ x1 - 1 ][ y1 ][ x2 ], dp [ x1 - 1 ][ y1 ][ x2 - 1 ], dp [ x1 ][ y1 - 1 ][ x2 ], dp [ x1 ][ y1 - 1 ][ x2 - 1 ]}); if ( ans < 0 ) continue ; dp [ x1 ][ y1 ][ x2 ] = ans + grid [ x1 - 1 ][ y1 - 1 ]; if ( x1 != x2 ) dp [ x1 ][ y1 ][ x2 ] += grid [ x2 - 1 ][ y2 - 1 ]; } return max ( 0 , dp [ n ][ n ][ n ]); } }; Approach 2: Top-down Time: $O(n^3)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { // the problem is identical as two people start picking cherries // from grid[0][0] simultaneously const int n = grid . size (); vector < vector < vector < int >>> memo ( n , vector < vector < int >> ( n , vector < int > ( n , INT_MIN ))); // dp(x1, y1, x2) := max cherries we could pick from // g[x1][y1] -> g[n - 1][n - 1] + g[x2][y2] -> g[n - 1][n - 1], // where y2 = x1 + y1 - x2 (reduce states from 4 to 3) function < int ( int , int , int ) > dp = [ & ]( int x1 , int y1 , int x2 ) { const int y2 = x1 + y1 - x2 ; if ( x1 == n || y1 == n || x2 == n || y2 == n ) return -1 ; if ( x1 == n - 1 && y1 == n - 1 ) return grid [ x1 ][ y1 ]; if ( grid [ x1 ][ y1 ] == -1 || grid [ x2 ][ y2 ] == -1 ) return -1 ; int & ans = memo [ x1 ][ y1 ][ x2 ]; if ( ans > INT_MIN ) return ans ; ans = max ({ dp ( x1 + 1 , y1 , x2 ), dp ( x1 + 1 , y1 , x2 + 1 ), dp ( x1 , y1 + 1 , x2 ), dp ( x1 , y1 + 1 , x2 + 1 )}); if ( ans == -1 ) return ans ; ans += grid [ x1 ][ y1 ]; // do pick some cherries if ( x1 != x2 ) ans += grid [ x2 ][ y2 ]; // two people are on different grids return ans ; }; return max ( 0 , dp ( 0 , 0 , 0 )); } };","title":"741. Cherry Pickup"},{"location":"problems/0741/#741-cherry-pickup","text":"","title":"741. Cherry Pickup"},{"location":"problems/0741/#approach-1-bottom-up","text":"Time: $O(n^3)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int n = grid . size (); // dp[x1][y1][x2] := max cherries we could pick from // g[0][0] -> g[x1 - 1][y1 - 1] + g[0][0] -> g[x2 - 1][y2 - 1], // where y2 = x1 + y1 - x2 (reduce states from 4 to 3) vector < vector < vector < int >>> dp ( n + 1 , vector < vector < int >> ( n + 1 , vector < int > ( n + 1 , -1 ))); dp [ 1 ][ 1 ][ 1 ] = grid [ 0 ][ 0 ]; for ( int x1 = 1 ; x1 <= n ; ++ x1 ) for ( int y1 = 1 ; y1 <= n ; ++ y1 ) for ( int x2 = 1 ; x2 <= n ; ++ x2 ) { const int y2 = x1 + y1 - x2 ; if ( y2 < 1 || y2 > n ) continue ; if ( grid [ x1 - 1 ][ y1 - 1 ] == -1 || grid [ x2 - 1 ][ y2 - 1 ] == -1 ) continue ; const int ans = max ({ dp [ x1 - 1 ][ y1 ][ x2 ], dp [ x1 - 1 ][ y1 ][ x2 - 1 ], dp [ x1 ][ y1 - 1 ][ x2 ], dp [ x1 ][ y1 - 1 ][ x2 - 1 ]}); if ( ans < 0 ) continue ; dp [ x1 ][ y1 ][ x2 ] = ans + grid [ x1 - 1 ][ y1 - 1 ]; if ( x1 != x2 ) dp [ x1 ][ y1 ][ x2 ] += grid [ x2 - 1 ][ y2 - 1 ]; } return max ( 0 , dp [ n ][ n ][ n ]); } };","title":"Approach 1: Bottom-up"},{"location":"problems/0741/#approach-2-top-down","text":"Time: $O(n^3)$ Space: $O(n^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { // the problem is identical as two people start picking cherries // from grid[0][0] simultaneously const int n = grid . size (); vector < vector < vector < int >>> memo ( n , vector < vector < int >> ( n , vector < int > ( n , INT_MIN ))); // dp(x1, y1, x2) := max cherries we could pick from // g[x1][y1] -> g[n - 1][n - 1] + g[x2][y2] -> g[n - 1][n - 1], // where y2 = x1 + y1 - x2 (reduce states from 4 to 3) function < int ( int , int , int ) > dp = [ & ]( int x1 , int y1 , int x2 ) { const int y2 = x1 + y1 - x2 ; if ( x1 == n || y1 == n || x2 == n || y2 == n ) return -1 ; if ( x1 == n - 1 && y1 == n - 1 ) return grid [ x1 ][ y1 ]; if ( grid [ x1 ][ y1 ] == -1 || grid [ x2 ][ y2 ] == -1 ) return -1 ; int & ans = memo [ x1 ][ y1 ][ x2 ]; if ( ans > INT_MIN ) return ans ; ans = max ({ dp ( x1 + 1 , y1 , x2 ), dp ( x1 + 1 , y1 , x2 + 1 ), dp ( x1 , y1 + 1 , x2 ), dp ( x1 , y1 + 1 , x2 + 1 )}); if ( ans == -1 ) return ans ; ans += grid [ x1 ][ y1 ]; // do pick some cherries if ( x1 != x2 ) ans += grid [ x2 ][ y2 ]; // two people are on different grids return ans ; }; return max ( 0 , dp ( 0 , 0 , 0 )); } };","title":"Approach 2: Top-down"},{"location":"problems/0742/","text":"742. Closest Leaf in a Binary Tree \ud83d\udd12","title":"742. Closest Leaf in a Binary Tree"},{"location":"problems/0742/#742-closest-leaf-in-a-binary-tree","text":"","title":"742. Closest Leaf in a Binary Tree \ud83d\udd12"},{"location":"problems/0743/","text":"743. Network Delay Time Time: $O(N\\log N)$ Space: $O(|E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int networkDelayTime ( vector < vector < int >>& times , int N , int K ) { int ans = 0 ; vector < vector < pair < int , int >>> graph ( N + 1 ); vector < int > seen ( N + 1 ); priority_queue < pair < int , int >> pq ; // {w, v}: min-heap sorted by w pq . push ({ -0 , K }); for ( const vector < int >& time : times ) graph [ time [ 0 ]]. push_back ({ time [ 1 ], time [ 2 ]}); while ( ! pq . empty ()) { const auto [ dist , u ] = pq . top (); pq . pop (); if ( seen [ u ]) continue ; seen [ u ] = true ; ans = - dist ; // the minDist to go to current node u if ( -- N == 0 ) return ans ; for ( const auto & [ v , w ] : graph [ u ]) pq . push ({ dist - w , v }); } return -1 ; } };","title":"743. Network Delay Time"},{"location":"problems/0743/#743-network-delay-time","text":"Time: $O(N\\log N)$ Space: $O(|E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int networkDelayTime ( vector < vector < int >>& times , int N , int K ) { int ans = 0 ; vector < vector < pair < int , int >>> graph ( N + 1 ); vector < int > seen ( N + 1 ); priority_queue < pair < int , int >> pq ; // {w, v}: min-heap sorted by w pq . push ({ -0 , K }); for ( const vector < int >& time : times ) graph [ time [ 0 ]]. push_back ({ time [ 1 ], time [ 2 ]}); while ( ! pq . empty ()) { const auto [ dist , u ] = pq . top (); pq . pop (); if ( seen [ u ]) continue ; seen [ u ] = true ; ans = - dist ; // the minDist to go to current node u if ( -- N == 0 ) return ans ; for ( const auto & [ v , w ] : graph [ u ]) pq . push ({ dist - w , v }); } return -1 ; } };","title":"743. Network Delay Time"},{"location":"problems/0744/","text":"744. Find Smallest Letter Greater Than Target Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target"},{"location":"problems/0744/#744-find-smallest-letter-greater-than-target","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target"},{"location":"problems/0745/","text":"745. Prefix and Suffix Search Approach 1: HashTable Time: $O(|words||word_i|^3) + O(|queries||word_i|)$ Space: $O(|words||word_i|^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WordFilter { public : WordFilter ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) { const string & word = words [ i ]; vector < string > prefixes ; vector < string > suffixes ; for ( int j = 0 ; j <= word . length (); ++ j ) { const string prefix = word . substr ( 0 , j ); const string suffix = word . substr ( j ); prefixes . push_back ( prefix ); suffixes . push_back ( suffix ); } for ( const string & prefix : prefixes ) for ( const string & suffix : suffixes ) keyToIndex [ prefix + '_' + suffix ] = i ; } } int f ( string prefix , string suffix ) { const string key = prefix + '_' + suffix ; if ( keyToIndex . count ( key )) return keyToIndex [ key ]; return -1 ; } private : unordered_map < string , int > keyToIndex ; }; Approach 2: Trie Time: $O(|words||word_i|^2) + O(|queries||word_i|)$ Space: $O(|words||word_i|^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 struct TrieNode { TrieNode () : children ( 27 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int weight = -1 ; }; class Trie { public : void insert ( const string & word , int weight ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; node -> weight = weight ; } } int startsWith ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) return -1 ; node = node -> children [ c - 'a' ]; } return node -> weight ; } private : TrieNode root ; }; class WordFilter { public : WordFilter ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j <= words [ i ]. length (); ++ j ) trie . insert ( words [ i ]. substr ( j ) + '{' + words [ i ], i ); } int f ( string prefix , string suffix ) { return trie . startsWith ( suffix + '{' + prefix ); } private : Trie trie ; };","title":"745. Prefix and Suffix Search"},{"location":"problems/0745/#745-prefix-and-suffix-search","text":"","title":"745. Prefix and Suffix Search"},{"location":"problems/0745/#approach-1-hashtable","text":"Time: $O(|words||word_i|^3) + O(|queries||word_i|)$ Space: $O(|words||word_i|^3)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WordFilter { public : WordFilter ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) { const string & word = words [ i ]; vector < string > prefixes ; vector < string > suffixes ; for ( int j = 0 ; j <= word . length (); ++ j ) { const string prefix = word . substr ( 0 , j ); const string suffix = word . substr ( j ); prefixes . push_back ( prefix ); suffixes . push_back ( suffix ); } for ( const string & prefix : prefixes ) for ( const string & suffix : suffixes ) keyToIndex [ prefix + '_' + suffix ] = i ; } } int f ( string prefix , string suffix ) { const string key = prefix + '_' + suffix ; if ( keyToIndex . count ( key )) return keyToIndex [ key ]; return -1 ; } private : unordered_map < string , int > keyToIndex ; };","title":"Approach 1: HashTable"},{"location":"problems/0745/#approach-2-trie","text":"Time: $O(|words||word_i|^2) + O(|queries||word_i|)$ Space: $O(|words||word_i|^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 struct TrieNode { TrieNode () : children ( 27 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int weight = -1 ; }; class Trie { public : void insert ( const string & word , int weight ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; node -> weight = weight ; } } int startsWith ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) return -1 ; node = node -> children [ c - 'a' ]; } return node -> weight ; } private : TrieNode root ; }; class WordFilter { public : WordFilter ( vector < string >& words ) { for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = 0 ; j <= words [ i ]. length (); ++ j ) trie . insert ( words [ i ]. substr ( j ) + '{' + words [ i ], i ); } int f ( string prefix , string suffix ) { return trie . startsWith ( suffix + '{' + prefix ); } private : Trie trie ; };","title":"Approach 2: Trie"},{"location":"problems/0746/","text":"746. Min Cost Climbing Stairs Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += Math . min ( cost [ i - 1 ] , cost [ i - 2 ] ); return Math . min ( cost [ n - 1 ] , cost [ n - 2 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : cost . append ( 0 ) for i in range ( 2 , len ( cost )): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return cost [ - 1 ]","title":"746. Min Cost Climbing Stairs"},{"location":"problems/0746/#746-min-cost-climbing-stairs","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += Math . min ( cost [ i - 1 ] , cost [ i - 2 ] ); return Math . min ( cost [ n - 1 ] , cost [ n - 2 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : cost . append ( 0 ) for i in range ( 2 , len ( cost )): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return cost [ - 1 ]","title":"746. Min Cost Climbing Stairs"},{"location":"problems/0747/","text":"747. Largest Number At Least Twice of Others Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) { secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ] ; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ] ; } return max >= 2 * secondMax ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1","title":"747. Largest Number At Least Twice of Others"},{"location":"problems/0747/#747-largest-number-at-least-twice-of-others","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) { secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ] ; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ] ; } return max >= 2 * secondMax ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1","title":"747. Largest Number At Least Twice of Others"},{"location":"problems/0748/","text":"748. Shortest Completing Word Time: $O(nl)$, where n = len(words) and l = len(word) Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ( 16 , '.' ); vector < int > count ( 26 ); for ( const char c : licensePlate ) if ( isalpha ( c )) ++ count [ tolower ( c ) - 'a' ]; // check if c1 is a subset of c2 auto isComplete = []( const vector < int >& c1 , const vector < int >& c2 ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( c1 [ i ] > c2 [ i ]) return false ; return true ; }; auto getCount = []( const string & word ) { vector < int > count ( 26 ); for ( const char c : word ) ++ count [ c - 'a' ]; return count ; }; for ( const string & word : words ) if ( word . length () < ans . length () && isComplete ( count , getCount ( word ))) ans = word ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String shortestCompletingWord ( String licensePlate , String [] words ) { String ans = \"****************\" ; int [] count = new int [ 26 ] ; for ( char c : licensePlate . toCharArray ()) if ( Character . isLetter ( c )) ++ count [ Character . toLowerCase ( c ) - 'a' ] ; for ( final String word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private boolean isMatch ( final String word , int [] count ) { int [] wordCount = new int [ 26 ] ; for ( char c : word . toCharArray ()) ++ wordCount [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordCount = collections . Counter ( word ) return False if any ( wordCount [ i ] < count [ i ] for i in string . ascii_letters ) else True ans = '*' * 16 count = collections . defaultdict ( int ) for c in licensePlate : if c . isalpha (): count [ c . lower ()] += 1 for word in words : if len ( word ) < len ( ans ) and isMatch ( word ): ans = word return ans","title":"748. Shortest Completing Word"},{"location":"problems/0748/#748-shortest-completing-word","text":"Time: $O(nl)$, where n = len(words) and l = len(word) Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ( 16 , '.' ); vector < int > count ( 26 ); for ( const char c : licensePlate ) if ( isalpha ( c )) ++ count [ tolower ( c ) - 'a' ]; // check if c1 is a subset of c2 auto isComplete = []( const vector < int >& c1 , const vector < int >& c2 ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( c1 [ i ] > c2 [ i ]) return false ; return true ; }; auto getCount = []( const string & word ) { vector < int > count ( 26 ); for ( const char c : word ) ++ count [ c - 'a' ]; return count ; }; for ( const string & word : words ) if ( word . length () < ans . length () && isComplete ( count , getCount ( word ))) ans = word ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public String shortestCompletingWord ( String licensePlate , String [] words ) { String ans = \"****************\" ; int [] count = new int [ 26 ] ; for ( char c : licensePlate . toCharArray ()) if ( Character . isLetter ( c )) ++ count [ Character . toLowerCase ( c ) - 'a' ] ; for ( final String word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private boolean isMatch ( final String word , int [] count ) { int [] wordCount = new int [ 26 ] ; for ( char c : word . toCharArray ()) ++ wordCount [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordCount = collections . Counter ( word ) return False if any ( wordCount [ i ] < count [ i ] for i in string . ascii_letters ) else True ans = '*' * 16 count = collections . defaultdict ( int ) for c in licensePlate : if c . isalpha (): count [ c . lower ()] += 1 for word in words : if len ( word ) < len ( ans ) and isMatch ( word ): ans = word return ans","title":"748. Shortest Completing Word"},{"location":"problems/0749/","text":"749. Contain Virus Time: Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct Region { // given m = # of rows and n = # of cols, (x, y) will be hashed as x * n + y unordered_set < int > infected ; unordered_set < int > noninfected ; // noninfected neighbors int wallsRequired = 0 ; }; class Solution { public : int containVirus ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < void ( int , int , Region & , vector < vector < bool >>& ) > dfs = [ & ]( int i , int j , Region & region , vector < vector < bool >>& seen ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( seen [ i ][ j ] || grid [ i ][ j ] == 2 ) return ; if ( grid [ i ][ j ] == 0 ) { region . noninfected . insert ( i * n + j ); ++ region . wallsRequired ; return ; } // grid[i][j] == 1 seen [ i ][ j ] = true ; region . infected . insert ( i * n + j ); dfs ( i + 1 , j , region , seen ); dfs ( i - 1 , j , region , seen ); dfs ( i , j + 1 , region , seen ); dfs ( i , j - 1 , region , seen ); }; while ( true ) { vector < Region > regions ; vector < vector < bool >> seen ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ! seen [ i ][ j ]) { Region region ; dfs ( i , j , region , seen ); // use DFS to find all regions (1s) if ( ! region . noninfected . empty ()) regions . push_back ( region ); } if ( regions . empty ()) break ; // no region causes further infection // region which infects most neighbors is in the back sort ( begin ( regions ), end ( regions ), []( const auto & a , const auto & b ) { return a . noninfected . size () < b . noninfected . size (); }); // build walls around the region which infects most neighbors Region region = regions . back (); regions . pop_back (); ans += region . wallsRequired ; for ( const int neighbor : region . infected ) { const int i = neighbor / n ; const int j = neighbor % n ; grid [ i ][ j ] = 2 ; // the grid is now contained and won't be infected anymore } // for remaining regions, expand (infect their neighbors) for ( const Region & region : regions ) for ( const int neighbor : region . noninfected ) { const int i = neighbor / n ; const int j = neighbor % n ; grid [ i ][ j ] = 1 ; } } return ans ; } };","title":"749. Contain Virus"},{"location":"problems/0749/#749-contain-virus","text":"Time: Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 struct Region { // given m = # of rows and n = # of cols, (x, y) will be hashed as x * n + y unordered_set < int > infected ; unordered_set < int > noninfected ; // noninfected neighbors int wallsRequired = 0 ; }; class Solution { public : int containVirus ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < void ( int , int , Region & , vector < vector < bool >>& ) > dfs = [ & ]( int i , int j , Region & region , vector < vector < bool >>& seen ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( seen [ i ][ j ] || grid [ i ][ j ] == 2 ) return ; if ( grid [ i ][ j ] == 0 ) { region . noninfected . insert ( i * n + j ); ++ region . wallsRequired ; return ; } // grid[i][j] == 1 seen [ i ][ j ] = true ; region . infected . insert ( i * n + j ); dfs ( i + 1 , j , region , seen ); dfs ( i - 1 , j , region , seen ); dfs ( i , j + 1 , region , seen ); dfs ( i , j - 1 , region , seen ); }; while ( true ) { vector < Region > regions ; vector < vector < bool >> seen ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ! seen [ i ][ j ]) { Region region ; dfs ( i , j , region , seen ); // use DFS to find all regions (1s) if ( ! region . noninfected . empty ()) regions . push_back ( region ); } if ( regions . empty ()) break ; // no region causes further infection // region which infects most neighbors is in the back sort ( begin ( regions ), end ( regions ), []( const auto & a , const auto & b ) { return a . noninfected . size () < b . noninfected . size (); }); // build walls around the region which infects most neighbors Region region = regions . back (); regions . pop_back (); ans += region . wallsRequired ; for ( const int neighbor : region . infected ) { const int i = neighbor / n ; const int j = neighbor % n ; grid [ i ][ j ] = 2 ; // the grid is now contained and won't be infected anymore } // for remaining regions, expand (infect their neighbors) for ( const Region & region : regions ) for ( const int neighbor : region . noninfected ) { const int i = neighbor / n ; const int j = neighbor % n ; grid [ i ][ j ] = 1 ; } } return ans ; } };","title":"749. Contain Virus"},{"location":"problems/0750/","text":"750. Number Of Corner Rectangles \ud83d\udd12","title":"750. Number Of Corner Rectangles"},{"location":"problems/0750/#750-number-of-corner-rectangles","text":"","title":"750. Number Of Corner Rectangles \ud83d\udd12"},{"location":"problems/0751/","text":"751. IP to CIDR \ud83d\udd12","title":"751. IP to CIDR"},{"location":"problems/0751/#751-ip-to-cidr","text":"","title":"751. IP to CIDR \ud83d\udd12"},{"location":"problems/0752/","text":"752. Open the Lock Time: $O(10^4)$ Space: $O(10^4)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int openLock ( vector < string >& deadends , string target ) { unordered_set < string > seen { begin ( deadends ), end ( deadends )}; if ( seen . count ( \"0000\" )) return -1 ; if ( target == \"0000\" ) return 0 ; int ans = 0 ; queue < string > q {{ \"0000\" }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { string word = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { const char cache = word [ i ]; // increase i-th digit by 1 word [ i ] = word [ i ] == '9' ? '0' : word [ i ] + 1 ; if ( word == target ) return ans ; if ( ! seen . count ( word )) { q . push ( word ); seen . insert ( word ); } word [ i ] = cache ; // decrease i-th digit by 1 word [ i ] = word [ i ] == '0' ? '9' : word [ i ] - 1 ; if ( word == target ) return ans ; if ( ! seen . count ( word )) { q . push ( word ); seen . insert ( word ); } word [ i ] = cache ; } } } return -1 ; } };","title":"752. Open the Lock"},{"location":"problems/0752/#752-open-the-lock","text":"Time: $O(10^4)$ Space: $O(10^4)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int openLock ( vector < string >& deadends , string target ) { unordered_set < string > seen { begin ( deadends ), end ( deadends )}; if ( seen . count ( \"0000\" )) return -1 ; if ( target == \"0000\" ) return 0 ; int ans = 0 ; queue < string > q {{ \"0000\" }}; while ( ! q . empty ()) { ++ ans ; for ( int i = q . size (); i > 0 ; -- i ) { string word = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { const char cache = word [ i ]; // increase i-th digit by 1 word [ i ] = word [ i ] == '9' ? '0' : word [ i ] + 1 ; if ( word == target ) return ans ; if ( ! seen . count ( word )) { q . push ( word ); seen . insert ( word ); } word [ i ] = cache ; // decrease i-th digit by 1 word [ i ] = word [ i ] == '0' ? '9' : word [ i ] - 1 ; if ( word == target ) return ans ; if ( ! seen . count ( word )) { q . push ( word ); seen . insert ( word ); } word [ i ] = cache ; } } } return -1 ; } };","title":"752. Open the Lock"},{"location":"problems/0753/","text":"753. Cracking the Safe Time: $O(k^{k^n}) \\to O(k^n)$ Space: $O(k^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : string crackSafe ( int n , int k ) { string ans ( n , '0' ); const int passwordSize = pow ( k , n ); unordered_set < string > seen { ans }; function < bool () > dfs = [ & ]() { if ( seen . size () == passwordSize ) return true ; string prefix = ans . substr ( ans . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { prefix . push_back ( c ); if ( ! seen . count ( prefix )) { seen . insert ( prefix ); ans . push_back ( c ); if ( dfs ()) return true ; ans . pop_back (); seen . erase ( prefix ); } prefix . pop_back (); } return false ; }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public String crackSafe ( int n , int k ) { passwordSize = ( int ) Math . pow ( k , n ); String path = new String ( new char [ n ] ). replace ( '\\0' , '0' ); Set < String > seen = new HashSet <> ( Arrays . asList ( path )); dfs ( n , k , seen , path ); return ans ; } private String ans ; private Integer passwordSize ; private boolean dfs ( int n , int k , Set < String > seen , String path ) { if ( seen . size () == passwordSize ) { ans = path ; return true ; } String prefix = path . substring ( path . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { String next = prefix + c ; if ( ! seen . contains ( next )) { seen . add ( next ); if ( dfs ( n , k , seen , path + c )) return true ; seen . remove ( next ); } } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def crackSafe ( self , n : int , k : int ) -> str : def dfs ( path : str ) -> str : if len ( seen ) == passwordSize : return path for c in map ( str , range ( k )): node = path [ - n + 1 :] + c if n > 1 else c if node not in seen : seen . add ( node ) res = dfs ( path + c ) if res : return res seen . remove ( node ) passwordSize = k ** n path = '0' * n seen = set () seen . add ( path ) return dfs ( path )","title":"753. Cracking the Safe"},{"location":"problems/0753/#753-cracking-the-safe","text":"Time: $O(k^{k^n}) \\to O(k^n)$ Space: $O(k^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : string crackSafe ( int n , int k ) { string ans ( n , '0' ); const int passwordSize = pow ( k , n ); unordered_set < string > seen { ans }; function < bool () > dfs = [ & ]() { if ( seen . size () == passwordSize ) return true ; string prefix = ans . substr ( ans . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { prefix . push_back ( c ); if ( ! seen . count ( prefix )) { seen . insert ( prefix ); ans . push_back ( c ); if ( dfs ()) return true ; ans . pop_back (); seen . erase ( prefix ); } prefix . pop_back (); } return false ; }; dfs (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public String crackSafe ( int n , int k ) { passwordSize = ( int ) Math . pow ( k , n ); String path = new String ( new char [ n ] ). replace ( '\\0' , '0' ); Set < String > seen = new HashSet <> ( Arrays . asList ( path )); dfs ( n , k , seen , path ); return ans ; } private String ans ; private Integer passwordSize ; private boolean dfs ( int n , int k , Set < String > seen , String path ) { if ( seen . size () == passwordSize ) { ans = path ; return true ; } String prefix = path . substring ( path . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { String next = prefix + c ; if ( ! seen . contains ( next )) { seen . add ( next ); if ( dfs ( n , k , seen , path + c )) return true ; seen . remove ( next ); } } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def crackSafe ( self , n : int , k : int ) -> str : def dfs ( path : str ) -> str : if len ( seen ) == passwordSize : return path for c in map ( str , range ( k )): node = path [ - n + 1 :] + c if n > 1 else c if node not in seen : seen . add ( node ) res = dfs ( path + c ) if res : return res seen . remove ( node ) passwordSize = k ** n path = '0' * n seen = set () seen . add ( path ) return dfs ( path )","title":"753. Cracking the Safe"},{"location":"problems/0754/","text":"754. Reach a Number Time: $O(\\sqrt{target})$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int reachNumber ( int target ) { const int newTarget = abs ( target ); int ans = 0 ; int pos = 0 ; while ( pos < newTarget ) pos += ++ ans ; while (( pos - newTarget ) & 1 ) pos += ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = Math . abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) % 2 == 1 ) pos += ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def reachNumber ( self , target : int ) -> int : ans = 0 pos = 0 target = abs ( target ) while pos < target : ans += 1 pos += ans while ( pos - target ) & 1 : ans += 1 pos += ans return ans","title":"754. Reach a Number"},{"location":"problems/0754/#754-reach-a-number","text":"Time: $O(\\sqrt{target})$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int reachNumber ( int target ) { const int newTarget = abs ( target ); int ans = 0 ; int pos = 0 ; while ( pos < newTarget ) pos += ++ ans ; while (( pos - newTarget ) & 1 ) pos += ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = Math . abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) % 2 == 1 ) pos += ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def reachNumber ( self , target : int ) -> int : ans = 0 pos = 0 target = abs ( target ) while pos < target : ans += 1 pos += ans while ( pos - target ) & 1 : ans += 1 pos += ans return ans","title":"754. Reach a Number"},{"location":"problems/0755/","text":"755. Pour Water \ud83d\udd12 Time: $O(VK)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > pourWater ( vector < int >& heights , int V , int K ) { const int n = heights . size (); int i = K ; while ( V -- ) { while ( i > 0 && heights [ i ] >= heights [ i - 1 ]) -- i ; while ( i + 1 < n && heights [ i ] >= heights [ i + 1 ]) ++ i ; while ( i > K && heights [ i ] == heights [ i - 1 ]) -- i ; ++ heights [ i ]; } return heights ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] pourWater ( int [] heights , int V , int K ) { final int n = heights . length ; int i = K ; while ( V -- > 0 ) { while ( i > 0 && heights [ i ] >= heights [ i - 1 ] ) -- i ; while ( i + 1 < n && heights [ i ] >= heights [ i + 1 ] ) ++ i ; while ( i > K && heights [ i ] == heights [ i - 1 ] ) -- i ; ++ heights [ i ] ; } return heights ; } }","title":"755. Pour Water"},{"location":"problems/0755/#755-pour-water","text":"Time: $O(VK)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > pourWater ( vector < int >& heights , int V , int K ) { const int n = heights . size (); int i = K ; while ( V -- ) { while ( i > 0 && heights [ i ] >= heights [ i - 1 ]) -- i ; while ( i + 1 < n && heights [ i ] >= heights [ i + 1 ]) ++ i ; while ( i > K && heights [ i ] == heights [ i - 1 ]) -- i ; ++ heights [ i ]; } return heights ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] pourWater ( int [] heights , int V , int K ) { final int n = heights . length ; int i = K ; while ( V -- > 0 ) { while ( i > 0 && heights [ i ] >= heights [ i - 1 ] ) -- i ; while ( i + 1 < n && heights [ i ] >= heights [ i + 1 ] ) ++ i ; while ( i > K && heights [ i ] == heights [ i - 1 ] ) -- i ; ++ heights [ i ] ; } return heights ; } }","title":"755. Pour Water \ud83d\udd12"},{"location":"problems/0756/","text":"756. Pyramid Transition Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool pyramidTransition ( string bottom , vector < string >& allowed ) { unordered_map < string , vector < char >> prefixToBlocks ; for ( const string & a : allowed ) prefixToBlocks [ a . substr ( 0 , 2 )]. push_back ( a [ 2 ]); function < bool ( const string & , const string & , int ) > dfs = [ & ]( const string & row , const string & nextRow , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , 0 ); for ( const char c : prefixToBlocks [ row . substr ( i , 2 )]) if ( dfs ( row , nextRow + c , i + 1 )) return true ; return false ; }; return dfs ( bottom , \"\" , 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean pyramidTransition ( String bottom , List < String > allowed ) { Map < String , List < Character >> prefixToBlocks = new HashMap <> (); for ( final String a : allowed ) prefixToBlocks . computeIfAbsent ( a . substring ( 0 , 2 ), k -> new LinkedList <> ()). add ( a . charAt ( 2 )); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private boolean dfs ( final String row , final String nextRow , Map < String , List < Character >> prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks . getOrDefault ( row . substring ( i , i + 2 ), new LinkedList <> ())) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def pyramidTransition ( self , bottom : str , allowed : List [ str ]) -> bool : def dfs ( row : str , nextRow : str , i : int ) -> bool : if len ( row ) == 1 : return True if len ( nextRow ) + 1 == len ( row ): return dfs ( nextRow , '' , 0 ) for c in prefixToBlocks [ row [ i : i + 2 ]]: if dfs ( row , nextRow + c , i + 1 ): return True return False prefixToBlocks = collections . defaultdict ( list ) for a in allowed : prefixToBlocks [ a [: 2 ]] . append ( a [ 2 ]) return dfs ( bottom , '' , 0 )","title":"756. Pyramid Transition Matrix"},{"location":"problems/0756/#756-pyramid-transition-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool pyramidTransition ( string bottom , vector < string >& allowed ) { unordered_map < string , vector < char >> prefixToBlocks ; for ( const string & a : allowed ) prefixToBlocks [ a . substr ( 0 , 2 )]. push_back ( a [ 2 ]); function < bool ( const string & , const string & , int ) > dfs = [ & ]( const string & row , const string & nextRow , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , 0 ); for ( const char c : prefixToBlocks [ row . substr ( i , 2 )]) if ( dfs ( row , nextRow + c , i + 1 )) return true ; return false ; }; return dfs ( bottom , \"\" , 0 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean pyramidTransition ( String bottom , List < String > allowed ) { Map < String , List < Character >> prefixToBlocks = new HashMap <> (); for ( final String a : allowed ) prefixToBlocks . computeIfAbsent ( a . substring ( 0 , 2 ), k -> new LinkedList <> ()). add ( a . charAt ( 2 )); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private boolean dfs ( final String row , final String nextRow , Map < String , List < Character >> prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks . getOrDefault ( row . substring ( i , i + 2 ), new LinkedList <> ())) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def pyramidTransition ( self , bottom : str , allowed : List [ str ]) -> bool : def dfs ( row : str , nextRow : str , i : int ) -> bool : if len ( row ) == 1 : return True if len ( nextRow ) + 1 == len ( row ): return dfs ( nextRow , '' , 0 ) for c in prefixToBlocks [ row [ i : i + 2 ]]: if dfs ( row , nextRow + c , i + 1 ): return True return False prefixToBlocks = collections . defaultdict ( list ) for a in allowed : prefixToBlocks [ a [: 2 ]] . append ( a [ 2 ]) return dfs ( bottom , '' , 0 )","title":"756. Pyramid Transition Matrix"},{"location":"problems/0757/","text":"757. Set Intersection Size At Least Two Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int intersectionSizeTwo ( vector < vector < int >>& intervals ) { int ans = 0 ; int max = -1 ; int secondMax = -1 ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& interval : intervals ) { const int a = interval [ 0 ]; const int b = interval [ 1 ]; // max and 2nd max still satisfy if ( max >= a && secondMax >= a ) continue ; if ( max >= a ) { // max still satisfy secondMax = max ; max = b ; // add b to the set S ans += 1 ; } else { // max and 2nd max can't satisfy max = b ; // add b to the set S secondMax = b - 1 ; // add b - 1 to the set S ans += 2 ; } } return ans ; } };","title":"757. Set Intersection Size At Least Two"},{"location":"problems/0757/#757-set-intersection-size-at-least-two","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int intersectionSizeTwo ( vector < vector < int >>& intervals ) { int ans = 0 ; int max = -1 ; int secondMax = -1 ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] < b [ 1 ]; }); for ( const vector < int >& interval : intervals ) { const int a = interval [ 0 ]; const int b = interval [ 1 ]; // max and 2nd max still satisfy if ( max >= a && secondMax >= a ) continue ; if ( max >= a ) { // max still satisfy secondMax = max ; max = b ; // add b to the set S ans += 1 ; } else { // max and 2nd max can't satisfy max = b ; // add b to the set S secondMax = b - 1 ; // add b - 1 to the set S ans += 2 ; } } return ans ; } };","title":"757. Set Intersection Size At Least Two"},{"location":"problems/0758/","text":"758. Bold Words in String \ud83d\udd12","title":"758. Bold Words in String"},{"location":"problems/0758/#758-bold-words-in-string","text":"","title":"758. Bold Words in String \ud83d\udd12"},{"location":"problems/0759/","text":"759. Employee Free Time \ud83d\udd12 Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < Interval > employeeFreeTime ( vector < vector < Interval >> schedule ) { if ( schedule . size () <= 1 ) return {}; vector < Interval > ans ; vector < Interval > intervals ; for ( const vector < Interval >& workingTimes : schedule ) for ( const Interval & interval : workingTimes ) intervals . push_back ( interval ); sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a . start < b . start ; }); int currentEnd = intervals [ 0 ]. end ; for ( const Interval & interval : intervals ) if ( interval . start > currentEnd ) { ans . push_back ({ currentEnd , interval . start }); currentEnd = interval . end ; } else { currentEnd = max ( currentEnd , interval . end ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < Interval > employeeFreeTime ( List < List < Interval >> schedule ) { if ( schedule . size () <= 1 ) return new ArrayList <> (); List < Interval > ans = new ArrayList <> (); List < Interval > intervals = new ArrayList <> (); schedule . forEach ( s -> intervals . addAll ( s )); Collections . sort ( intervals , ( a , b ) -> a . start - b . start ); int currentEnd = intervals . get ( 0 ). end ; for ( final Interval interval : intervals ) if ( interval . start > currentEnd ) { ans . add ( new Interval ( currentEnd , interval . start )); currentEnd = interval . end ; } else { currentEnd = Math . max ( currentEnd , interval . end ); } return ans ; } }","title":"759. Employee Free Time"},{"location":"problems/0759/#759-employee-free-time","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < Interval > employeeFreeTime ( vector < vector < Interval >> schedule ) { if ( schedule . size () <= 1 ) return {}; vector < Interval > ans ; vector < Interval > intervals ; for ( const vector < Interval >& workingTimes : schedule ) for ( const Interval & interval : workingTimes ) intervals . push_back ( interval ); sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a . start < b . start ; }); int currentEnd = intervals [ 0 ]. end ; for ( const Interval & interval : intervals ) if ( interval . start > currentEnd ) { ans . push_back ({ currentEnd , interval . start }); currentEnd = interval . end ; } else { currentEnd = max ( currentEnd , interval . end ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < Interval > employeeFreeTime ( List < List < Interval >> schedule ) { if ( schedule . size () <= 1 ) return new ArrayList <> (); List < Interval > ans = new ArrayList <> (); List < Interval > intervals = new ArrayList <> (); schedule . forEach ( s -> intervals . addAll ( s )); Collections . sort ( intervals , ( a , b ) -> a . start - b . start ); int currentEnd = intervals . get ( 0 ). end ; for ( final Interval interval : intervals ) if ( interval . start > currentEnd ) { ans . add ( new Interval ( currentEnd , interval . start )); currentEnd = interval . end ; } else { currentEnd = Math . max ( currentEnd , interval . end ); } return ans ; } }","title":"759. Employee Free Time \ud83d\udd12"},{"location":"problems/0760/","text":"760. Find Anagram Mappings \ud83d\udd12","title":"760. Find Anagram Mappings"},{"location":"problems/0760/#760-find-anagram-mappings","text":"","title":"760. Find Anagram Mappings \ud83d\udd12"},{"location":"problems/0761/","text":"761. Special Binary String Time: $O(n\\log n) \\to O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : string makeLargestSpecial ( string S ) { vector < string > specials ; int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S [ j ] == '1' ? 1 : -1 ; if ( count == 0 ) { // find a special string const string & inner = S . substr ( i + 1 , j - i - 1 ); specials . push_back ( '1' + makeLargestSpecial ( inner ) + '0' ); i = j + 1 ; } } sort ( begin ( specials ), end ( specials ), greater <> ()); string merged ; for ( const string & special : specials ) merged += special ; return merged ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String makeLargestSpecial ( String S ) { List < String > specials = new ArrayList <> (); int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S . charAt ( j ) == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . add ( \"1\" + makeLargestSpecial ( S . substring ( i + 1 , j )) + \"0\" ); i = j + 1 ; } } Collections . sort ( specials , Collections . reverseOrder ()); return String . join ( \"\" , specials ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def makeLargestSpecial ( self , S : str ) -> str : specials = [] count = 0 i = 0 for j , c in enumerate ( S ): count += 1 if c == '1' else - 1 if count == 0 : specials . append ( '1' + self . makeLargestSpecial ( S [ i + 1 : j ]) + '0' ) i = j + 1 return '' . join ( sorted ( specials )[:: - 1 ])","title":"761. Special Binary String"},{"location":"problems/0761/#761-special-binary-string","text":"Time: $O(n\\log n) \\to O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : string makeLargestSpecial ( string S ) { vector < string > specials ; int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S [ j ] == '1' ? 1 : -1 ; if ( count == 0 ) { // find a special string const string & inner = S . substr ( i + 1 , j - i - 1 ); specials . push_back ( '1' + makeLargestSpecial ( inner ) + '0' ); i = j + 1 ; } } sort ( begin ( specials ), end ( specials ), greater <> ()); string merged ; for ( const string & special : specials ) merged += special ; return merged ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String makeLargestSpecial ( String S ) { List < String > specials = new ArrayList <> (); int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S . charAt ( j ) == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . add ( \"1\" + makeLargestSpecial ( S . substring ( i + 1 , j )) + \"0\" ); i = j + 1 ; } } Collections . sort ( specials , Collections . reverseOrder ()); return String . join ( \"\" , specials ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def makeLargestSpecial ( self , S : str ) -> str : specials = [] count = 0 i = 0 for j , c in enumerate ( S ): count += 1 if c == '1' else - 1 if count == 0 : specials . append ( '1' + self . makeLargestSpecial ( S [ i + 1 : j ]) + '0' ) i = j + 1 return '' . join ( sorted ( specials )[:: - 1 ])","title":"761. Special Binary String"},{"location":"problems/0762/","text":"762. Prime Number of Set Bits in Binary Representation Time: $O(R - L + 1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int countPrimeSetBits ( int L , int R ) { // { 2, 3, 5, 7, 11, 13, 17, 19 }th bits are 1s // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation"},{"location":"problems/0762/#762-prime-number-of-set-bits-in-binary-representation","text":"Time: $O(R - L + 1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int countPrimeSetBits ( int L , int R ) { // { 2, 3, 5, 7, 11, 13, 17, 19 }th bits are 1s // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation"},{"location":"problems/0763/","text":"763. Partition Labels Time: $O(n)$ Space: $O(26) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > rightmost ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) rightmost [ S [ i ] - 'a' ] = i ; int l = 0 ; // first index of current running string int r = 0 ; // right most so far for ( int i = 0 ; i < S . length (); ++ i ) { r = max ( r , rightmost [ S [ i ] - 'a' ]); if ( r == i ) { ans . push_back ( i - l + 1 ); l = i + 1 ; } } return ans ; } };","title":"763. Partition Labels"},{"location":"problems/0763/#763-partition-labels","text":"Time: $O(n)$ Space: $O(26) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > rightmost ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) rightmost [ S [ i ] - 'a' ] = i ; int l = 0 ; // first index of current running string int r = 0 ; // right most so far for ( int i = 0 ; i < S . length (); ++ i ) { r = max ( r , rightmost [ S [ i ] - 'a' ]); if ( r == i ) { ans . push_back ( i - l + 1 ); l = i + 1 ; } } return ans ; } };","title":"763. Partition Labels"},{"location":"problems/0764/","text":"764. Largest Plus Sign Time: $O(N^2)$ Space: $O(N^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int orderOfLargestPlusSign ( int N , vector < vector < int >>& mines ) { vector < vector < int >> grid ( N , vector < int > ( N , N )); for ( const vector < int >& mine : mines ) grid [ mine [ 0 ]][ mine [ 1 ]] = 0 ; // extend four directions, if meet 0, need to start over from 0 for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 , leftToRight = 0 ; j < N ; ++ j ) { leftToRight = ( grid [ i ][ j ] == 0 ? 0 : leftToRight + 1 ); grid [ i ][ j ] = min ( grid [ i ][ j ], leftToRight ); } for ( int j = N - 1 , rightToLeft = 0 ; j >= 0 ; -- j ) { rightToLeft = ( grid [ i ][ j ] == 0 ? 0 : rightToLeft + 1 ); grid [ i ][ j ] = min ( grid [ i ][ j ], rightToLeft ); } for ( int j = 0 , upToDown = 0 ; j < N ; ++ j ) { upToDown = ( grid [ j ][ i ] == 0 ? 0 : upToDown + 1 ); grid [ j ][ i ] = min ( grid [ j ][ i ], upToDown ); } for ( int j = N - 1 , downToUp = 0 ; j >= 0 ; -- j ) { downToUp = ( grid [ j ][ i ] == 0 ) ? 0 : downToUp + 1 ; grid [ j ][ i ] = min ( grid [ j ][ i ], downToUp ); } } int ans = 0 ; for ( const vector < int >& row : grid ) ans = max ( ans , * max_element ( begin ( row ), end ( row ))); return ans ; } };","title":"764. Largest Plus Sign"},{"location":"problems/0764/#764-largest-plus-sign","text":"Time: $O(N^2)$ Space: $O(N^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int orderOfLargestPlusSign ( int N , vector < vector < int >>& mines ) { vector < vector < int >> grid ( N , vector < int > ( N , N )); for ( const vector < int >& mine : mines ) grid [ mine [ 0 ]][ mine [ 1 ]] = 0 ; // extend four directions, if meet 0, need to start over from 0 for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 , leftToRight = 0 ; j < N ; ++ j ) { leftToRight = ( grid [ i ][ j ] == 0 ? 0 : leftToRight + 1 ); grid [ i ][ j ] = min ( grid [ i ][ j ], leftToRight ); } for ( int j = N - 1 , rightToLeft = 0 ; j >= 0 ; -- j ) { rightToLeft = ( grid [ i ][ j ] == 0 ? 0 : rightToLeft + 1 ); grid [ i ][ j ] = min ( grid [ i ][ j ], rightToLeft ); } for ( int j = 0 , upToDown = 0 ; j < N ; ++ j ) { upToDown = ( grid [ j ][ i ] == 0 ? 0 : upToDown + 1 ); grid [ j ][ i ] = min ( grid [ j ][ i ], upToDown ); } for ( int j = N - 1 , downToUp = 0 ; j >= 0 ; -- j ) { downToUp = ( grid [ j ][ i ] == 0 ) ? 0 : downToUp + 1 ; grid [ j ][ i ] = min ( grid [ j ][ i ], downToUp ); } } int ans = 0 ; for ( const vector < int >& row : grid ) ans = max ( ans , * max_element ( begin ( row ), end ( row ))); return ans ; } };","title":"764. Largest Plus Sign"},{"location":"problems/0765/","text":"765. Couples Holding Hands Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class UF { public : int groupsCount ; UF ( int n ) : rank ( n ), parent ( n ), groupsCount ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- groupsCount ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } private : int find ( int u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : int minSwapsCouples ( vector < int >& row ) { const int n = row . size () / 2 ; UF uf ( n ); for ( int i = 0 ; i < n ; ++ i ) { const int a = row [ 2 * i ]; const int b = row [ 2 * i + 1 ]; uf . union_ ( a / 2 , b / 2 ); } return n - uf . groupsCount ; } };","title":"765. Couples Holding Hands"},{"location":"problems/0765/#765-couples-holding-hands","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class UF { public : int groupsCount ; UF ( int n ) : rank ( n ), parent ( n ), groupsCount ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- groupsCount ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pu ] > rank [ pv ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } private : int find ( int u ) { if ( parent [ u ] != u ) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } vector < int > rank ; vector < int > parent ; }; class Solution { public : int minSwapsCouples ( vector < int >& row ) { const int n = row . size () / 2 ; UF uf ( n ); for ( int i = 0 ; i < n ; ++ i ) { const int a = row [ 2 * i ]; const int b = row [ 2 * i + 1 ]; uf . union_ ( a / 2 , b / 2 ); } return n - uf . groupsCount ; } };","title":"765. Couples Holding Hands"},{"location":"problems/0766/","text":"766. Toeplitz Matrix Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length - 1 ; ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 class Solution : def isToeplitzMatrix ( self , matrix : List [ List [ int ]]) -> bool : for i in range ( len ( matrix ) - 1 ): for j in range ( len ( matrix [ 0 ]) - 1 ): if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]: return False return True","title":"766. Toeplitz Matrix"},{"location":"problems/0766/#766-toeplitz-matrix","text":"Time: $O(mn)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length - 1 ; ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 class Solution : def isToeplitzMatrix ( self , matrix : List [ List [ int ]]) -> bool : for i in range ( len ( matrix ) - 1 ): for j in range ( len ( matrix [ 0 ]) - 1 ): if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]: return False return True","title":"766. Toeplitz Matrix"},{"location":"problems/0767/","text":"767. Reorganize String Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string reorganizeString ( string S ) { const int n = S . length (); vector < int > count ( 128 ); for ( const char c : S ) ++ count [ c ]; const int maxCount = * max_element ( begin ( count ), end ( count )); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; const char maxCountChar = getMaxCountChar ( count , maxCount ); string ans ( n , ' ' ); int i = 0 ; // point to ans auto fillIn = [ & ]( char c ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) // out-of-bound, reset the index to 1 i = 1 ; }; // fill in 0, 2, 4, ... indices with the maxCount char while ( count [ maxCountChar ] -- > 0 ) fillIn ( maxCountChar ); // fill in remaining characters for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ] -- > 0 ) fillIn ( c ); return ans ; } private : char getMaxCountChar ( const vector < int >& count , int maxCount ) { for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c ] == maxCount ) return c ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public String reorganizeString ( String S ) { final int n = S . length (); int [] count = new int [ 26 ] ; for ( char c : S . toCharArray ()) ++ count [ c - 'a' ] ; int maxCount = Arrays . stream ( count ). max (). getAsInt (); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; char [] ans = new char [ n ] ; if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ? 1 : 0 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return new String ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reorganizeString ( self , S : str ) -> str : n = len ( S ) count = collections . Counter ( S ) maxCount = max ( count . values ()) if maxCount > ( n + 1 ) // 2 : return '' if maxCount == ( n + 1 ) // 2 : maxLetter = max ( count , key = count . get ) ans = [ maxLetter if i % 2 == 0 else '' for i in range ( n )] del count [ maxLetter ] i = 1 else : ans = [ '' ] * n i = 0 for c , freq in count . items (): for _ in range ( freq ): ans [ i ] = c i += 2 if i >= n : i = 1 return '' . join ( ans )","title":"767. Reorganize String"},{"location":"problems/0767/#767-reorganize-string","text":"Time: $O(n)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string reorganizeString ( string S ) { const int n = S . length (); vector < int > count ( 128 ); for ( const char c : S ) ++ count [ c ]; const int maxCount = * max_element ( begin ( count ), end ( count )); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; const char maxCountChar = getMaxCountChar ( count , maxCount ); string ans ( n , ' ' ); int i = 0 ; // point to ans auto fillIn = [ & ]( char c ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) // out-of-bound, reset the index to 1 i = 1 ; }; // fill in 0, 2, 4, ... indices with the maxCount char while ( count [ maxCountChar ] -- > 0 ) fillIn ( maxCountChar ); // fill in remaining characters for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ] -- > 0 ) fillIn ( c ); return ans ; } private : char getMaxCountChar ( const vector < int >& count , int maxCount ) { for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c ] == maxCount ) return c ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public String reorganizeString ( String S ) { final int n = S . length (); int [] count = new int [ 26 ] ; for ( char c : S . toCharArray ()) ++ count [ c - 'a' ] ; int maxCount = Arrays . stream ( count ). max (). getAsInt (); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; char [] ans = new char [ n ] ; if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ? 1 : 0 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return new String ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reorganizeString ( self , S : str ) -> str : n = len ( S ) count = collections . Counter ( S ) maxCount = max ( count . values ()) if maxCount > ( n + 1 ) // 2 : return '' if maxCount == ( n + 1 ) // 2 : maxLetter = max ( count , key = count . get ) ans = [ maxLetter if i % 2 == 0 else '' for i in range ( n )] del count [ maxLetter ] i = 1 else : ans = [ '' ] * n i = 0 for c , freq in count . items (): for _ in range ( freq ): ans [ i ] = c i += 2 if i >= n : i = 1 return '' . join ( ans )","title":"767. Reorganize String"},{"location":"problems/0768/","text":"768. Max Chunks To Make Sorted II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int mini = INT_MAX ; int maxi = INT_MIN ; vector < int > minFromBack ( n ); vector < int > maxFromFront ( n ); for ( int i = n - 1 ; i >= 0 ; -- i ) minFromBack [ i ] = mini = min ( mini , arr [ i ]); for ( int i = 0 ; i < n ; ++ i ) maxFromFront [ i ] = maxi = max ( maxi , arr [ i ]); for ( int i = 0 ; i + 1 < n ; ++ i ) if ( maxFromFront [ i ] <= minFromBack [ i + 1 ]) ++ ans ; return ans + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ] ; min [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , arr [ i ] ); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max <= min [ i + 1 ] ) ++ ans ; } return ans + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 maxi = float ( '-inf' ) mini = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): maxi = max ( maxi , arr [ i ]) if maxi <= mini [ i + 1 ]: ans += 1 return ans + 1","title":"768. Max Chunks To Make Sorted II"},{"location":"problems/0768/#768-max-chunks-to-make-sorted-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int mini = INT_MAX ; int maxi = INT_MIN ; vector < int > minFromBack ( n ); vector < int > maxFromFront ( n ); for ( int i = n - 1 ; i >= 0 ; -- i ) minFromBack [ i ] = mini = min ( mini , arr [ i ]); for ( int i = 0 ; i < n ; ++ i ) maxFromFront [ i ] = maxi = max ( maxi , arr [ i ]); for ( int i = 0 ; i + 1 < n ; ++ i ) if ( maxFromFront [ i ] <= minFromBack [ i + 1 ]) ++ ans ; return ans + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ] ; min [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , arr [ i ] ); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max <= min [ i + 1 ] ) ++ ans ; } return ans + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 maxi = float ( '-inf' ) mini = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): maxi = max ( maxi , arr [ i ]) if maxi <= mini [ i + 1 ]: ans += 1 return ans + 1","title":"768. Max Chunks To Make Sorted II"},{"location":"problems/0769/","text":"769. Max Chunks To Make Sorted Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int maxi = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { maxi = max ( maxi , arr [ i ]); if ( maxi == i ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max == i ) ++ ans ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 maxi = float ( '-inf' ) for i , a in enumerate ( arr ): maxi = max ( maxi , a ) if maxi == i : ans += 1 return ans","title":"769. Max Chunks To Make Sorted"},{"location":"problems/0769/#769-max-chunks-to-make-sorted","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int maxi = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { maxi = max ( maxi , arr [ i ]); if ( maxi == i ) ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max == i ) ++ ans ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 maxi = float ( '-inf' ) for i , a in enumerate ( arr ): maxi = max ( maxi , a ) if maxi == i : ans += 1 return ans","title":"769. Max Chunks To Make Sorted"},{"location":"problems/0770/","text":"770. Basic Calculator IV","title":"770. Basic Calculator IV"},{"location":"problems/0770/#770-basic-calculator-iv","text":"","title":"770. Basic Calculator IV"},{"location":"problems/0771/","text":"771. Jewels and Stones Time: $O(|J| + |S|)$ Space: $O(|J|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numJewelsInStones ( string J , string S ) { int ans = 0 ; unordered_set < char > jewels ( begin ( J ), end ( J )); for ( const char s : S ) if ( jewels . count ( s )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numJewelsInStones ( String J , String S ) { int ans = 0 ; Set < Character > jewels = new HashSet <> (); for ( char j : J . toCharArray ()) jewels . add ( j ); for ( char s : S . toCharArray ()) if ( jewels . contains ( s )) ++ ans ; return ans ; } } Python 1 2 3 4 class Solution : def numJewelsInStones ( self , J : str , S : str ) -> int : jewels = set ( J ) return sum ( s in jewels for s in S )","title":"771. Jewels and Stones"},{"location":"problems/0771/#771-jewels-and-stones","text":"Time: $O(|J| + |S|)$ Space: $O(|J|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numJewelsInStones ( string J , string S ) { int ans = 0 ; unordered_set < char > jewels ( begin ( J ), end ( J )); for ( const char s : S ) if ( jewels . count ( s )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numJewelsInStones ( String J , String S ) { int ans = 0 ; Set < Character > jewels = new HashSet <> (); for ( char j : J . toCharArray ()) jewels . add ( j ); for ( char s : S . toCharArray ()) if ( jewels . contains ( s )) ++ ans ; return ans ; } } Python 1 2 3 4 class Solution : def numJewelsInStones ( self , J : str , S : str ) -> int : jewels = set ( J ) return sum ( s in jewels for s in S )","title":"771. Jewels and Stones"},{"location":"problems/0772/","text":"772. Basic Calculator III \ud83d\udd12 Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Solution { public : int calculate ( string s ) { stack < long > nums ; // stores nums stack < char > ops ; // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { long num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . pop (); // remove '(' } else if ( c == '+' || c == '-' || c == '*' || c == '/' ) { while ( ! ops . empty () && compare ( ops . top (), c )) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : long calculate ( char op , long b , long a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw ; } // return true if op1 is a operator and priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } long pop ( stack < long >& nums ) { const long num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw new IllegalArgumentException (); } // return true if op1 is a operator and priority(op1) >= priority(op2) boolean compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"772. Basic Calculator III"},{"location":"problems/0772/#772-basic-calculator-iii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Solution { public : int calculate ( string s ) { stack < long > nums ; // stores nums stack < char > ops ; // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isspace ( c )) continue ; if ( isdigit ( c )) { long num = c - '0' ; while ( i + 1 < s . length () && isdigit ( s [ i + 1 ])) { num = num * 10 + ( s [ i + 1 ] - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . pop (); // remove '(' } else if ( c == '+' || c == '-' || c == '*' || c == '/' ) { while ( ! ops . empty () && compare ( ops . top (), c )) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); ops . push ( c ); } } while ( ! ops . empty ()) nums . push ( calculate ( pop ( ops ), pop ( nums ), pop ( nums ))); return nums . top (); } private : long calculate ( char op , long b , long a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw ; } // return true if op1 is a operator and priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } long pop ( stack < long >& nums ) { const long num = nums . top (); nums . pop (); return num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public int calculate ( String s ) { Stack < Integer > nums = new Stack <> (); // stores nums Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( int i = 0 ; i < s . length (); ++ i ) { final char c = s . charAt ( i ); if ( c == ' ' ) continue ; if ( Character . isDigit ( c )) { int num = c - '0' ; while ( i + 1 < s . length () && Character . isDigit ( s . charAt ( i + 1 ))) { num = num * 10 + ( s . charAt ( i + 1 ) - '0' ); ++ i ; } nums . push ( num ); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); ops . push ( c ); } } while ( ! ops . isEmpty ()) nums . push ( calculate ( ops . pop (), nums . pop (), nums . pop ())); return nums . peek (); } private int calculate ( char op , int b , int a ) { switch ( op ) { case '+' : return a + b ; case '-' : return a - b ; case '*' : return a * b ; case '/' : return a / b ; } throw new IllegalArgumentException (); } // return true if op1 is a operator and priority(op1) >= priority(op2) boolean compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"772. Basic Calculator III \ud83d\udd12"},{"location":"problems/0773/","text":"773. Sliding Puzzle Time: $O((mn)!)$ Space: $O((mn)!)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : int slidingPuzzle ( vector < vector < int >>& board ) { constexpr int m = 2 ; constexpr int n = 3 ; const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; const string goal = \"123450\" ; int ans = 0 ; string start ; // hash 2D vector to string for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) start += '0' + board [ i ][ j ]; if ( start == goal ) return 0 ; queue < string > q {{ start }}; unordered_set < string > seen { start }; while ( ! q . empty ()) { ++ ans ; for ( int size = q . size (); size > 0 ; -- size ) { string s = q . front (); q . pop (); const int zeroIndex = s . find ( '0' ); const int i = zeroIndex / n ; const int j = zeroIndex % n ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; const int swappedIndex = x * n + y ; swap ( s [ zeroIndex ], s [ swappedIndex ]); if ( s == goal ) return ans ; if ( ! seen . count ( s )) { q . push ( s ); seen . insert ( s ); } swap ( s [ zeroIndex ], s [ swappedIndex ]); } } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public int slidingPuzzle ( int [][] board ) { final int row = 2 ; final int col = 3 ; final int [][] dirs = new int [][] { { - 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 } }; String start = \"\" ; String goal = \"\" ; int steps = 0 ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) { start += ( char ) ( board [ i ][ j ] + '0' ); goal += ( char ) (( i * col + j + 1 ) % ( col * row ) + '0' ); } if ( start . equals ( goal )) return 0 ; Set < String > visited = new HashSet <> (); visited . add ( start ); Queue < String > q = new LinkedList <> (); q . add ( start ); while ( ! q . isEmpty ()) { ++ steps ; for ( int k = q . size (); k > 0 ; -- k ) { final String s = q . poll (); final int p = s . indexOf ( \"0\" ); final int y = p / col ; final int x = p % col ; for ( int i = 0 ; i < 4 ; ++ i ) { final int tx = x + dirs [ i ][ 0 ] ; final int ty = y + dirs [ i ][ 1 ] ; if ( tx < 0 || ty < 0 || tx == col || ty == row ) continue ; final int loc = ty * col + tx ; StringBuilder sb = new StringBuilder ( s ); sb . setCharAt ( p , s . charAt ( loc )); sb . setCharAt ( loc , s . charAt ( p )); final String t = sb . toString (); if ( visited . contains ( t )) continue ; if ( t . equals ( goal )) return steps ; visited . add ( t ); q . add ( t ); } } } return - 1 ; } }","title":"773. Sliding Puzzle"},{"location":"problems/0773/#773-sliding-puzzle","text":"Time: $O((mn)!)$ Space: $O((mn)!)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : int slidingPuzzle ( vector < vector < int >>& board ) { constexpr int m = 2 ; constexpr int n = 3 ; const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; const string goal = \"123450\" ; int ans = 0 ; string start ; // hash 2D vector to string for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) start += '0' + board [ i ][ j ]; if ( start == goal ) return 0 ; queue < string > q {{ start }}; unordered_set < string > seen { start }; while ( ! q . empty ()) { ++ ans ; for ( int size = q . size (); size > 0 ; -- size ) { string s = q . front (); q . pop (); const int zeroIndex = s . find ( '0' ); const int i = zeroIndex / n ; const int j = zeroIndex % n ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; const int swappedIndex = x * n + y ; swap ( s [ zeroIndex ], s [ swappedIndex ]); if ( s == goal ) return ans ; if ( ! seen . count ( s )) { q . push ( s ); seen . insert ( s ); } swap ( s [ zeroIndex ], s [ swappedIndex ]); } } } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public int slidingPuzzle ( int [][] board ) { final int row = 2 ; final int col = 3 ; final int [][] dirs = new int [][] { { - 1 , 0 }, { 1 , 0 }, { 0 , - 1 }, { 0 , 1 } }; String start = \"\" ; String goal = \"\" ; int steps = 0 ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) { start += ( char ) ( board [ i ][ j ] + '0' ); goal += ( char ) (( i * col + j + 1 ) % ( col * row ) + '0' ); } if ( start . equals ( goal )) return 0 ; Set < String > visited = new HashSet <> (); visited . add ( start ); Queue < String > q = new LinkedList <> (); q . add ( start ); while ( ! q . isEmpty ()) { ++ steps ; for ( int k = q . size (); k > 0 ; -- k ) { final String s = q . poll (); final int p = s . indexOf ( \"0\" ); final int y = p / col ; final int x = p % col ; for ( int i = 0 ; i < 4 ; ++ i ) { final int tx = x + dirs [ i ][ 0 ] ; final int ty = y + dirs [ i ][ 1 ] ; if ( tx < 0 || ty < 0 || tx == col || ty == row ) continue ; final int loc = ty * col + tx ; StringBuilder sb = new StringBuilder ( s ); sb . setCharAt ( p , s . charAt ( loc )); sb . setCharAt ( loc , s . charAt ( p )); final String t = sb . toString (); if ( visited . contains ( t )) continue ; if ( t . equals ( goal )) return steps ; visited . add ( t ); q . add ( t ); } } } return - 1 ; } }","title":"773. Sliding Puzzle"},{"location":"problems/0774/","text":"774. Minimize Max Distance to Gas Station \ud83d\udd12","title":"774. Minimize Max Distance to Gas Station"},{"location":"problems/0774/#774-minimize-max-distance-to-gas-station","text":"","title":"774. Minimize Max Distance to Gas Station \ud83d\udd12"},{"location":"problems/0775/","text":"775. Global and Local Inversions Approach 1: Local inversions $\\subseteq$ global inversions Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { int maxi = -1 ; // the most likely to be greater than A[i + 2] for ( int i = 0 ; i + 2 < A . size (); ++ i ) { maxi = max ( maxi , A [ i ]); if ( maxi > A [ i + 2 ]) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True Approach 2: Ideal permutation Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"775. Global and Local Inversions"},{"location":"problems/0775/#775-global-and-local-inversions","text":"","title":"775. Global and Local Inversions"},{"location":"problems/0775/#approach-1-local-inversions-subseteq-global-inversions","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { int maxi = -1 ; // the most likely to be greater than A[i + 2] for ( int i = 0 ; i + 2 < A . size (); ++ i ) { maxi = max ( maxi , A [ i ]); if ( maxi > A [ i + 2 ]) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True","title":"Approach 1: Local inversions $\\subseteq$ global inversions"},{"location":"problems/0775/#approach-2-ideal-permutation","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"Approach 2: Ideal permutation"},{"location":"problems/0776/","text":"776. Split BST \ud83d\udd12","title":"776. Split BST"},{"location":"problems/0776/#776-split-bst","text":"","title":"776. Split BST \ud83d\udd12"},{"location":"problems/0777/","text":"777. Swap Adjacent in LR String Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool canTransform ( string start , string end ) { int i = 0 ; // point to start int j = 0 ; // point to end while ( i < start . length ()) { while ( start [ i ] == 'X' ) ++ i ; while ( end [ j ] == 'X' ) ++ j ; if ( start [ i ] != end [ j ]) return false ; if ( start [ i ] == 'R' && i > j ) return false ; if ( start [ i ] == 'L' && i < j ) return false ; ++ i ; ++ j ; } return true ; } };","title":"777. Swap Adjacent in LR String"},{"location":"problems/0777/#777-swap-adjacent-in-lr-string","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool canTransform ( string start , string end ) { int i = 0 ; // point to start int j = 0 ; // point to end while ( i < start . length ()) { while ( start [ i ] == 'X' ) ++ i ; while ( end [ j ] == 'X' ) ++ j ; if ( start [ i ] != end [ j ]) return false ; if ( start [ i ] == 'R' && i > j ) return false ; if ( start [ i ] == 'L' && i < j ) return false ; ++ i ; ++ j ; } return true ; } };","title":"777. Swap Adjacent in LR String"},{"location":"problems/0778/","text":"778. Swim in Rising Water Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct Item { int i ; int j ; }; class Solution { public : int swimInWater ( vector < vector < int >>& grid ) { const int n = grid . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = grid [ 0 ][ 0 ]; auto compare = [ & ]( const Item & a , const Item & b ) { return grid [ a . i ][ a . j ] > grid [ b . i ][ b . j ]; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); vector < vector < bool >> seen ( n , vector < bool > ( n )); pq . push ({ 0 , 0 }); seen [ 0 ][ 0 ] = true ; while ( ! pq . empty ()) { const auto [ i , j ] = pq . top (); pq . pop (); ans = max ( ans , grid [ i ][ j ]); if ( i == n - 1 && j == n - 1 ) break ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; pq . push ({ x , y }); seen [ x ][ y ] = true ; } } return ans ; } };","title":"778. Swim in Rising Water"},{"location":"problems/0778/#778-swim-in-rising-water","text":"Time: $O(mn\\log mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct Item { int i ; int j ; }; class Solution { public : int swimInWater ( vector < vector < int >>& grid ) { const int n = grid . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = grid [ 0 ][ 0 ]; auto compare = [ & ]( const Item & a , const Item & b ) { return grid [ a . i ][ a . j ] > grid [ b . i ][ b . j ]; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); vector < vector < bool >> seen ( n , vector < bool > ( n )); pq . push ({ 0 , 0 }); seen [ 0 ][ 0 ] = true ; while ( ! pq . empty ()) { const auto [ i , j ] = pq . top (); pq . pop (); ans = max ( ans , grid [ i ][ j ]); if ( i == n - 1 && j == n - 1 ) break ; for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( seen [ x ][ y ]) continue ; pq . push ({ x , y }); seen [ x ][ y ] = true ; } } return ans ; } };","title":"778. Swim in Rising Water"},{"location":"problems/0779/","text":"779. K-th Symbol in Grammar Time: $O(N)$ Space: $O(N)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int kthGrammar ( int N , int K ) { if ( N == 1 ) return 0 ; if ( K & 1 ) return kthGrammar ( N - 1 , ( K + 1 ) / 2 ) != 0 ; // left node return kthGrammar ( N - 1 , K / 2 ) == 0 ; // right node } };","title":"779. K-th Symbol in Grammar"},{"location":"problems/0779/#779-k-th-symbol-in-grammar","text":"Time: $O(N)$ Space: $O(N)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int kthGrammar ( int N , int K ) { if ( N == 1 ) return 0 ; if ( K & 1 ) return kthGrammar ( N - 1 , ( K + 1 ) / 2 ) != 0 ; // left node return kthGrammar ( N - 1 , K / 2 ) == 0 ; // right node } };","title":"779. K-th Symbol in Grammar"},{"location":"problems/0780/","text":"780. Reaching Points Time: $O(\\log N)$, where $N = \\max(tx, ty)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % sx == 0 || sy == ty && sx <= tx && ( tx - sx ) % sy == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } } Python 1 2 3 4 5 6 7 class Solution : def reachingPoints ( self , sx : int , sy : int , tx : int , ty : int ) -> bool : while sx < tx and sy < ty : tx , ty = tx % ty , ty % tx return sx == tx and sy <= ty and ( ty - sy ) % tx == 0 or \\ sy == ty and sx <= tx and ( tx - sx ) % ty == 0","title":"780. Reaching Points"},{"location":"problems/0780/#780-reaching-points","text":"Time: $O(\\log N)$, where $N = \\max(tx, ty)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % sx == 0 || sy == ty && sx <= tx && ( tx - sx ) % sy == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } } Python 1 2 3 4 5 6 7 class Solution : def reachingPoints ( self , sx : int , sy : int , tx : int , ty : int ) -> bool : while sx < tx and sy < ty : tx , ty = tx % ty , ty % tx return sx == tx and sy <= ty and ( ty - sy ) % tx == 0 or \\ sy == ty and sx <= tx and ( tx - sx ) % ty == 0","title":"780. Reaching Points"},{"location":"problems/0781/","text":"781. Rabbits in Forest Time: $O(n)$ Space: $O(1000)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; vector < int > count ( 1000 ); for ( const int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numRabbits ( int [] answers ) { int ans = 0 ; int [] count = new int [ 1000 ] ; for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numRabbits ( self , answers : List [ int ]) -> int : ans = 0 count = collections . Counter () for answer in answers : if count [ answer ] % ( answer + 1 ) == 0 : ans += answer + 1 count [ answer ] += 1 return ans","title":"781. Rabbits in Forest"},{"location":"problems/0781/#781-rabbits-in-forest","text":"Time: $O(n)$ Space: $O(1000)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; vector < int > count ( 1000 ); for ( const int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numRabbits ( int [] answers ) { int ans = 0 ; int [] count = new int [ 1000 ] ; for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numRabbits ( self , answers : List [ int ]) -> int : ans = 0 count = collections . Counter () for answer in answers : if count [ answer ] % ( answer + 1 ) == 0 : ans += answer + 1 count [ answer ] += 1 return ans","title":"781. Rabbits in Forest"},{"location":"problems/0782/","text":"782. Transform to Chessboard Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int movesToChessboard ( vector < vector < int >>& board ) { const int n = board . size (); int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] == 1 ) return -1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ]; colSum += board [ i ][ 0 ]; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return -1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return -1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSwaps += board [ i ][ 0 ] == ( i & 1 ); colSwaps += board [ 0 ][ i ] == ( i & 1 ); } if ( n & 1 ) { if ( rowSwaps & 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps & 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = min ( rowSwaps , n - rowSwaps ); colSwaps = min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public int movesToChessboard ( int [][] board ) { final int n = board . length ; int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] ) == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ] ; colSum += board [ i ][ 0 ] ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( board [ i ][ 0 ] == ( i & 1 )) ++ rowSwaps ; if ( board [ 0 ][ i ] == ( i & 1 )) ++ colSwaps ; } if ( n % 2 == 1 ) { if ( rowSwaps % 2 == 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps % 2 == 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = Math . min ( rowSwaps , n - rowSwaps ); colSwaps = Math . min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def movesToChessboard ( self , board : List [ List [ int ]]) -> int : n = len ( board ) if any ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] for i in range ( n ) for j in range ( n )): return - 1 rowSum = sum ( board [ 0 ]) colSum = sum ( board [ i ][ 0 ] for i in range ( n )) if rowSum != n // 2 and rowSum != ( n + 1 ) // 2 : return - 1 if colSum != n // 2 and colSum != ( n + 1 ) // 2 : return - 1 rowSwaps = sum ( board [ i ][ 0 ] == ( i & 1 ) for i in range ( n )) colSwaps = sum ( board [ 0 ][ i ] == ( i & 1 ) for i in range ( n )) if n & 1 : if rowSwaps & 1 : rowSwaps = n - rowSwaps if colSwaps & 1 : colSwaps = n - colSwaps else : rowSwaps = min ( rowSwaps , n - rowSwaps ) colSwaps = min ( colSwaps , n - colSwaps ) return ( rowSwaps + colSwaps ) // 2","title":"782. Transform to Chessboard"},{"location":"problems/0782/#782-transform-to-chessboard","text":"Time: $O(n^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int movesToChessboard ( vector < vector < int >>& board ) { const int n = board . size (); int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] == 1 ) return -1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ]; colSum += board [ i ][ 0 ]; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return -1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return -1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSwaps += board [ i ][ 0 ] == ( i & 1 ); colSwaps += board [ 0 ][ i ] == ( i & 1 ); } if ( n & 1 ) { if ( rowSwaps & 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps & 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = min ( rowSwaps , n - rowSwaps ); colSwaps = min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public int movesToChessboard ( int [][] board ) { final int n = board . length ; int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] ) == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ] ; colSum += board [ i ][ 0 ] ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( board [ i ][ 0 ] == ( i & 1 )) ++ rowSwaps ; if ( board [ 0 ][ i ] == ( i & 1 )) ++ colSwaps ; } if ( n % 2 == 1 ) { if ( rowSwaps % 2 == 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps % 2 == 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = Math . min ( rowSwaps , n - rowSwaps ); colSwaps = Math . min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def movesToChessboard ( self , board : List [ List [ int ]]) -> int : n = len ( board ) if any ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] for i in range ( n ) for j in range ( n )): return - 1 rowSum = sum ( board [ 0 ]) colSum = sum ( board [ i ][ 0 ] for i in range ( n )) if rowSum != n // 2 and rowSum != ( n + 1 ) // 2 : return - 1 if colSum != n // 2 and colSum != ( n + 1 ) // 2 : return - 1 rowSwaps = sum ( board [ i ][ 0 ] == ( i & 1 ) for i in range ( n )) colSwaps = sum ( board [ 0 ][ i ] == ( i & 1 ) for i in range ( n )) if n & 1 : if rowSwaps & 1 : rowSwaps = n - rowSwaps if colSwaps & 1 : colSwaps = n - colSwaps else : rowSwaps = min ( rowSwaps , n - rowSwaps ) colSwaps = min ( colSwaps , n - colSwaps ) return ( rowSwaps + colSwaps ) // 2","title":"782. Transform to Chessboard"},{"location":"problems/0783/","text":"783. Minimum Distance Between BST Nodes Time: $O(n)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; int prev = -1 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( prev >= 0 ) ans = min ( ans , root -> val - prev ); prev = root -> val ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"783. Minimum Distance Between BST Nodes"},{"location":"problems/0783/#783-minimum-distance-between-bst-nodes","text":"Time: $O(n)$ Space: $O(\\log n) \\to O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minDiffInBST ( TreeNode * root ) { int ans = INT_MAX ; int prev = -1 ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); if ( prev >= 0 ) ans = min ( ans , root -> val - prev ); prev = root -> val ; inorder ( root -> right ); }; inorder ( root ); return ans ; } };","title":"783. Minimum Distance Between BST Nodes"},{"location":"problems/0784/","text":"784. Letter Case Permutation Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > letterCasePermutation ( string S ) { vector < string > ans ; function < void ( int ) > dfs = [ & ]( int i ) { if ( i == S . length ()) { ans . push_back ( S ); return ; } if ( isdigit ( S [ i ])) { dfs ( i + 1 ); return ; } S [ i ] = tolower ( S [ i ]); dfs ( i + 1 ); S [ i ] = toupper ( S [ i ]); dfs ( i + 1 ); }; dfs ( 0 ); return ans ; } };","title":"784. Letter Case Permutation"},{"location":"problems/0784/#784-letter-case-permutation","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > letterCasePermutation ( string S ) { vector < string > ans ; function < void ( int ) > dfs = [ & ]( int i ) { if ( i == S . length ()) { ans . push_back ( S ); return ; } if ( isdigit ( S [ i ])) { dfs ( i + 1 ); return ; } S [ i ] = tolower ( S [ i ]); dfs ( i + 1 ); S [ i ] = toupper ( S [ i ]); dfs ( i + 1 ); }; dfs ( 0 ); return ans ; } };","title":"784. Letter Case Permutation"},{"location":"problems/0785/","text":"785. Is Graph Bipartite? Approach 1: BFS Time: $O(|V| + |E|)$ Space: $O(|V|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isBipartite ( vector < vector < int >>& graph ) { vector < int > colors ( graph . size ()); // 1: red, -1, green for ( int i = 0 ; i < graph . size (); ++ i ) { if ( colors [ i ] != 0 ) // already colored successfully continue ; colors [ i ] = 1 ; // always color red queue < int > q {{ i }}; while ( ! q . empty ()) { const int node = q . front (); q . pop (); const int color = colors [ node ]; for ( const int neighbor : graph [ node ]) if ( colors [ neighbor ] == 0 ) { colors [ neighbor ] = - color ; q . push ( neighbor ); } else if ( colors [ neighbor ] == color ) { return false ; } } } return true ; } }; Approach 2: DFS Time: $O(|V| + |E|)$ Space: $O(|V|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isBipartite ( vector < vector < int >>& graph ) { vector < int > colors ( graph . size ()); // 1: red, -1: green function < bool ( int , int ) > isValidColor = [ & ]( int node , int color ) { if ( colors [ node ] != 0 ) // the painted color should be same as the `color` return colors [ node ] == color ; colors [ node ] = color ; // paint the node with `color` for ( const int neighbor : graph [ node ]) // all neighbors should have valid colors if ( ! isValidColor ( neighbor , - color )) return false ; return true ; }; for ( int i = 0 ; i < graph . size (); ++ i ) if ( colors [ i ] == 0 && ! isValidColor ( i , 1 )) // start to paint it with `1` return false ; return true ; } };","title":"785. Is Graph Bipartite?"},{"location":"problems/0785/#785-is-graph-bipartite","text":"","title":"785. Is Graph Bipartite?"},{"location":"problems/0785/#approach-1-bfs","text":"Time: $O(|V| + |E|)$ Space: $O(|V|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool isBipartite ( vector < vector < int >>& graph ) { vector < int > colors ( graph . size ()); // 1: red, -1, green for ( int i = 0 ; i < graph . size (); ++ i ) { if ( colors [ i ] != 0 ) // already colored successfully continue ; colors [ i ] = 1 ; // always color red queue < int > q {{ i }}; while ( ! q . empty ()) { const int node = q . front (); q . pop (); const int color = colors [ node ]; for ( const int neighbor : graph [ node ]) if ( colors [ neighbor ] == 0 ) { colors [ neighbor ] = - color ; q . push ( neighbor ); } else if ( colors [ neighbor ] == color ) { return false ; } } } return true ; } };","title":"Approach 1: BFS"},{"location":"problems/0785/#approach-2-dfs","text":"Time: $O(|V| + |E|)$ Space: $O(|V|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool isBipartite ( vector < vector < int >>& graph ) { vector < int > colors ( graph . size ()); // 1: red, -1: green function < bool ( int , int ) > isValidColor = [ & ]( int node , int color ) { if ( colors [ node ] != 0 ) // the painted color should be same as the `color` return colors [ node ] == color ; colors [ node ] = color ; // paint the node with `color` for ( const int neighbor : graph [ node ]) // all neighbors should have valid colors if ( ! isValidColor ( neighbor , - color )) return false ; return true ; }; for ( int i = 0 ; i < graph . size (); ++ i ) if ( colors [ i ] == 0 && ! isValidColor ( i , 1 )) // start to paint it with `1` return false ; return true ; } };","title":"Approach 2: DFS"},{"location":"problems/0786/","text":"786. K-th Smallest Prime Fraction Time: $O(n\\log \\max^2(A))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); double l = 0.0 ; double r = 1.0 ; while ( l < r ) { const double m = ( l + r ) / 2.0 ; int fractionsNoGreaterThanM = 0 ; int p = 0 ; int q = 1 ; // for each index i, find the first index j s.t. A[i] / A[j] <= m, // so fractionsNoGreaterThanM for index i will be n - j for ( int i = 0 , j = 1 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; if ( j == n ) break ; fractionsNoGreaterThanM += n - j ; if ( p * A [ j ] < q * A [ i ]) { p = A [ i ]; q = A [ j ]; } } if ( fractionsNoGreaterThanM == K ) return { p , q }; if ( fractionsNoGreaterThanM < K ) l = m ; else r = m ; } throw ; } };","title":"786. K-th Smallest Prime Fraction"},{"location":"problems/0786/#786-k-th-smallest-prime-fraction","text":"Time: $O(n\\log \\max^2(A))$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); double l = 0.0 ; double r = 1.0 ; while ( l < r ) { const double m = ( l + r ) / 2.0 ; int fractionsNoGreaterThanM = 0 ; int p = 0 ; int q = 1 ; // for each index i, find the first index j s.t. A[i] / A[j] <= m, // so fractionsNoGreaterThanM for index i will be n - j for ( int i = 0 , j = 1 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; if ( j == n ) break ; fractionsNoGreaterThanM += n - j ; if ( p * A [ j ] < q * A [ i ]) { p = A [ i ]; q = A [ j ]; } } if ( fractionsNoGreaterThanM == K ) return { p , q }; if ( fractionsNoGreaterThanM < K ) l = m ; else r = m ; } throw ; } };","title":"786. K-th Smallest Prime Fraction"},{"location":"problems/0787/","text":"787. Cheapest Flights Within K Stops","title":"787. Cheapest Flights Within K Stops"},{"location":"problems/0787/#787-cheapest-flights-within-k-stops","text":"","title":"787. Cheapest Flights Within K Stops"},{"location":"problems/0788/","text":"788. Rotated Digits Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private : bool isGoodNumber ( int i ) { bool isRotated = false ; for ( const char c : to_string ( i )) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private boolean isGoodNumber ( int i ) { boolean isRotated = false ; for ( char c : String . valueOf ( i ). toCharArray ()) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rotatedDigits ( self , N : int ) -> int : def isGoodNumber ( i : int ) -> bool : isRotated = False for c in str ( i ): if c == '0' or c == '1' or c == '8' : continue if c == '2' or c == '5' or c == '6' or c == '9' : isRotated = True else : return False return isRotated return sum ( isGoodNumber ( i ) for i in range ( 1 , N + 1 ))","title":"788. Rotated Digits"},{"location":"problems/0788/#788-rotated-digits","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private : bool isGoodNumber ( int i ) { bool isRotated = false ; for ( const char c : to_string ( i )) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private boolean isGoodNumber ( int i ) { boolean isRotated = false ; for ( char c : String . valueOf ( i ). toCharArray ()) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rotatedDigits ( self , N : int ) -> int : def isGoodNumber ( i : int ) -> bool : isRotated = False for c in str ( i ): if c == '0' or c == '1' or c == '8' : continue if c == '2' or c == '5' or c == '6' or c == '9' : isRotated = True else : return False return isRotated return sum ( isGoodNumber ( i ) for i in range ( 1 , N + 1 ))","title":"788. Rotated Digits"},{"location":"problems/0789/","text":"789. Escape The Ghosts Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool escapeGhosts ( vector < vector < int >>& ghosts , vector < int >& target ) { const int d = abs ( target [ 0 ]) + abs ( target [ 1 ]); for ( const vector < int >& ghost : ghosts ) if ( d >= abs ( ghost [ 0 ] - target [ 0 ]) + abs ( ghost [ 1 ] - target [ 1 ])) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean escapeGhosts ( int [][] ghosts , int [] target ) { int ghostSteps = Integer . MAX_VALUE ; for ( int [] ghost : ghosts ) ghostSteps = Math . min ( ghostSteps , Math . abs ( ghost [ 0 ] - target [ 0 ] ) + Math . abs ( ghost [ 1 ] - target [ 1 ] )); return Math . abs ( target [ 0 ] ) + Math . abs ( target [ 1 ] ) < ghostSteps ; } } Python 1 2 3 4 5 6 class Solution : def escapeGhosts ( self , ghosts : List [ List [ int ]], target : List [ int ]) -> bool : ghostSteps = min ( abs ( x - target [ 0 ]) + abs ( y - target [ 1 ]) for x , y in ghosts ) return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps","title":"789. Escape The Ghosts"},{"location":"problems/0789/#789-escape-the-ghosts","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool escapeGhosts ( vector < vector < int >>& ghosts , vector < int >& target ) { const int d = abs ( target [ 0 ]) + abs ( target [ 1 ]); for ( const vector < int >& ghost : ghosts ) if ( d >= abs ( ghost [ 0 ] - target [ 0 ]) + abs ( ghost [ 1 ] - target [ 1 ])) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean escapeGhosts ( int [][] ghosts , int [] target ) { int ghostSteps = Integer . MAX_VALUE ; for ( int [] ghost : ghosts ) ghostSteps = Math . min ( ghostSteps , Math . abs ( ghost [ 0 ] - target [ 0 ] ) + Math . abs ( ghost [ 1 ] - target [ 1 ] )); return Math . abs ( target [ 0 ] ) + Math . abs ( target [ 1 ] ) < ghostSteps ; } } Python 1 2 3 4 5 6 class Solution : def escapeGhosts ( self , ghosts : List [ List [ int ]], target : List [ int ]) -> bool : ghostSteps = min ( abs ( x - target [ 0 ]) + abs ( y - target [ 1 ]) for x , y in ghosts ) return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps","title":"789. Escape The Ghosts"},{"location":"problems/0790/","text":"790. Domino and Tromino Tiling Time: $O(N)$ Space: $O(N)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numTilings ( int N ) { constexpr int kMod = 1e9 + 7 ; vector < long > dp ( 1001 , 0 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ]) % kMod ; return dp [ N ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numTilings ( int N ) { final int kMod = ( int ) 1e9 + 7 ; long [] dp = new long [ 1001 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ] ) % kMod ; return ( int ) dp [ N ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def numTilings ( self , N : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 , 1 , 2 , 5 ] + [ 0 ] * 997 for i in range ( 4 , N + 1 ): dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] return dp [ N ] % kMod","title":"790. Domino and Tromino Tiling"},{"location":"problems/0790/#790-domino-and-tromino-tiling","text":"Time: $O(N)$ Space: $O(N)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numTilings ( int N ) { constexpr int kMod = 1e9 + 7 ; vector < long > dp ( 1001 , 0 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ]) % kMod ; return dp [ N ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numTilings ( int N ) { final int kMod = ( int ) 1e9 + 7 ; long [] dp = new long [ 1001 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ] ) % kMod ; return ( int ) dp [ N ] ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def numTilings ( self , N : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 , 1 , 2 , 5 ] + [ 0 ] * 997 for i in range ( 4 , N + 1 ): dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] return dp [ N ] % kMod","title":"790. Domino and Tromino Tiling"},{"location":"problems/0791/","text":"791. Custom Sort String Time: $O(|S| + |T|)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string customSortString ( const string & S , const string & T ) { string ans ; vector < int > count ( 128 ); for ( const char c : T ) ++ count [ c ]; for ( const char c : S ) while ( count [ c ] -- > 0 ) ans += c ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ] -- > 0 ) ans += c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String customSortString ( final String S , final String T ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; for ( final char c : T . toCharArray ()) ++ count [ c ] ; for ( final char c : S . toCharArray ()) while ( count [ c ]-- > 0 ) sb . append ( c ); for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ]-- > 0 ) sb . append ( c ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def customSortString ( self , S : str , T : str ) -> str : ans = \"\" count = [ 0 ] * 26 for c in T : count [ ord ( c ) - ord ( 'a' )] += 1 for c in S : while count [ ord ( c ) - ord ( 'a' )] > 0 : ans += c count [ ord ( c ) - ord ( 'a' )] -= 1 for c in string . ascii_lowercase : for _ in range ( count [ ord ( c ) - ord ( 'a' )]): ans += c return ans","title":"791. Custom Sort String"},{"location":"problems/0791/#791-custom-sort-string","text":"Time: $O(|S| + |T|)$ Space: $O(26)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string customSortString ( const string & S , const string & T ) { string ans ; vector < int > count ( 128 ); for ( const char c : T ) ++ count [ c ]; for ( const char c : S ) while ( count [ c ] -- > 0 ) ans += c ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ] -- > 0 ) ans += c ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String customSortString ( final String S , final String T ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; for ( final char c : T . toCharArray ()) ++ count [ c ] ; for ( final char c : S . toCharArray ()) while ( count [ c ]-- > 0 ) sb . append ( c ); for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c ]-- > 0 ) sb . append ( c ); return sb . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def customSortString ( self , S : str , T : str ) -> str : ans = \"\" count = [ 0 ] * 26 for c in T : count [ ord ( c ) - ord ( 'a' )] += 1 for c in S : while count [ ord ( c ) - ord ( 'a' )] > 0 : ans += c count [ ord ( c ) - ord ( 'a' )] -= 1 for c in string . ascii_lowercase : for _ in range ( count [ ord ( c ) - ord ( 'a' )]): ans += c return ans","title":"791. Custom Sort String"},{"location":"problems/0792/","text":"792. Number of Matching Subsequences Time: $O(|S| + \\Sigma|word_i|)$ Space: $O(\\Sigma|word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { int ans = 0 ; // pair (i, j) := words[i] and the character j waiting for vector < vector < pair < int , int >>> waiting ( 26 ); // for each word, it's waiting for word[1] for ( int i = 0 ; i < words . size (); ++ i ) waiting [ words [ i ][ 0 ] - 'a' ]. push_back ({ i , 1 }); for ( const char c : S ) { // clear waiting[c] and take the value of waiting[c] in advance vector < pair < int , int >> advance ; swap ( advance , waiting [ c - 'a' ]); for ( auto & [ i , j ] : advance ) if ( j == words [ i ]. length ()) // all characters in words[i] are matched ++ ans ; else waiting [ words [ i ][ j ++ ] - 'a' ]. push_back ({ i , j }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } ++ node . count ; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root )","title":"792. Number of Matching Subsequences"},{"location":"problems/0792/#792-number-of-matching-subsequences","text":"Time: $O(|S| + \\Sigma|word_i|)$ Space: $O(\\Sigma|word_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { int ans = 0 ; // pair (i, j) := words[i] and the character j waiting for vector < vector < pair < int , int >>> waiting ( 26 ); // for each word, it's waiting for word[1] for ( int i = 0 ; i < words . size (); ++ i ) waiting [ words [ i ][ 0 ] - 'a' ]. push_back ({ i , 1 }); for ( const char c : S ) { // clear waiting[c] and take the value of waiting[c] in advance vector < pair < int , int >> advance ; swap ( advance , waiting [ c - 'a' ]); for ( auto & [ i , j ] : advance ) if ( j == words [ i ]. length ()) // all characters in words[i] are matched ++ ans ; else waiting [ words [ i ][ j ++ ] - 'a' ]. push_back ({ i , j }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } ++ node . count ; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root )","title":"792. Number of Matching Subsequences"},{"location":"problems/0793/","text":"793. Preimage Size of Factorial Zeroes Function Time: $O(\\log_2 K \\cdot \\log_5 K$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int preimageSizeFZF ( int K ) { long l = 0 ; long r = 5 * ( long ) K ; while ( l < r ) { const long m = l + ( r - l ) / 2 ; if ( trailingZeroes ( m ) < K ) l = m + 1 ; else r = m ; } return trailingZeroes ( l ) == K ? 5 : 0 ; } private : // 172. Factorial Trailing Zeroes int trailingZeroes ( long n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"793. Preimage Size of Factorial Zeroes Function"},{"location":"problems/0793/#793-preimage-size-of-factorial-zeroes-function","text":"Time: $O(\\log_2 K \\cdot \\log_5 K$ Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int preimageSizeFZF ( int K ) { long l = 0 ; long r = 5 * ( long ) K ; while ( l < r ) { const long m = l + ( r - l ) / 2 ; if ( trailingZeroes ( m ) < K ) l = m + 1 ; else r = m ; } return trailingZeroes ( l ) == K ? 5 : 0 ; } private : // 172. Factorial Trailing Zeroes int trailingZeroes ( long n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"793. Preimage Size of Factorial Zeroes Function"},{"location":"problems/0794/","text":"794. Valid Tic-Tac-Toe State Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : bool validTicTacToe ( vector < string >& board ) { const int countX = sum ( board , 'X' ); const int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private : int sum ( const vector < string >& board , char c ) { int ans = 0 ; for ( const string & row : board ) ans += count ( begin ( row ), end ( row ), c ); return ans ; } bool isWinned ( const vector < string >& board , char c ) { vector < string > rotated = rotate ( board ); auto equalsToThree = [ & c ]( const string & row ) { return count ( begin ( row ), end ( row ), c ) == 3 ; }; return any_of ( begin ( board ), end ( board ), equalsToThree ) || any_of ( begin ( rotated ), end ( rotated ), equalsToThree ) || board [ 0 ][ 0 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 2 ] == c || board [ 0 ][ 2 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 0 ] == c ; } vector < string > rotate ( const vector < string >& board ) { vector < string > rotated ( 3 ); for ( const string & row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ]. push_back ( row [ i ]); return rotated ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean validTicTacToe ( String [] board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private int sum ( final String [] board , char c ) { int ans = 0 ; for ( final String row : board ) ans += row . chars (). filter ( i -> i == c ). count (); return ans ; } private boolean isWinned ( final String [] board , char c ) { String [] rotated = rotate ( board ); return Arrays . stream ( board ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || Arrays . stream ( rotated ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || board [ 0 ] . charAt ( 0 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 2 ) == c || board [ 0 ] . charAt ( 2 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 0 ) == c ; } private String [] rotate ( final String [] board ) { String [] rotated = new String [ 3 ] ; for ( final String row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ] += row . charAt ( i ); return rotated ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def validTicTacToe ( self , board : List [ str ]) -> bool : def isWin ( c : chr ) -> bool : return any ( row . count ( c ) == 3 for row in board ) or \\ any ( row . count ( c ) == 3 for row in list ( zip ( * board ))) or \\ all ( board [ i ][ i ] == c for i in range ( 3 )) or \\ all ( board [ i ][ 2 - i ] == c for i in range ( 3 )) countX = sum ( row . count ( 'X' ) for row in board ) countO = sum ( row . count ( 'O' ) for row in board ) if countX < countO or countX - countO > 1 : return False if isWin ( 'X' ) and countX == countO or isWin ( 'O' ) and countX != countO : return False return True","title":"794. Valid Tic-Tac-Toe State"},{"location":"problems/0794/#794-valid-tic-tac-toe-state","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : bool validTicTacToe ( vector < string >& board ) { const int countX = sum ( board , 'X' ); const int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private : int sum ( const vector < string >& board , char c ) { int ans = 0 ; for ( const string & row : board ) ans += count ( begin ( row ), end ( row ), c ); return ans ; } bool isWinned ( const vector < string >& board , char c ) { vector < string > rotated = rotate ( board ); auto equalsToThree = [ & c ]( const string & row ) { return count ( begin ( row ), end ( row ), c ) == 3 ; }; return any_of ( begin ( board ), end ( board ), equalsToThree ) || any_of ( begin ( rotated ), end ( rotated ), equalsToThree ) || board [ 0 ][ 0 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 2 ] == c || board [ 0 ][ 2 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 0 ] == c ; } vector < string > rotate ( const vector < string >& board ) { vector < string > rotated ( 3 ); for ( const string & row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ]. push_back ( row [ i ]); return rotated ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean validTicTacToe ( String [] board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private int sum ( final String [] board , char c ) { int ans = 0 ; for ( final String row : board ) ans += row . chars (). filter ( i -> i == c ). count (); return ans ; } private boolean isWinned ( final String [] board , char c ) { String [] rotated = rotate ( board ); return Arrays . stream ( board ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || Arrays . stream ( rotated ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || board [ 0 ] . charAt ( 0 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 2 ) == c || board [ 0 ] . charAt ( 2 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 0 ) == c ; } private String [] rotate ( final String [] board ) { String [] rotated = new String [ 3 ] ; for ( final String row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ] += row . charAt ( i ); return rotated ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def validTicTacToe ( self , board : List [ str ]) -> bool : def isWin ( c : chr ) -> bool : return any ( row . count ( c ) == 3 for row in board ) or \\ any ( row . count ( c ) == 3 for row in list ( zip ( * board ))) or \\ all ( board [ i ][ i ] == c for i in range ( 3 )) or \\ all ( board [ i ][ 2 - i ] == c for i in range ( 3 )) countX = sum ( row . count ( 'X' ) for row in board ) countO = sum ( row . count ( 'O' ) for row in board ) if countX < countO or countX - countO > 1 : return False if isWin ( 'X' ) and countX == countO or isWin ( 'O' ) and countX != countO : return False return True","title":"794. Valid Tic-Tac-Toe State"},{"location":"problems/0795/","text":"795. Number of Subarrays with Bounded Maximum Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = -1 ; int r = -1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; // handle reset value if ( A [ i ] >= L ) r = i ; // handle reset and needed value ans += r - l ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans","title":"795. Number of Subarrays with Bounded Maximum"},{"location":"problems/0795/#795-number-of-subarrays-with-bounded-maximum","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = -1 ; int r = -1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; // handle reset value if ( A [ i ] >= L ) r = i ; // handle reset and needed value ans += r - l ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans","title":"795. Number of Subarrays with Bounded Maximum"},{"location":"problems/0796/","text":"796. Rotate String Time: $O(|A|^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool rotateString ( string A , string B ) { return A . length () == B . length () && ( A + A ). find ( B ) != string :: npos ; } };","title":"796. Rotate String"},{"location":"problems/0796/#796-rotate-string","text":"Time: $O(|A|^2)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : bool rotateString ( string A , string B ) { return A . length () == B . length () && ( A + A ). find ( B ) != string :: npos ; } };","title":"796. Rotate String"},{"location":"problems/0797/","text":"797. All Paths From Source to Target Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> allPathsSourceTarget ( vector < vector < int >>& graph ) { vector < vector < int >> ans ; vector < int > path { 0 }; function < void ( int ) > dfs = [ & ]( int node ) { if ( node == graph . size () - 1 ) { ans . push_back ( path ); return ; } for ( const int neighbor : graph [ node ]) { path . push_back ( neighbor ); dfs ( neighbor ); path . pop_back (); } }; dfs ( 0 ); return ans ; } };","title":"797. All Paths From Source to Target"},{"location":"problems/0797/#797-all-paths-from-source-to-target","text":"Time: $O(2^n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> allPathsSourceTarget ( vector < vector < int >>& graph ) { vector < vector < int >> ans ; vector < int > path { 0 }; function < void ( int ) > dfs = [ & ]( int node ) { if ( node == graph . size () - 1 ) { ans . push_back ( path ); return ; } for ( const int neighbor : graph [ node ]) { path . push_back ( neighbor ); dfs ( neighbor ); path . pop_back (); } }; dfs ( 0 ); return ans ; } };","title":"797. All Paths From Source to Target"},{"location":"problems/0798/","text":"798. Smallest Rotation with Highest Score Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int bestRotation ( vector < int >& A ) { const int n = A . size (); // rotate[i] := how many points losing after rotating left i times vector < int > rotate ( n ); // rotating i - A[i] times makes A[i] == its new index // so rotating i - A[i] + 1 times will \"start\" to make A[i] > its index, // which is the starting index to lose point for ( int i = 0 ; i < n ; ++ i ) -- rotate [( i - A [ i ] + 1 + n ) % n ]; // each time we rotate, we make index 0 to index n - 1, // so we get 1 point for ( int i = 1 ; i < n ; ++ i ) rotate [ i ] += rotate [ i - 1 ] + 1 ; return distance ( begin ( rotate ), max_element ( begin ( rotate ), begin ( rotate ) + n )); } };","title":"798. Smallest Rotation with Highest Score"},{"location":"problems/0798/#798-smallest-rotation-with-highest-score","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int bestRotation ( vector < int >& A ) { const int n = A . size (); // rotate[i] := how many points losing after rotating left i times vector < int > rotate ( n ); // rotating i - A[i] times makes A[i] == its new index // so rotating i - A[i] + 1 times will \"start\" to make A[i] > its index, // which is the starting index to lose point for ( int i = 0 ; i < n ; ++ i ) -- rotate [( i - A [ i ] + 1 + n ) % n ]; // each time we rotate, we make index 0 to index n - 1, // so we get 1 point for ( int i = 1 ; i < n ; ++ i ) rotate [ i ] += rotate [ i - 1 ] + 1 ; return distance ( begin ( rotate ), max_element ( begin ( rotate ), begin ( rotate ) + n )); } };","title":"798. Smallest Rotation with Highest Score"},{"location":"problems/0799/","text":"799. Champagne Tower Approach 1: 2D DP Time: $O(|\\text{query_row}|^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : double champagneTower ( int poured , int query_row , int query_glass ) { vector < vector < double >> dp ( query_row + 1 , vector < double > ( query_row + 1 )); dp [ 0 ][ 0 ] = poured ; for ( int i = 0 ; i < query_row ; ++ i ) for ( int j = 0 ; j <= i ; ++ j ) if ( dp [ i ][ j ] > 1 ) { dp [ i + 1 ][ j ] += ( dp [ i ][ j ] - 1 ) / 2.0 ; dp [ i + 1 ][ j + 1 ] += ( dp [ i ][ j ] - 1 ) / 2.0 ; } return min ( 1.0 , dp [ query_row ][ query_glass ]); } }; Approach 2: 1D DP Time: $O(|\\text{query_row}|^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : double champagneTower ( int poured , int query_row , int query_glass ) { vector < double > dp ( query_row + 1 ); dp [ 0 ] = poured ; for ( int i = 0 ; i < query_row ; ++ i ) { vector < double > newDp ( query_row + 1 ); for ( int j = 0 ; j <= i ; ++ j ) if ( dp [ j ] > 1 ) { newDp [ j ] += ( dp [ j ] - 1 ) / 2.0 ; newDp [ j + 1 ] += ( dp [ j ] - 1 ) / 2.0 ; } dp = move ( newDp ); } return min ( 1.0 , dp [ query_glass ]); } };","title":"799. Champagne Tower"},{"location":"problems/0799/#799-champagne-tower","text":"","title":"799. Champagne Tower"},{"location":"problems/0799/#approach-1-2d-dp","text":"Time: $O(|\\text{query_row}|^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : double champagneTower ( int poured , int query_row , int query_glass ) { vector < vector < double >> dp ( query_row + 1 , vector < double > ( query_row + 1 )); dp [ 0 ][ 0 ] = poured ; for ( int i = 0 ; i < query_row ; ++ i ) for ( int j = 0 ; j <= i ; ++ j ) if ( dp [ i ][ j ] > 1 ) { dp [ i + 1 ][ j ] += ( dp [ i ][ j ] - 1 ) / 2.0 ; dp [ i + 1 ][ j + 1 ] += ( dp [ i ][ j ] - 1 ) / 2.0 ; } return min ( 1.0 , dp [ query_row ][ query_glass ]); } };","title":"Approach 1: 2D DP"},{"location":"problems/0799/#approach-2-1d-dp","text":"Time: $O(|\\text{query_row}|^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : double champagneTower ( int poured , int query_row , int query_glass ) { vector < double > dp ( query_row + 1 ); dp [ 0 ] = poured ; for ( int i = 0 ; i < query_row ; ++ i ) { vector < double > newDp ( query_row + 1 ); for ( int j = 0 ; j <= i ; ++ j ) if ( dp [ j ] > 1 ) { newDp [ j ] += ( dp [ j ] - 1 ) / 2.0 ; newDp [ j + 1 ] += ( dp [ j ] - 1 ) / 2.0 ; } dp = move ( newDp ); } return min ( 1.0 , dp [ query_glass ]); } };","title":"Approach 2: 1D DP"},{"location":"problems/0800/","text":"800. Similar RGB Color \ud83d\udd12","title":"800. Similar RGB Color"},{"location":"problems/0800/#800-similar-rgb-color","text":"","title":"800. Similar RGB Color \ud83d\udd12"},{"location":"problems/0801/","text":"801. Minimum Swaps To Make Sequences Increasing Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minSwap ( vector < int >& A , vector < int >& B ) { vector < int > keepAt ( A . size (), INT_MAX ); vector < int > swapAt ( A . size (), INT_MAX ); keepAt [ 0 ] = 0 ; swapAt [ 0 ] = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ]) { keepAt [ i ] = keepAt [ i - 1 ]; swapAt [ i ] = swapAt [ i - 1 ] + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ]) { keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]); swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ); } } return min ( keepAt . back (), swapAt . back ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minSwap ( int [] A , int [] B ) { int keepAt = 0 ; int swapAt = 1 ; int prevKeepAt = 0 ; int prevSwapAt = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { keepAt = Integer . MAX_VALUE ; swapAt = Integer . MAX_VALUE ; if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ] ) { keepAt = prevKeepAt ; swapAt = prevSwapAt + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ] ) { keepAt = Math . min ( keepAt , prevSwapAt ); swapAt = Math . min ( swapAt , prevKeepAt + 1 ); } prevKeepAt = keepAt ; prevSwapAt = swapAt ; } return Math . min ( keepAt , swapAt ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minSwap ( self , A : List [ int ], B : List [ int ]) -> int : keepAt = [ float ( 'inf' )] * len ( A ) swapAt = [ float ( 'inf' )] * len ( A ) keepAt [ 0 ] = 0 swapAt [ 0 ] = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ] and B [ i ] > B [ i - 1 ]: keepAt [ i ] = keepAt [ i - 1 ] swapAt [ i ] = swapAt [ i - 1 ] + 1 if A [ i ] > B [ i - 1 ] and B [ i ] > A [ i - 1 ]: keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]) swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ) return min ( keepAt [ - 1 ], swapAt [ - 1 ])","title":"801. Minimum Swaps To Make Sequences Increasing"},{"location":"problems/0801/#801-minimum-swaps-to-make-sequences-increasing","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minSwap ( vector < int >& A , vector < int >& B ) { vector < int > keepAt ( A . size (), INT_MAX ); vector < int > swapAt ( A . size (), INT_MAX ); keepAt [ 0 ] = 0 ; swapAt [ 0 ] = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ]) { keepAt [ i ] = keepAt [ i - 1 ]; swapAt [ i ] = swapAt [ i - 1 ] + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ]) { keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]); swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ); } } return min ( keepAt . back (), swapAt . back ()); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minSwap ( int [] A , int [] B ) { int keepAt = 0 ; int swapAt = 1 ; int prevKeepAt = 0 ; int prevSwapAt = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { keepAt = Integer . MAX_VALUE ; swapAt = Integer . MAX_VALUE ; if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ] ) { keepAt = prevKeepAt ; swapAt = prevSwapAt + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ] ) { keepAt = Math . min ( keepAt , prevSwapAt ); swapAt = Math . min ( swapAt , prevKeepAt + 1 ); } prevKeepAt = keepAt ; prevSwapAt = swapAt ; } return Math . min ( keepAt , swapAt ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minSwap ( self , A : List [ int ], B : List [ int ]) -> int : keepAt = [ float ( 'inf' )] * len ( A ) swapAt = [ float ( 'inf' )] * len ( A ) keepAt [ 0 ] = 0 swapAt [ 0 ] = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ] and B [ i ] > B [ i - 1 ]: keepAt [ i ] = keepAt [ i - 1 ] swapAt [ i ] = swapAt [ i - 1 ] + 1 if A [ i ] > B [ i - 1 ] and B [ i ] > A [ i - 1 ]: keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]) swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ) return min ( keepAt [ - 1 ], swapAt [ - 1 ])","title":"801. Minimum Swaps To Make Sequences Increasing"},{"location":"problems/0802/","text":"802. Find Eventual Safe States","title":"802. Find Eventual Safe States"},{"location":"problems/0802/#802-find-eventual-safe-states","text":"","title":"802. Find Eventual Safe States"},{"location":"problems/0803/","text":"803. Bricks Falling When Hit","title":"803. Bricks Falling When Hit"},{"location":"problems/0803/#803-bricks-falling-when-hit","text":"","title":"803. Bricks Falling When Hit"},{"location":"problems/0804/","text":"804. Unique Morse Code Words Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int uniqueMorseRepresentations ( vector < string >& words ) { vector < string > morse { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; unordered_set < string > transformations ; for ( const string & word : words ) { string transformation ; for ( char c : word ) transformation += morse [ c - 'a' ]; transformations . insert ( transformation ); } return transformations . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int uniqueMorseRepresentations ( String [] words ) { String [] morse = { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; Set < String > transformations = new HashSet <> (); for ( final String word : words ) { StringBuilder transformation = new StringBuilder (); for ( char c : word . toCharArray ()) transformation . append ( morse [ c - 'a' ] ); transformations . add ( transformation . toString ()); } return transformations . size (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniqueMorseRepresentations ( self , words : List [ str ]) -> int : morse = [ \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" ] transformations = set () for word in words : transformation = '' . join ( morse [ ord ( c ) - ord ( 'a' )] for c in word ) transformations . add ( transformation ) return len ( transformations )","title":"804. Unique Morse Code Words"},{"location":"problems/0804/#804-unique-morse-code-words","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int uniqueMorseRepresentations ( vector < string >& words ) { vector < string > morse { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; unordered_set < string > transformations ; for ( const string & word : words ) { string transformation ; for ( char c : word ) transformation += morse [ c - 'a' ]; transformations . insert ( transformation ); } return transformations . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int uniqueMorseRepresentations ( String [] words ) { String [] morse = { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; Set < String > transformations = new HashSet <> (); for ( final String word : words ) { StringBuilder transformation = new StringBuilder (); for ( char c : word . toCharArray ()) transformation . append ( morse [ c - 'a' ] ); transformations . add ( transformation . toString ()); } return transformations . size (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniqueMorseRepresentations ( self , words : List [ str ]) -> int : morse = [ \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" ] transformations = set () for word in words : transformation = '' . join ( morse [ ord ( c ) - ord ( 'a' )] for c in word ) transformations . add ( transformation ) return len ( transformations )","title":"804. Unique Morse Code Words"},{"location":"problems/0805/","text":"805. Split Array With Same Average Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool splitArraySameAverage ( vector < int >& A ) { const int n = A . size (); const int sum = accumulate ( begin ( A ), end ( A ), 0 ); if ( ! isPossible ( sum , n )) return false ; vector < unordered_set < int >> sums ( n / 2 + 1 ); sums [ 0 ]. insert ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums [ i - 1 ]) sums [ i ]. insert ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums [ i ]. count ( i * sum / n )) return true ; return false ; } private : bool isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public boolean splitArraySameAverage ( int [] A ) { final int n = A . length ; final int sum = Arrays . stream ( A ). sum (); if ( ! isPossible ( sum , n )) return false ; List < Set < Integer >> sums = new ArrayList <> (); for ( int i = 0 ; i < n / 2 + 1 ; ++ i ) sums . add ( new HashSet <> ()); sums . get ( 0 ). add ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums . get ( i - 1 )) sums . get ( i ). add ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums . get ( i ). contains ( i * sum / n )) return true ; return false ; } private boolean isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def splitArraySameAverage ( self , A : List [ int ]) -> bool : n = len ( A ) summ = sum ( A ) if not any ( i * summ % n == 0 for i in range ( 1 , n // 2 + 1 )): return False sums = [ set () for _ in range ( n // 2 + 1 )] sums [ 0 ] . add ( 0 ) for a in A : for i in range ( n // 2 , 0 , - 1 ): for val in sums [ i - 1 ]: sums [ i ] . add ( a + val ) for i in range ( 1 , n // 2 + 1 ): if i * summ % n == 0 and i * summ // n in sums [ i ]: return True return False","title":"805. Split Array With Same Average"},{"location":"problems/0805/#805-split-array-with-same-average","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool splitArraySameAverage ( vector < int >& A ) { const int n = A . size (); const int sum = accumulate ( begin ( A ), end ( A ), 0 ); if ( ! isPossible ( sum , n )) return false ; vector < unordered_set < int >> sums ( n / 2 + 1 ); sums [ 0 ]. insert ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums [ i - 1 ]) sums [ i ]. insert ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums [ i ]. count ( i * sum / n )) return true ; return false ; } private : bool isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public boolean splitArraySameAverage ( int [] A ) { final int n = A . length ; final int sum = Arrays . stream ( A ). sum (); if ( ! isPossible ( sum , n )) return false ; List < Set < Integer >> sums = new ArrayList <> (); for ( int i = 0 ; i < n / 2 + 1 ; ++ i ) sums . add ( new HashSet <> ()); sums . get ( 0 ). add ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums . get ( i - 1 )) sums . get ( i ). add ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums . get ( i ). contains ( i * sum / n )) return true ; return false ; } private boolean isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def splitArraySameAverage ( self , A : List [ int ]) -> bool : n = len ( A ) summ = sum ( A ) if not any ( i * summ % n == 0 for i in range ( 1 , n // 2 + 1 )): return False sums = [ set () for _ in range ( n // 2 + 1 )] sums [ 0 ] . add ( 0 ) for a in A : for i in range ( n // 2 , 0 , - 1 ): for val in sums [ i - 1 ]: sums [ i ] . add ( a + val ) for i in range ( 1 , n // 2 + 1 ): if i * summ % n == 0 and i * summ // n in sums [ i ]: return True return False","title":"805. Split Array With Same Average"},{"location":"problems/0806/","text":"806. Number of Lines To Write String","title":"806. Number of Lines To Write String"},{"location":"problems/0806/#806-number-of-lines-to-write-string","text":"","title":"806. Number of Lines To Write String"},{"location":"problems/0807/","text":"807. Max Increase to Keep City Skyline","title":"807. Max Increase to Keep City Skyline"},{"location":"problems/0807/#807-max-increase-to-keep-city-skyline","text":"","title":"807. Max Increase to Keep City Skyline"},{"location":"problems/0808/","text":"808. Soup Servings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : double soupServings ( int N ) { memo = vector < vector < double >> ( 4800 / 25 , vector < double > ( 4800 / 25 , 0 )); return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private : vector < vector < double >> memo ; double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ]; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public double soupServings ( int N ) { return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private double [][] memo = new double [ 192 ][ 192 ] ; private double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ] ; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def soupServings ( self , N : int ) -> float : def dfs ( a : int , b : int ) -> float : if a <= 0 and b <= 0 : return 0.5 if a <= 0 : return 1.0 if b <= 0 : return 0.0 if memo [ a ][ b ] > 0 : return memo [ a ][ b ] memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )) return memo [ a ][ b ] memo = [[ 0.0 ] * 192 for _ in range ( 192 )] return 1 if N >= 4800 else dfs (( N + 24 ) // 25 , ( N + 24 ) // 25 )","title":"808. Soup Servings"},{"location":"problems/0808/#808-soup-servings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : double soupServings ( int N ) { memo = vector < vector < double >> ( 4800 / 25 , vector < double > ( 4800 / 25 , 0 )); return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private : vector < vector < double >> memo ; double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ]; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public double soupServings ( int N ) { return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private double [][] memo = new double [ 192 ][ 192 ] ; private double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ] ; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def soupServings ( self , N : int ) -> float : def dfs ( a : int , b : int ) -> float : if a <= 0 and b <= 0 : return 0.5 if a <= 0 : return 1.0 if b <= 0 : return 0.0 if memo [ a ][ b ] > 0 : return memo [ a ][ b ] memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )) return memo [ a ][ b ] memo = [[ 0.0 ] * 192 for _ in range ( 192 )] return 1 if N >= 4800 else dfs (( N + 24 ) // 25 , ( N + 24 ) // 25 )","title":"808. Soup Servings"},{"location":"problems/0809/","text":"809. Expressive Words Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int expressiveWords ( string S , vector < string >& words ) { int ans = 0 ; for ( const string & word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private : bool isStretchy ( const string & S , const string & word ) { const int n = S . length (); const int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S [ i ] == word [ j ]) ++ j ; else if ( i > 1 && S [ i ] == S [ i - 1 ] && S [ i - 1 ] == S [ i - 2 ]) continue ; else if ( 0 < i && i + 1 < n && S [ i - 1 ] == S [ i ] && S [ i ] == S [ i + 1 ]) continue ; else return false ; return j == m ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int expressiveWords ( String S , String [] words ) { int ans = 0 ; for ( final String word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private boolean isStretchy ( final String S , final String word ) { final int n = S . length (); final int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S . charAt ( i ) == word . charAt ( j )) ++ j ; else if ( i > 1 && S . charAt ( i ) == S . charAt ( i - 1 ) && S . charAt ( i - 1 ) == S . charAt ( i - 2 )) continue ; else if ( 0 < i && i + 1 < n && S . charAt ( i - 1 ) == S . charAt ( i ) && S . charAt ( i ) == S . charAt ( i + 1 )) continue ; else return false ; return j == m ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def expressiveWords ( self , S : str , words : List [ str ]) -> int : def isStretchy ( word : str ) -> bool : n = len ( S ) m = len ( word ) j = 0 for i in range ( n ): if j < m and S [ i ] == word [ j ]: j += 1 elif i > 1 and S [ i ] == S [ i - 1 ] == S [ i - 2 ]: continue elif 0 < i < n - 1 and S [ i - 1 ] == S [ i ] == S [ i + 1 ]: continue else : return False return j == m return sum ( isStretchy ( word ) for word in words )","title":"809. Expressive Words"},{"location":"problems/0809/#809-expressive-words","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int expressiveWords ( string S , vector < string >& words ) { int ans = 0 ; for ( const string & word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private : bool isStretchy ( const string & S , const string & word ) { const int n = S . length (); const int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S [ i ] == word [ j ]) ++ j ; else if ( i > 1 && S [ i ] == S [ i - 1 ] && S [ i - 1 ] == S [ i - 2 ]) continue ; else if ( 0 < i && i + 1 < n && S [ i - 1 ] == S [ i ] && S [ i ] == S [ i + 1 ]) continue ; else return false ; return j == m ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int expressiveWords ( String S , String [] words ) { int ans = 0 ; for ( final String word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private boolean isStretchy ( final String S , final String word ) { final int n = S . length (); final int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S . charAt ( i ) == word . charAt ( j )) ++ j ; else if ( i > 1 && S . charAt ( i ) == S . charAt ( i - 1 ) && S . charAt ( i - 1 ) == S . charAt ( i - 2 )) continue ; else if ( 0 < i && i + 1 < n && S . charAt ( i - 1 ) == S . charAt ( i ) && S . charAt ( i ) == S . charAt ( i + 1 )) continue ; else return false ; return j == m ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def expressiveWords ( self , S : str , words : List [ str ]) -> int : def isStretchy ( word : str ) -> bool : n = len ( S ) m = len ( word ) j = 0 for i in range ( n ): if j < m and S [ i ] == word [ j ]: j += 1 elif i > 1 and S [ i ] == S [ i - 1 ] == S [ i - 2 ]: continue elif 0 < i < n - 1 and S [ i - 1 ] == S [ i ] == S [ i + 1 ]: continue else : return False return j == m return sum ( isStretchy ( word ) for word in words )","title":"809. Expressive Words"},{"location":"problems/0810/","text":"810. Chalkboard XOR Game Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool xorGame ( vector < int >& nums ) { int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor < int > ()); return xors == 0 || nums . size () % 2 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean xorGame ( int [] nums ) { int xors = 0 ; for ( int num : nums ) xors ^= num ; return xors == 0 || nums . length % 2 == 0 ; } } Python 1 2 3 4 5 6 7 8 class Solution : def xorGame ( self , nums : List [ int ]) -> bool : xors = 0 for num in nums : xors ^= num return xors == 0 or len ( nums ) % 2 == 0","title":"810. Chalkboard XOR Game"},{"location":"problems/0810/#810-chalkboard-xor-game","text":"Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool xorGame ( vector < int >& nums ) { int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor < int > ()); return xors == 0 || nums . size () % 2 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean xorGame ( int [] nums ) { int xors = 0 ; for ( int num : nums ) xors ^= num ; return xors == 0 || nums . length % 2 == 0 ; } } Python 1 2 3 4 5 6 7 8 class Solution : def xorGame ( self , nums : List [ int ]) -> bool : xors = 0 for num in nums : xors ^= num return xors == 0 or len ( nums ) % 2 == 0","title":"810. Chalkboard XOR Game"},{"location":"problems/0811/","text":"811. Subdomain Visit Count Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < string > subdomainVisits ( vector < string >& cpdomains ) { vector < string > ans ; unordered_map < string , int > count ; for ( const string & cpdomain : cpdomains ) { int space = cpdomain . find ( ' ' ); int num = stoi ( cpdomain . substr ( 0 , space )); string domain = cpdomain . substr ( space + 1 ); count [ domain ] += num ; for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain [ i ] == '.' ) count [ domain . substr ( i + 1 )] += num ; } for ( const auto & [ subdomain , freq ] : count ) ans . push_back ( to_string ( freq ) + ' ' + subdomain ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < String > subdomainVisits ( String [] cpdomains ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String cpdomain : cpdomains ) { int space = cpdomain . indexOf ( ' ' ); int num = Integer . valueOf ( cpdomain . substring ( 0 , space )); String domain = cpdomain . substring ( space + 1 ); count . put ( domain , count . getOrDefault ( domain , 0 ) + num ); for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain . charAt ( i ) == '.' ) { String subdomain = domain . substring ( i + 1 ); count . put ( subdomain , count . getOrDefault ( subdomain , 0 ) + num ); } } for ( final String subdomain : count . keySet ()) ans . add ( String . valueOf ( count . get ( subdomain )) + ' ' + subdomain ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subdomainVisits ( self , cpdomains : List [ str ]) -> List [ str ]: ans = [] count = collections . Counter () for cpdomain in cpdomains : num , domains = cpdomain . split () num , domains = int ( num ), domains . split ( '.' ) for i in range ( len ( domains ))[:: - 1 ]: count [ '.' . join ( domains [ i :])] += num return [ str ( freq ) + ' ' + domain for domain , freq in count . items ()]","title":"811. Subdomain Visit Count"},{"location":"problems/0811/#811-subdomain-visit-count","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < string > subdomainVisits ( vector < string >& cpdomains ) { vector < string > ans ; unordered_map < string , int > count ; for ( const string & cpdomain : cpdomains ) { int space = cpdomain . find ( ' ' ); int num = stoi ( cpdomain . substr ( 0 , space )); string domain = cpdomain . substr ( space + 1 ); count [ domain ] += num ; for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain [ i ] == '.' ) count [ domain . substr ( i + 1 )] += num ; } for ( const auto & [ subdomain , freq ] : count ) ans . push_back ( to_string ( freq ) + ' ' + subdomain ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public List < String > subdomainVisits ( String [] cpdomains ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String cpdomain : cpdomains ) { int space = cpdomain . indexOf ( ' ' ); int num = Integer . valueOf ( cpdomain . substring ( 0 , space )); String domain = cpdomain . substring ( space + 1 ); count . put ( domain , count . getOrDefault ( domain , 0 ) + num ); for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain . charAt ( i ) == '.' ) { String subdomain = domain . substring ( i + 1 ); count . put ( subdomain , count . getOrDefault ( subdomain , 0 ) + num ); } } for ( final String subdomain : count . keySet ()) ans . add ( String . valueOf ( count . get ( subdomain )) + ' ' + subdomain ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subdomainVisits ( self , cpdomains : List [ str ]) -> List [ str ]: ans = [] count = collections . Counter () for cpdomain in cpdomains : num , domains = cpdomain . split () num , domains = int ( num ), domains . split ( '.' ) for i in range ( len ( domains ))[:: - 1 ]: count [ '.' . join ( domains [ i :])] += num return [ str ( freq ) + ' ' + domain for domain , freq in count . items ()]","title":"811. Subdomain Visit Count"},{"location":"problems/0812/","text":"812. Largest Triangle Area Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double largestTriangleArea ( vector < vector < int >>& points ) { double ans = 0 ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) for ( vector < int >& C : points ) ans = max ( ans , 0.5 * abs (( B [ 0 ] - A [ 0 ]) * ( C [ 1 ] - A [ 1 ]) - ( C [ 0 ] - A [ 0 ]) * ( B [ 1 ] - A [ 1 ]))); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public double largestTriangleArea ( int [][] points ) { double ans = 0 ; for ( int [] A : points ) for ( int [] B : points ) for ( int [] C : points ) ans = Math . max ( ans , 0.5 * Math . abs (( B [ 0 ] - A [ 0 ] ) * ( C [ 1 ] - A [ 1 ] ) - ( C [ 0 ] - A [ 0 ] ) * ( B [ 1 ] - A [ 1 ] ))); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def largestTriangleArea ( self , points : List [ List [ int ]]) -> float : ans = 0 for Ax , Ay in points : for Bx , By in points : for Cx , Cy in points : ans = max ( ans , 0.5 * abs (( Bx - Ax ) * ( Cy - Ay ) - ( Cx - Ax ) * ( By - Ay ))) return ans","title":"812. Largest Triangle Area"},{"location":"problems/0812/#812-largest-triangle-area","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double largestTriangleArea ( vector < vector < int >>& points ) { double ans = 0 ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) for ( vector < int >& C : points ) ans = max ( ans , 0.5 * abs (( B [ 0 ] - A [ 0 ]) * ( C [ 1 ] - A [ 1 ]) - ( C [ 0 ] - A [ 0 ]) * ( B [ 1 ] - A [ 1 ]))); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public double largestTriangleArea ( int [][] points ) { double ans = 0 ; for ( int [] A : points ) for ( int [] B : points ) for ( int [] C : points ) ans = Math . max ( ans , 0.5 * Math . abs (( B [ 0 ] - A [ 0 ] ) * ( C [ 1 ] - A [ 1 ] ) - ( C [ 0 ] - A [ 0 ] ) * ( B [ 1 ] - A [ 1 ] ))); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def largestTriangleArea ( self , points : List [ List [ int ]]) -> float : ans = 0 for Ax , Ay in points : for Bx , By in points : for Cx , Cy in points : ans = max ( ans , 0.5 * abs (( Bx - Ax ) * ( Cy - Ay ) - ( Cx - Ax ) * ( By - Ay ))) return ans","title":"812. Largest Triangle Area"},{"location":"problems/0813/","text":"813. Largest Sum of Averages Approach 1: Bottom-up Time: $O(Kn^2)$ Space: $O(Kn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); // dp[i][k] := largest score to partition first i nums into k groups vector < vector < double >> dp ( n + 1 , vector < double > ( K + 1 , 0.0 )); vector < double > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + A [ i - 1 ]; dp [ i ][ 1 ] = prefixSum [ i ] / i ; } for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) { const double average = ( prefixSum [ i ] - prefixSum [ j ]) / ( i - j ); dp [ i ][ k ] = max ( dp [ i ][ k ], dp [ j ][ k - 1 ] + average ); } return dp [ n ][ K ]; } }; Approach 2: Top-down Time: $O(Kn^2)$ Space: $O(Kn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); vector < vector < double >> memo ( n + 1 , vector < double > ( K + 1 , 0.0 )); vector < double > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + A [ i - 1 ]; // dp(n, K) := largest score to partition A[0..i) into k groups function < double ( int , int ) > dp = [ & ]( int n , int K ) { if ( K == 1 ) return prefixSum [ n ] / n ; double & ans = memo [ n ][ K ]; if ( ans > 0.0 ) return ans ; // try all possible partitions for ( int i = K - 1 ; i < n ; ++ i ) ans = max ( ans , dp ( i , K - 1 ) + ( prefixSum [ n ] - prefixSum [ i ]) / ( n - i )); return ans ; }; return dp ( n , K ); } };","title":"813. Largest Sum of Averages"},{"location":"problems/0813/#813-largest-sum-of-averages","text":"","title":"813. Largest Sum of Averages"},{"location":"problems/0813/#approach-1-bottom-up","text":"Time: $O(Kn^2)$ Space: $O(Kn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); // dp[i][k] := largest score to partition first i nums into k groups vector < vector < double >> dp ( n + 1 , vector < double > ( K + 1 , 0.0 )); vector < double > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] += prefixSum [ i - 1 ] + A [ i - 1 ]; dp [ i ][ 1 ] = prefixSum [ i ] / i ; } for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) { const double average = ( prefixSum [ i ] - prefixSum [ j ]) / ( i - j ); dp [ i ][ k ] = max ( dp [ i ][ k ], dp [ j ][ k - 1 ] + average ); } return dp [ n ][ K ]; } };","title":"Approach 1: Bottom-up"},{"location":"problems/0813/#approach-2-top-down","text":"Time: $O(Kn^2)$ Space: $O(Kn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); vector < vector < double >> memo ( n + 1 , vector < double > ( K + 1 , 0.0 )); vector < double > prefixSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + A [ i - 1 ]; // dp(n, K) := largest score to partition A[0..i) into k groups function < double ( int , int ) > dp = [ & ]( int n , int K ) { if ( K == 1 ) return prefixSum [ n ] / n ; double & ans = memo [ n ][ K ]; if ( ans > 0.0 ) return ans ; // try all possible partitions for ( int i = K - 1 ; i < n ; ++ i ) ans = max ( ans , dp ( i , K - 1 ) + ( prefixSum [ n ] - prefixSum [ i ]) / ( n - i )); return ans ; }; return dp ( n , K ); } };","title":"Approach 2: Top-down"},{"location":"problems/0814/","text":"814. Binary Tree Pruning","title":"814. Binary Tree Pruning"},{"location":"problems/0814/#814-binary-tree-pruning","text":"","title":"814. Binary Tree Pruning"},{"location":"problems/0815/","text":"815. Bus Routes","title":"815. Bus Routes"},{"location":"problems/0815/#815-bus-routes","text":"","title":"815. Bus Routes"},{"location":"problems/0816/","text":"816. Ambiguous Coordinates Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > ambiguousCoordinates ( string S ) { vector < string > ans ; S = S . substr ( 1 , S . length () - 2 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( const string & x : splits ( S . substr ( 0 , i ))) for ( const string & y : splits ( S . substr ( i ))) ans . push_back ( '(' + x + \", \" + y + ')' ); return ans ; } private : vector < string > splits ( const string S ) { if ( S . empty () || S . length () > 1 && S . front () == '0' && S . back () == '0' ) return {}; if ( S . back () == '0' ) return { S }; if ( S . front () == '0' ) return { \"0.\" + S . substr ( 1 )}; vector < string > candidates { S }; for ( int i = 1 ; i < S . length (); ++ i ) candidates . push_back ( S . substr ( 0 , i ) + '.' + S . substr ( i )); return candidates ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > ambiguousCoordinates ( String S ) { List < String > ans = new ArrayList <> (); S = S . substring ( 1 , S . length () - 1 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( final String x : splits ( S . substring ( 0 , i ))) for ( final String y : splits ( S . substring ( i ))) ans . add ( \"(\" + x + \", \" + y + \")\" ); return ans ; } private List < String > splits ( final String S ) { if ( S . isEmpty () || S . length () > 1 && S . charAt ( 0 ) == '0' && S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> (); if ( S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> ( Arrays . asList ( S )); if ( S . charAt ( 0 ) == '0' ) return new ArrayList <> ( Arrays . asList ( \"0.\" + S . substring ( 1 ))); List < String > res = new ArrayList <> (); res . add ( S ); for ( int i = 1 ; i < S . length (); ++ i ) res . add ( S . substring ( 0 , i ) + \".\" + S . substring ( i )); return res ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def ambiguousCoordinates ( self , S : str ) -> List [ str ]: def splits ( S : str ) -> List [ str ]: if not S or len ( S ) > 1 and S [ 0 ] == S [ - 1 ] == '0' : return [] if S [ - 1 ] == '0' : return [ S ] if S [ 0 ] == '0' : return [ S [ 0 ] + '.' + S [ 1 :]] return [ S ] + [ S [: i ] + '.' + S [ i :] for i in range ( 1 , len ( S ))] ans = [] S = S [ 1 : - 1 ] for i in range ( 1 , len ( S )): for x in splits ( S [: i ]): for y in splits ( S [ i :]): ans . append ( '( %s , %s )' % ( x , y )) return ans","title":"816. Ambiguous Coordinates"},{"location":"problems/0816/#816-ambiguous-coordinates","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > ambiguousCoordinates ( string S ) { vector < string > ans ; S = S . substr ( 1 , S . length () - 2 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( const string & x : splits ( S . substr ( 0 , i ))) for ( const string & y : splits ( S . substr ( i ))) ans . push_back ( '(' + x + \", \" + y + ')' ); return ans ; } private : vector < string > splits ( const string S ) { if ( S . empty () || S . length () > 1 && S . front () == '0' && S . back () == '0' ) return {}; if ( S . back () == '0' ) return { S }; if ( S . front () == '0' ) return { \"0.\" + S . substr ( 1 )}; vector < string > candidates { S }; for ( int i = 1 ; i < S . length (); ++ i ) candidates . push_back ( S . substr ( 0 , i ) + '.' + S . substr ( i )); return candidates ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < String > ambiguousCoordinates ( String S ) { List < String > ans = new ArrayList <> (); S = S . substring ( 1 , S . length () - 1 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( final String x : splits ( S . substring ( 0 , i ))) for ( final String y : splits ( S . substring ( i ))) ans . add ( \"(\" + x + \", \" + y + \")\" ); return ans ; } private List < String > splits ( final String S ) { if ( S . isEmpty () || S . length () > 1 && S . charAt ( 0 ) == '0' && S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> (); if ( S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> ( Arrays . asList ( S )); if ( S . charAt ( 0 ) == '0' ) return new ArrayList <> ( Arrays . asList ( \"0.\" + S . substring ( 1 ))); List < String > res = new ArrayList <> (); res . add ( S ); for ( int i = 1 ; i < S . length (); ++ i ) res . add ( S . substring ( 0 , i ) + \".\" + S . substring ( i )); return res ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def ambiguousCoordinates ( self , S : str ) -> List [ str ]: def splits ( S : str ) -> List [ str ]: if not S or len ( S ) > 1 and S [ 0 ] == S [ - 1 ] == '0' : return [] if S [ - 1 ] == '0' : return [ S ] if S [ 0 ] == '0' : return [ S [ 0 ] + '.' + S [ 1 :]] return [ S ] + [ S [: i ] + '.' + S [ i :] for i in range ( 1 , len ( S ))] ans = [] S = S [ 1 : - 1 ] for i in range ( 1 , len ( S )): for x in splits ( S [: i ]): for y in splits ( S [ i :]): ans . append ( '( %s , %s )' % ( x , y )) return ans","title":"816. Ambiguous Coordinates"},{"location":"problems/0817/","text":"817. Linked List Components Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > setG { begin ( G ), end ( G )}; for (; head ; head = head -> next ) if ( setG . count ( head -> val ) && ( ! head -> next || ! setG . count ( head -> next -> val ))) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numComponents ( ListNode head , int [] G ) { int ans = 0 ; Set < Integer > setG = new HashSet <> (); for ( int g : G ) setG . add ( g ); for (; head != null ; head = head . next ) if ( setG . contains ( head . val ) && ( head . next == null || ! setG . contains ( head . next . val ))) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numComponents ( self , head : ListNode , G : List [ int ]) -> int : ans = 0 G = set ( G ) while head : if head . val in G and ( head . next == None or head . next . val not in G ): ans += 1 head = head . next return ans","title":"817. Linked List Components"},{"location":"problems/0817/#817-linked-list-components","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > setG { begin ( G ), end ( G )}; for (; head ; head = head -> next ) if ( setG . count ( head -> val ) && ( ! head -> next || ! setG . count ( head -> next -> val ))) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numComponents ( ListNode head , int [] G ) { int ans = 0 ; Set < Integer > setG = new HashSet <> (); for ( int g : G ) setG . add ( g ); for (; head != null ; head = head . next ) if ( setG . contains ( head . val ) && ( head . next == null || ! setG . contains ( head . next . val ))) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numComponents ( self , head : ListNode , G : List [ int ]) -> int : ans = 0 G = set ( G ) while head : if head . val in G and ( head . next == None or head . next . val not in G ): ans += 1 head = head . next return ans","title":"817. Linked List Components"},{"location":"problems/0818/","text":"818. Race Car","title":"818. Race Car"},{"location":"problems/0818/#818-race-car","text":"","title":"818. Race Car"},{"location":"problems/0819/","text":"819. Most Common Word Time: $O(|paragraph|)$ Space: $O(|paragraph| + |banned|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string mostCommonWord ( string paragraph , vector < string >& banned ) { string ans ; int maxCount = 0 ; unordered_map < string , int > count ; unordered_set < string > bannedSet { begin ( banned ), end ( banned )}; // make paragraph to lowercase and empty punctuations for ( char & c : paragraph ) c = isalpha ( c ) ? tolower ( c ) : ' ' ; istringstream iss ( paragraph ); for ( string word ; iss >> word ;) if ( ! bannedSet . count ( word )) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) if ( freq > maxCount ) { maxCount = freq ; ans = word ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String mostCommonWord ( String paragraph , String [] banned ) { Pair < String , Integer > ans = new Pair <> ( \"\" , 0 ); Set < String > bannedSet = new HashSet <> ( Arrays . asList ( banned )); Map < String , Integer > count = new HashMap <> (); String [] words = paragraph . replaceAll ( \"\\\\W+\" , \" \" ). toLowerCase (). split ( \"\\\\s+\" ); for ( final String word : words ) if ( ! bannedSet . contains ( word )) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); if ( count . get ( word ) > ans . getValue ()) ans = new Pair <> ( word , count . get ( word )); } return ans . getKey (); } } Python 1 2 3 4 5 class Solution : def mostCommonWord ( self , paragraph : str , banned : List [ str ]) -> str : banned = set ( banned ) words = re . findall ( r '\\w+' , paragraph . lower ()) return collections . Counter ( word for word in words if word not in banned ) . most_common ( 1 )[ 0 ][ 0 ]","title":"819. Most Common Word"},{"location":"problems/0819/#819-most-common-word","text":"Time: $O(|paragraph|)$ Space: $O(|paragraph| + |banned|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string mostCommonWord ( string paragraph , vector < string >& banned ) { string ans ; int maxCount = 0 ; unordered_map < string , int > count ; unordered_set < string > bannedSet { begin ( banned ), end ( banned )}; // make paragraph to lowercase and empty punctuations for ( char & c : paragraph ) c = isalpha ( c ) ? tolower ( c ) : ' ' ; istringstream iss ( paragraph ); for ( string word ; iss >> word ;) if ( ! bannedSet . count ( word )) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) if ( freq > maxCount ) { maxCount = freq ; ans = word ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String mostCommonWord ( String paragraph , String [] banned ) { Pair < String , Integer > ans = new Pair <> ( \"\" , 0 ); Set < String > bannedSet = new HashSet <> ( Arrays . asList ( banned )); Map < String , Integer > count = new HashMap <> (); String [] words = paragraph . replaceAll ( \"\\\\W+\" , \" \" ). toLowerCase (). split ( \"\\\\s+\" ); for ( final String word : words ) if ( ! bannedSet . contains ( word )) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); if ( count . get ( word ) > ans . getValue ()) ans = new Pair <> ( word , count . get ( word )); } return ans . getKey (); } } Python 1 2 3 4 5 class Solution : def mostCommonWord ( self , paragraph : str , banned : List [ str ]) -> str : banned = set ( banned ) words = re . findall ( r '\\w+' , paragraph . lower ()) return collections . Counter ( word for word in words if word not in banned ) . most_common ( 1 )[ 0 ][ 0 ]","title":"819. Most Common Word"},{"location":"problems/0820/","text":"820. Short Encoding of Words","title":"820. Short Encoding of Words"},{"location":"problems/0820/#820-short-encoding-of-words","text":"","title":"820. Short Encoding of Words"},{"location":"problems/0821/","text":"821. Shortest Distance to a Character","title":"821. Shortest Distance to a Character"},{"location":"problems/0821/#821-shortest-distance-to-a-character","text":"","title":"821. Shortest Distance to a Character"},{"location":"problems/0822/","text":"822. Card Flipping Game","title":"822. Card Flipping Game"},{"location":"problems/0822/#822-card-flipping-game","text":"","title":"822. Card Flipping Game"},{"location":"problems/0823/","text":"823. Binary Trees With Factors","title":"823. Binary Trees With Factors"},{"location":"problems/0823/#823-binary-trees-with-factors","text":"","title":"823. Binary Trees With Factors"},{"location":"problems/0824/","text":"824. Goat Latin Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string toGoatLatin ( string S ) { string ans ; unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; istringstream iss ( S ); string word ; int i = 1 ; while ( iss >> word ) { if ( i > 1 ) ans += ' ' ; if ( vowels . count ( word [ 0 ])) ans += word ; else ans += word . substr ( 1 ) + word [ 0 ]; ans += \"ma\" + string ( i ++ , 'a' ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public String toGoatLatin ( String S ) { String ans = \"\" ; String vowels = \"aeiouAEIOU\" ; String [] words = S . split ( \" \" ); int i = 1 ; for ( final String word : words ) { if ( i > 1 ) ans += \" \" ; if ( vowels . contains ( \"\" + word . charAt ( 0 ))) ans += word ; else ans += word . substring ( 1 ) + word . charAt ( 0 ); ans += \"ma\" + new String ( new char [ i ++] ). replace ( '\\0' , 'a' ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def toGoatLatin ( self , S : str ) -> str : ans = '' vowels = 'aeiouAEIOU' words = S . split () i = 1 for word in words : if i > 1 : ans += ' ' if word [ 0 ] in vowels : ans += word else : ans += word [ 1 :] + word [ 0 ] ans += 'ma' + 'a' * i i += 1 return ans","title":"824. Goat Latin"},{"location":"problems/0824/#824-goat-latin","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string toGoatLatin ( string S ) { string ans ; unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; istringstream iss ( S ); string word ; int i = 1 ; while ( iss >> word ) { if ( i > 1 ) ans += ' ' ; if ( vowels . count ( word [ 0 ])) ans += word ; else ans += word . substr ( 1 ) + word [ 0 ]; ans += \"ma\" + string ( i ++ , 'a' ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public String toGoatLatin ( String S ) { String ans = \"\" ; String vowels = \"aeiouAEIOU\" ; String [] words = S . split ( \" \" ); int i = 1 ; for ( final String word : words ) { if ( i > 1 ) ans += \" \" ; if ( vowels . contains ( \"\" + word . charAt ( 0 ))) ans += word ; else ans += word . substring ( 1 ) + word . charAt ( 0 ); ans += \"ma\" + new String ( new char [ i ++] ). replace ( '\\0' , 'a' ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def toGoatLatin ( self , S : str ) -> str : ans = '' vowels = 'aeiouAEIOU' words = S . split () i = 1 for word in words : if i > 1 : ans += ' ' if word [ 0 ] in vowels : ans += word else : ans += word [ 1 :] + word [ 0 ] ans += 'ma' + 'a' * i i += 1 return ans","title":"824. Goat Latin"},{"location":"problems/0825/","text":"825. Friends Of Appropriate Ages Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int age : ages ) ++ count [ age ]; for ( const auto & [ ageA , countA ] : count ) for ( const auto & [ ageB , countB ] : count ) if ( request ( ageA , ageB )) if ( ageA == ageB ) ans += countA * ( countB - 1 ); else ans += countA * countB ; return ans ; } private : bool request ( int ageA , int ageB ) { return ! ( ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ] ; for ( int age : ages ) ++ count [ age ] ; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans","title":"825. Friends Of Appropriate Ages"},{"location":"problems/0825/#825-friends-of-appropriate-ages","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; unordered_map < int , int > count ; for ( const int age : ages ) ++ count [ age ]; for ( const auto & [ ageA , countA ] : count ) for ( const auto & [ ageB , countB ] : count ) if ( request ( ageA , ageB )) if ( ageA == ageB ) ans += countA * ( countB - 1 ); else ans += countA * countB ; return ans ; } private : bool request ( int ageA , int ageB ) { return ! ( ageB <= 0.5 * ageA + 7 || ageB > ageA || ageB > 100 && ageA < 100 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ] ; for ( int age : ages ) ++ count [ age ] ; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans","title":"825. Friends Of Appropriate Ages"},{"location":"problems/0826/","text":"826. Most Profit Assigning Work Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxProfitAssignment ( vector < int >& difficulty , vector < int >& profit , vector < int >& worker ) { int ans = 0 ; vector < pair < int , int >> jobs ; for ( int i = 0 ; i < difficulty . size (); ++ i ) jobs . push_back ({ difficulty [ i ], profit [ i ]}); sort ( begin ( jobs ), end ( jobs )); sort ( begin ( worker ), end ( worker )); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs [ i ]. first ; ++ i ) maxProfit = max ( maxProfit , jobs [ i ]. second ); ans += maxProfit ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProfitAssignment ( int [] difficulty , int [] profit , int [] worker ) { int ans = 0 ; List < Pair < Integer , Integer >> jobs = new ArrayList <> (); for ( int i = 0 ; i < difficulty . length ; ++ i ) jobs . add ( new Pair <> ( difficulty [ i ] , profit [ i ] )); Collections . sort ( jobs , Comparator . comparing ( Pair :: getKey )); Arrays . sort ( worker ); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs . get ( i ). getKey (); ++ i ) maxProfit = Math . max ( maxProfit , jobs . get ( i ). getValue ()); ans += maxProfit ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxProfitAssignment ( self , difficulty : List [ int ], profit : List [ int ], worker : List [ int ]) -> int : ans = 0 jobs = sorted ( zip ( difficulty , profit )) worker . sort ( reverse = 1 ) i = 0 maxProfit = 0 for w in sorted ( worker ): while i < len ( jobs ) and w >= jobs [ i ][ 0 ]: maxProfit = max ( maxProfit , jobs [ i ][ 1 ]) i += 1 ans += maxProfit return ans","title":"826. Most Profit Assigning Work"},{"location":"problems/0826/#826-most-profit-assigning-work","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxProfitAssignment ( vector < int >& difficulty , vector < int >& profit , vector < int >& worker ) { int ans = 0 ; vector < pair < int , int >> jobs ; for ( int i = 0 ; i < difficulty . size (); ++ i ) jobs . push_back ({ difficulty [ i ], profit [ i ]}); sort ( begin ( jobs ), end ( jobs )); sort ( begin ( worker ), end ( worker )); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs [ i ]. first ; ++ i ) maxProfit = max ( maxProfit , jobs [ i ]. second ); ans += maxProfit ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProfitAssignment ( int [] difficulty , int [] profit , int [] worker ) { int ans = 0 ; List < Pair < Integer , Integer >> jobs = new ArrayList <> (); for ( int i = 0 ; i < difficulty . length ; ++ i ) jobs . add ( new Pair <> ( difficulty [ i ] , profit [ i ] )); Collections . sort ( jobs , Comparator . comparing ( Pair :: getKey )); Arrays . sort ( worker ); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs . get ( i ). getKey (); ++ i ) maxProfit = Math . max ( maxProfit , jobs . get ( i ). getValue ()); ans += maxProfit ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxProfitAssignment ( self , difficulty : List [ int ], profit : List [ int ], worker : List [ int ]) -> int : ans = 0 jobs = sorted ( zip ( difficulty , profit )) worker . sort ( reverse = 1 ) i = 0 maxProfit = 0 for w in sorted ( worker ): while i < len ( jobs ) and w >= jobs [ i ][ 0 ]: maxProfit = max ( maxProfit , jobs [ i ][ 1 ]) i += 1 ans += maxProfit return ans","title":"826. Most Profit Assigning Work"},{"location":"problems/0827/","text":"827. Making A Large Island Time: $O(n^2)$ Space: $O(|\\text{connected islands}|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int largestIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > sizes { 0 , 0 }; // sizes[i] := the size of i-th island // get the number of grid[i][j] auto getNum = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; // invalid return grid [ i ][ j ]; }; function < int ( int , int , int ) > paint = [ & ]( int i , int j , int color ) { if ( getNum ( i , j ) != 1 ) return 0 ; grid [ i ][ j ] = color ; return paint ( i + 1 , j , color ) + paint ( i - 1 , j , color ) + paint ( i , j + 1 , color ) + paint ( i , j - 1 , color ) + 1 ; }; // For each 1 in the grid, paint all connected 1 with the next available // color (2, 3, and so on). Also, remember the size of the island we just // painted with that color. for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) sizes . push_back ( paint ( i , j , sizes . size ())); // paint 2, 3, ... for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 0 ) { const unordered_set < int > nums { getNum ( i + 1 , j ), getNum ( i - 1 , j ), getNum ( i , j + 1 ), getNum ( i , j - 1 )}; ans = max ( ans , getConnectedSize ( nums , sizes ) + 1 ); } return ans == 0 ? m * n : ans ; } private : int getConnectedSize ( const unordered_set < int >& nums , const vector < int >& sizes ) { int size = 0 ; for ( const int num : nums ) size += sizes [ num ]; return size ; } };","title":"827. Making A Large Island"},{"location":"problems/0827/#827-making-a-large-island","text":"Time: $O(n^2)$ Space: $O(|\\text{connected islands}|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int largestIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > sizes { 0 , 0 }; // sizes[i] := the size of i-th island // get the number of grid[i][j] auto getNum = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; // invalid return grid [ i ][ j ]; }; function < int ( int , int , int ) > paint = [ & ]( int i , int j , int color ) { if ( getNum ( i , j ) != 1 ) return 0 ; grid [ i ][ j ] = color ; return paint ( i + 1 , j , color ) + paint ( i - 1 , j , color ) + paint ( i , j + 1 , color ) + paint ( i , j - 1 , color ) + 1 ; }; // For each 1 in the grid, paint all connected 1 with the next available // color (2, 3, and so on). Also, remember the size of the island we just // painted with that color. for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) sizes . push_back ( paint ( i , j , sizes . size ())); // paint 2, 3, ... for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 0 ) { const unordered_set < int > nums { getNum ( i + 1 , j ), getNum ( i - 1 , j ), getNum ( i , j + 1 ), getNum ( i , j - 1 )}; ans = max ( ans , getConnectedSize ( nums , sizes ) + 1 ); } return ans == 0 ? m * n : ans ; } private : int getConnectedSize ( const unordered_set < int >& nums , const vector < int >& sizes ) { int size = 0 ; for ( const int num : nums ) size += sizes [ num ]; return size ; } };","title":"827. Making A Large Island"},{"location":"problems/0828/","text":"828. Count Unique Characters of All Substrings of a Given String Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniqueLetterString ( string s ) { int ans = 0 ; int count = 0 ; vector < int > lastCount ( 26 ); vector < int > lastSeen ( 26 , -1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s [ i ] - 'A' ; int currentCount = i - lastSeen [ c ]; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int uniqueLetterString ( String s ) { int ans = 0 ; int count = 0 ; int [] lastCount = new int [ 26 ] ; int [] lastSeen = new int [ 26 ] ; Arrays . fill ( lastSeen , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s . charAt ( i ) - 'A' ; int currentCount = i - lastSeen [ c ] ; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniqueLetterString ( self , s : str ) -> int : ans = 0 count = 0 lastCount = [ 0 ] * 26 lastSeen = [ - 1 ] * 26 for i , c in enumerate ( s ): c = ord ( c ) - ord ( 'A' ) currentCount = i - lastSeen [ c ] count = count - lastCount [ c ] + currentCount lastCount [ c ] = currentCount lastSeen [ c ] = i ans += count return ans","title":"828. Count Unique Characters of All Substrings of a Given String"},{"location":"problems/0828/#828-count-unique-characters-of-all-substrings-of-a-given-string","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniqueLetterString ( string s ) { int ans = 0 ; int count = 0 ; vector < int > lastCount ( 26 ); vector < int > lastSeen ( 26 , -1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s [ i ] - 'A' ; int currentCount = i - lastSeen [ c ]; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int uniqueLetterString ( String s ) { int ans = 0 ; int count = 0 ; int [] lastCount = new int [ 26 ] ; int [] lastSeen = new int [ 26 ] ; Arrays . fill ( lastSeen , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s . charAt ( i ) - 'A' ; int currentCount = i - lastSeen [ c ] ; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniqueLetterString ( self , s : str ) -> int : ans = 0 count = 0 lastCount = [ 0 ] * 26 lastSeen = [ - 1 ] * 26 for i , c in enumerate ( s ): c = ord ( c ) - ord ( 'A' ) currentCount = i - lastSeen [ c ] count = count - lastCount [ c ] + currentCount lastCount [ c ] = currentCount lastSeen [ c ] = i ans += count return ans","title":"828. Count Unique Characters of All Substrings of a Given String"},{"location":"problems/0829/","text":"829. Consecutive Numbers Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def consecutiveNumbersSum ( self , N : int ) -> int : ans = 0 i = 1 triangleNum = 1 while triangleNum <= N : if ( N - triangleNum ) % i == 0 : ans += 1 i += 1 triangleNum += i return ans","title":"829. Consecutive Numbers Sum"},{"location":"problems/0829/#829-consecutive-numbers-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def consecutiveNumbersSum ( self , N : int ) -> int : ans = 0 i = 1 triangleNum = 1 while triangleNum <= N : if ( N - triangleNum ) % i == 0 : ans += 1 i += 1 triangleNum += i return ans","title":"829. Consecutive Numbers Sum"},{"location":"problems/0830/","text":"830. Positions of Large Groups Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) ++ j ; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"830. Positions of Large Groups"},{"location":"problems/0830/#830-positions-of-large-groups","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) ++ j ; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"830. Positions of Large Groups"},{"location":"problems/0831/","text":"831. Masking Personal Information Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string maskPII ( string S ) { int atIndex = S . find ( '@' ); if ( atIndex != string :: npos ) { transform ( begin ( S ), end ( S ), begin ( S ), :: tolower ); return S . substr ( 0 , 1 ) + \"*****\" + S . substr ( atIndex - 1 ); } string ans ; for ( char c : S ) if ( isdigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substr ( ans . length () - 4 ); return '+' + string ( ans . length () - 10 , '*' ) + \"-***-***-\" + ans . substr ( ans . length () - 4 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String maskPII ( String S ) { int atIndex = S . indexOf ( '@' ); if ( atIndex > 0 ) { S = S . toLowerCase (); return S . charAt ( 0 ) + \"*****\" + S . substring ( atIndex - 1 ); } String ans = \"\" ; for ( char c : S . toCharArray ()) if ( Character . isDigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substring ( ans . length () - 4 ); return '+' + new String ( new char [ ans . length () - 10 ] ). replace ( '\\0' , '*' ) + \"-***-***-\" + ans . substring ( ans . length () - 4 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def maskPII ( self , S : str ) -> str : atIndex = S . find ( '@' ) if atIndex != - 1 : S = S . lower () return S [ 0 ] + '*' * 5 + S [ atIndex - 1 :] ans = '' . join ( c for c in S if c . isdigit ()) if len ( ans ) == 10 : return '***-***-' + ans [ - 4 :] return '+' + '*' * ( len ( ans ) - 10 ) + '-***-***-' + ans [ - 4 :]","title":"831. Masking Personal Information"},{"location":"problems/0831/#831-masking-personal-information","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string maskPII ( string S ) { int atIndex = S . find ( '@' ); if ( atIndex != string :: npos ) { transform ( begin ( S ), end ( S ), begin ( S ), :: tolower ); return S . substr ( 0 , 1 ) + \"*****\" + S . substr ( atIndex - 1 ); } string ans ; for ( char c : S ) if ( isdigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substr ( ans . length () - 4 ); return '+' + string ( ans . length () - 10 , '*' ) + \"-***-***-\" + ans . substr ( ans . length () - 4 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String maskPII ( String S ) { int atIndex = S . indexOf ( '@' ); if ( atIndex > 0 ) { S = S . toLowerCase (); return S . charAt ( 0 ) + \"*****\" + S . substring ( atIndex - 1 ); } String ans = \"\" ; for ( char c : S . toCharArray ()) if ( Character . isDigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substring ( ans . length () - 4 ); return '+' + new String ( new char [ ans . length () - 10 ] ). replace ( '\\0' , '*' ) + \"-***-***-\" + ans . substring ( ans . length () - 4 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def maskPII ( self , S : str ) -> str : atIndex = S . find ( '@' ) if atIndex != - 1 : S = S . lower () return S [ 0 ] + '*' * 5 + S [ atIndex - 1 :] ans = '' . join ( c for c in S if c . isdigit ()) if len ( ans ) == 10 : return '***-***-' + ans [ - 4 :] return '+' + '*' * ( len ( ans ) - 10 ) + '-***-***-' + ans [ - 4 :]","title":"831. Masking Personal Information"},{"location":"problems/0832/","text":"832. Flipping an Image Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ] ; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } } Python 1 2 3 4 5 6 7 class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A","title":"832. Flipping an Image"},{"location":"problems/0832/#832-flipping-an-image","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ] ; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } } Python 1 2 3 4 5 6 7 class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A","title":"832. Flipping an Image"},{"location":"problems/0833/","text":"833. Find And Replace in String Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string findReplaceString ( string S , vector < int >& indexes , vector < string >& sources , vector < string >& targets ) { vector < pair < int , int >> sortedIndexes ; for ( int i = 0 ; i < indexes . size (); ++ i ) sortedIndexes . push_back ({ indexes [ i ], i }); sort ( rbegin ( sortedIndexes ), rend ( sortedIndexes )); for ( const auto & [ index , i ] : sortedIndexes ) { string source = sources [ i ]; string target = targets [ i ]; if ( S . substr ( index , source . length ()) == source ) S = S . substr ( 0 , index ) + target + S . substr ( index + source . length ()); } return S ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String findReplaceString ( String S , int [] indexes , String [] sources , String [] targets ) { List < int []> sortedIndexes = new ArrayList <> (); for ( int i = 0 ; i < indexes . length ; ++ i ) sortedIndexes . add ( new int [] { indexes [ i ] , i }); Collections . sort ( sortedIndexes , Comparator . comparing ( i -> - i [ 0 ] )); for ( int [] sortedIndex : sortedIndexes ) { int index = sortedIndex [ 0 ] ; int i = sortedIndex [ 1 ] ; String source = sources [ i ] ; String target = targets [ i ] ; if ( S . substring ( index , index + source . length ()). equals ( source )) S = S . substring ( 0 , index ) + target + S . substring ( index + source . length ()); } return S ; } } Python 1 2 3 4 5 6 7 class Solution : def findReplaceString ( self , S : str , indexes : List [ int ], sources : List [ str ], targets : List [ str ]) -> str : for index , source , target in sorted ( zip ( indexes , sources , targets ), reverse = True ): if S [ index : index + len ( source )] == source : S = S [: index ] + target + S [ index + len ( source ):] return S","title":"833. Find And Replace in String"},{"location":"problems/0833/#833-find-and-replace-in-string","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string findReplaceString ( string S , vector < int >& indexes , vector < string >& sources , vector < string >& targets ) { vector < pair < int , int >> sortedIndexes ; for ( int i = 0 ; i < indexes . size (); ++ i ) sortedIndexes . push_back ({ indexes [ i ], i }); sort ( rbegin ( sortedIndexes ), rend ( sortedIndexes )); for ( const auto & [ index , i ] : sortedIndexes ) { string source = sources [ i ]; string target = targets [ i ]; if ( S . substr ( index , source . length ()) == source ) S = S . substr ( 0 , index ) + target + S . substr ( index + source . length ()); } return S ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String findReplaceString ( String S , int [] indexes , String [] sources , String [] targets ) { List < int []> sortedIndexes = new ArrayList <> (); for ( int i = 0 ; i < indexes . length ; ++ i ) sortedIndexes . add ( new int [] { indexes [ i ] , i }); Collections . sort ( sortedIndexes , Comparator . comparing ( i -> - i [ 0 ] )); for ( int [] sortedIndex : sortedIndexes ) { int index = sortedIndex [ 0 ] ; int i = sortedIndex [ 1 ] ; String source = sources [ i ] ; String target = targets [ i ] ; if ( S . substring ( index , index + source . length ()). equals ( source )) S = S . substring ( 0 , index ) + target + S . substring ( index + source . length ()); } return S ; } } Python 1 2 3 4 5 6 7 class Solution : def findReplaceString ( self , S : str , indexes : List [ int ], sources : List [ str ], targets : List [ str ]) -> str : for index , source , target in sorted ( zip ( indexes , sources , targets ), reverse = True ): if S [ index : index + len ( source )] == source : S = S [: index ] + target + S [ index + len ( source ):] return S","title":"833. Find And Replace in String"},{"location":"problems/0834/","text":"834. Sum of Distances in Tree","title":"834. Sum of Distances in Tree"},{"location":"problems/0834/#834-sum-of-distances-in-tree","text":"","title":"834. Sum of Distances in Tree"},{"location":"problems/0835/","text":"835. Image Overlap Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( const auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <> (); List < int []> onesB = new ArrayList <> (); Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ] ) * magic + a [ 1 ] - b [ 1 ] ; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0","title":"835. Image Overlap"},{"location":"problems/0835/#835-image-overlap","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( const auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <> (); List < int []> onesB = new ArrayList <> (); Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ] ) * magic + a [ 1 ] - b [ 1 ] ; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0","title":"835. Image Overlap"},{"location":"problems/0836/","text":"836. Rectangle Overlap Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ]; } }; Java 1 2 3 4 5 class Solution { public boolean isRectangleOverlap ( int [] rec1 , int [] rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ] ; } } Python 1 2 3 class Solution : def isRectangleOverlap ( self , rec1 : List [ int ], rec2 : List [ int ]) -> bool : return rec1 [ 0 ] < rec2 [ 2 ] and rec2 [ 0 ] < rec1 [ 2 ] and rec1 [ 1 ] < rec2 [ 3 ] and rec2 [ 1 ] < rec1 [ 3 ]","title":"836. Rectangle Overlap"},{"location":"problems/0836/#836-rectangle-overlap","text":"Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ]; } }; Java 1 2 3 4 5 class Solution { public boolean isRectangleOverlap ( int [] rec1 , int [] rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ] ; } } Python 1 2 3 class Solution : def isRectangleOverlap ( self , rec1 : List [ int ], rec2 : List [ int ]) -> bool : return rec1 [ 0 ] < rec2 [ 2 ] and rec2 [ 0 ] < rec1 [ 2 ] and rec1 [ 1 ] < rec2 [ 3 ] and rec2 [ 1 ] < rec1 [ 3 ]","title":"836. Rectangle Overlap"},{"location":"problems/0837/","text":"837. New 21 Game","title":"837. New 21 Game"},{"location":"problems/0837/#837-new-21-game","text":"","title":"837. New 21 Game"},{"location":"problems/0838/","text":"838. Push Dominoes Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string pushDominoes ( string dominoes ) { int L = -1 ; int R = -1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || dominoes [ i ] == 'R' ) { if ( L < R ) while ( R < i ) dominoes [ R ++ ] = 'R' ; R = i ; } else if ( dominoes [ i ] == 'L' ) { if ( R < L || L == -1 && R == -1 ) { if ( L == -1 && R == -1 ) ++ L ; while ( L < i ) dominoes [ L ++ ] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { dominoes [ l ++ ] = 'R' ; dominoes [ r -- ] = 'L' ; } } L = i ; } return dominoes ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public String pushDominoes ( String dominoes ) { char [] ans = dominoes . toCharArray (); int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || ans [ i ] == 'R' ) { if ( L < R ) while ( R < i ) ans [ R ++] = 'R' ; R = i ; } else if ( ans [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) ans [ L ++] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { ans [ l ++] = 'R' ; ans [ r --] = 'L' ; } } L = i ; } return new String ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def pushDominoes ( self , dominoes : str ) -> str : ans = list ( dominoes ) L = - 1 R = - 1 for i in range ( len ( dominoes ) + 1 ): if i == len ( dominoes ) or dominoes [ i ] == 'R' : if L < R : while R < i : ans [ R ] = 'R' R += 1 R = i elif dominoes [ i ] == 'L' : if R < L or ( L , R ) == ( - 1 , - 1 ): if ( L , R ) == ( - 1 , - 1 ): L += 1 while L < i : ans [ L ] = 'L' L += 1 else : l = R + 1 r = i - 1 while l < r : ans [ l ] = 'R' ans [ r ] = 'L' l += 1 r -= 1 L = i return '' . join ( ans )","title":"838. Push Dominoes"},{"location":"problems/0838/#838-push-dominoes","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string pushDominoes ( string dominoes ) { int L = -1 ; int R = -1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || dominoes [ i ] == 'R' ) { if ( L < R ) while ( R < i ) dominoes [ R ++ ] = 'R' ; R = i ; } else if ( dominoes [ i ] == 'L' ) { if ( R < L || L == -1 && R == -1 ) { if ( L == -1 && R == -1 ) ++ L ; while ( L < i ) dominoes [ L ++ ] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { dominoes [ l ++ ] = 'R' ; dominoes [ r -- ] = 'L' ; } } L = i ; } return dominoes ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public String pushDominoes ( String dominoes ) { char [] ans = dominoes . toCharArray (); int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || ans [ i ] == 'R' ) { if ( L < R ) while ( R < i ) ans [ R ++] = 'R' ; R = i ; } else if ( ans [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) ans [ L ++] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { ans [ l ++] = 'R' ; ans [ r --] = 'L' ; } } L = i ; } return new String ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def pushDominoes ( self , dominoes : str ) -> str : ans = list ( dominoes ) L = - 1 R = - 1 for i in range ( len ( dominoes ) + 1 ): if i == len ( dominoes ) or dominoes [ i ] == 'R' : if L < R : while R < i : ans [ R ] = 'R' R += 1 R = i elif dominoes [ i ] == 'L' : if R < L or ( L , R ) == ( - 1 , - 1 ): if ( L , R ) == ( - 1 , - 1 ): L += 1 while L < i : ans [ L ] = 'L' L += 1 else : l = R + 1 r = i - 1 while l < r : ans [ l ] = 'R' ans [ r ] = 'L' l += 1 r -= 1 L = i return '' . join ( ans )","title":"838. Push Dominoes"},{"location":"problems/0839/","text":"839. Similar String Groups Approach 1: DFS Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int numSimilarGroups ( vector < string >& A ) { int ans = 0 ; vector < bool > seen ( A . size ()); // dfs on string A[i] function < void ( int ) > dfs = [ & ]( int i ) { seen [ i ] = true ; for ( int j = 0 ; j < A . size (); ++ j ) if ( ! seen [ j ] && isSimilar ( A [ i ], A [ j ])) dfs ( j ); }; for ( int i = 0 ; i < A . size (); ++ i ) if ( ! seen [ i ]) { dfs ( i ); ++ ans ; } return ans ; } private : bool isSimilar ( const string & X , const string & Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X [ i ] != Y [ i ] && ++ diff > 2 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int numSimilarGroups ( String [] A ) { int ans = 0 ; boolean [] seen = new boolean [ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) if ( ! seen [ i ] ) { dfs ( A , i , seen ); ++ ans ; } return ans ; } private void dfs ( final String [] A , int i , boolean [] seen ) { seen [ i ] = true ; for ( int j = 0 ; j < A . length ; ++ j ) if ( ! seen [ j ] && isSimilar ( A [ i ] , A [ j ] )) dfs ( A , j , seen ); } private boolean isSimilar ( final String X , final String Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X . charAt ( i ) != Y . charAt ( i ) && ++ diff > 2 ) return false ; return true ; } } Approach 2: UF Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class UF { public : UF ( int n ) : size ( n ), rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int getSize () { return size ; } private : int size ; vector < int > rank ; vector < int > parent ; int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } }; class Solution { public : int numSimilarGroups ( vector < string >& A ) { UF uf ( A . size ()); for ( int i = 1 ; i < A . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( isSimilar ( A [ i ], A [ j ])) uf . union_ ( i , j ); return uf . getSize (); } private : bool isSimilar ( const string & X , const string & Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X [ i ] != Y [ i ] && ++ diff > 2 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class UF { public UF ( int n ) { size = n ; rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int getSize () { return size ; } private int size ; private int [] rank ; private int [] parent ; private int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } } class Solution { public int numSimilarGroups ( String [] A ) { UF uf = new UF ( A . length ); for ( int i = 1 ; i < A . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( isSimilar ( A [ i ] , A [ j ] )) uf . union ( i , j ); return uf . getSize (); } private boolean isSimilar ( final String X , final String Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X . charAt ( i ) != Y . charAt ( i ) && ++ diff > 2 ) return false ; return true ; } }","title":"839. Similar String Groups"},{"location":"problems/0839/#839-similar-string-groups","text":"","title":"839. Similar String Groups"},{"location":"problems/0839/#approach-1-dfs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int numSimilarGroups ( vector < string >& A ) { int ans = 0 ; vector < bool > seen ( A . size ()); // dfs on string A[i] function < void ( int ) > dfs = [ & ]( int i ) { seen [ i ] = true ; for ( int j = 0 ; j < A . size (); ++ j ) if ( ! seen [ j ] && isSimilar ( A [ i ], A [ j ])) dfs ( j ); }; for ( int i = 0 ; i < A . size (); ++ i ) if ( ! seen [ i ]) { dfs ( i ); ++ ans ; } return ans ; } private : bool isSimilar ( const string & X , const string & Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X [ i ] != Y [ i ] && ++ diff > 2 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int numSimilarGroups ( String [] A ) { int ans = 0 ; boolean [] seen = new boolean [ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) if ( ! seen [ i ] ) { dfs ( A , i , seen ); ++ ans ; } return ans ; } private void dfs ( final String [] A , int i , boolean [] seen ) { seen [ i ] = true ; for ( int j = 0 ; j < A . length ; ++ j ) if ( ! seen [ j ] && isSimilar ( A [ i ] , A [ j ] )) dfs ( A , j , seen ); } private boolean isSimilar ( final String X , final String Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X . charAt ( i ) != Y . charAt ( i ) && ++ diff > 2 ) return false ; return true ; } }","title":"Approach 1: DFS"},{"location":"problems/0839/#approach-2-uf","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class UF { public : UF ( int n ) : size ( n ), rank ( n ), parent ( n ) { for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { const int pu = find ( u ); const int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int getSize () { return size ; } private : int size ; vector < int > rank ; vector < int > parent ; int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } }; class Solution { public : int numSimilarGroups ( vector < string >& A ) { UF uf ( A . size ()); for ( int i = 1 ; i < A . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( isSimilar ( A [ i ], A [ j ])) uf . union_ ( i , j ); return uf . getSize (); } private : bool isSimilar ( const string & X , const string & Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X [ i ] != Y [ i ] && ++ diff > 2 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class UF { public UF ( int n ) { size = n ; rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { final int pu = find ( u ); final int pv = find ( v ); if ( pu == pv ) return ; -- size ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int getSize () { return size ; } private int size ; private int [] rank ; private int [] parent ; private int find ( int u ) { if ( u != parent [ u ] ) parent [ u ] = find ( parent [ u ] ); return parent [ u ] ; } } class Solution { public int numSimilarGroups ( String [] A ) { UF uf = new UF ( A . length ); for ( int i = 1 ; i < A . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( isSimilar ( A [ i ] , A [ j ] )) uf . union ( i , j ); return uf . getSize (); } private boolean isSimilar ( final String X , final String Y ) { int diff = 0 ; for ( int i = 0 ; i < X . length (); ++ i ) if ( X . charAt ( i ) != Y . charAt ( i ) && ++ diff > 2 ) return false ; return true ; } }","title":"Approach 2: UF"},{"location":"problems/0840/","text":"840. Magic Squares In Grid Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ] ); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"840. Magic Squares In Grid"},{"location":"problems/0840/#840-magic-squares-in-grid","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ] ); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"840. Magic Squares In Grid"},{"location":"problems/0841/","text":"841. Keys and Rooms","title":"841. Keys and Rooms"},{"location":"problems/0841/#841-keys-and-rooms","text":"","title":"841. Keys and Rooms"},{"location":"problems/0842/","text":"842. Split Array into Fibonacci Sequence Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < int > splitIntoFibonacci ( string S ) { vector < int > ans ; dfs ( S , 0 , ans ); return ans ; } private : bool dfs ( const string & S , int s , vector < int >& ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S [ s ] == '0' && i > s ) break ; long num = stol ( S . substr ( s , i + 1 - s )); if ( num > INT_MAX ) break ; if ( ans . size () >= 2 && num > ( long ) ans [ ans . size () - 2 ] + ans . back ()) break ; if ( ans . size () <= 1 || num == ( long ) ans [ ans . size () - 2 ] + ans . back ()) { ans . push_back ( num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . pop_back (); } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < Integer > splitIntoFibonacci ( String S ) { List < Integer > ans = new ArrayList <> (); dfs ( S , 0 , ans ); return ans ; } private boolean dfs ( final String S , int s , List < Integer > ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S . charAt ( s ) == '0' && i > s ) break ; long num = Long . valueOf ( S . substring ( s , i + 1 )); if ( num > Integer . MAX_VALUE ) break ; if ( ans . size () >= 2 && num > ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) break ; if ( ans . size () <= 1 || num == ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) { ans . add (( int ) num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . remove ( ans . size () - 1 ); } } return false ; } }","title":"842. Split Array into Fibonacci Sequence"},{"location":"problems/0842/#842-split-array-into-fibonacci-sequence","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < int > splitIntoFibonacci ( string S ) { vector < int > ans ; dfs ( S , 0 , ans ); return ans ; } private : bool dfs ( const string & S , int s , vector < int >& ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S [ s ] == '0' && i > s ) break ; long num = stol ( S . substr ( s , i + 1 - s )); if ( num > INT_MAX ) break ; if ( ans . size () >= 2 && num > ( long ) ans [ ans . size () - 2 ] + ans . back ()) break ; if ( ans . size () <= 1 || num == ( long ) ans [ ans . size () - 2 ] + ans . back ()) { ans . push_back ( num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . pop_back (); } } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < Integer > splitIntoFibonacci ( String S ) { List < Integer > ans = new ArrayList <> (); dfs ( S , 0 , ans ); return ans ; } private boolean dfs ( final String S , int s , List < Integer > ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S . charAt ( s ) == '0' && i > s ) break ; long num = Long . valueOf ( S . substring ( s , i + 1 )); if ( num > Integer . MAX_VALUE ) break ; if ( ans . size () >= 2 && num > ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) break ; if ( ans . size () <= 1 || num == ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) { ans . add (( int ) num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . remove ( ans . size () - 1 ); } } return false ; } }","title":"842. Split Array into Fibonacci Sequence"},{"location":"problems/0843/","text":"843. Guess the Word","title":"843. Guess the Word"},{"location":"problems/0843/#843-guess-the-word","text":"","title":"843. Guess the Word"},{"location":"problems/0844/","text":"844. Backspace String Compare Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool backspaceCompare ( const string & S , const string & T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S [ i ] == '#' || backspace ); -- i ) backspace += S [ i ] == '#' ? 1 : -1 ; for ( int backspace = 0 ; j >= 0 && ( T [ j ] == '#' || backspace ); -- j ) backspace += T [ j ] == '#' ? 1 : -1 ; if ( i >= 0 && j >= 0 && S [ i ] != T [ j ]) return false ; if ( i < 0 && j >= 0 && T [ j ] != '#' ) return false ; if ( j < 0 && i >= 0 && S [ i ] != '#' ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean backspaceCompare ( final String S , final String T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S . charAt ( i ) == '#' || backspace > 0 ); -- i ) backspace += S . charAt ( i ) == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T . charAt ( j ) == '#' || backspace > 0 ); -- j ) backspace += T . charAt ( j ) == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S . charAt ( i ) != T . charAt ( j )) return false ; if ( i < 0 && j >= 0 && T . charAt ( j ) != '#' ) return false ; if ( j < 0 && i >= 0 && S . charAt ( i ) != '#' ) return false ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def backspaceCompare ( self , S : str , T : str ) -> bool : i = len ( S ) - 1 j = len ( T ) - 1 while i >= 0 or j >= 0 : backspace = 0 while i >= 0 and ( S [ i ] == '#' or backspace > 0 ): backspace += 1 if S [ i ] == '#' else - 1 i -= 1 backspace = 0 while j >= 0 and ( T [ j ] == '#' or backspace > 0 ): backspace += 1 if T [ j ] == '#' else - 1 j -= 1 if i >= 0 and j >= 0 and S [ i ] != T [ j ] or \\ i < 0 and j >= 0 and S [ j ] != '#' or \\ j < 0 and i >= 0 and S [ i ] != '#' : return False i -= 1 j -= 1 return True","title":"844. Backspace String Compare"},{"location":"problems/0844/#844-backspace-string-compare","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool backspaceCompare ( const string & S , const string & T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S [ i ] == '#' || backspace ); -- i ) backspace += S [ i ] == '#' ? 1 : -1 ; for ( int backspace = 0 ; j >= 0 && ( T [ j ] == '#' || backspace ); -- j ) backspace += T [ j ] == '#' ? 1 : -1 ; if ( i >= 0 && j >= 0 && S [ i ] != T [ j ]) return false ; if ( i < 0 && j >= 0 && T [ j ] != '#' ) return false ; if ( j < 0 && i >= 0 && S [ i ] != '#' ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean backspaceCompare ( final String S , final String T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S . charAt ( i ) == '#' || backspace > 0 ); -- i ) backspace += S . charAt ( i ) == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T . charAt ( j ) == '#' || backspace > 0 ); -- j ) backspace += T . charAt ( j ) == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S . charAt ( i ) != T . charAt ( j )) return false ; if ( i < 0 && j >= 0 && T . charAt ( j ) != '#' ) return false ; if ( j < 0 && i >= 0 && S . charAt ( i ) != '#' ) return false ; } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def backspaceCompare ( self , S : str , T : str ) -> bool : i = len ( S ) - 1 j = len ( T ) - 1 while i >= 0 or j >= 0 : backspace = 0 while i >= 0 and ( S [ i ] == '#' or backspace > 0 ): backspace += 1 if S [ i ] == '#' else - 1 i -= 1 backspace = 0 while j >= 0 and ( T [ j ] == '#' or backspace > 0 ): backspace += 1 if T [ j ] == '#' else - 1 j -= 1 if i >= 0 and j >= 0 and S [ i ] != T [ j ] or \\ i < 0 and j >= 0 and S [ j ] != '#' or \\ j < 0 and i >= 0 and S [ i ] != '#' : return False i -= 1 j -= 1 return True","title":"844. Backspace String Compare"},{"location":"problems/0845/","text":"845. Longest Mountain in Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int longestMountain ( vector < int >& A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . size ();) { while ( i + 1 < A . size () && A [ i ] == A [ i + 1 ]) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . size () && A [ i ] < A [ i + 1 ]) { ++ increasing ; ++ i ; } while ( i + 1 < A . size () && A [ i ] > A [ i + 1 ]) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = max ( ans , increasing + decreasing + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int longestMountain ( int [] A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . length ;) { while ( i + 1 < A . length && A [ i ] == A [ i + 1 ] ) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . length && A [ i ] < A [ i + 1 ] ) { ++ increasing ; ++ i ; } while ( i + 1 < A . length && A [ i ] > A [ i + 1 ] ) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = Math . max ( ans , increasing + decreasing + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def longestMountain ( self , A : List [ int ]) -> int : ans = 0 i = 0 while i + 1 < len ( A ): while i + 1 < len ( A ) and A [ i ] == A [ i + 1 ]: i += 1 increasing = 0 decreasing = 0 while i + 1 < len ( A ) and A [ i ] < A [ i + 1 ]: increasing += 1 i += 1 while i + 1 < len ( A ) and A [ i ] > A [ i + 1 ]: decreasing += 1 i += 1 if increasing > 0 and decreasing > 0 : ans = max ( ans , increasing + decreasing + 1 ) return ans","title":"845. Longest Mountain in Array"},{"location":"problems/0845/#845-longest-mountain-in-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int longestMountain ( vector < int >& A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . size ();) { while ( i + 1 < A . size () && A [ i ] == A [ i + 1 ]) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . size () && A [ i ] < A [ i + 1 ]) { ++ increasing ; ++ i ; } while ( i + 1 < A . size () && A [ i ] > A [ i + 1 ]) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = max ( ans , increasing + decreasing + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int longestMountain ( int [] A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . length ;) { while ( i + 1 < A . length && A [ i ] == A [ i + 1 ] ) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . length && A [ i ] < A [ i + 1 ] ) { ++ increasing ; ++ i ; } while ( i + 1 < A . length && A [ i ] > A [ i + 1 ] ) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = Math . max ( ans , increasing + decreasing + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def longestMountain ( self , A : List [ int ]) -> int : ans = 0 i = 0 while i + 1 < len ( A ): while i + 1 < len ( A ) and A [ i ] == A [ i + 1 ]: i += 1 increasing = 0 decreasing = 0 while i + 1 < len ( A ) and A [ i ] < A [ i + 1 ]: increasing += 1 i += 1 while i + 1 < len ( A ) and A [ i ] > A [ i + 1 ]: decreasing += 1 i += 1 if increasing > 0 and decreasing > 0 : ans = max ( ans , increasing + decreasing + 1 ) return ans","title":"845. Longest Mountain in Array"},{"location":"problems/0846/","text":"846. Hand of Straights","title":"846. Hand of Straights"},{"location":"problems/0846/#846-hand-of-straights","text":"","title":"846. Hand of Straights"},{"location":"problems/0847/","text":"847. Shortest Path Visiting All Nodes Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return -1 ; } };","title":"847. Shortest Path Visiting All Nodes"},{"location":"problems/0847/#847-shortest-path-visiting-all-nodes","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return -1 ; } };","title":"847. Shortest Path Visiting All Nodes"},{"location":"problems/0848/","text":"848. Shifting Letters Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { string ans ; for ( int i = shifts . size () - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ]) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans += ( S [ i ] - 'a' + shifts [ i ]) % 26 + 'a' ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String shiftingLetters ( String S , int [] shifts ) { StringBuilder ans = new StringBuilder (); for ( int i = shifts . length - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ] ) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans . append (( char ) (( S . charAt ( i ) - 'a' + shifts [ i ] ) % 26 + 'a' )); return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def shiftingLetters ( self , S : str , shifts : List [ int ]) -> str : ans = '' for i in range ( len ( shifts ) - 2 , - 1 , - 1 ): shifts [ i ] += shifts [ i + 1 ] for c , shift in zip ( S , shifts ): ans += chr (( ord ( c ) - ord ( 'a' ) + shift ) % 26 + ord ( 'a' )) return ans","title":"848. Shifting Letters"},{"location":"problems/0848/#848-shifting-letters","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { string ans ; for ( int i = shifts . size () - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ]) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans += ( S [ i ] - 'a' + shifts [ i ]) % 26 + 'a' ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String shiftingLetters ( String S , int [] shifts ) { StringBuilder ans = new StringBuilder (); for ( int i = shifts . length - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ] ) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans . append (( char ) (( S . charAt ( i ) - 'a' + shifts [ i ] ) % 26 + 'a' )); return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def shiftingLetters ( self , S : str , shifts : List [ int ]) -> str : ans = '' for i in range ( len ( shifts ) - 2 , - 1 , - 1 ): shifts [ i ] += shifts [ i + 1 ] for c , shift in zip ( S , shifts ): ans += chr (( ord ( c ) - ord ( 'a' ) + shift ) % 26 + ord ( 'a' )) return ans","title":"848. Shifting Letters"},{"location":"problems/0849/","text":"849. Maximize Distance to Closest Person Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = -1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == -1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 )","title":"849. Maximize Distance to Closest Person"},{"location":"problems/0849/#849-maximize-distance-to-closest-person","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = -1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == -1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 )","title":"849. Maximize Distance to Closest Person"},{"location":"problems/0850/","text":"850. Rectangle Area II","title":"850. Rectangle Area II"},{"location":"problems/0850/#850-rectangle-area-ii","text":"","title":"850. Rectangle Area II"},{"location":"problems/0851/","text":"851. Loud and Rich","title":"851. Loud and Rich"},{"location":"problems/0851/#851-loud-and-rich","text":"","title":"851. Loud and Rich"},{"location":"problems/0852/","text":"852. Peak Index in a Mountain Array","title":"852. Peak Index in a Mountain Array"},{"location":"problems/0852/#852-peak-index-in-a-mountain-array","text":"","title":"852. Peak Index in a Mountain Array"},{"location":"problems/0853/","text":"853. Car Fleet","title":"853. Car Fleet"},{"location":"problems/0853/#853-car-fleet","text":"","title":"853. Car Fleet"},{"location":"problems/0854/","text":"854. K-Similar Strings","title":"854. K-Similar Strings"},{"location":"problems/0854/#854-k-similar-strings","text":"","title":"854. K-Similar Strings"},{"location":"problems/0855/","text":"855. Exam Room Time: $O(n)$ seat(), $O(1)$ leave() Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ExamRoom { public : ExamRoom ( int N ) : N ( N ) {} int seat () { if ( students . empty ()) { students . push_back ( 0 ); map [ 0 ] = begin ( students ); return 0 ; } int prevStudent = -1 ; int maxDistToClosest = 0 ; int val = 0 ; // inserted val list < int >:: iterator pos ; // inserted position for ( auto it = begin ( students ); it != end ( students ); ++ it ) { if ( prevStudent == -1 ) { // doesn't insert before maxDistToClosest = * it ; // distance between it and the begining pos = it ; } else if (( * it - prevStudent ) / 2 > maxDistToClosest ) { maxDistToClosest = ( * it - prevStudent ) / 2 ; val = ( * it + prevStudent ) / 2 ; pos = it ; } prevStudent = * it ; } if ( N - 1 - students . back () > maxDistToClosest ) { pos = end ( students ); val = N - 1 ; } map [ val ] = students . insert ( pos , val ); return val ; } void leave ( int p ) { students . erase ( map [ p ]); } private : int N ; list < int > students ; unordered_map < int , list < int >:: iterator > map ; // {p: student iterator} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Node { public Node prev ; public Node next ; public int value ; public Node ( int value ) { this . value = value ; } } class ExamRoom { public ExamRoom ( int N ) { this . N = N ; join ( head , tail ); } public int seat () { if ( head . next == tail ) { Node node = new Node ( 0 ); join ( head , node ); join ( node , tail ); map . put ( 0 , node ); return 0 ; } int prevStudent = - 1 ; int maxDistToClosest = 0 ; int val = 0 ; // inserted val Node pos = null ; // inserted position for ( Node node = head ; node != tail ; node = node . next ) { if ( prevStudent == - 1 ) { // doesn't insert before maxDistToClosest = node . value ; // distance between it and the begining pos = node ; } else if (( node . value - prevStudent ) / 2 > maxDistToClosest ) { maxDistToClosest = ( node . value - prevStudent ) / 2 ; val = ( node . value + prevStudent ) / 2 ; pos = node ; } prevStudent = node . value ; } if ( N - 1 - tail . prev . value > maxDistToClosest ) { pos = tail ; val = N - 1 ; } Node insertedNode = new Node ( val ); join ( pos . prev , insertedNode ); join ( insertedNode , pos ); map . put ( val , insertedNode ); return val ; } public void leave ( int p ) { Node removedNode = map . get ( p ); join ( removedNode . prev , removedNode . next ); } private int N ; private Node head = new Node ( - 1 ); private Node tail = new Node ( - 1 ); private Map < Integer , Node > map = new HashMap <> (); // {p: student iterator} private void join ( Node node1 , Node node2 ) { node1 . next = node2 ; node2 . prev = node1 ; } private void remove ( Node node ) { join ( node . prev , node . next ); } }","title":"855. Exam Room"},{"location":"problems/0855/#855-exam-room","text":"Time: $O(n)$ seat(), $O(1)$ leave() Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ExamRoom { public : ExamRoom ( int N ) : N ( N ) {} int seat () { if ( students . empty ()) { students . push_back ( 0 ); map [ 0 ] = begin ( students ); return 0 ; } int prevStudent = -1 ; int maxDistToClosest = 0 ; int val = 0 ; // inserted val list < int >:: iterator pos ; // inserted position for ( auto it = begin ( students ); it != end ( students ); ++ it ) { if ( prevStudent == -1 ) { // doesn't insert before maxDistToClosest = * it ; // distance between it and the begining pos = it ; } else if (( * it - prevStudent ) / 2 > maxDistToClosest ) { maxDistToClosest = ( * it - prevStudent ) / 2 ; val = ( * it + prevStudent ) / 2 ; pos = it ; } prevStudent = * it ; } if ( N - 1 - students . back () > maxDistToClosest ) { pos = end ( students ); val = N - 1 ; } map [ val ] = students . insert ( pos , val ); return val ; } void leave ( int p ) { students . erase ( map [ p ]); } private : int N ; list < int > students ; unordered_map < int , list < int >:: iterator > map ; // {p: student iterator} }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Node { public Node prev ; public Node next ; public int value ; public Node ( int value ) { this . value = value ; } } class ExamRoom { public ExamRoom ( int N ) { this . N = N ; join ( head , tail ); } public int seat () { if ( head . next == tail ) { Node node = new Node ( 0 ); join ( head , node ); join ( node , tail ); map . put ( 0 , node ); return 0 ; } int prevStudent = - 1 ; int maxDistToClosest = 0 ; int val = 0 ; // inserted val Node pos = null ; // inserted position for ( Node node = head ; node != tail ; node = node . next ) { if ( prevStudent == - 1 ) { // doesn't insert before maxDistToClosest = node . value ; // distance between it and the begining pos = node ; } else if (( node . value - prevStudent ) / 2 > maxDistToClosest ) { maxDistToClosest = ( node . value - prevStudent ) / 2 ; val = ( node . value + prevStudent ) / 2 ; pos = node ; } prevStudent = node . value ; } if ( N - 1 - tail . prev . value > maxDistToClosest ) { pos = tail ; val = N - 1 ; } Node insertedNode = new Node ( val ); join ( pos . prev , insertedNode ); join ( insertedNode , pos ); map . put ( val , insertedNode ); return val ; } public void leave ( int p ) { Node removedNode = map . get ( p ); join ( removedNode . prev , removedNode . next ); } private int N ; private Node head = new Node ( - 1 ); private Node tail = new Node ( - 1 ); private Map < Integer , Node > map = new HashMap <> (); // {p: student iterator} private void join ( Node node1 , Node node2 ) { node1 . next = node2 ; node2 . prev = node1 ; } private void remove ( Node node ) { join ( node . prev , node . next ); } }","title":"855. Exam Room"},{"location":"problems/0856/","text":"856. Score of Parentheses Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int scoreOfParentheses ( string S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S [ i ] == '(' ? 1 : -1 ; if ( S [ i ] == ')' && S [ i - 1 ] == '(' ) ans += 1 << layer ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int scoreOfParentheses ( String S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S . charAt ( i ) == '(' ? 1 : - 1 ; if ( S . charAt ( i ) == ')' && S . charAt ( i - 1 ) == '(' ) ans += 1 << layer ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def scoreOfParentheses ( self , S : str ) -> int : ans = 0 layer = 0 for a , b in zip ( S , S [ 1 :]): if a + b == '()' : ans += 1 << layer layer += 1 if a == '(' else - 1 return ans","title":"856. Score of Parentheses"},{"location":"problems/0856/#856-score-of-parentheses","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int scoreOfParentheses ( string S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S [ i ] == '(' ? 1 : -1 ; if ( S [ i ] == ')' && S [ i - 1 ] == '(' ) ans += 1 << layer ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int scoreOfParentheses ( String S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S . charAt ( i ) == '(' ? 1 : - 1 ; if ( S . charAt ( i ) == ')' && S . charAt ( i - 1 ) == '(' ) ans += 1 << layer ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def scoreOfParentheses ( self , S : str ) -> int : ans = 0 layer = 0 for a , b in zip ( S , S [ 1 :]): if a + b == '()' : ans += 1 << layer layer += 1 if a == '(' else - 1 return ans","title":"856. Score of Parentheses"},{"location":"problems/0857/","text":"857. Minimum Cost to Hire K Workers","title":"857. Minimum Cost to Hire K Workers"},{"location":"problems/0857/#857-minimum-cost-to-hire-k-workers","text":"","title":"857. Minimum Cost to Hire K Workers"},{"location":"problems/0858/","text":"858. Mirror Reflection Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int mirrorReflection ( int p , int q ) { int m = 1 ; // # of room extension + 1 int n = 1 ; // # of reflection + 1 while ( m * p != n * q ) m = ++ n * q / p ; if ( n % 2 == 0 ) return 2 ; if ( m % 2 == 0 ) return 0 ; if ( m % 2 == 1 ) return 1 ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int mirrorReflection ( int p , int q ) { int m = 1 ; // # of room extension + 1 int n = 1 ; // # of reflection + 1 while ( m * p != n * q ) m = ++ n * q / p ; if ( n % 2 == 0 ) return 2 ; if ( m % 2 == 0 ) return 0 ; if ( m % 2 == 1 ) return 1 ; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def mirrorReflection ( self , p : int , q : int ) -> int : m = 1 n = 1 while m * p != n * q : n += 1 m = n * q // p if m % 2 == 0 and n % 2 == 1 : return 0 if m % 2 == 1 and n % 2 == 1 : return 1 if m % 2 == 1 and n % 2 == 0 : return 2","title":"858. Mirror Reflection"},{"location":"problems/0858/#858-mirror-reflection","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int mirrorReflection ( int p , int q ) { int m = 1 ; // # of room extension + 1 int n = 1 ; // # of reflection + 1 while ( m * p != n * q ) m = ++ n * q / p ; if ( n % 2 == 0 ) return 2 ; if ( m % 2 == 0 ) return 0 ; if ( m % 2 == 1 ) return 1 ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int mirrorReflection ( int p , int q ) { int m = 1 ; // # of room extension + 1 int n = 1 ; // # of reflection + 1 while ( m * p != n * q ) m = ++ n * q / p ; if ( n % 2 == 0 ) return 2 ; if ( m % 2 == 0 ) return 0 ; if ( m % 2 == 1 ) return 1 ; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def mirrorReflection ( self , p : int , q : int ) -> int : m = 1 n = 1 while m * p != n * q : n += 1 m = n * q // p if m % 2 == 0 and n % 2 == 1 : return 0 if m % 2 == 1 and n % 2 == 1 : return 1 if m % 2 == 1 and n % 2 == 0 : return 2","title":"858. Mirror Reflection"},{"location":"problems/0859/","text":"859. Buddy Strings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool buddyStrings ( string A , string B ) { if ( A . length () != B . length ()) return false ; if ( A == B && set < char > ( begin ( A ), end ( A )). size () < A . length ()) return true ; vector < int > diff ; for ( int i = 0 ; i < A . length (); ++ i ) if ( A [ i ] != B [ i ]) diff . push_back ( i ); return diff . size () == 2 && A [ diff [ 0 ]] == B [ diff [ 1 ]] && A [ diff [ 1 ]] == B [ diff [ 0 ]]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean buddyStrings ( String A , String B ) { if ( A . length () != B . length ()) return false ; if ( A . equals ( B )) { Set < Character > set = new HashSet <> (); for ( char c : A . toCharArray ()) set . add ( c ); return set . size () < A . length (); } List < Integer > diff = new ArrayList <> (); for ( int i = 0 ; i < A . length (); ++ i ) if ( A . charAt ( i ) != B . charAt ( i )) diff . add ( i ); return diff . size () == 2 && A . charAt ( diff . get ( 0 )) == B . charAt ( diff . get ( 1 )) && A . charAt ( diff . get ( 1 )) == B . charAt ( diff . get ( 0 )); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def buddyStrings ( self , A : str , B : str ) -> bool : if len ( A ) != len ( B ): return False if A == B and len ( set ( A )) < len ( A ): return True diff = [( a , b ) for a , b in zip ( A , B ) if a != b ] return len ( diff ) == 2 and diff [ 0 ] == diff [ 1 ][:: - 1 ]","title":"859. Buddy Strings"},{"location":"problems/0859/#859-buddy-strings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool buddyStrings ( string A , string B ) { if ( A . length () != B . length ()) return false ; if ( A == B && set < char > ( begin ( A ), end ( A )). size () < A . length ()) return true ; vector < int > diff ; for ( int i = 0 ; i < A . length (); ++ i ) if ( A [ i ] != B [ i ]) diff . push_back ( i ); return diff . size () == 2 && A [ diff [ 0 ]] == B [ diff [ 1 ]] && A [ diff [ 1 ]] == B [ diff [ 0 ]]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean buddyStrings ( String A , String B ) { if ( A . length () != B . length ()) return false ; if ( A . equals ( B )) { Set < Character > set = new HashSet <> (); for ( char c : A . toCharArray ()) set . add ( c ); return set . size () < A . length (); } List < Integer > diff = new ArrayList <> (); for ( int i = 0 ; i < A . length (); ++ i ) if ( A . charAt ( i ) != B . charAt ( i )) diff . add ( i ); return diff . size () == 2 && A . charAt ( diff . get ( 0 )) == B . charAt ( diff . get ( 1 )) && A . charAt ( diff . get ( 1 )) == B . charAt ( diff . get ( 0 )); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def buddyStrings ( self , A : str , B : str ) -> bool : if len ( A ) != len ( B ): return False if A == B and len ( set ( A )) < len ( A ): return True diff = [( a , b ) for a , b in zip ( A , B ) if a != b ] return len ( diff ) == 2 and diff [ 0 ] == diff [ 1 ][:: - 1 ]","title":"859. Buddy Strings"},{"location":"problems/0860/","text":"860. Lemonade Change","title":"860. Lemonade Change"},{"location":"problems/0860/#860-lemonade-change","text":"","title":"860. Lemonade Change"},{"location":"problems/0861/","text":"861. Score After Flipping Matrix","title":"861. Score After Flipping Matrix"},{"location":"problems/0861/#861-score-after-flipping-matrix","text":"","title":"861. Score After Flipping Matrix"},{"location":"problems/0862/","text":"862. Shortest Subarray with Sum at Least K Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { const int n = A . size (); int ans = n + 1 ; deque < int > deque ; vector < int > prefixSum ( n + 1 ); for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ]; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . empty () && prefixSum [ i ] - prefixSum [ deque . front ()] >= K ) ans = min ( ans , i - deque . front ()), deque . pop_front (); while ( ! deque . empty () && prefixSum [ i ] <= prefixSum [ deque . back ()]) deque . pop_back (); deque . push_back ( i ); } return ans <= n ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int shortestSubarray ( int [] A , int K ) { final int n = A . length ; int ans = n + 1 ; Deque < Integer > deque = new ArrayDeque <> (); int [] prefixSum = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] ; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . isEmpty () && prefixSum [ i ] - prefixSum [ deque . getFirst () ] >= K ) ans = Math . min ( ans , i - deque . pollFirst ()); while ( ! deque . isEmpty () && prefixSum [ i ] <= prefixSum [ deque . getLast () ] ) deque . pollLast (); deque . addLast ( i ); } return ans <= n ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def shortestSubarray ( self , A : List [ int ], K : int ) -> int : n = len ( A ) ans = n + 1 prefixSum = [ 0 ] * ( n + 1 ) for i in range ( n ): prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] deque = collections . deque () for i in range ( n + 1 ): while deque and prefixSum [ i ] - prefixSum [ deque [ 0 ]] >= K : ans = min ( ans , i - deque . popleft ()) while deque and prefixSum [ i ] <= prefixSum [ deque [ - 1 ]]: deque . pop () deque . append ( i ) return ans if ans <= n else - 1","title":"862. Shortest Subarray with Sum at Least K"},{"location":"problems/0862/#862-shortest-subarray-with-sum-at-least-k","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { const int n = A . size (); int ans = n + 1 ; deque < int > deque ; vector < int > prefixSum ( n + 1 ); for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ]; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . empty () && prefixSum [ i ] - prefixSum [ deque . front ()] >= K ) ans = min ( ans , i - deque . front ()), deque . pop_front (); while ( ! deque . empty () && prefixSum [ i ] <= prefixSum [ deque . back ()]) deque . pop_back (); deque . push_back ( i ); } return ans <= n ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int shortestSubarray ( int [] A , int K ) { final int n = A . length ; int ans = n + 1 ; Deque < Integer > deque = new ArrayDeque <> (); int [] prefixSum = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] ; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . isEmpty () && prefixSum [ i ] - prefixSum [ deque . getFirst () ] >= K ) ans = Math . min ( ans , i - deque . pollFirst ()); while ( ! deque . isEmpty () && prefixSum [ i ] <= prefixSum [ deque . getLast () ] ) deque . pollLast (); deque . addLast ( i ); } return ans <= n ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def shortestSubarray ( self , A : List [ int ], K : int ) -> int : n = len ( A ) ans = n + 1 prefixSum = [ 0 ] * ( n + 1 ) for i in range ( n ): prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] deque = collections . deque () for i in range ( n + 1 ): while deque and prefixSum [ i ] - prefixSum [ deque [ 0 ]] >= K : ans = min ( ans , i - deque . popleft ()) while deque and prefixSum [ i ] <= prefixSum [ deque [ - 1 ]]: deque . pop () deque . append ( i ) return ans if ans <= n else - 1","title":"862. Shortest Subarray with Sum at Least K"},{"location":"problems/0863/","text":"863. All Nodes Distance K in Binary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < int > distanceK ( TreeNode * root , TreeNode * target , int K ) { vector < int > ans ; unordered_map < TreeNode * , int > nodeToDistance ; function < void ( TreeNode * ) > findDistance = [ & ]( TreeNode * root ) { if ( ! root ) return ; if ( root == target ) { nodeToDistance [ root ] = 0 ; return ; } findDistance ( root -> left ); if ( nodeToDistance . count ( root -> left )) { nodeToDistance [ root ] = nodeToDistance [ root -> left ] + 1 ; return ; } findDistance ( root -> right ); if ( nodeToDistance . count ( root -> right )) { nodeToDistance [ root ] = nodeToDistance [ root -> right ] + 1 ; } }; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int distance ) { if ( ! root ) return ; if ( nodeToDistance . count ( root )) distance = nodeToDistance [ root ]; if ( distance == K ) ans . push_back ( root -> val ); dfs ( root -> left , distance + 1 ); dfs ( root -> right , distance + 1 ); }; findDistance ( root ); dfs ( root , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public List < Integer > distanceK ( TreeNode root , TreeNode target , int K ) { List < Integer > ans = new ArrayList <> (); Map < TreeNode , Integer > nodeToDistance = new HashMap <> (); findDistance ( root , target , nodeToDistance ); dfs ( root , K , 0 , nodeToDistance , ans ); return ans ; } private void findDistance ( TreeNode root , TreeNode target , Map < TreeNode , Integer > nodeToDistance ) { if ( root == null ) return ; if ( root == target ) { nodeToDistance . put ( root , 0 ); return ; } findDistance ( root . left , target , nodeToDistance ); if ( nodeToDistance . containsKey ( root . left )) { nodeToDistance . put ( root , nodeToDistance . get ( root . left ) + 1 ); return ; } findDistance ( root . right , target , nodeToDistance ); if ( nodeToDistance . containsKey ( root . right )) { nodeToDistance . put ( root , nodeToDistance . get ( root . right ) + 1 ); return ; } } private void dfs ( TreeNode root , int K , int distance , Map < TreeNode , Integer > nodeToDistance , List < Integer > ans ) { if ( root == null ) return ; if ( nodeToDistance . containsKey ( root )) distance = nodeToDistance . get ( root ); if ( distance == K ) ans . add ( root . val ); dfs ( root . left , K , distance + 1 , nodeToDistance , ans ); dfs ( root . right , K , distance + 1 , nodeToDistance , ans ); } }","title":"863. All Nodes Distance K in Binary Tree"},{"location":"problems/0863/#863-all-nodes-distance-k-in-binary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < int > distanceK ( TreeNode * root , TreeNode * target , int K ) { vector < int > ans ; unordered_map < TreeNode * , int > nodeToDistance ; function < void ( TreeNode * ) > findDistance = [ & ]( TreeNode * root ) { if ( ! root ) return ; if ( root == target ) { nodeToDistance [ root ] = 0 ; return ; } findDistance ( root -> left ); if ( nodeToDistance . count ( root -> left )) { nodeToDistance [ root ] = nodeToDistance [ root -> left ] + 1 ; return ; } findDistance ( root -> right ); if ( nodeToDistance . count ( root -> right )) { nodeToDistance [ root ] = nodeToDistance [ root -> right ] + 1 ; } }; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int distance ) { if ( ! root ) return ; if ( nodeToDistance . count ( root )) distance = nodeToDistance [ root ]; if ( distance == K ) ans . push_back ( root -> val ); dfs ( root -> left , distance + 1 ); dfs ( root -> right , distance + 1 ); }; findDistance ( root ); dfs ( root , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public List < Integer > distanceK ( TreeNode root , TreeNode target , int K ) { List < Integer > ans = new ArrayList <> (); Map < TreeNode , Integer > nodeToDistance = new HashMap <> (); findDistance ( root , target , nodeToDistance ); dfs ( root , K , 0 , nodeToDistance , ans ); return ans ; } private void findDistance ( TreeNode root , TreeNode target , Map < TreeNode , Integer > nodeToDistance ) { if ( root == null ) return ; if ( root == target ) { nodeToDistance . put ( root , 0 ); return ; } findDistance ( root . left , target , nodeToDistance ); if ( nodeToDistance . containsKey ( root . left )) { nodeToDistance . put ( root , nodeToDistance . get ( root . left ) + 1 ); return ; } findDistance ( root . right , target , nodeToDistance ); if ( nodeToDistance . containsKey ( root . right )) { nodeToDistance . put ( root , nodeToDistance . get ( root . right ) + 1 ); return ; } } private void dfs ( TreeNode root , int K , int distance , Map < TreeNode , Integer > nodeToDistance , List < Integer > ans ) { if ( root == null ) return ; if ( nodeToDistance . containsKey ( root )) distance = nodeToDistance . get ( root ); if ( distance == K ) ans . add ( root . val ); dfs ( root . left , K , distance + 1 , nodeToDistance , ans ); dfs ( root . right , K , distance + 1 , nodeToDistance , ans ); } }","title":"863. All Nodes Distance K in Binary Tree"},{"location":"problems/0864/","text":"864. Shortest Path to Get All Keys","title":"864. Shortest Path to Get All Keys"},{"location":"problems/0864/#864-shortest-path-to-get-all-keys","text":"","title":"864. Shortest Path to Get All Keys"},{"location":"problems/0865/","text":"865. Smallest Subtree with all the Deepest Nodes","title":"865. Smallest Subtree with all the Deepest Nodes"},{"location":"problems/0865/#865-smallest-subtree-with-all-the-deepest-nodes","text":"","title":"865. Smallest Subtree with all the Deepest Nodes"},{"location":"problems/0866/","text":"866. Prime Palindrome Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = to_string ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } throw ; } private : vector < int > getPalindromes ( int n ) { vector < int > palindromes ; int length = n / 2 ; for ( int i = pow ( 10 , length - 1 ); i < pow ( 10 , length ); ++ i ) { string s = to_string ( i ); string reversedS = s ; reverse ( begin ( reversedS ), end ( reversedS )); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . push_back ( stoi ( s + to_string ( j ) + reversedS )); } return palindromes ; } bool isPrime ( int num ) { for ( int i = 2 ; i < sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = String . valueOf ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } } private List < Integer > getPalindromes ( int n ) { List < Integer > palindromes = new ArrayList <> (); int length = n / 2 ; for ( int i = ( int ) Math . pow ( 10 , length - 1 ); i < ( int ) Math . pow ( 10 , length ); ++ i ) { String s = String . valueOf ( i ); String reversedS = new StringBuilder ( s ). reverse (). toString (); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . add ( Integer . valueOf ( s + String . valueOf ( j ) + reversedS )); } return palindromes ; } private boolean isPrime ( int num ) { for ( int i = 2 ; i < ( int ) Math . sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def primePalindrome ( self , N : int ) -> int : def getPalindromes ( n : int ) -> int : length = n // 2 for i in range ( 10 ** ( length - 1 ), 10 ** length ): s = str ( i ) for j in range ( 10 ): yield int ( s + str ( j ) + s [:: - 1 ]) def isPrime ( num : int ) -> bool : return not any ( num % i == 0 for i in range ( 2 , int ( num ** 0.5 + 1 ))) if N <= 2 : return 2 if N == 3 : return 3 if N <= 5 : return 5 if N <= 7 : return 7 if N <= 11 : return 11 n = len ( str ( N )) while True : for num in getPalindromes ( n ): if num >= N and isPrime ( num ): return num n += 1","title":"866. Prime Palindrome"},{"location":"problems/0866/#866-prime-palindrome","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = to_string ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } throw ; } private : vector < int > getPalindromes ( int n ) { vector < int > palindromes ; int length = n / 2 ; for ( int i = pow ( 10 , length - 1 ); i < pow ( 10 , length ); ++ i ) { string s = to_string ( i ); string reversedS = s ; reverse ( begin ( reversedS ), end ( reversedS )); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . push_back ( stoi ( s + to_string ( j ) + reversedS )); } return palindromes ; } bool isPrime ( int num ) { for ( int i = 2 ; i < sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = String . valueOf ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } } private List < Integer > getPalindromes ( int n ) { List < Integer > palindromes = new ArrayList <> (); int length = n / 2 ; for ( int i = ( int ) Math . pow ( 10 , length - 1 ); i < ( int ) Math . pow ( 10 , length ); ++ i ) { String s = String . valueOf ( i ); String reversedS = new StringBuilder ( s ). reverse (). toString (); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . add ( Integer . valueOf ( s + String . valueOf ( j ) + reversedS )); } return palindromes ; } private boolean isPrime ( int num ) { for ( int i = 2 ; i < ( int ) Math . sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def primePalindrome ( self , N : int ) -> int : def getPalindromes ( n : int ) -> int : length = n // 2 for i in range ( 10 ** ( length - 1 ), 10 ** length ): s = str ( i ) for j in range ( 10 ): yield int ( s + str ( j ) + s [:: - 1 ]) def isPrime ( num : int ) -> bool : return not any ( num % i == 0 for i in range ( 2 , int ( num ** 0.5 + 1 ))) if N <= 2 : return 2 if N == 3 : return 3 if N <= 5 : return 5 if N <= 7 : return 7 if N <= 11 : return 11 n = len ( str ( N )) while True : for num in getPalindromes ( n ): if num >= N and isPrime ( num ): return num n += 1","title":"866. Prime Palindrome"},{"location":"problems/0867/","text":"867. Transpose Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ] . length ][ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) ans [ j ][ i ] = A [ i ][ j ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans","title":"867. Transpose Matrix"},{"location":"problems/0867/#867-transpose-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ] . length ][ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) ans [ j ][ i ] = A [ i ][ j ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans","title":"867. Transpose Matrix"},{"location":"problems/0868/","text":"868. Binary Gap Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = Math . max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def binaryGap ( self , N : int ) -> int : ans = 0 prevOneIndex = 30 i = 0 n = N while n > 0 : if n % 2 == 1 : ans = max ( ans , i - prevOneIndex ) prevOneIndex = i n >>= 1 i += 1 return ans","title":"868. Binary Gap"},{"location":"problems/0868/#868-binary-gap","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = Math . max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def binaryGap ( self , N : int ) -> int : ans = 0 prevOneIndex = 30 i = 0 n = N while n > 0 : if n % 2 == 1 : ans = max ( ans , i - prevOneIndex ) prevOneIndex = i n >>= 1 i += 1 return ans","title":"868. Binary Gap"},{"location":"problems/0869/","text":"869. Reordered Power of 2 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private : int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += pow ( 10 , n % 10 ); return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += Math . pow ( 10 , n % 10 ); return count ; } } Python 1 2 3 4 class Solution : def reorderedPowerOf2 ( self , N : int ) -> bool : count = collections . Counter ( str ( N )) return any ( collections . Counter ( str ( 1 << i )) == count for i in range ( 30 ))","title":"869. Reordered Power of 2"},{"location":"problems/0869/#869-reordered-power-of-2","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private : int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += pow ( 10 , n % 10 ); return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += Math . pow ( 10 , n % 10 ); return count ; } } Python 1 2 3 4 class Solution : def reorderedPowerOf2 ( self , N : int ) -> bool : count = collections . Counter ( str ( N )) return any ( collections . Counter ( str ( 1 << i )) == count for i in range ( 30 ))","title":"869. Reordered Power of 2"},{"location":"problems/0870/","text":"870. Advantage Shuffle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set { begin ( A ), end ( A )}; for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * rbegin ( set ) <= B [ i ] ? begin ( set ) : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] advantageCount ( int [] A , int [] B ) { TreeMap < Integer , Integer > map = new TreeMap <> (); for ( int a : A ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); for ( int i = 0 ; i < B . length ; i ++ ) { Integer key = map . higherKey ( B [ i ] ); if ( key == null ) key = map . firstKey (); map . put ( key , map . get ( key ) - 1 ); if ( map . get ( key ) == 0 ) map . remove ( key ); A [ i ] = key ; } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 from sortedcontainers import SortedList class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: sl = SortedList ( A ) for i , b in enumerate ( B ): index = 0 if sl [ - 1 ] <= b else sl . bisect_right ( b ) A [ i ] = sl [ index ] del sl [ index ] return A","title":"870. Advantage Shuffle"},{"location":"problems/0870/#870-advantage-shuffle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set { begin ( A ), end ( A )}; for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * rbegin ( set ) <= B [ i ] ? begin ( set ) : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] advantageCount ( int [] A , int [] B ) { TreeMap < Integer , Integer > map = new TreeMap <> (); for ( int a : A ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); for ( int i = 0 ; i < B . length ; i ++ ) { Integer key = map . higherKey ( B [ i ] ); if ( key == null ) key = map . firstKey (); map . put ( key , map . get ( key ) - 1 ); if ( map . get ( key ) == 0 ) map . remove ( key ); A [ i ] = key ; } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 from sortedcontainers import SortedList class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: sl = SortedList ( A ) for i , b in enumerate ( B ): index = 0 if sl [ - 1 ] <= b else sl . bisect_right ( b ) A [ i ] = sl [ index ] del sl [ index ] return A","title":"870. Advantage Shuffle"},{"location":"problems/0871/","text":"871. Minimum Number of Refueling Stops Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minRefuelStops ( int target , int startFuel , vector < vector < int >>& stations ) { vector < long > dp ( stations . size () + 1 , 0 ); dp [ 0 ] = startFuel ; for ( int i = 0 ; i < stations . size (); ++ i ) for ( int j = i + 1 ; j > 0 ; -- j ) if ( dp [ j - 1 ] >= stations [ i ][ 0 ]) dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + stations [ i ][ 1 ]); for ( int i = 0 ; i <= stations . size (); ++ i ) if ( dp [ i ] >= target ) return i ; return -1 ; } };","title":"871. Minimum Number of Refueling Stops"},{"location":"problems/0871/#871-minimum-number-of-refueling-stops","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minRefuelStops ( int target , int startFuel , vector < vector < int >>& stations ) { vector < long > dp ( stations . size () + 1 , 0 ); dp [ 0 ] = startFuel ; for ( int i = 0 ; i < stations . size (); ++ i ) for ( int j = i + 1 ; j > 0 ; -- j ) if ( dp [ j - 1 ] >= stations [ i ][ 0 ]) dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + stations [ i ][ 1 ]); for ( int i = 0 ; i <= stations . size (); ++ i ) if ( dp [ i ] >= target ) return i ; return -1 ; } };","title":"871. Minimum Number of Refueling Stops"},{"location":"problems/0872/","text":"872. Leaf-Similar Trees","title":"872. Leaf-Similar Trees"},{"location":"problems/0872/#872-leaf-similar-trees","text":"","title":"872. Leaf-Similar Trees"},{"location":"problems/0873/","text":"873. Length of Longest Fibonacci Subsequence Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > indices = new HashMap <> (); int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) indices . put ( A [ i ] , i ); for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ] ; if ( ai < A [ j ] && indices . containsKey ( ai )) { int i = indices . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ] ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 indices = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in indices : i = indices [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans","title":"873. Length of Longest Fibonacci Subsequence"},{"location":"problems/0873/#873-length-of-longest-fibonacci-subsequence","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { const int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { const int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > indices = new HashMap <> (); int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) indices . put ( A [ i ] , i ); for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ] ; if ( ai < A [ j ] && indices . containsKey ( ai )) { int i = indices . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ] ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 indices = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in indices : i = indices [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans","title":"873. Length of Longest Fibonacci Subsequence"},{"location":"problems/0874/","text":"874. Walking Robot Simulation","title":"874. Walking Robot Simulation"},{"location":"problems/0874/#874-walking-robot-simulation","text":"","title":"874. Walking Robot Simulation"},{"location":"problems/0875/","text":"875. Koko Eating Bananas Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( begin ( piles ), end ( piles )) + 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour > H ) l = m + 1 ; else r = m ; } return l ; } };","title":"875. Koko Eating Bananas"},{"location":"problems/0875/#875-koko-eating-bananas","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( begin ( piles ), end ( piles )) + 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour > H ) l = m + 1 ; else r = m ; } return l ; } };","title":"875. Koko Eating Bananas"},{"location":"problems/0876/","text":"876. Middle of the Linked List Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def middleNode ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow","title":"876. Middle of the Linked List"},{"location":"problems/0876/#876-middle-of-the-linked-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def middleNode ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow","title":"876. Middle of the Linked List"},{"location":"problems/0877/","text":"877. Stone Game Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool stoneGame ( vector < int >& piles ) { const int n = piles . size (); vector < int > dp = piles ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = max ( piles [ i ] - dp [ i + d ], piles [ i + d ] - dp [ i + d - 1 ]); return dp [ n - 1 ] > 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean stoneGame ( int [] piles ) { final int n = piles . length ; int [] dp = Arrays . copyOf ( piles , n ); for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = Math . max ( piles [ i ] - dp [ i + d ] , piles [ i + d ] - dp [ i + d - 1 ] ); return dp [ n - 1 ] > 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def stoneGame ( self , piles : List [ int ]) -> bool : n = len ( piles ) dp = [[ 0 ] * n for _ in range ( n )] for i , pile in enumerate ( piles ): dp [ i ][ i ] = pile for d in range ( 1 , n ): for i in range ( n - d ): dp [ i ][ i + d ] = max ( piles [ i ] - dp [ i + 1 ][ i + d ], piles [ i + d ] - dp [ i ][ i + d - 1 ]) return dp [ 0 ][ n - 1 ] > 0","title":"877. Stone Game"},{"location":"problems/0877/#877-stone-game","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool stoneGame ( vector < int >& piles ) { const int n = piles . size (); vector < int > dp = piles ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = max ( piles [ i ] - dp [ i + d ], piles [ i + d ] - dp [ i + d - 1 ]); return dp [ n - 1 ] > 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean stoneGame ( int [] piles ) { final int n = piles . length ; int [] dp = Arrays . copyOf ( piles , n ); for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = Math . max ( piles [ i ] - dp [ i + d ] , piles [ i + d ] - dp [ i + d - 1 ] ); return dp [ n - 1 ] > 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def stoneGame ( self , piles : List [ int ]) -> bool : n = len ( piles ) dp = [[ 0 ] * n for _ in range ( n )] for i , pile in enumerate ( piles ): dp [ i ][ i ] = pile for d in range ( 1 , n ): for i in range ( n - d ): dp [ i ][ i + d ] = max ( piles [ i ] - dp [ i + 1 ][ i + d ], piles [ i + d ] - dp [ i ][ i + d - 1 ]) return dp [ 0 ][ n - 1 ] > 0","title":"877. Stone Game"},{"location":"problems/0878/","text":"878. Nth Magical Number Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int nthMagicalNumber ( long N , long A , long B ) { const int kMod = int ( 1e9 + 7 ); long lcm = A * B / __gcd ( A , B ); long l = min ( A , B ); long r = min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return l % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int nthMagicalNumber ( long N , long A , long B ) { final long kMod = ( long ) 1e9 + 7 ; long lcm = A * B / gcd ( A , B ); long l = Math . min ( A , B ); long r = Math . min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return ( int ) ( l % kMod ); } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def nthMagicalNumber ( self , N : int , A : int , B : int ) -> int : kMod = int ( 1e9 + 7 ) lcm = A * B // math . gcd ( A , B ) l = min ( A , B ) r = min ( A , B ) * N while l < r : m = ( l + r ) // 2 if m // A + m // B - m // lcm < N : l = m + 1 else : r = m return l % kMod","title":"878. Nth Magical Number"},{"location":"problems/0878/#878-nth-magical-number","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int nthMagicalNumber ( long N , long A , long B ) { const int kMod = int ( 1e9 + 7 ); long lcm = A * B / __gcd ( A , B ); long l = min ( A , B ); long r = min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return l % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int nthMagicalNumber ( long N , long A , long B ) { final long kMod = ( long ) 1e9 + 7 ; long lcm = A * B / gcd ( A , B ); long l = Math . min ( A , B ); long r = Math . min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return ( int ) ( l % kMod ); } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def nthMagicalNumber ( self , N : int , A : int , B : int ) -> int : kMod = int ( 1e9 + 7 ) lcm = A * B // math . gcd ( A , B ) l = min ( A , B ) r = min ( A , B ) * N while l < r : m = ( l + r ) // 2 if m // A + m // B - m // lcm < N : l = m + 1 else : r = m return l % kMod","title":"878. Nth Magical Number"},{"location":"problems/0879/","text":"879. Profitable Schemes","title":"879. Profitable Schemes"},{"location":"problems/0879/#879-profitable-schemes","text":"","title":"879. Profitable Schemes"},{"location":"problems/0880/","text":"880. Decoded String at Index","title":"880. Decoded String at Index"},{"location":"problems/0880/#880-decoded-string-at-index","text":"","title":"880. Decoded String at Index"},{"location":"problems/0881/","text":"881. Boats to Save People Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 ; sort ( begin ( people ), end ( people )); for ( int i = 0 , j = people . size () - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j -- ]; if ( people [ i ] <= remain ) ++ i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numRescueBoats ( int [] people , int limit ) { int ans = 0 ; Arrays . sort ( people ); for ( int i = 0 , j = people . length - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j --] ; if ( people [ i ] <= remain ) ++ i ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : ans = 0 i = 0 j = len ( people ) - 1 people . sort () while i <= j : remain = limit - people [ j ] j -= 1 if people [ i ] <= remain : i += 1 ans += 1 return ans","title":"881. Boats to Save People"},{"location":"problems/0881/#881-boats-to-save-people","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 ; sort ( begin ( people ), end ( people )); for ( int i = 0 , j = people . size () - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j -- ]; if ( people [ i ] <= remain ) ++ i ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int numRescueBoats ( int [] people , int limit ) { int ans = 0 ; Arrays . sort ( people ); for ( int i = 0 , j = people . length - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j --] ; if ( people [ i ] <= remain ) ++ i ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : ans = 0 i = 0 j = len ( people ) - 1 people . sort () while i <= j : remain = limit - people [ j ] j -= 1 if people [ i ] <= remain : i += 1 ans += 1 return ans","title":"881. Boats to Save People"},{"location":"problems/0882/","text":"882. Reachable Nodes In Subdivided Graph","title":"882. Reachable Nodes In Subdivided Graph"},{"location":"problems/0882/#882-reachable-nodes-in-subdivided-graph","text":"","title":"882. Reachable Nodes In Subdivided Graph"},{"location":"problems/0883/","text":"883. Projection Area of 3D Shapes Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int projectionArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . size (); ++ j ) { maxOfRow = max ( maxOfRow , grid [ i ][ j ]); maxOfCol = max ( maxOfCol , grid [ j ][ i ]); if ( grid [ i ][ j ]) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int projectionArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . length ; ++ j ) { maxOfRow = Math . max ( maxOfRow , grid [ i ][ j ] ); maxOfCol = Math . max ( maxOfCol , grid [ j ][ i ] ); if ( grid [ i ][ j ] > 0 ) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } } Python 1 2 3 class Solution : def projectionArea ( self , grid : List [ List [ int ]]) -> int : return sum ( a > 0 for row in grid for a in row ) + sum ( max ( row ) for row in grid ) + sum ( max ( col ) for col in zip ( * grid ))","title":"883. Projection Area of 3D Shapes"},{"location":"problems/0883/#883-projection-area-of-3d-shapes","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int projectionArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . size (); ++ j ) { maxOfRow = max ( maxOfRow , grid [ i ][ j ]); maxOfCol = max ( maxOfCol , grid [ j ][ i ]); if ( grid [ i ][ j ]) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int projectionArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . length ; ++ j ) { maxOfRow = Math . max ( maxOfRow , grid [ i ][ j ] ); maxOfCol = Math . max ( maxOfCol , grid [ j ][ i ] ); if ( grid [ i ][ j ] > 0 ) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } } Python 1 2 3 class Solution : def projectionArea ( self , grid : List [ List [ int ]]) -> int : return sum ( a > 0 for row in grid for a in row ) + sum ( max ( row ) for row in grid ) + sum ( max ( col ) for col in zip ( * grid ))","title":"883. Projection Area of 3D Shapes"},{"location":"problems/0884/","text":"884. Uncommon Words from Two Sentences Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < string > uncommonFromSentences ( string A , string B ) { vector < string > ans ; unordered_map < string , int > count ; istringstream iss ( A + ' ' + B ); while ( iss >> A ) ++ count [ A ]; for ( const auto & [ word , freq ] : count ) if ( freq == 1 ) ans . push_back ( word ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String [] uncommonFromSentences ( String A , String B ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : ( A + ' ' + B ). split ( \" \" )) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) if ( count . get ( word ) == 1 ) ans . add ( word ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 class Solution : def uncommonFromSentences ( self , A : str , B : str ) -> List [ str ]: count = collections . Counter (( A + ' ' + B ) . split ()) return [ word for word , freq in count . items () if freq == 1 ]","title":"884. Uncommon Words from Two Sentences"},{"location":"problems/0884/#884-uncommon-words-from-two-sentences","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < string > uncommonFromSentences ( string A , string B ) { vector < string > ans ; unordered_map < string , int > count ; istringstream iss ( A + ' ' + B ); while ( iss >> A ) ++ count [ A ]; for ( const auto & [ word , freq ] : count ) if ( freq == 1 ) ans . push_back ( word ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String [] uncommonFromSentences ( String A , String B ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : ( A + ' ' + B ). split ( \" \" )) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) if ( count . get ( word ) == 1 ) ans . add ( word ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 class Solution : def uncommonFromSentences ( self , A : str , B : str ) -> List [ str ]: count = collections . Counter (( A + ' ' + B ) . split ()) return [ word for word , freq in count . items () if freq == 1 ]","title":"884. Uncommon Words from Two Sentences"},{"location":"problems/0885/","text":"885. Spiral Matrix III Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans {{ r0 , c0 }}; vector < int > dx { 1 , 0 , -1 , 0 }; vector < int > dy { 0 , 1 , 0 , -1 }; for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ]; c0 += dx [ i % 4 ]; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [][] spiralMatrixIII ( int R , int C , int r0 , int c0 ) { List < int []> ans = new ArrayList <> (); final int [] dx = { 1 , 0 , - 1 , 0 }; final int [] dy = { 0 , 1 , 0 , - 1 }; ans . add ( new int [] { r0 , c0 }); for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ] ; c0 += dx [ i % 4 ] ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . add ( new int [] { r0 , c0 }); } return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] dx = [ 1 , 0 , - 1 , 0 ] dy = [ 0 , 1 , 0 , - 1 ] i = 0 while len ( ans ) < R * C : for _ in range ( i // 2 + 1 ): r0 += dy [ i % 4 ] c0 += dx [ i % 4 ] if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) i += 1 return ans","title":"885. Spiral Matrix III"},{"location":"problems/0885/#885-spiral-matrix-iii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans {{ r0 , c0 }}; vector < int > dx { 1 , 0 , -1 , 0 }; vector < int > dy { 0 , 1 , 0 , -1 }; for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ]; c0 += dx [ i % 4 ]; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [][] spiralMatrixIII ( int R , int C , int r0 , int c0 ) { List < int []> ans = new ArrayList <> (); final int [] dx = { 1 , 0 , - 1 , 0 }; final int [] dy = { 0 , 1 , 0 , - 1 }; ans . add ( new int [] { r0 , c0 }); for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ] ; c0 += dx [ i % 4 ] ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . add ( new int [] { r0 , c0 }); } return ans . toArray ( new int [ ans . size () ][] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] dx = [ 1 , 0 , - 1 , 0 ] dy = [ 0 , 1 , 0 , - 1 ] i = 0 while len ( ans ) < R * C : for _ in range ( i // 2 + 1 ): r0 += dy [ i % 4 ] c0 += dx [ i % 4 ] if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) i += 1 return ans","title":"885. Spiral Matrix III"},{"location":"problems/0886/","text":"886. Possible Bipartition","title":"886. Possible Bipartition"},{"location":"problems/0886/#886-possible-bipartition","text":"","title":"886. Possible Bipartition"},{"location":"problems/0887/","text":"887. Super Egg Drop Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int superEggDrop ( int K , int N ) { int moves = 0 ; vector < vector < int >> dp ( N + 1 , vector < int > ( K + 1 )); while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int superEggDrop ( int K , int N ) { int moves = 0 ; int [][] dp = new int [ N + 1 ][ K + 1 ] ; while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def superEggDrop ( self , K : int , N : int ) -> int : moves = 0 dp = [[ 0 ] * ( K + 1 ) for _ in range ( N + 1 )] while dp [ moves ][ K ] < N : moves += 1 for eggs in range ( 1 , K + 1 ): dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + \\ dp [ moves - 1 ][ eggs ] + 1 return moves","title":"887. Super Egg Drop"},{"location":"problems/0887/#887-super-egg-drop","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int superEggDrop ( int K , int N ) { int moves = 0 ; vector < vector < int >> dp ( N + 1 , vector < int > ( K + 1 )); while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int superEggDrop ( int K , int N ) { int moves = 0 ; int [][] dp = new int [ N + 1 ][ K + 1 ] ; while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def superEggDrop ( self , K : int , N : int ) -> int : moves = 0 dp = [[ 0 ] * ( K + 1 ) for _ in range ( N + 1 )] while dp [ moves ][ K ] < N : moves += 1 for eggs in range ( 1 , K + 1 ): dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + \\ dp [ moves - 1 ][ eggs ] + 1 return moves","title":"887. Super Egg Drop"},{"location":"problems/0888/","text":"888. Fair Candy Swap Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( begin ( A ), end ( A ), 0 ) - accumulate ( begin ( B ), end ( B ), 0 )) / 2 ; unordered_set < int > set { begin ( B ), end ( B )}; for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <> (); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ]","title":"888. Fair Candy Swap"},{"location":"problems/0888/#888-fair-candy-swap","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( begin ( A ), end ( A ), 0 ) - accumulate ( begin ( B ), end ( B ), 0 )) / 2 ; unordered_set < int > set { begin ( B ), end ( B )}; for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <> (); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ]","title":"888. Fair Candy Swap"},{"location":"problems/0889/","text":"889. Construct Binary Tree from Preorder and Postorder Traversal Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal"},{"location":"problems/0889/#889-construct-binary-tree-from-preorder-and-postorder-traversal","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal"},{"location":"problems/0890/","text":"890. Find and Replace Pattern Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > ans ; for ( const string & word : words ) if ( isIsomorphic ( word , pattern )) ans . push_back ( word ); return ans ; } private : bool isIsomorphic ( const string & w , const string & p ) { vector < int > map_w ( 128 ); vector < int > map_p ( 128 ); for ( int i = 0 ; i < w . length (); ++ i ) { if ( map_w [ w [ i ]] != map_p [ p [ i ]]) return false ; map_w [ w [ i ]] = i + 1 ; map_p [ p [ i ]] = i + 1 ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > findAndReplacePattern ( String [] words , String pattern ) { List < String > ans = new ArrayList <> (); for ( final String word : words ) if ( isIsomorphic ( word , pattern )) ans . add ( word ); return ans ; } private boolean isIsomorphic ( final String w , final String p ) { Map < Character , Integer > map_w = new HashMap <> (); Map < Character , Integer > map_p = new HashMap <> (); for ( Integer i = 0 ; i < w . length (); ++ i ) if ( map_w . put ( w . charAt ( i ), i ) != map_p . put ( p . charAt ( i ), i )) return false ; return true ; } } Python 1 2 3 4 5 class Solution : def findAndReplacePattern ( self , words : List [ str ], pattern : str ) -> List [ str ]: def isIsomorphic ( w : str , p : str ) -> bool : return [ * map ( w . index , w )] == [ * map ( p . index , p )] return [ word for word in words if isIsomorphic ( word , pattern )]","title":"890. Find and Replace Pattern"},{"location":"problems/0890/#890-find-and-replace-pattern","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > ans ; for ( const string & word : words ) if ( isIsomorphic ( word , pattern )) ans . push_back ( word ); return ans ; } private : bool isIsomorphic ( const string & w , const string & p ) { vector < int > map_w ( 128 ); vector < int > map_p ( 128 ); for ( int i = 0 ; i < w . length (); ++ i ) { if ( map_w [ w [ i ]] != map_p [ p [ i ]]) return false ; map_w [ w [ i ]] = i + 1 ; map_p [ p [ i ]] = i + 1 ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > findAndReplacePattern ( String [] words , String pattern ) { List < String > ans = new ArrayList <> (); for ( final String word : words ) if ( isIsomorphic ( word , pattern )) ans . add ( word ); return ans ; } private boolean isIsomorphic ( final String w , final String p ) { Map < Character , Integer > map_w = new HashMap <> (); Map < Character , Integer > map_p = new HashMap <> (); for ( Integer i = 0 ; i < w . length (); ++ i ) if ( map_w . put ( w . charAt ( i ), i ) != map_p . put ( p . charAt ( i ), i )) return false ; return true ; } } Python 1 2 3 4 5 class Solution : def findAndReplacePattern ( self , words : List [ str ], pattern : str ) -> List [ str ]: def isIsomorphic ( w : str , p : str ) -> bool : return [ * map ( w . index , w )] == [ * map ( p . index , p )] return [ word for word in words if isIsomorphic ( word , pattern )]","title":"890. Find and Replace Pattern"},{"location":"problems/0891/","text":"891. Sum of Subsequence Widths Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans","title":"891. Sum of Subsequence Widths"},{"location":"problems/0891/#891-sum-of-subsequence-widths","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans","title":"891. Sum of Subsequence Widths"},{"location":"problems/0892/","text":"892. Surface Area of 3D Shapes Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int surfaceArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid . size (); ++ j ) { if ( grid [ i ][ j ]) ans += grid [ i ][ j ] * 4 + 2 ; if ( i ) ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 ; if ( j ) ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int surfaceArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid . length ; ++ j ) { if ( grid [ i ][ j ] > 0 ) ans += grid [ i ][ j ] * 4 + 2 ; if ( i > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i - 1 ][ j ] ) * 2 ; if ( j > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i ][ j - 1 ] ) * 2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def surfaceArea ( self , grid : List [ List [ int ]]) -> int : ans = 0 for i in range ( len ( grid )): for j in range ( len ( grid )): if grid [ i ][ j ]: ans += grid [ i ][ j ] * 4 + 2 if i : ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 if j : ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 return ans","title":"892. Surface Area of 3D Shapes"},{"location":"problems/0892/#892-surface-area-of-3d-shapes","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int surfaceArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid . size (); ++ j ) { if ( grid [ i ][ j ]) ans += grid [ i ][ j ] * 4 + 2 ; if ( i ) ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 ; if ( j ) ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int surfaceArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid . length ; ++ j ) { if ( grid [ i ][ j ] > 0 ) ans += grid [ i ][ j ] * 4 + 2 ; if ( i > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i - 1 ][ j ] ) * 2 ; if ( j > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i ][ j - 1 ] ) * 2 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def surfaceArea ( self , grid : List [ List [ int ]]) -> int : ans = 0 for i in range ( len ( grid )): for j in range ( len ( grid )): if grid [ i ][ j ]: ans += grid [ i ][ j ] * 4 + 2 if i : ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 if j : ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 return ans","title":"892. Surface Area of 3D Shapes"},{"location":"problems/0893/","text":"893. Groups of Special-Equivalent Strings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int numSpecialEquivGroups ( vector < string >& A ) { unordered_set < string > set ; for ( const string & s : A ) { string even ; string odd ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s [ i ]; else odd += s [ i ]; sort ( begin ( even ), end ( even )); sort ( begin ( odd ), end ( odd )); set . insert ( even + odd ); } return set . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int numSpecialEquivGroups ( String [] A ) { Set < String > set = new HashSet <> (); for ( final String s : A ) { String even = \"\" ; String odd = \"\" ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s . charAt ( i ); else odd += s . charAt ( i ); char [] evenCharArray = even . toCharArray (); char [] oddCharArray = odd . toCharArray (); Arrays . sort ( evenCharArray ); Arrays . sort ( oddCharArray ); set . add ( new String ( evenCharArray ) + new String ( oddCharArray )); } return set . size (); } } Python 1 2 3 class Solution : def numSpecialEquivGroups ( self , A : List [ str ]) -> int : return len ({ '' . join ( sorted ( s [:: 2 ])) + '' . join ( sorted ( s [ 1 :: 2 ])) for s in A })","title":"893. Groups of Special-Equivalent Strings"},{"location":"problems/0893/#893-groups-of-special-equivalent-strings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int numSpecialEquivGroups ( vector < string >& A ) { unordered_set < string > set ; for ( const string & s : A ) { string even ; string odd ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s [ i ]; else odd += s [ i ]; sort ( begin ( even ), end ( even )); sort ( begin ( odd ), end ( odd )); set . insert ( even + odd ); } return set . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int numSpecialEquivGroups ( String [] A ) { Set < String > set = new HashSet <> (); for ( final String s : A ) { String even = \"\" ; String odd = \"\" ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s . charAt ( i ); else odd += s . charAt ( i ); char [] evenCharArray = even . toCharArray (); char [] oddCharArray = odd . toCharArray (); Arrays . sort ( evenCharArray ); Arrays . sort ( oddCharArray ); set . add ( new String ( evenCharArray ) + new String ( oddCharArray )); } return set . size (); } } Python 1 2 3 class Solution : def numSpecialEquivGroups ( self , A : List [ str ]) -> int : return len ({ '' . join ( sorted ( s [:: 2 ])) + '' . join ( sorted ( s [ 1 :: 2 ])) for s in A })","title":"893. Groups of Special-Equivalent Strings"},{"location":"problems/0894/","text":"894. All Possible Full Binary Trees","title":"894. All Possible Full Binary Trees"},{"location":"problems/0894/#894-all-possible-full-binary-trees","text":"","title":"894. All Possible Full Binary Trees"},{"location":"problems/0895/","text":"895. Maximum Frequency Stack Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class FreqStack { public : void push ( int x ) { maxFreq = max ( maxFreq , ++ count [ x ]); countToStack [ count [ x ]]. push ( x ); } int pop () { int value = countToStack [ maxFreq ]. top (); -- count [ value ]; countToStack [ maxFreq ]. pop (); if ( countToStack [ maxFreq ]. empty ()) -- maxFreq ; return value ; } private : int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , stack < int >> countToStack ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FreqStack { public void push ( int x ) { count . put ( x , count . getOrDefault ( x , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( x )); if ( ! countToStack . containsKey ( count . get ( x ))) countToStack . put ( count . get ( x ), new Stack <> ()); countToStack . get ( count . get ( x )). add ( x ); } public int pop () { int value = countToStack . get ( maxFreq ). pop (); count . put ( value , count . get ( value ) - 1 ); if ( countToStack . get ( maxFreq ). isEmpty ()) -- maxFreq ; return value ; } private int maxFreq = 0 ; private Map < Integer , Integer > count = new HashMap <> (); private Map < Integer , Stack < Integer >> countToStack = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class FreqStack : def __init__ ( self ): self . count = collections . Counter () self . countToStack = collections . defaultdict ( list ) self . maxFreq = 0 def push ( self , x : int ) -> None : self . count [ x ] += 1 self . maxFreq = max ( self . maxFreq , self . count [ x ]) self . countToStack [ self . count [ x ]] . append ( x ) def pop ( self ) -> int : value = self . countToStack [ self . maxFreq ] . pop () self . count [ value ] -= 1 if not self . countToStack [ self . maxFreq ]: self . maxFreq -= 1 return value","title":"895. Maximum Frequency Stack"},{"location":"problems/0895/#895-maximum-frequency-stack","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class FreqStack { public : void push ( int x ) { maxFreq = max ( maxFreq , ++ count [ x ]); countToStack [ count [ x ]]. push ( x ); } int pop () { int value = countToStack [ maxFreq ]. top (); -- count [ value ]; countToStack [ maxFreq ]. pop (); if ( countToStack [ maxFreq ]. empty ()) -- maxFreq ; return value ; } private : int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , stack < int >> countToStack ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FreqStack { public void push ( int x ) { count . put ( x , count . getOrDefault ( x , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( x )); if ( ! countToStack . containsKey ( count . get ( x ))) countToStack . put ( count . get ( x ), new Stack <> ()); countToStack . get ( count . get ( x )). add ( x ); } public int pop () { int value = countToStack . get ( maxFreq ). pop (); count . put ( value , count . get ( value ) - 1 ); if ( countToStack . get ( maxFreq ). isEmpty ()) -- maxFreq ; return value ; } private int maxFreq = 0 ; private Map < Integer , Integer > count = new HashMap <> (); private Map < Integer , Stack < Integer >> countToStack = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class FreqStack : def __init__ ( self ): self . count = collections . Counter () self . countToStack = collections . defaultdict ( list ) self . maxFreq = 0 def push ( self , x : int ) -> None : self . count [ x ] += 1 self . maxFreq = max ( self . maxFreq , self . count [ x ]) self . countToStack [ self . count [ x ]] . append ( x ) def pop ( self ) -> int : value = self . countToStack [ self . maxFreq ] . pop () self . count [ value ] -= 1 if not self . countToStack [ self . maxFreq ]: self . maxFreq -= 1 return value","title":"895. Maximum Frequency Stack"},{"location":"problems/0896/","text":"896. Monotonic Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i ] >= A [ i - 1 ]; decreasing &= A [ i ] <= A [ i - 1 ]; } return increasing || decreasing ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; ++ i ) { increasing &= A [ i - 1 ] <= A [ i ] ; decreasing &= A [ i - 1 ] >= A [ i ] ; } return increasing || decreasing ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing","title":"896. Monotonic Array"},{"location":"problems/0896/#896-monotonic-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i ] >= A [ i - 1 ]; decreasing &= A [ i ] <= A [ i - 1 ]; } return increasing || decreasing ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; ++ i ) { increasing &= A [ i - 1 ] <= A [ i ] ; decreasing &= A [ i - 1 ] >= A [ i ] ; } return increasing || decreasing ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing","title":"896. Monotonic Array"},{"location":"problems/0897/","text":"897. Increasing Order Search Tree","title":"897. Increasing Order Search Tree"},{"location":"problems/0897/#897-increasing-order-search-tree","text":"","title":"897. Increasing Order Search Tree"},{"location":"problems/0898/","text":"898. Bitwise ORs of Subarrays Time: $O(n\\log\\max(A))$ Space: $O(n\\log\\max(A))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int subarrayBitwiseORs ( vector < int >& A ) { // s(j) := A[i] | A[i + 1] | ... | A[j] for all 0 <= i <= j (fixed) vector < int > s ; int l = 0 ; for ( const int a : A ) { const int r = s . size (); s . push_back ( a ); // s[l..r) are the values generated in the previous iteration for ( int i = l ; i < r ; ++ i ) if ( s . back () != ( s [ i ] | a )) s . push_back ( s [ i ] | a ); l = r ; } return unordered_set < int > ( begin ( s ), end ( s )). size (); } };","title":"898. Bitwise ORs of Subarrays"},{"location":"problems/0898/#898-bitwise-ors-of-subarrays","text":"Time: $O(n\\log\\max(A))$ Space: $O(n\\log\\max(A))$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int subarrayBitwiseORs ( vector < int >& A ) { // s(j) := A[i] | A[i + 1] | ... | A[j] for all 0 <= i <= j (fixed) vector < int > s ; int l = 0 ; for ( const int a : A ) { const int r = s . size (); s . push_back ( a ); // s[l..r) are the values generated in the previous iteration for ( int i = l ; i < r ; ++ i ) if ( s . back () != ( s [ i ] | a )) s . push_back ( s [ i ] | a ); l = r ; } return unordered_set < int > ( begin ( s ), end ( s )). size (); } };","title":"898. Bitwise ORs of Subarrays"},{"location":"problems/0899/","text":"899. Orderly Queue Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string orderlyQueue ( string S , int K ) { if ( K > 1 ) { sort ( begin ( S ), end ( S )); return S ; } string ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) ans = min ( ans , S . substr ( i ) + S . substr ( 0 , i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String orderlyQueue ( String S , int K ) { if ( K > 1 ) { char [] chars = S . toCharArray (); Arrays . sort ( chars ); return String . valueOf ( chars ); } String ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) { String S2 = S . substring ( i ) + S . substring ( 0 , i ); if ( ans . compareTo ( S2 ) > 0 ) ans = S2 ; } return ans ; } } Python 1 2 3 class Solution : def orderlyQueue ( self , S : str , K : int ) -> str : return '' . join ( sorted ( S )) if K > 1 else min ( S [ i :] + S [: i ] for i in range ( len ( S )))","title":"899. Orderly Queue"},{"location":"problems/0899/#899-orderly-queue","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : string orderlyQueue ( string S , int K ) { if ( K > 1 ) { sort ( begin ( S ), end ( S )); return S ; } string ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) ans = min ( ans , S . substr ( i ) + S . substr ( 0 , i )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String orderlyQueue ( String S , int K ) { if ( K > 1 ) { char [] chars = S . toCharArray (); Arrays . sort ( chars ); return String . valueOf ( chars ); } String ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) { String S2 = S . substring ( i ) + S . substring ( 0 , i ); if ( ans . compareTo ( S2 ) > 0 ) ans = S2 ; } return ans ; } } Python 1 2 3 class Solution : def orderlyQueue ( self , S : str , K : int ) -> str : return '' . join ( sorted ( S )) if K > 1 else min ( S [ i :] + S [: i ] for i in range ( len ( S )))","title":"899. Orderly Queue"},{"location":"problems/0900/","text":"900. RLE Iterator Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return -1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ] ; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ] ; } private int index = 0 ; private int [] A ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"900. RLE Iterator"},{"location":"problems/0900/#900-rle-iterator","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return -1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ] ; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ] ; } private int index = 0 ; private int [] A ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"900. RLE Iterator"},{"location":"problems/0901/","text":"901. Online Stock Span","title":"901. Online Stock Span"},{"location":"problems/0901/#901-online-stock-span","text":"","title":"901. Online Stock Span"},{"location":"problems/0902/","text":"902. Numbers At Most N Given Digit Set Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int atMostNGivenDigitSet ( vector < string >& D , int N ) { int ans = 0 ; string num = to_string ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += pow ( D . size (), i ); for ( int i = 0 ; i < num . length (); ++ i ) { bool dHasSameNum = false ; for ( const string & digit : D ) { if ( digit [ 0 ] < num [ i ]) ans += pow ( D . size (), num . length () - i - 1 ); else if ( digit [ 0 ] == num [ i ]) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int atMostNGivenDigitSet ( String [] D , int N ) { int ans = 0 ; String num = String . valueOf ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += Math . pow ( D . length , i ); for ( int i = 0 ; i < num . length (); ++ i ) { boolean dHasSameNum = false ; for ( final String digit : D ) { if ( digit . charAt ( 0 ) < num . charAt ( i )) ans += Math . pow ( D . length , num . length () - i - 1 ); else if ( digit . charAt ( 0 ) == num . charAt ( i )) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def atMostNGivenDigitSet ( self , D : List [ str ], N : int ) -> int : ans = 0 num = str ( N ) for i in range ( 1 , len ( num )): ans += len ( D ) ** i for i , c in enumerate ( num ): dHasSameNum = False for digit in D : if digit < c : ans += len ( D ) ** ( len ( num ) - i - 1 ) elif digit == c : dHasSameNum = True if not dHasSameNum : return ans return ans + 1","title":"902. Numbers At Most N Given Digit Set"},{"location":"problems/0902/#902-numbers-at-most-n-given-digit-set","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int atMostNGivenDigitSet ( vector < string >& D , int N ) { int ans = 0 ; string num = to_string ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += pow ( D . size (), i ); for ( int i = 0 ; i < num . length (); ++ i ) { bool dHasSameNum = false ; for ( const string & digit : D ) { if ( digit [ 0 ] < num [ i ]) ans += pow ( D . size (), num . length () - i - 1 ); else if ( digit [ 0 ] == num [ i ]) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int atMostNGivenDigitSet ( String [] D , int N ) { int ans = 0 ; String num = String . valueOf ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += Math . pow ( D . length , i ); for ( int i = 0 ; i < num . length (); ++ i ) { boolean dHasSameNum = false ; for ( final String digit : D ) { if ( digit . charAt ( 0 ) < num . charAt ( i )) ans += Math . pow ( D . length , num . length () - i - 1 ); else if ( digit . charAt ( 0 ) == num . charAt ( i )) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def atMostNGivenDigitSet ( self , D : List [ str ], N : int ) -> int : ans = 0 num = str ( N ) for i in range ( 1 , len ( num )): ans += len ( D ) ** i for i , c in enumerate ( num ): dHasSameNum = False for digit in D : if digit < c : ans += len ( D ) ** ( len ( num ) - i - 1 ) elif digit == c : dHasSameNum = True if not dHasSameNum : return ans return ans + 1","title":"902. Numbers At Most N Given Digit Set"},{"location":"problems/0903/","text":"903. Valid Permutations for DI Sequence","title":"903. Valid Permutations for DI Sequence"},{"location":"problems/0903/#903-valid-permutations-for-di-sequence","text":"","title":"903. Valid Permutations for DI Sequence"},{"location":"problems/0904/","text":"904. Fruit Into Baskets Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int totalFruit ( vector < int >& tree ) { int ans = 0 ; unordered_map < int , int > count ; for ( int l = 0 , r = 0 ; r < tree . size (); ++ r ) { ++ count [ tree [ r ]]; while ( count . size () > 2 ) { if ( -- count [ tree [ l ]] == 0 ) count . erase ( tree [ l ]); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int totalFruit ( int [] tree ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int l = 0 , r = 0 ; r < tree . length ; ++ r ) { count . put ( tree [ r ] , count . getOrDefault ( tree [ r ] , 0 ) + 1 ); while ( count . size () > 2 ) { count . put ( tree [ l ] , count . get ( tree [ l ] ) - 1 ); count . remove ( tree [ l ] , 0 ); ++ l ; } ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def totalFruit ( self , tree : List [ int ]) -> int : ans = 0 count = collections . defaultdict ( int ) l = 0 for r , t in enumerate ( tree ): count [ t ] += 1 while len ( count ) > 2 : count [ tree [ l ]] -= 1 if count [ tree [ l ]] == 0 : del count [ tree [ l ]] l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"904. Fruit Into Baskets"},{"location":"problems/0904/#904-fruit-into-baskets","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int totalFruit ( vector < int >& tree ) { int ans = 0 ; unordered_map < int , int > count ; for ( int l = 0 , r = 0 ; r < tree . size (); ++ r ) { ++ count [ tree [ r ]]; while ( count . size () > 2 ) { if ( -- count [ tree [ l ]] == 0 ) count . erase ( tree [ l ]); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int totalFruit ( int [] tree ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int l = 0 , r = 0 ; r < tree . length ; ++ r ) { count . put ( tree [ r ] , count . getOrDefault ( tree [ r ] , 0 ) + 1 ); while ( count . size () > 2 ) { count . put ( tree [ l ] , count . get ( tree [ l ] ) - 1 ); count . remove ( tree [ l ] , 0 ); ++ l ; } ans = Math . max ( ans , r - l + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def totalFruit ( self , tree : List [ int ]) -> int : ans = 0 count = collections . defaultdict ( int ) l = 0 for r , t in enumerate ( tree ): count [ t ] += 1 while len ( count ) > 2 : count [ tree [ l ]] -= 1 if count [ tree [ l ]] == 0 : del count [ tree [ l ]] l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"904. Fruit Into Baskets"},{"location":"problems/0905/","text":"905. Sort Array By Parity Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A","title":"905. Sort Array By Parity"},{"location":"problems/0905/#905-sort-array-by-parity","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A","title":"905. Sort Array By Parity"},{"location":"problems/0906/","text":"906. Super Palindromes Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : int superpalindromesInRange ( string L , string R ) { int ans = 0 ; long long l = stoll ( L ); long long r = stoll ( R ); for ( long long i = sqrt ( l ); i * i <= r ;) { long long palindrome = nextPalindrome ( i ); long long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private : long long nextPalindrome ( int num ) { const string s = to_string ( num ); const int n = s . length (); string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = to_string ( stoll ( half ) + 1 ); reversedHalf = reversed ( half . substr ( 0 , n / 2 )); return stoll ( half + reversedHalf ); } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } bool isPalindrome ( long long num ) { const string s = to_string ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public int superpalindromesInRange ( String L , String R ) { int ans = 0 ; Long l = Long . valueOf ( L ); Long r = Long . valueOf ( R ); for ( long i = ( long ) Math . sqrt ( l ); i * i <= r ;) { long palindrome = nextPalindrome ( i ); long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private long nextPalindrome ( long num ) { final String s = String . valueOf ( num ); final int n = s . length (); String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = String . valueOf ( Long . valueOf ( half ) + 1 ); reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); return Long . valueOf ( half + reversedHalf ); } private boolean isPalindrome ( long num ) { final String s = String . valueOf ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def superpalindromesInRange ( self , L : str , R : str ) -> int : def nextPalindrome ( num : int ) -> int : s = str ( num ) n = len ( s ) half = s [ 0 :( n + 1 ) // 2 ] reversedHalf = half [: n // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate >= num : return candidate half = str ( int ( half ) + 1 ) reversedHalf = half [: n // 2 ][:: - 1 ] return int ( half + reversedHalf ) def isPalindrome ( num : int ) -> bool : s = str ( num ) l = 0 r = len ( s ) - 1 while l < r : if s [ l ] != s [ r ]: return False l += 1 r -= 1 return True ans = 0 l = int ( L ) r = int ( R ) i = int ( sqrt ( l )) while i * i <= r : palindrome = nextPalindrome ( i ) squared = palindrome ** 2 if squared <= r and isPalindrome ( squared ): ans += 1 i = palindrome + 1 return ans","title":"906. Super Palindromes"},{"location":"problems/0906/#906-super-palindromes","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : int superpalindromesInRange ( string L , string R ) { int ans = 0 ; long long l = stoll ( L ); long long r = stoll ( R ); for ( long long i = sqrt ( l ); i * i <= r ;) { long long palindrome = nextPalindrome ( i ); long long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private : long long nextPalindrome ( int num ) { const string s = to_string ( num ); const int n = s . length (); string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = to_string ( stoll ( half ) + 1 ); reversedHalf = reversed ( half . substr ( 0 , n / 2 )); return stoll ( half + reversedHalf ); } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } bool isPalindrome ( long long num ) { const string s = to_string ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public int superpalindromesInRange ( String L , String R ) { int ans = 0 ; Long l = Long . valueOf ( L ); Long r = Long . valueOf ( R ); for ( long i = ( long ) Math . sqrt ( l ); i * i <= r ;) { long palindrome = nextPalindrome ( i ); long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private long nextPalindrome ( long num ) { final String s = String . valueOf ( num ); final int n = s . length (); String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = String . valueOf ( Long . valueOf ( half ) + 1 ); reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); return Long . valueOf ( half + reversedHalf ); } private boolean isPalindrome ( long num ) { final String s = String . valueOf ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def superpalindromesInRange ( self , L : str , R : str ) -> int : def nextPalindrome ( num : int ) -> int : s = str ( num ) n = len ( s ) half = s [ 0 :( n + 1 ) // 2 ] reversedHalf = half [: n // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate >= num : return candidate half = str ( int ( half ) + 1 ) reversedHalf = half [: n // 2 ][:: - 1 ] return int ( half + reversedHalf ) def isPalindrome ( num : int ) -> bool : s = str ( num ) l = 0 r = len ( s ) - 1 while l < r : if s [ l ] != s [ r ]: return False l += 1 r -= 1 return True ans = 0 l = int ( L ) r = int ( R ) i = int ( sqrt ( l )) while i * i <= r : palindrome = nextPalindrome ( i ) squared = palindrome ** 2 if squared <= r and isPalindrome ( squared ): ans += 1 i = palindrome + 1 return ans","title":"906. Super Palindromes"},{"location":"problems/0907/","text":"907. Sum of Subarray Minimums Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , -1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? -1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ] ; int [] next = new int [ n ] ; Stack < Integer > stack1 = new Stack <> (); Stack < Integer > stack2 = new Stack <> (); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; ++ i ) { while ( ! stack1 . isEmpty () && A [ stack1 . peek () ] > A [ i ] ) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while ( ! stack2 . isEmpty () && A [ stack2 . peek () ] > A [ i ] ) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i )) % kMod ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans","title":"907. Sum of Subarray Minimums"},{"location":"problems/0907/#907-sum-of-subarray-minimums","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , -1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? -1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ] ; int [] next = new int [ n ] ; Stack < Integer > stack1 = new Stack <> (); Stack < Integer > stack2 = new Stack <> (); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; ++ i ) { while ( ! stack1 . isEmpty () && A [ stack1 . peek () ] > A [ i ] ) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while ( ! stack2 . isEmpty () && A [ stack2 . peek () ] > A [ i ] ) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i )) % kMod ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans","title":"907. Sum of Subarray Minimums"},{"location":"problems/0908/","text":"908. Smallest Range I Time: Space: C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int smallestRangeI ( vector < int >& A , int K ) { int max = * max_element ( begin ( A ), end ( A )); int min = * min_element ( begin ( A ), end ( A )); return std :: max ( 0 , max - min - 2 * K ); } }; Java 1 2 3 4 5 6 7 8 class Solution { public int smallestRangeI ( int [] A , int K ) { int max = Arrays . stream ( A ). max (). getAsInt (); int min = Arrays . stream ( A ). min (). getAsInt (); return Math . max ( 0 , max - min - 2 * K ); } } Python 1 2 3 class Solution : def smallestRangeI ( self , A : List [ int ], K : int ) -> int : return max ( 0 , max ( A ) - min ( A ) - 2 * K )","title":"908. Smallest Range I"},{"location":"problems/0908/#908-smallest-range-i","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int smallestRangeI ( vector < int >& A , int K ) { int max = * max_element ( begin ( A ), end ( A )); int min = * min_element ( begin ( A ), end ( A )); return std :: max ( 0 , max - min - 2 * K ); } }; Java 1 2 3 4 5 6 7 8 class Solution { public int smallestRangeI ( int [] A , int K ) { int max = Arrays . stream ( A ). max (). getAsInt (); int min = Arrays . stream ( A ). min (). getAsInt (); return Math . max ( 0 , max - min - 2 * K ); } } Python 1 2 3 class Solution : def smallestRangeI ( self , A : List [ int ], K : int ) -> int : return max ( 0 , max ( A ) - min ( A ) - 2 * K )","title":"908. Smallest Range I"},{"location":"problems/0909/","text":"909. Snakes and Ladders","title":"909. Snakes and Ladders"},{"location":"problems/0909/#909-snakes-and-ladders","text":"","title":"909. Snakes and Ladders"},{"location":"problems/0910/","text":"910. Smallest Range II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRangeII ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); int ans = A . back () - A . front (); int left = A . front () + K ; int right = A . back () - K ; for ( int i = 0 ; i + 1 < A . size (); ++ i ) { int min = std :: min ( left , A [ i + 1 ] - K ); int max = std :: max ( right , A [ i ] + K ); ans = std :: min ( ans , max - min ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int smallestRangeII ( int [] A , int K ) { Arrays . sort ( A ); int ans = A [ A . length - 1 ] - A [ 0 ] ; int left = A [ 0 ] + K ; int right = A [ A . length - 1 ] - K ; for ( int i = 0 ; i + 1 < A . length ; ++ i ) { int min = Math . min ( left , A [ i + 1 ] - K ); int max = Math . max ( right , A [ i ] + K ); ans = Math . min ( ans , max - min ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def smallestRangeII ( self , A : List [ int ], K : int ) -> int : A . sort () ans = A [ - 1 ] - A [ 0 ] left = A [ 0 ] + K right = A [ - 1 ] - K for a , b in zip ( A , A [ 1 :]): mini = min ( left , b - K ) maxi = max ( right , a + K ) ans = min ( ans , maxi - mini ) return ans","title":"910. Smallest Range II"},{"location":"problems/0910/#910-smallest-range-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRangeII ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); int ans = A . back () - A . front (); int left = A . front () + K ; int right = A . back () - K ; for ( int i = 0 ; i + 1 < A . size (); ++ i ) { int min = std :: min ( left , A [ i + 1 ] - K ); int max = std :: max ( right , A [ i ] + K ); ans = std :: min ( ans , max - min ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int smallestRangeII ( int [] A , int K ) { Arrays . sort ( A ); int ans = A [ A . length - 1 ] - A [ 0 ] ; int left = A [ 0 ] + K ; int right = A [ A . length - 1 ] - K ; for ( int i = 0 ; i + 1 < A . length ; ++ i ) { int min = Math . min ( left , A [ i + 1 ] - K ); int max = Math . max ( right , A [ i ] + K ); ans = Math . min ( ans , max - min ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def smallestRangeII ( self , A : List [ int ], K : int ) -> int : A . sort () ans = A [ - 1 ] - A [ 0 ] left = A [ 0 ] + K right = A [ - 1 ] - K for a , b in zip ( A , A [ 1 :]): mini = min ( left , b - K ) maxi = max ( right , a + K ) ans = min ( ans , maxi - mini ) return ans","title":"910. Smallest Range II"},{"location":"problems/0911/","text":"911. Online Election","title":"911. Online Election"},{"location":"problems/0911/#911-online-election","text":"","title":"911. Online Election"},{"location":"problems/0912/","text":"912. Sort an Array","title":"912. Sort an Array"},{"location":"problems/0912/#912-sort-an-array","text":"","title":"912. Sort an Array"},{"location":"problems/0913/","text":"913. Cat and Mouse","title":"913. Cat and Mouse"},{"location":"problems/0913/#913-cat-and-mouse","text":"","title":"913. Cat and Mouse"},{"location":"problems/0914/","text":"914. X of a Kind in a Deck of Cards Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > count ; int gcd = 0 ; for ( int d : deck ) ++ count [ d ]; for ( const auto & [ _ , value ] : count ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > count = new HashMap <> (); int gcd = 0 ; for ( int d : deck ) count . put ( d , count . getOrDefault ( d , 0 ) + 1 ); for ( int value : count . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } } Python 1 2 3 4 class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : count = collections . Counter ( deck ) return functools . reduce ( math . gcd , count . values ()) >= 2","title":"914. X of a Kind in a Deck of Cards"},{"location":"problems/0914/#914-x-of-a-kind-in-a-deck-of-cards","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > count ; int gcd = 0 ; for ( int d : deck ) ++ count [ d ]; for ( const auto & [ _ , value ] : count ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > count = new HashMap <> (); int gcd = 0 ; for ( int d : deck ) count . put ( d , count . getOrDefault ( d , 0 ) + 1 ); for ( int value : count . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } } Python 1 2 3 4 class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : count = collections . Counter ( deck ) return functools . reduce ( math . gcd , count . values ()) >= 2","title":"914. X of a Kind in a Deck of Cards"},{"location":"problems/0915/","text":"915. Partition Array into Disjoint Intervals Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ] ; min [ n - 1 ] = A [ n - 1 ] ; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , A [ i ] ); for ( int i = 0 ; i < n ; ++ i ) { max = Math . max ( max , A [ i ] ); if ( max <= min [ i + 1 ] ) return i + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) mini = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] maxi = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): maxi = max ( maxi , a ) if maxi <= mini [ i + 1 ]: return i + 1","title":"915. Partition Array into Disjoint Intervals"},{"location":"problems/0915/#915-partition-array-into-disjoint-intervals","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ] ; min [ n - 1 ] = A [ n - 1 ] ; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , A [ i ] ); for ( int i = 0 ; i < n ; ++ i ) { max = Math . max ( max , A [ i ] ); if ( max <= min [ i + 1 ] ) return i + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) mini = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] maxi = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): maxi = max ( maxi , a ) if maxi <= mini [ i + 1 ]: return i + 1","title":"915. Partition Array into Disjoint Intervals"},{"location":"problems/0916/","text":"916. Word Subsets Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > wordSubsets ( vector < string >& A , vector < string >& B ) { vector < string > ans ; vector < int > countB ( 26 ); for ( const string & b : B ) { vector < int > temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = max ( countB [ i ], temp [ i ]); } for ( const string & a : A ) if ( isUniversal ( counter ( a ), countB )) ans . push_back ( a ); return ans ; } private : vector < int > counter ( const string & s ) { vector < int > count ( 26 ); for ( char c : s ) ++ count [ c - 'a' ]; return count ; } bool isUniversal ( vector < int > countA , vector < int >& countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < String > wordSubsets ( String [] A , String [] B ) { List < String > ans = new ArrayList <> (); int [] countB = new int [ 26 ] ; for ( final String b : B ) { int [] temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = Math . max ( countB [ i ] , temp [ i ] ); } for ( final String a : A ) if ( isUniversal ( counter ( a ), countB )) ans . add ( a ); return ans ; } private int [] counter ( final String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; return count ; } private boolean isUniversal ( int [] countA , int [] countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 class Solution : def wordSubsets ( self , A : List [ str ], B : List [ str ]) -> List [ str ]: count = collections . Counter () for b in B : count = count | collections . Counter ( b ) return [ a for a in A if collections . Counter ( a ) & count == count ]","title":"916. Word Subsets"},{"location":"problems/0916/#916-word-subsets","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > wordSubsets ( vector < string >& A , vector < string >& B ) { vector < string > ans ; vector < int > countB ( 26 ); for ( const string & b : B ) { vector < int > temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = max ( countB [ i ], temp [ i ]); } for ( const string & a : A ) if ( isUniversal ( counter ( a ), countB )) ans . push_back ( a ); return ans ; } private : vector < int > counter ( const string & s ) { vector < int > count ( 26 ); for ( char c : s ) ++ count [ c - 'a' ]; return count ; } bool isUniversal ( vector < int > countA , vector < int >& countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ]) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public List < String > wordSubsets ( String [] A , String [] B ) { List < String > ans = new ArrayList <> (); int [] countB = new int [ 26 ] ; for ( final String b : B ) { int [] temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = Math . max ( countB [ i ] , temp [ i ] ); } for ( final String a : A ) if ( isUniversal ( counter ( a ), countB )) ans . add ( a ); return ans ; } private int [] counter ( final String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; return count ; } private boolean isUniversal ( int [] countA , int [] countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ] ) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 class Solution : def wordSubsets ( self , A : List [ str ], B : List [ str ]) -> List [ str ]: count = collections . Counter () for b in B : count = count | collections . Counter ( b ) return [ a for a in A if collections . Counter ( a ) & count == count ]","title":"916. Word Subsets"},{"location":"problems/0917/","text":"917. Reverse Only Letters Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string reverseOnlyLetters ( string S ) { for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! isalpha ( S [ i ])) ++ i ; while ( i < j && ! isalpha ( S [ j ])) -- j ; swap ( S [ i ], S [ j ]); } return S ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public String reverseOnlyLetters ( String S ) { StringBuilder ans = new StringBuilder ( S ); for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! Character . isLetter ( S . charAt ( i ))) ++ i ; while ( i < j && ! Character . isLetter ( S . charAt ( j ))) -- j ; ans . setCharAt ( i , S . charAt ( j )); ans . setCharAt ( j , S . charAt ( i )); } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def reverseOnlyLetters ( self , S : str ) -> str : S = list ( S ) i = 0 j = len ( S ) - 1 while i < j : while i < j and not S [ i ] . isalpha (): i += 1 while i < j and not S [ j ] . isalpha (): j -= 1 S [ i ], S [ j ] = S [ j ], S [ i ] i += 1 j -= 1 return '' . join ( S )","title":"917. Reverse Only Letters"},{"location":"problems/0917/#917-reverse-only-letters","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string reverseOnlyLetters ( string S ) { for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! isalpha ( S [ i ])) ++ i ; while ( i < j && ! isalpha ( S [ j ])) -- j ; swap ( S [ i ], S [ j ]); } return S ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public String reverseOnlyLetters ( String S ) { StringBuilder ans = new StringBuilder ( S ); for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! Character . isLetter ( S . charAt ( i ))) ++ i ; while ( i < j && ! Character . isLetter ( S . charAt ( j ))) -- j ; ans . setCharAt ( i , S . charAt ( j )); ans . setCharAt ( j , S . charAt ( i )); } return ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def reverseOnlyLetters ( self , S : str ) -> str : S = list ( S ) i = 0 j = len ( S ) - 1 while i < j : while i < j and not S [ i ] . isalpha (): i += 1 while i < j and not S [ j ] . isalpha (): j -= 1 S [ i ], S [ j ] = S [ j ], S [ i ] i += 1 j -= 1 return '' . join ( S )","title":"917. Reverse Only Letters"},{"location":"problems/0918/","text":"918. Maximum Sum Circular Subarray Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum )","title":"918. Maximum Sum Circular Subarray"},{"location":"problems/0918/#918-maximum-sum-circular-subarray","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum )","title":"918. Maximum Sum Circular Subarray"},{"location":"problems/0919/","text":"919. Complete Binary Tree Inserter","title":"919. Complete Binary Tree Inserter"},{"location":"problems/0919/#919-complete-binary-tree-inserter","text":"","title":"919. Complete Binary Tree Inserter"},{"location":"problems/0920/","text":"920. Number of Music Playlists","title":"920. Number of Music Playlists"},{"location":"problems/0920/#920-number-of-music-playlists","text":"","title":"920. Number of Music Playlists"},{"location":"problems/0921/","text":"921. Minimum Add to Make Parentheses Valid Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minAddToMakeValid ( string S ) { int l = 0 ; int r = 0 ; for ( const char c : S ) if ( c == '(' ) { ++ l ; } else { if ( l == 0 ) ++ r ; else -- l ; } return l + r ; } };","title":"921. Minimum Add to Make Parentheses Valid"},{"location":"problems/0921/#921-minimum-add-to-make-parentheses-valid","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minAddToMakeValid ( string S ) { int l = 0 ; int r = 0 ; for ( const char c : S ) if ( c == '(' ) { ++ l ; } else { if ( l == 0 ) ++ r ; else -- l ; } return l + r ; } };","title":"921. Minimum Add to Make Parentheses Valid"},{"location":"problems/0922/","text":"922. Sort Array By Parity II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A","title":"922. Sort Array By Parity II"},{"location":"problems/0922/#922-sort-array-by-parity-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } return A ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A","title":"922. Sort Array By Parity II"},{"location":"problems/0923/","text":"923. 3Sum With Multiplicity Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { const int kMod = 1e9 + 7 ; long ans = 0 ; unordered_map < int , long > count ; for ( int a : A ) ++ count [ a ]; for ( const auto & [ i , x ] : count ) for ( const auto & [ j , y ] : count ) { int k = target - i - j ; if ( ! count . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * count [ k ]; else if ( i < j && j < k ) ans += x * y * count [ k ]; } return ans % kMod ; } };","title":"923. 3Sum With Multiplicity"},{"location":"problems/0923/#923-3sum-with-multiplicity","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { const int kMod = 1e9 + 7 ; long ans = 0 ; unordered_map < int , long > count ; for ( int a : A ) ++ count [ a ]; for ( const auto & [ i , x ] : count ) for ( const auto & [ j , y ] : count ) { int k = target - i - j ; if ( ! count . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * count [ k ]; else if ( i < j && j < k ) ans += x * y * count [ k ]; } return ans % kMod ; } };","title":"923. 3Sum With Multiplicity"},{"location":"problems/0924/","text":"924. Minimize Malware Spread","title":"924. Minimize Malware Spread"},{"location":"problems/0924/#924-minimize-malware-spread","text":"","title":"924. Minimize Malware Spread"},{"location":"problems/0925/","text":"925. Long Pressed Name Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isLongPressedName ( string name , string typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name [ i ] == typed [ j ]) ++ i ; else if ( j == 0 || typed [ j ] != typed [ j - 1 ]) return false ; return i == name . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isLongPressedName ( String name , String typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name . charAt ( i ) == typed . charAt ( j )) ++ i ; else if ( j == 0 || typed . charAt ( j ) != typed . charAt ( j - 1 )) return false ; return i == name . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isLongPressedName ( self , name : str , typed : str ) -> bool : i = 0 for j , t in enumerate ( typed ): if i < len ( name ) and name [ i ] == t : i += 1 elif j == 0 or t != typed [ j - 1 ]: return False return i == len ( name )","title":"925. Long Pressed Name"},{"location":"problems/0925/#925-long-pressed-name","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isLongPressedName ( string name , string typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name [ i ] == typed [ j ]) ++ i ; else if ( j == 0 || typed [ j ] != typed [ j - 1 ]) return false ; return i == name . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isLongPressedName ( String name , String typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name . charAt ( i ) == typed . charAt ( j )) ++ i ; else if ( j == 0 || typed . charAt ( j ) != typed . charAt ( j - 1 )) return false ; return i == name . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isLongPressedName ( self , name : str , typed : str ) -> bool : i = 0 for j , t in enumerate ( typed ): if i < len ( name ) and name [ i ] == t : i += 1 elif j == 0 or t != typed [ j - 1 ]: return False return i == len ( name )","title":"925. Long Pressed Name"},{"location":"problems/0926/","text":"926. Flip String to Monotone Increasing Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ] ; for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ] , dp [ 1 ] ) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ] , dp [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ])","title":"926. Flip String to Monotone Increasing"},{"location":"problems/0926/#926-flip-string-to-monotone-increasing","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ] ; for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ] , dp [ 1 ] ) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ] , dp [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ])","title":"926. Flip String to Monotone Increasing"},{"location":"problems/0927/","text":"927. Three Equal Parts Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : vector < int > threeEqualParts ( vector < int >& A ) { int ones = count_if ( begin ( A ), end ( A ), []( int a ) { return a == 1 ; }); if ( ones == 0 ) return { 0 , A . size () - 1 }; if ( ones % 3 != 0 ) return { -1 , -1 }; int k = ones / 3 ; int i ; int j ; int first ; int second ; int third ; for ( i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . size (); ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . size (); ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . size () && A [ first ] == A [ second ] && A [ second ] == A [ third ]) { ++ first ; ++ second ; ++ third ; } if ( third == A . size ()) return { first - 1 , second }; return { -1 , -1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public int [] threeEqualParts ( int [] A ) { int ones = 0 ; for ( int a : A ) if ( a == 1 ) ++ ones ; if ( ones == 0 ) return new int [] { 0 , A . length - 1 }; if ( ones % 3 != 0 ) return new int [] { - 1 , - 1 }; int k = ones / 3 ; int i = 0 ; int j = 0 ; int first = 0 ; int second = 0 ; int third = 0 ; for ( i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . length ; ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . length ; ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . length && A [ first ] == A [ second ] && A [ second ] == A [ third ] ) { ++ first ; ++ second ; ++ third ; } if ( third == A . length ) return new int [] { first - 1 , second }; return new int [] { - 1 , - 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def threeEqualParts ( self , A : List [ int ]) -> List [ int ]: ones = sum ( a == 1 for a in A ) if ones == 0 : return [ 0 , len ( A ) - 1 ] if ones % 3 != 0 : return [ - 1 , - 1 ] k = ones // 3 i = 0 for i in range ( len ( A )): if A [ i ] == 1 : first = i break gapOnes = k for j in range ( i + 1 , len ( A )): if A [ j ] == 1 : gapOnes -= 1 if gapOnes == 0 : second = j break gapOnes = k for i in range ( j + 1 , len ( A )): if A [ i ] == 1 : gapOnes -= 1 if gapOnes == 0 : third = i break while third < len ( A ) and A [ first ] == A [ second ] == A [ third ]: first += 1 second += 1 third += 1 if third == len ( A ): return [ first - 1 , second ] return [ - 1 , - 1 ]","title":"927. Three Equal Parts"},{"location":"problems/0927/#927-three-equal-parts","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public : vector < int > threeEqualParts ( vector < int >& A ) { int ones = count_if ( begin ( A ), end ( A ), []( int a ) { return a == 1 ; }); if ( ones == 0 ) return { 0 , A . size () - 1 }; if ( ones % 3 != 0 ) return { -1 , -1 }; int k = ones / 3 ; int i ; int j ; int first ; int second ; int third ; for ( i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . size (); ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . size (); ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . size () && A [ first ] == A [ second ] && A [ second ] == A [ third ]) { ++ first ; ++ second ; ++ third ; } if ( third == A . size ()) return { first - 1 , second }; return { -1 , -1 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 class Solution { public int [] threeEqualParts ( int [] A ) { int ones = 0 ; for ( int a : A ) if ( a == 1 ) ++ ones ; if ( ones == 0 ) return new int [] { 0 , A . length - 1 }; if ( ones % 3 != 0 ) return new int [] { - 1 , - 1 }; int k = ones / 3 ; int i = 0 ; int j = 0 ; int first = 0 ; int second = 0 ; int third = 0 ; for ( i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . length ; ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . length ; ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . length && A [ first ] == A [ second ] && A [ second ] == A [ third ] ) { ++ first ; ++ second ; ++ third ; } if ( third == A . length ) return new int [] { first - 1 , second }; return new int [] { - 1 , - 1 }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution : def threeEqualParts ( self , A : List [ int ]) -> List [ int ]: ones = sum ( a == 1 for a in A ) if ones == 0 : return [ 0 , len ( A ) - 1 ] if ones % 3 != 0 : return [ - 1 , - 1 ] k = ones // 3 i = 0 for i in range ( len ( A )): if A [ i ] == 1 : first = i break gapOnes = k for j in range ( i + 1 , len ( A )): if A [ j ] == 1 : gapOnes -= 1 if gapOnes == 0 : second = j break gapOnes = k for i in range ( j + 1 , len ( A )): if A [ i ] == 1 : gapOnes -= 1 if gapOnes == 0 : third = i break while third < len ( A ) and A [ first ] == A [ second ] == A [ third ]: first += 1 second += 1 third += 1 if third == len ( A ): return [ first - 1 , second ] return [ - 1 , - 1 ]","title":"927. Three Equal Parts"},{"location":"problems/0928/","text":"928. Minimize Malware Spread II","title":"928. Minimize Malware Spread II"},{"location":"problems/0928/#928-minimize-malware-spread-ii","text":"","title":"928. Minimize Malware Spread II"},{"location":"problems/0929/","text":"929. Unique Email Addresses Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int numUniqueEmails ( vector < string >& emails ) { unordered_set < string > normalized ; for ( const string & email : emails ) { string local ; for ( const char c : email ) { if ( c == '+' || c == '@' ) break ; if ( c == '.' ) continue ; local += c ; } string atDomain = email . substr ( email . find ( '@' )); normalized . insert ( local + atDomain ); } return normalized . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int numUniqueEmails ( String [] emails ) { Set < String > normalized = new HashSet <> (); for ( final String email : emails ) { String [] parts = email . split ( \"@\" ); String [] local = parts [ 0 ] . split ( \"\\\\+\" ); normalized . add ( local [ 0 ] . replace ( \".\" , \"\" ) + \"@\" + parts [ 1 ] ); } return normalized . size (); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def numUniqueEmails ( self , emails : List [ str ]) -> int : seen = set () for email in emails : local , domain = email . split ( '@' ) local = local . split ( '+' )[ 0 ] . replace ( '.' , '' ) seen . add ( local + '@' + domain ) return len ( seen )","title":"929. Unique Email Addresses"},{"location":"problems/0929/#929-unique-email-addresses","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int numUniqueEmails ( vector < string >& emails ) { unordered_set < string > normalized ; for ( const string & email : emails ) { string local ; for ( const char c : email ) { if ( c == '+' || c == '@' ) break ; if ( c == '.' ) continue ; local += c ; } string atDomain = email . substr ( email . find ( '@' )); normalized . insert ( local + atDomain ); } return normalized . size (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int numUniqueEmails ( String [] emails ) { Set < String > normalized = new HashSet <> (); for ( final String email : emails ) { String [] parts = email . split ( \"@\" ); String [] local = parts [ 0 ] . split ( \"\\\\+\" ); normalized . add ( local [ 0 ] . replace ( \".\" , \"\" ) + \"@\" + parts [ 1 ] ); } return normalized . size (); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def numUniqueEmails ( self , emails : List [ str ]) -> int : seen = set () for email in emails : local , domain = email . split ( '@' ) local = local . split ( '+' )[ 0 ] . replace ( '.' , '' ) seen . add ( local + '@' + domain ) return len ( seen )","title":"929. Unique Email Addresses"},{"location":"problems/0930/","text":"930. Binary Subarrays With Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarraysWithSum ( vector < int >& A , int S ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int a : A ) { prefixSum += a ; if ( count . count ( prefixSum - S )) ans += count [ prefixSum - S ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numSubarraysWithSum ( int [] A , int S ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int a : A ) { prefixSum += a ; if ( count . containsKey ( prefixSum - S )) ans += count . get ( prefixSum - S ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numSubarraysWithSum ( self , A : List [ int ], S : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter ({ 0 : 1 }) for a in A : prefixSum += a ans += count [ prefixSum - S ] count [ prefixSum ] += 1 return ans","title":"930. Binary Subarrays With Sum"},{"location":"problems/0930/#930-binary-subarrays-with-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarraysWithSum ( vector < int >& A , int S ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int a : A ) { prefixSum += a ; if ( count . count ( prefixSum - S )) ans += count [ prefixSum - S ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numSubarraysWithSum ( int [] A , int S ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int a : A ) { prefixSum += a ; if ( count . containsKey ( prefixSum - S )) ans += count . get ( prefixSum - S ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numSubarraysWithSum ( self , A : List [ int ], S : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter ({ 0 : 1 }) for a in A : prefixSum += a ans += count [ prefixSum - S ] count [ prefixSum ] += 1 return ans","title":"930. Binary Subarrays With Sum"},{"location":"problems/0931/","text":"931. Minimum Falling Path Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minFallingPathSum ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int mini = INT_MAX ; for ( int k = max ( 0 , j - 1 ); k < min ( n , j + 2 ); ++ k ) mini = min ( mini , A [ i - 1 ][ k ]); A [ i ][ j ] += mini ; } return * min_element ( begin ( A [ n - 1 ]), end ( A [ n - 1 ])); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minFallingPathSum ( int [][] A ) { final int n = A . length ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int min = Integer . MAX_VALUE ; for ( int k = Math . max ( 0 , j - 1 ); k < Math . min ( n , j + 2 ); ++ k ) min = Math . min ( min , A [ i - 1 ][ k ] ); A [ i ][ j ] += min ; } return Arrays . stream ( A [ n - 1 ] ). min (). getAsInt (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minFallingPathSum ( self , A : List [ List [ int ]]) -> int : n = len ( A ) for i in range ( 1 , n ): for j in range ( n ): mini = float ( 'inf' ) for k in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): mini = min ( mini , A [ i - 1 ][ k ]) A [ i ][ j ] += mini return min ( A [ - 1 ])","title":"931. Minimum Falling Path Sum"},{"location":"problems/0931/#931-minimum-falling-path-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minFallingPathSum ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int mini = INT_MAX ; for ( int k = max ( 0 , j - 1 ); k < min ( n , j + 2 ); ++ k ) mini = min ( mini , A [ i - 1 ][ k ]); A [ i ][ j ] += mini ; } return * min_element ( begin ( A [ n - 1 ]), end ( A [ n - 1 ])); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minFallingPathSum ( int [][] A ) { final int n = A . length ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int min = Integer . MAX_VALUE ; for ( int k = Math . max ( 0 , j - 1 ); k < Math . min ( n , j + 2 ); ++ k ) min = Math . min ( min , A [ i - 1 ][ k ] ); A [ i ][ j ] += min ; } return Arrays . stream ( A [ n - 1 ] ). min (). getAsInt (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minFallingPathSum ( self , A : List [ List [ int ]]) -> int : n = len ( A ) for i in range ( 1 , n ): for j in range ( n ): mini = float ( 'inf' ) for k in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): mini = min ( mini , A [ i - 1 ][ k ]) A [ i ][ j ] += mini return min ( A [ - 1 ])","title":"931. Minimum Falling Path Sum"},{"location":"problems/0932/","text":"932. Beautiful Array","title":"932. Beautiful Array"},{"location":"problems/0932/#932-beautiful-array","text":"","title":"932. Beautiful Array"},{"location":"problems/0933/","text":"933. Number of Recent Calls","title":"933. Number of Recent Calls"},{"location":"problems/0933/#933-number-of-recent-calls","text":"","title":"933. Number of Recent Calls"},{"location":"problems/0934/","text":"934. Shortest Bridge Approach 1: Pure DFS Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int shortestBridge ( vector < vector < int >>& A ) { const int n = A . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; queue < pair < int , int >> q ; // mark one group to 2s (visited) by DFS and push them to the queue function < void ( int , int ) > markAsTwo = [ & ]( int i , int j ) { if ( i < 0 || i == n || j < 0 || j == n ) return ; if ( A [ i ][ j ] != 1 ) return ; A [ i ][ j ] = 2 ; q . push ({ i , j }); markAsTwo ( i + 1 , j ); markAsTwo ( i - 1 , j ); markAsTwo ( i , j + 1 ); markAsTwo ( i , j - 1 ); }; [ & ]() { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( A [ i ][ j ] == 1 ) { markAsTwo ( i , j ); return ; } }(); // expand by BFS while ( ! q . empty ()) { for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( A [ x ][ y ] == 2 ) continue ; if ( A [ x ][ y ] == 1 ) return ans ; A [ x ][ y ] = 2 ; q . push ({ x , y }); } } ++ ans ; } throw ; } }; Approach 2: DFS + BFS Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int shortestBridge ( vector < vector < int >>& A ) { const int n = A . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; queue < pair < int , int >> q ; // mark one group to 2s by DFS and push them to the queue function < void ( int , int ) > markAsTwo = [ & ]( int i , int j ) { if ( i < 0 || i == n || j < 0 || j == n ) return ; if ( A [ i ][ j ] != 1 ) return ; A [ i ][ j ] = -1 ; q . push ({ i , j }); markAsTwo ( i + 1 , j ); markAsTwo ( i - 1 , j ); markAsTwo ( i , j + 1 ); markAsTwo ( i , j - 1 ); }; [ & ]() { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( A [ i ][ j ] == 1 ) { markAsTwo ( i , j ); return ; } }(); // expand by BFS while ( ! q . empty ()) { for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( A [ x ][ y ] == -1 ) continue ; if ( A [ x ][ y ] == 1 ) return ans ; A [ x ][ y ] = -1 ; q . push ({ x , y }); } } ++ ans ; } throw ; } };","title":"934. Shortest Bridge"},{"location":"problems/0934/#934-shortest-bridge","text":"","title":"934. Shortest Bridge"},{"location":"problems/0934/#approach-1-pure-dfs","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int shortestBridge ( vector < vector < int >>& A ) { const int n = A . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; queue < pair < int , int >> q ; // mark one group to 2s (visited) by DFS and push them to the queue function < void ( int , int ) > markAsTwo = [ & ]( int i , int j ) { if ( i < 0 || i == n || j < 0 || j == n ) return ; if ( A [ i ][ j ] != 1 ) return ; A [ i ][ j ] = 2 ; q . push ({ i , j }); markAsTwo ( i + 1 , j ); markAsTwo ( i - 1 , j ); markAsTwo ( i , j + 1 ); markAsTwo ( i , j - 1 ); }; [ & ]() { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( A [ i ][ j ] == 1 ) { markAsTwo ( i , j ); return ; } }(); // expand by BFS while ( ! q . empty ()) { for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( A [ x ][ y ] == 2 ) continue ; if ( A [ x ][ y ] == 1 ) return ans ; A [ x ][ y ] = 2 ; q . push ({ x , y }); } } ++ ans ; } throw ; } };","title":"Approach 1: Pure DFS"},{"location":"problems/0934/#approach-2-dfs-bfs","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int shortestBridge ( vector < vector < int >>& A ) { const int n = A . size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; queue < pair < int , int >> q ; // mark one group to 2s by DFS and push them to the queue function < void ( int , int ) > markAsTwo = [ & ]( int i , int j ) { if ( i < 0 || i == n || j < 0 || j == n ) return ; if ( A [ i ][ j ] != 1 ) return ; A [ i ][ j ] = -1 ; q . push ({ i , j }); markAsTwo ( i + 1 , j ); markAsTwo ( i - 1 , j ); markAsTwo ( i , j + 1 ); markAsTwo ( i , j - 1 ); }; [ & ]() { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( A [ i ][ j ] == 1 ) { markAsTwo ( i , j ); return ; } }(); // expand by BFS while ( ! q . empty ()) { for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == n || y < 0 || y == n ) continue ; if ( A [ x ][ y ] == -1 ) continue ; if ( A [ x ][ y ] == 1 ) return ans ; A [ x ][ y ] = -1 ; q . push ({ x , y }); } } ++ ans ; } throw ; } };","title":"Approach 2: DFS + BFS"},{"location":"problems/0935/","text":"935. Knight Dialer Time: Space:","title":"935. Knight Dialer"},{"location":"problems/0935/#935-knight-dialer","text":"Time: Space:","title":"935. Knight Dialer"},{"location":"problems/0936/","text":"936. Stamping The Sequence Time: $O((|target| - |stamp|)^2 \\cdot |stamp|)$ Space: $O(|target|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < int > movesToStamp ( string stamp , string target ) { vector < int > ans ; // stamped[i] := true if we already stamped target by stamp on index i vector < bool > stamped ( target . length ()); int stampedCount = 0 ; // out goal is to make stampedCount = target.length() while ( stampedCount < target . length ()) { bool isStamped = false ; // try to stamp target[i..i + stamp.length()) for each index for ( int i = 0 ; i <= target . length () - stamp . length (); ++ i ) { if ( stamped [ i ]) continue ; const int stampified = stampify ( stamp , target , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . push_back ( i ); } // after trying stamp each index, we can't find a valid stamp if ( ! isStamped ) return {}; } reverse ( begin ( ans ), end ( ans )); return ans ; } private : // stamp target[i..i + stamp.length()) and return # of newly stamped chars // e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\" int stampify ( const string & stamp , string & target , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( target [ s + i ] == '*' ) // already stamped -- stampified ; else if ( target [ s + i ] != stamp [ i ]) return 0 ; // we can't stamp on index i if ( stampified > 0 ) fill ( begin ( target ) + s , begin ( target ) + s + stamp . length (), '*' ); return stampified ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public int [] movesToStamp ( String stamp , String target ) { List < Integer > ans = new ArrayList <> (); char [] T = target . toCharArray (); // stamped[i] := true if we already stamped target by stamp on index i boolean [] stamped = new boolean [ target . length () ] ; int stampedCount = 0 ; // out goal is to make stampedCount = target.length() while ( stampedCount < T . length ) { boolean isStamped = false ; // try to stamp target[i..i + stamp.length()) for each index for ( int i = 0 ; i <= T . length - stamp . length (); ++ i ) { if ( stamped [ i ] ) continue ; final int stampified = stampify ( stamp , T , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . add ( i ); } // after trying stamp each index, we can't find a valid stamp if ( ! isStamped ) return new int [] {}; } Collections . reverse ( ans ); return ans . stream (). mapToInt ( i -> i ). toArray (); } // stamp target[i..i + stamp.length()) and return # of newly stamped chars // e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\" private int stampify ( final String stamp , char [] T , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( T [ s + i ] == '*' ) // already stamped -- stampified ; else if ( T [ s + i ] != stamp . charAt ( i )) return 0 ; // we can't stamp on index i Arrays . fill ( T , s , s + stamp . length (), '*' ); return stampified ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def movesToStamp ( self , stamp : str , target : str ) -> List [ int ]: def stampify ( s : int ) -> int : stampified = len ( stamp ) for i , st in enumerate ( stamp ): if target [ s + i ] == '*' : stampified -= 1 elif target [ s + i ] != st : return 0 for i in range ( s , s + len ( stamp )): target [ i ] = '*' return stampified ans = [] target = list ( target ) stamped = [ False ] * len ( target ) stampedCount = 0 while stampedCount < len ( target ): isStamped = False for i in range ( len ( target ) - len ( stamp ) + 1 ): if stamped [ i ]: continue stampified = stampify ( i ) if stampified == 0 : continue stampedCount += stampified isStamped = True stamped [ i ] = True ans . append ( i ) if not isStamped : return [] return ans [:: - 1 ]","title":"936. Stamping The Sequence"},{"location":"problems/0936/#936-stamping-the-sequence","text":"Time: $O((|target| - |stamp|)^2 \\cdot |stamp|)$ Space: $O(|target|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < int > movesToStamp ( string stamp , string target ) { vector < int > ans ; // stamped[i] := true if we already stamped target by stamp on index i vector < bool > stamped ( target . length ()); int stampedCount = 0 ; // out goal is to make stampedCount = target.length() while ( stampedCount < target . length ()) { bool isStamped = false ; // try to stamp target[i..i + stamp.length()) for each index for ( int i = 0 ; i <= target . length () - stamp . length (); ++ i ) { if ( stamped [ i ]) continue ; const int stampified = stampify ( stamp , target , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . push_back ( i ); } // after trying stamp each index, we can't find a valid stamp if ( ! isStamped ) return {}; } reverse ( begin ( ans ), end ( ans )); return ans ; } private : // stamp target[i..i + stamp.length()) and return # of newly stamped chars // e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\" int stampify ( const string & stamp , string & target , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( target [ s + i ] == '*' ) // already stamped -- stampified ; else if ( target [ s + i ] != stamp [ i ]) return 0 ; // we can't stamp on index i if ( stampified > 0 ) fill ( begin ( target ) + s , begin ( target ) + s + stamp . length (), '*' ); return stampified ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { public int [] movesToStamp ( String stamp , String target ) { List < Integer > ans = new ArrayList <> (); char [] T = target . toCharArray (); // stamped[i] := true if we already stamped target by stamp on index i boolean [] stamped = new boolean [ target . length () ] ; int stampedCount = 0 ; // out goal is to make stampedCount = target.length() while ( stampedCount < T . length ) { boolean isStamped = false ; // try to stamp target[i..i + stamp.length()) for each index for ( int i = 0 ; i <= T . length - stamp . length (); ++ i ) { if ( stamped [ i ] ) continue ; final int stampified = stampify ( stamp , T , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . add ( i ); } // after trying stamp each index, we can't find a valid stamp if ( ! isStamped ) return new int [] {}; } Collections . reverse ( ans ); return ans . stream (). mapToInt ( i -> i ). toArray (); } // stamp target[i..i + stamp.length()) and return # of newly stamped chars // e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\" private int stampify ( final String stamp , char [] T , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( T [ s + i ] == '*' ) // already stamped -- stampified ; else if ( T [ s + i ] != stamp . charAt ( i )) return 0 ; // we can't stamp on index i Arrays . fill ( T , s , s + stamp . length (), '*' ); return stampified ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def movesToStamp ( self , stamp : str , target : str ) -> List [ int ]: def stampify ( s : int ) -> int : stampified = len ( stamp ) for i , st in enumerate ( stamp ): if target [ s + i ] == '*' : stampified -= 1 elif target [ s + i ] != st : return 0 for i in range ( s , s + len ( stamp )): target [ i ] = '*' return stampified ans = [] target = list ( target ) stamped = [ False ] * len ( target ) stampedCount = 0 while stampedCount < len ( target ): isStamped = False for i in range ( len ( target ) - len ( stamp ) + 1 ): if stamped [ i ]: continue stampified = stampify ( i ) if stampified == 0 : continue stampedCount += stampified isStamped = True stamped [ i ] = True ans . append ( i ) if not isStamped : return [] return ans [:: - 1 ]","title":"936. Stamping The Sequence"},{"location":"problems/0937/","text":"937. Reorder Data in Log Files Time: $O(\\Sigma|digitLogs_i| + Sigma|letterLogs_i|\\log Sigma|letterLogs_i|)$ Space: $O(\\Sigma|logs_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > reorderLogFiles ( vector < string >& logs ) { vector < string > ans ; vector < string > digitLogs ; vector < pair < string , string >> letterLogs ; for ( const string & log : logs ) { int i = log . find_first_of ( ' ' ); if ( isdigit ( log [ i + 1 ])) digitLogs . push_back ( log ); else letterLogs . push_back ({ log . substr ( 0 , i ), log . substr ( i + 1 )}); } sort ( begin ( letterLogs ), end ( letterLogs ), []( const auto & a , const auto & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; }); for ( const auto & [ identifier , letters ] : letterLogs ) ans . push_back ( identifier + ' ' + letters ); for ( const string & digitLog : digitLogs ) ans . push_back ( digitLog ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String [] reorderLogFiles ( String [] logs ) { List < String > ans = new ArrayList <> (); List < String > digitLogs = new ArrayList <> (); List < String []> letterLogs = new ArrayList <> (); for ( final String log : logs ) { int i = log . indexOf ( ' ' ); if ( Character . isDigit ( log . charAt ( i + 1 ))) digitLogs . add ( log ); else letterLogs . add ( new String [] { log . substring ( 0 , i ), log . substring ( i + 1 ) }); } Collections . sort ( letterLogs , new Comparator < String []> () { @Override public int compare ( String [] l1 , String [] l2 ) { return l1 [ 1 ] . compareTo ( l2 [ 1 ] ) == 0 ? l1 [ 0 ] . compareTo ( l2 [ 0 ] ) : l1 [ 1 ] . compareTo ( l2 [ 1 ] ); } }); for ( final String [] letterLog : letterLogs ) ans . add ( letterLog [ 0 ] + \" \" + letterLog [ 1 ] ); for ( final String digitLog : digitLogs ) ans . add ( digitLog ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def reorderLogFiles ( self , logs : List [ str ]) -> List [ str ]: digitLogs = [] letterLogs = [] for log in logs : i = log . index ( ' ' ) if log [ i + 1 ] . isdigit (): digitLogs . append ( log ) else : letterLogs . append (( log [: i ], log [ i + 1 :])) letterLogs . sort ( key = lambda l : ( l [ 1 ], l [ 0 ])) return [ identifier + ' ' + letters for identifier , letters in letterLogs ] + digitLogs","title":"937. Reorder Data in Log Files"},{"location":"problems/0937/#937-reorder-data-in-log-files","text":"Time: $O(\\Sigma|digitLogs_i| + Sigma|letterLogs_i|\\log Sigma|letterLogs_i|)$ Space: $O(\\Sigma|logs_i|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < string > reorderLogFiles ( vector < string >& logs ) { vector < string > ans ; vector < string > digitLogs ; vector < pair < string , string >> letterLogs ; for ( const string & log : logs ) { int i = log . find_first_of ( ' ' ); if ( isdigit ( log [ i + 1 ])) digitLogs . push_back ( log ); else letterLogs . push_back ({ log . substr ( 0 , i ), log . substr ( i + 1 )}); } sort ( begin ( letterLogs ), end ( letterLogs ), []( const auto & a , const auto & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; }); for ( const auto & [ identifier , letters ] : letterLogs ) ans . push_back ( identifier + ' ' + letters ); for ( const string & digitLog : digitLogs ) ans . push_back ( digitLog ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public String [] reorderLogFiles ( String [] logs ) { List < String > ans = new ArrayList <> (); List < String > digitLogs = new ArrayList <> (); List < String []> letterLogs = new ArrayList <> (); for ( final String log : logs ) { int i = log . indexOf ( ' ' ); if ( Character . isDigit ( log . charAt ( i + 1 ))) digitLogs . add ( log ); else letterLogs . add ( new String [] { log . substring ( 0 , i ), log . substring ( i + 1 ) }); } Collections . sort ( letterLogs , new Comparator < String []> () { @Override public int compare ( String [] l1 , String [] l2 ) { return l1 [ 1 ] . compareTo ( l2 [ 1 ] ) == 0 ? l1 [ 0 ] . compareTo ( l2 [ 0 ] ) : l1 [ 1 ] . compareTo ( l2 [ 1 ] ); } }); for ( final String [] letterLog : letterLogs ) ans . add ( letterLog [ 0 ] + \" \" + letterLog [ 1 ] ); for ( final String digitLog : digitLogs ) ans . add ( digitLog ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def reorderLogFiles ( self , logs : List [ str ]) -> List [ str ]: digitLogs = [] letterLogs = [] for log in logs : i = log . index ( ' ' ) if log [ i + 1 ] . isdigit (): digitLogs . append ( log ) else : letterLogs . append (( log [: i ], log [ i + 1 :])) letterLogs . sort ( key = lambda l : ( l [ 1 ], l [ 0 ])) return [ identifier + ' ' + letters for identifier , letters in letterLogs ] + digitLogs","title":"937. Reorder Data in Log Files"},{"location":"problems/0938/","text":"938. Range Sum of BST Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int rangeSumBST ( TreeNode * root , int L , int R ) { if ( ! root ) return 0 ; if ( root -> val < L ) return rangeSumBST ( root -> right , L , R ); if ( root -> val > R ) return rangeSumBST ( root -> left , L , R ); return root -> val + rangeSumBST ( root -> left , L , R ) + rangeSumBST ( root -> right , L , R ); } };","title":"938. Range Sum of BST"},{"location":"problems/0938/#938-range-sum-of-bst","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int rangeSumBST ( TreeNode * root , int L , int R ) { if ( ! root ) return 0 ; if ( root -> val < L ) return rangeSumBST ( root -> right , L , R ); if ( root -> val > R ) return rangeSumBST ( root -> left , L , R ); return root -> val + rangeSumBST ( root -> left , L , R ) + rangeSumBST ( root -> right , L , R ); } };","title":"938. Range Sum of BST"},{"location":"problems/0939/","text":"939. Minimum Area Rectangle Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minAreaRect ( vector < vector < int >>& points ) { int ans = INT_MAX ; unordered_map < int , unordered_set < int >> xToYs ; for ( const vector < int >& point : points ) xToYs [ point [ 0 ]]. insert ( point [ 1 ]); for ( int i = 1 ; i < points . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const vector < int >& p = points [ i ]; const vector < int >& q = points [ j ]; if ( p [ 0 ] == q [ 0 ] || p [ 1 ] == q [ 1 ]) continue ; if ( xToYs [ p [ 0 ]]. count ( q [ 1 ]) && xToYs [ q [ 0 ]]. count ( p [ 1 ])) ans = min ( ans , abs ( p [ 0 ] - q [ 0 ]) * abs ( p [ 1 ] - q [ 1 ])); } return ans == INT_MAX ? 0 : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minAreaRect ( int [][] points ) { int ans = Integer . MAX_VALUE ; Map < Integer , Set < Integer >> xToYs = new HashMap <> (); for ( final int [] point : points ) { xToYs . putIfAbsent ( point [ 0 ] , new HashSet <> ()); xToYs . get ( point [ 0 ] ). add ( point [ 1 ] ); } for ( int i = 1 ; i < points . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int [] p = points [ i ] ; final int [] q = points [ j ] ; if ( p [ 0 ] == q [ 0 ] || p [ 1 ] == q [ 1 ] ) continue ; if ( xToYs . get ( p [ 0 ] ). contains ( q [ 1 ] ) && xToYs . get ( q [ 0 ] ). contains ( p [ 1 ] )) ans = Math . min ( ans , Math . abs ( p [ 0 ] - q [ 0 ] ) * Math . abs ( p [ 1 ] - q [ 1 ] )); } return ans == Integer . MAX_VALUE ? 0 : ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minAreaRect ( self , points : List [ List [ int ]]) -> int : ans = float ( 'inf' ) xToYs = collections . defaultdict ( set ) for x , y in points : xToYs [ x ] . add ( y ) for i in range ( len ( points )): for j in range ( i ): x1 , y1 = points [ i ] x2 , y2 = points [ j ] if x1 == x2 or y1 == y2 : continue if y2 in xToYs [ x1 ] and y1 in xToYs [ x2 ]: ans = min ( ans , abs ( x1 - x2 ) * abs ( y1 - y2 )) return ans if ans < float ( 'inf' ) else 0","title":"939. Minimum Area Rectangle"},{"location":"problems/0939/#939-minimum-area-rectangle","text":"Time: $O(n^2)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minAreaRect ( vector < vector < int >>& points ) { int ans = INT_MAX ; unordered_map < int , unordered_set < int >> xToYs ; for ( const vector < int >& point : points ) xToYs [ point [ 0 ]]. insert ( point [ 1 ]); for ( int i = 1 ; i < points . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { const vector < int >& p = points [ i ]; const vector < int >& q = points [ j ]; if ( p [ 0 ] == q [ 0 ] || p [ 1 ] == q [ 1 ]) continue ; if ( xToYs [ p [ 0 ]]. count ( q [ 1 ]) && xToYs [ q [ 0 ]]. count ( p [ 1 ])) ans = min ( ans , abs ( p [ 0 ] - q [ 0 ]) * abs ( p [ 1 ] - q [ 1 ])); } return ans == INT_MAX ? 0 : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int minAreaRect ( int [][] points ) { int ans = Integer . MAX_VALUE ; Map < Integer , Set < Integer >> xToYs = new HashMap <> (); for ( final int [] point : points ) { xToYs . putIfAbsent ( point [ 0 ] , new HashSet <> ()); xToYs . get ( point [ 0 ] ). add ( point [ 1 ] ); } for ( int i = 1 ; i < points . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { final int [] p = points [ i ] ; final int [] q = points [ j ] ; if ( p [ 0 ] == q [ 0 ] || p [ 1 ] == q [ 1 ] ) continue ; if ( xToYs . get ( p [ 0 ] ). contains ( q [ 1 ] ) && xToYs . get ( q [ 0 ] ). contains ( p [ 1 ] )) ans = Math . min ( ans , Math . abs ( p [ 0 ] - q [ 0 ] ) * Math . abs ( p [ 1 ] - q [ 1 ] )); } return ans == Integer . MAX_VALUE ? 0 : ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minAreaRect ( self , points : List [ List [ int ]]) -> int : ans = float ( 'inf' ) xToYs = collections . defaultdict ( set ) for x , y in points : xToYs [ x ] . add ( y ) for i in range ( len ( points )): for j in range ( i ): x1 , y1 = points [ i ] x2 , y2 = points [ j ] if x1 == x2 or y1 == y2 : continue if y2 in xToYs [ x1 ] and y1 in xToYs [ x2 ]: ans = min ( ans , abs ( x1 - x2 ) * abs ( y1 - y2 )) return ans if ans < float ( 'inf' ) else 0","title":"939. Minimum Area Rectangle"},{"location":"problems/0940/","text":"940. Distinct Subsequences II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int distinctSubseqII ( string S ) { const int kMod = 1e9 + 7 ; vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( begin ( map ), end ( map ), 1L ) % kMod ; return accumulate ( begin ( map ), end ( map ), 0L ) % kMod ; } };","title":"940. Distinct Subsequences II"},{"location":"problems/0940/#940-distinct-subsequences-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int distinctSubseqII ( string S ) { const int kMod = 1e9 + 7 ; vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( begin ( map ), end ( map ), 1L ) % kMod ; return accumulate ( begin ( map ), end ( map ), 0L ) % kMod ; } };","title":"940. Distinct Subsequences II"},{"location":"problems/0941/","text":"941. Valid Mountain Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ] ) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ] ) -- r ; return l > 0 && r < A . length - 1 && l == r ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r","title":"941. Valid Mountain Array"},{"location":"problems/0941/#941-valid-mountain-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ] ) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ] ) -- r ; return l > 0 && r < A . length - 1 && l == r ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r","title":"941. Valid Mountain Array"},{"location":"problems/0942/","text":"942. DI String Match Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > diStringMatch ( string S ) { vector < int > ans ; int min = 0 ; int max = S . length (); for ( char c : S ) ans . push_back ( c == 'I' ? min ++ : max -- ); ans . push_back ( min ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] diStringMatch ( String S ) { final int n = S . length (); int [] ans = new int [ n + 1 ] ; int min = 0 ; int max = n ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = S . charAt ( i ) == 'I' ? min ++ : max -- ; ans [ n ] = min ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def diStringMatch ( self , S : str ) -> List [ int ]: ans = [] mini = 0 maxi = len ( S ) for c in S : if c == 'I' : ans . append ( mini ) mini += 1 else : ans . append ( maxi ) maxi -= 1 ans . append ( mini ) return ans","title":"942. DI String Match"},{"location":"problems/0942/#942-di-string-match","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > diStringMatch ( string S ) { vector < int > ans ; int min = 0 ; int max = S . length (); for ( char c : S ) ans . push_back ( c == 'I' ? min ++ : max -- ); ans . push_back ( min ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] diStringMatch ( String S ) { final int n = S . length (); int [] ans = new int [ n + 1 ] ; int min = 0 ; int max = n ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = S . charAt ( i ) == 'I' ? min ++ : max -- ; ans [ n ] = min ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def diStringMatch ( self , S : str ) -> List [ int ]: ans = [] mini = 0 maxi = len ( S ) for c in S : if c == 'I' : ans . append ( mini ) mini += 1 else : ans . append ( maxi ) maxi -= 1 ans . append ( mini ) return ans","title":"942. DI String Match"},{"location":"problems/0943/","text":"943. Find the Shortest Superstring","title":"943. Find the Shortest Superstring"},{"location":"problems/0943/#943-find-the-shortest-superstring","text":"","title":"943. Find the Shortest Superstring"},{"location":"problems/0944/","text":"944. Delete Columns to Make Sorted","title":"944. Delete Columns to Make Sorted"},{"location":"problems/0944/#944-delete-columns-to-make-sorted","text":"","title":"944. Delete Columns to Make Sorted"},{"location":"problems/0945/","text":"945. Minimum Increment to Make Array Unique Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( begin ( A ), end ( A )); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans","title":"945. Minimum Increment to Make Array Unique"},{"location":"problems/0945/#945-minimum-increment-to-make-array-unique","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( begin ( A ), end ( A )); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans","title":"945. Minimum Increment to Make Array Unique"},{"location":"problems/0946/","text":"946. Validate Stack Sequences","title":"946. Validate Stack Sequences"},{"location":"problems/0946/#946-validate-stack-sequences","text":"","title":"946. Validate Stack Sequences"},{"location":"problems/0947/","text":"947. Most Stones Removed with Same Row or Column","title":"947. Most Stones Removed with Same Row or Column"},{"location":"problems/0947/#947-most-stones-removed-with-same-row-or-column","text":"","title":"947. Most Stones Removed with Same Row or Column"},{"location":"problems/0948/","text":"948. Bag of Tokens","title":"948. Bag of Tokens"},{"location":"problems/0948/#948-bag-of-tokens","text":"","title":"948. Bag of Tokens"},{"location":"problems/0949/","text":"949. Largest Time for Given Digits Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string largestTimeFromDigits ( vector < int >& A ) { string ans ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; string hours = to_string ( A [ i ]) + to_string ( A [ j ]); string minutes = to_string ( A [ k ]) + to_string ( A [ 6 - i - j - k ]); if ( hours < \"24\" && minutes < \"60\" ) ans = max ( ans , hours + ':' + minutes ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String largestTimeFromDigits ( int [] A ) { String ans = \"\" ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; String hours = \"\" + A [ i ] + A [ j ] ; String minutes = \"\" + A [ k ] + A [ 6 - i - j - k ] ; String time = hours + ':' + minutes ; if ( hours . compareTo ( \"24\" ) < 0 && minutes . compareTo ( \"60\" ) < 0 && ans . compareTo ( time ) < 0 ) ans = time ; } return ans ; } } Python 1 2 3 4 5 6 7 class Solution : def largestTimeFromDigits ( self , A : List [ int ]) -> str : for time in itertools . permutations ( sorted ( A , reverse = True )): if time [: 2 ] < ( 2 , 4 ) and time [ 2 ] < 6 : return ' %d%d : %d%d ' % time return ''","title":"949. Largest Time for Given Digits"},{"location":"problems/0949/#949-largest-time-for-given-digits","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string largestTimeFromDigits ( vector < int >& A ) { string ans ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; string hours = to_string ( A [ i ]) + to_string ( A [ j ]); string minutes = to_string ( A [ k ]) + to_string ( A [ 6 - i - j - k ]); if ( hours < \"24\" && minutes < \"60\" ) ans = max ( ans , hours + ':' + minutes ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String largestTimeFromDigits ( int [] A ) { String ans = \"\" ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; String hours = \"\" + A [ i ] + A [ j ] ; String minutes = \"\" + A [ k ] + A [ 6 - i - j - k ] ; String time = hours + ':' + minutes ; if ( hours . compareTo ( \"24\" ) < 0 && minutes . compareTo ( \"60\" ) < 0 && ans . compareTo ( time ) < 0 ) ans = time ; } return ans ; } } Python 1 2 3 4 5 6 7 class Solution : def largestTimeFromDigits ( self , A : List [ int ]) -> str : for time in itertools . permutations ( sorted ( A , reverse = True )): if time [: 2 ] < ( 2 , 4 ) and time [ 2 ] < 6 : return ' %d%d : %d%d ' % time return ''","title":"949. Largest Time for Given Digits"},{"location":"problems/0950/","text":"950. Reveal Cards In Increasing Order Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( begin ( deck ), end ( deck ), greater < int > ()); deque < int > deque { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return { begin ( deque ), end ( deque )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <> (); deque . addFirst ( deck [ n - 1 ] ); for ( int i = n - 2 ; i >= 0 ; -- i ) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ] ); } for ( int i = 0 ; i < n ; ++ i ) deck [ i ] = deque . pollFirst (); return deck ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"950. Reveal Cards In Increasing Order"},{"location":"problems/0950/#950-reveal-cards-in-increasing-order","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( begin ( deck ), end ( deck ), greater < int > ()); deque < int > deque { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return { begin ( deque ), end ( deque )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <> (); deque . addFirst ( deck [ n - 1 ] ); for ( int i = n - 2 ; i >= 0 ; -- i ) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ] ); } for ( int i = 0 ; i < n ; ++ i ) deck [ i ] = deque . pollFirst (); return deck ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"950. Reveal Cards In Increasing Order"},{"location":"problems/0951/","text":"951. Flip Equivalent Binary Trees","title":"951. Flip Equivalent Binary Trees"},{"location":"problems/0951/#951-flip-equivalent-binary-trees","text":"","title":"951. Flip Equivalent Binary Trees"},{"location":"problems/0952/","text":"952. Largest Component Size by Common Factor Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { while ( u != parent [ u ]) { parent [ u ] = parent [ parent [ u ]]; u = parent [ u ]; } return u ; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int largestComponentSize ( vector < int >& A ) { const int n = * max_element ( begin ( A ), end ( A )); int ans = 0 ; UF uf ( n ); unordered_map < int , int > count ; for ( int a : A ) for ( int num = 2 ; num <= sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union_ ( a , num ); uf . union_ ( a , a / num ); } for ( int a : A ) ans = max ( ans , ++ count [ uf . find ( a )]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { public int largestComponentSize ( int [] A ) { final int n = Arrays . stream ( A ). max (). getAsInt (); int ans = 0 ; UF uf = new UF ( n ); Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int num = 2 ; num <= ( int ) Math . sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union ( a , num ); uf . union ( a , a / num ); } for ( int a : A ) { int pa = uf . find ( a ); count . put ( pa , count . getOrDefault ( pa , 0 ) + 1 ); ans = Math . max ( ans , count . get ( pa )); } return ans ; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution : def largestComponentSize ( self , A : List [ int ]) -> int : n = max ( A ) ans = 0 uf = UF ( n ) count = collections . Counter () for a in A : for num in range ( 2 , int ( sqrt ( a ) + 1 )): if a % num == 0 : uf . union ( a , num ) uf . union ( a , a // num ) for a in A : pa = uf . find ( a ) count [ pa ] += 1 ans = max ( ans , count [ pa ]) return ans class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . parent [ u ] pv = self . parent [ v ] if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"952. Largest Component Size by Common Factor"},{"location":"problems/0952/#952-largest-component-size-by-common-factor","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { while ( u != parent [ u ]) { parent [ u ] = parent [ parent [ u ]]; u = parent [ u ]; } return u ; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int largestComponentSize ( vector < int >& A ) { const int n = * max_element ( begin ( A ), end ( A )); int ans = 0 ; UF uf ( n ); unordered_map < int , int > count ; for ( int a : A ) for ( int num = 2 ; num <= sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union_ ( a , num ); uf . union_ ( a , a / num ); } for ( int a : A ) ans = max ( ans , ++ count [ uf . find ( a )]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Solution { public int largestComponentSize ( int [] A ) { final int n = Arrays . stream ( A ). max (). getAsInt (); int ans = 0 ; UF uf = new UF ( n ); Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int num = 2 ; num <= ( int ) Math . sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union ( a , num ); uf . union ( a , a / num ); } for ( int a : A ) { int pa = uf . find ( a ); count . put ( pa , count . getOrDefault ( pa , 0 ) + 1 ); ans = Math . max ( ans , count . get ( pa )); } return ans ; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution : def largestComponentSize ( self , A : List [ int ]) -> int : n = max ( A ) ans = 0 uf = UF ( n ) count = collections . Counter () for a in A : for num in range ( 2 , int ( sqrt ( a ) + 1 )): if a % num == 0 : uf . union ( a , num ) uf . union ( a , a // num ) for a in A : pa = uf . find ( a ) count [ pa ] += 1 ans = max ( ans , count [ pa ]) return ans class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . parent [ u ] pv = self . parent [ v ] if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"952. Largest Component Size by Common Factor"},{"location":"problems/0953/","text":"953. Verifying an Alien Dictionary Time: $O(n)$ Space: $O(26) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isAlienSorted ( vector < string >& words , const string & order ) { vector < char > map ( 26 ); // order = \"bca\" -> map = ['c', 'a', 'b'] for ( int i = 0 ; i < 26 ; ++ i ) map [ order [ i ] - 'a' ] = i + 'a' ; for ( string & word : words ) for ( char & c : word ) c = map [ c - 'a' ]; return is_sorted ( begin ( words ), end ( words )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean isAlienSorted ( String [] words , String order ) { for ( int i = 0 ; i < order . length (); ++ i ) map . put ( order . charAt ( i ), ( char ) ( i + 'a' )); for ( int i = 0 ; i + 1 < words . length ; ++ i ) if ( bigger ( words [ i ] , words [ i + 1 ] )) return false ; return true ; } private Map < Character , Character > map = new HashMap <> (); private boolean bigger ( String s1 , String s2 ) { for ( int i = 0 ; i < s1 . length () && i < s2 . length (); ++ i ) if ( s1 . charAt ( i ) != s2 . charAt ( i )) return map . get ( s1 . charAt ( i )) > map . get ( s2 . charAt ( i )); return s1 . length () > s2 . length (); } } Python 1 2 3 4 5 class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : dict = { c : i for i , c in enumerate ( order )} words = [[ dict [ c ] for c in word ] for word in words ] return all ( w1 <= w2 for w1 , w2 in zip ( words , words [ 1 :]))","title":"953. Verifying an Alien Dictionary"},{"location":"problems/0953/#953-verifying-an-alien-dictionary","text":"Time: $O(n)$ Space: $O(26) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isAlienSorted ( vector < string >& words , const string & order ) { vector < char > map ( 26 ); // order = \"bca\" -> map = ['c', 'a', 'b'] for ( int i = 0 ; i < 26 ; ++ i ) map [ order [ i ] - 'a' ] = i + 'a' ; for ( string & word : words ) for ( char & c : word ) c = map [ c - 'a' ]; return is_sorted ( begin ( words ), end ( words )); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean isAlienSorted ( String [] words , String order ) { for ( int i = 0 ; i < order . length (); ++ i ) map . put ( order . charAt ( i ), ( char ) ( i + 'a' )); for ( int i = 0 ; i + 1 < words . length ; ++ i ) if ( bigger ( words [ i ] , words [ i + 1 ] )) return false ; return true ; } private Map < Character , Character > map = new HashMap <> (); private boolean bigger ( String s1 , String s2 ) { for ( int i = 0 ; i < s1 . length () && i < s2 . length (); ++ i ) if ( s1 . charAt ( i ) != s2 . charAt ( i )) return map . get ( s1 . charAt ( i )) > map . get ( s2 . charAt ( i )); return s1 . length () > s2 . length (); } } Python 1 2 3 4 5 class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : dict = { c : i for i , c in enumerate ( order )} words = [[ dict [ c ] for c in word ] for word in words ] return all ( w1 <= w2 for w1 , w2 in zip ( words , words [ 1 :]))","title":"953. Verifying an Alien Dictionary"},{"location":"problems/0954/","text":"954. Array of Doubled Pairs Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( const int a , const int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); A = Arrays . stream ( A ). boxed (). sorted (( a , b ) -> Math . abs ( a ) - Math . abs ( b )). mapToInt ( i -> i ). toArray (); for ( int a : A ) { if ( count . get ( a ) == 0 ) continue ; if ( count . getOrDefault ( 2 * a , 0 ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : count = collections . Counter ( A ) for key in sorted ( count , key = abs ): if count [ key ] > count [ 2 * key ]: return False count [ 2 * key ] -= count [ key ] return True","title":"954. Array of Doubled Pairs"},{"location":"problems/0954/#954-array-of-doubled-pairs","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( const int a , const int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); A = Arrays . stream ( A ). boxed (). sorted (( a , b ) -> Math . abs ( a ) - Math . abs ( b )). mapToInt ( i -> i ). toArray (); for ( int a : A ) { if ( count . get ( a ) == 0 ) continue ; if ( count . getOrDefault ( 2 * a , 0 ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : count = collections . Counter ( A ) for key in sorted ( count , key = abs ): if count [ key ] > count [ 2 * key ]: return False count [ 2 * key ] -= count [ key ] return True","title":"954. Array of Doubled Pairs"},{"location":"problems/0955/","text":"955. Delete Columns to Make Sorted II","title":"955. Delete Columns to Make Sorted II"},{"location":"problems/0955/#955-delete-columns-to-make-sorted-ii","text":"","title":"955. Delete Columns to Make Sorted II"},{"location":"problems/0956/","text":"956. Tallest Billboard","title":"956. Tallest Billboard"},{"location":"problems/0956/#956-tallest-billboard","text":"","title":"956. Tallest Billboard"},{"location":"problems/0957/","text":"957. Prison Cells After N Days Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > prisonAfterNDays ( vector < int >& cells , int N ) { vector < int > firstDayCells ; vector < int > nextDayCells ( cells . size ()); for ( int day = 0 ; N -- > 0 ; cells = nextDayCells , ++ day ) { for ( int i = 1 ; i + 1 < cells . size (); ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ]; if ( day == 0 ) firstDayCells = nextDayCells ; else if ( nextDayCells == firstDayCells ) N %= day ; } return cells ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] prisonAfterNDays ( int [] cells , int N ) { int [] firstDayCells = new int [ cells . length ] ; int [] nextDayCells = new int [ cells . length ] ; for ( int day = 0 ; N -- > 0 ; cells = nextDayCells . clone (), ++ day ) { for ( int i = 1 ; i + 1 < cells . length ; ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ] ? 1 : 0 ; if ( day == 0 ) firstDayCells = nextDayCells . clone (); else if ( Arrays . equals ( nextDayCells , firstDayCells )) N %= day ; } return cells ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def prisonAfterNDays ( self , cells : List [ int ], N : int ) -> List [ int ]: nextDayCells = [ 0 ] * len ( cells ) day = 0 while N > 0 : N -= 1 for i in range ( 1 , len ( cells ) - 1 ): nextDayCells [ i ] = 1 if cells [ i - 1 ] == cells [ i + 1 ] else 0 if day == 0 : firstDayCells = nextDayCells . copy () elif nextDayCells == firstDayCells : N %= day cells = nextDayCells . copy () day += 1 return cells","title":"957. Prison Cells After N Days"},{"location":"problems/0957/#957-prison-cells-after-n-days","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > prisonAfterNDays ( vector < int >& cells , int N ) { vector < int > firstDayCells ; vector < int > nextDayCells ( cells . size ()); for ( int day = 0 ; N -- > 0 ; cells = nextDayCells , ++ day ) { for ( int i = 1 ; i + 1 < cells . size (); ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ]; if ( day == 0 ) firstDayCells = nextDayCells ; else if ( nextDayCells == firstDayCells ) N %= day ; } return cells ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] prisonAfterNDays ( int [] cells , int N ) { int [] firstDayCells = new int [ cells . length ] ; int [] nextDayCells = new int [ cells . length ] ; for ( int day = 0 ; N -- > 0 ; cells = nextDayCells . clone (), ++ day ) { for ( int i = 1 ; i + 1 < cells . length ; ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ] ? 1 : 0 ; if ( day == 0 ) firstDayCells = nextDayCells . clone (); else if ( Arrays . equals ( nextDayCells , firstDayCells )) N %= day ; } return cells ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def prisonAfterNDays ( self , cells : List [ int ], N : int ) -> List [ int ]: nextDayCells = [ 0 ] * len ( cells ) day = 0 while N > 0 : N -= 1 for i in range ( 1 , len ( cells ) - 1 ): nextDayCells [ i ] = 1 if cells [ i - 1 ] == cells [ i + 1 ] else 0 if day == 0 : firstDayCells = nextDayCells . copy () elif nextDayCells == firstDayCells : N %= day cells = nextDayCells . copy () day += 1 return cells","title":"957. Prison Cells After N Days"},{"location":"problems/0958/","text":"958. Check Completeness of a Binary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isCompleteTree ( TreeNode * root ) { if ( ! root ) return true ; queue < TreeNode *> q {{ root }}; while ( q . front () != nullptr ) { root = q . front (), q . pop (); q . push ( root -> left ); q . push ( root -> right ); } while ( ! q . empty () && q . front () == nullptr ) q . pop (); return q . empty (); } };","title":"958. Check Completeness of a Binary Tree"},{"location":"problems/0958/#958-check-completeness-of-a-binary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isCompleteTree ( TreeNode * root ) { if ( ! root ) return true ; queue < TreeNode *> q {{ root }}; while ( q . front () != nullptr ) { root = q . front (), q . pop (); q . push ( root -> left ); q . push ( root -> right ); } while ( ! q . empty () && q . front () == nullptr ) q . pop (); return q . empty (); } };","title":"958. Check Completeness of a Binary Tree"},{"location":"problems/0959/","text":"959. Regions Cut By Slashes","title":"959. Regions Cut By Slashes"},{"location":"problems/0959/#959-regions-cut-by-slashes","text":"","title":"959. Regions Cut By Slashes"},{"location":"problems/0960/","text":"960. Delete Columns to Make Sorted III","title":"960. Delete Columns to Make Sorted III"},{"location":"problems/0960/#960-delete-columns-to-make-sorted-iii","text":"","title":"960. Delete Columns to Make Sorted III"},{"location":"problems/0961/","text":"961. N-Repeated Element in Size 2N Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int repeatedNTimes ( vector < int >& A ) { for ( int i = 0 ; i + 2 < A . size (); ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ]) return A [ i ]; return A . back (); } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public int repeatedNTimes ( int [] A ) { for ( int i = 0 ; i + 2 < A . length ; ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ] ) return A [ i ] ; return A [ A . length - 1 ] ; } } Python 1 2 3 4 5 6 7 class Solution : def repeatedNTimes ( self , A : List [ int ]) -> int : for i in range ( len ( A ) - 2 ): if A [ i ] == A [ i + 1 ] or A [ i ] == A [ i + 2 ]: return A [ i ] return A [ - 1 ]","title":"961. N-Repeated Element in Size 2N Array"},{"location":"problems/0961/#961-n-repeated-element-in-size-2n-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 class Solution { public : int repeatedNTimes ( vector < int >& A ) { for ( int i = 0 ; i + 2 < A . size (); ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ]) return A [ i ]; return A . back (); } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public int repeatedNTimes ( int [] A ) { for ( int i = 0 ; i + 2 < A . length ; ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ] ) return A [ i ] ; return A [ A . length - 1 ] ; } } Python 1 2 3 4 5 6 7 class Solution : def repeatedNTimes ( self , A : List [ int ]) -> int : for i in range ( len ( A ) - 2 ): if A [ i ] == A [ i + 1 ] or A [ i ] == A [ i + 2 ]: return A [ i ] return A [ - 1 ]","title":"961. N-Repeated Element in Size 2N Array"},{"location":"problems/0962/","text":"962. Maximum Width Ramp Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < A . length ; ++ i ) if ( stack . isEmpty () || A [ i ] < A [ stack . peek () ] ) stack . push ( i ); for ( int i = A . length - 1 ; i > ans ; -- i ) while ( ! stack . isEmpty () && A [ i ] >= A [ stack . peek () ] ) ans = Math . max ( ans , i - stack . pop ()); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans","title":"962. Maximum Width Ramp"},{"location":"problems/0962/#962-maximum-width-ramp","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < A . length ; ++ i ) if ( stack . isEmpty () || A [ i ] < A [ stack . peek () ] ) stack . push ( i ); for ( int i = A . length - 1 ; i > ans ; -- i ) while ( ! stack . isEmpty () && A [ i ] >= A [ stack . peek () ] ) ans = Math . max ( ans , i - stack . pop ()); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans","title":"962. Maximum Width Ramp"},{"location":"problems/0963/","text":"963. Minimum Area Rectangle II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double minAreaFreeRect ( vector < vector < int >>& points ) { long long ans = LLONG_MAX ; unordered_map < int , vector < tuple < int , int , int , int >>> centerToPoints ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) { int center = hash ( A , B ); centerToPoints [ center ]. push_back ({ A [ 0 ], A [ 1 ], B [ 0 ], B [ 1 ]}); } for ( const auto & [ _ , points ] : centerToPoints ) for ( const auto & [ ax , ay , bx , by ] : points ) for ( const auto & [ cx , cy , dx , dy ] : points ) if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { long long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = min ( ans , squaredArea ); } return ans == LLONG_MAX ? 0 : sqrt ( ans ); } private : int hash ( vector < int >& p , vector < int >& q ) { return (( long long )( p [ 0 ] + q [ 0 ]) << 16 ) + ( p [ 1 ] + q [ 1 ]); } long long dist ( int px , int py , int qx , int qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public double minAreaFreeRect ( int [][] points ) { Long ans = Long . MAX_VALUE ; Map < Integer , List < int []>> centerToPoints = new HashMap <> (); for ( int [] A : points ) for ( int [] B : points ) { int center = hash ( A , B ); if ( centerToPoints . get ( center ) == null ) centerToPoints . put ( center , new ArrayList <> ()); centerToPoints . get ( center ). add ( new int [] { A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] }); } for ( List < int []> pointPairs : centerToPoints . values ()) for ( int [] ab : pointPairs ) for ( int [] cd : pointPairs ) { int ax = ab [ 0 ] , ay = ab [ 1 ] ; int cx = cd [ 0 ] , cy = cd [ 1 ] , dx = cd [ 2 ] , dy = cd [ 3 ] ; if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { Long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = Math . min ( ans , squaredArea ); } } return ans == Long . MAX_VALUE ? 0 : Math . sqrt ( ans ); } private int hash ( int [] p , int [] q ) { return (( p [ 0 ] + q [ 0 ] ) << 16 ) + ( p [ 1 ] + q [ 1 ] ); } private Long dist ( long px , long py , long qx , long qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def minAreaFreeRect ( self , points : List [ List [ int ]]) -> float : def dist ( px : int , py : int , qx : int , qy : int ) -> float : return ( px - qx ) ** 2 + ( py - qy ) ** 2 ans = float ( 'inf' ) centerToPoints = collections . defaultdict ( list ) for ax , ay in points : for bx , by in points : center = (( ax + bx ) / 2 , ( ay + by ) / 2 ) centerToPoints [ center ] . append (( ax , ay , bx , by )) for points in centerToPoints . values (): for ax , ay , _ , _ in points : for cx , cy , dx , dy in points : if ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 : squaredArea = dist ( ax , ay , cx , cy ) * \\ dist ( ax , ay , dx , dy ) if squaredArea > 0 : ans = min ( ans , squaredArea ) return 0 if ans == float ( 'inf' ) else sqrt ( ans )","title":"963. Minimum Area Rectangle II"},{"location":"problems/0963/#963-minimum-area-rectangle-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double minAreaFreeRect ( vector < vector < int >>& points ) { long long ans = LLONG_MAX ; unordered_map < int , vector < tuple < int , int , int , int >>> centerToPoints ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) { int center = hash ( A , B ); centerToPoints [ center ]. push_back ({ A [ 0 ], A [ 1 ], B [ 0 ], B [ 1 ]}); } for ( const auto & [ _ , points ] : centerToPoints ) for ( const auto & [ ax , ay , bx , by ] : points ) for ( const auto & [ cx , cy , dx , dy ] : points ) if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { long long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = min ( ans , squaredArea ); } return ans == LLONG_MAX ? 0 : sqrt ( ans ); } private : int hash ( vector < int >& p , vector < int >& q ) { return (( long long )( p [ 0 ] + q [ 0 ]) << 16 ) + ( p [ 1 ] + q [ 1 ]); } long long dist ( int px , int py , int qx , int qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public double minAreaFreeRect ( int [][] points ) { Long ans = Long . MAX_VALUE ; Map < Integer , List < int []>> centerToPoints = new HashMap <> (); for ( int [] A : points ) for ( int [] B : points ) { int center = hash ( A , B ); if ( centerToPoints . get ( center ) == null ) centerToPoints . put ( center , new ArrayList <> ()); centerToPoints . get ( center ). add ( new int [] { A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] }); } for ( List < int []> pointPairs : centerToPoints . values ()) for ( int [] ab : pointPairs ) for ( int [] cd : pointPairs ) { int ax = ab [ 0 ] , ay = ab [ 1 ] ; int cx = cd [ 0 ] , cy = cd [ 1 ] , dx = cd [ 2 ] , dy = cd [ 3 ] ; if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { Long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = Math . min ( ans , squaredArea ); } } return ans == Long . MAX_VALUE ? 0 : Math . sqrt ( ans ); } private int hash ( int [] p , int [] q ) { return (( p [ 0 ] + q [ 0 ] ) << 16 ) + ( p [ 1 ] + q [ 1 ] ); } private Long dist ( long px , long py , long qx , long qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def minAreaFreeRect ( self , points : List [ List [ int ]]) -> float : def dist ( px : int , py : int , qx : int , qy : int ) -> float : return ( px - qx ) ** 2 + ( py - qy ) ** 2 ans = float ( 'inf' ) centerToPoints = collections . defaultdict ( list ) for ax , ay in points : for bx , by in points : center = (( ax + bx ) / 2 , ( ay + by ) / 2 ) centerToPoints [ center ] . append (( ax , ay , bx , by )) for points in centerToPoints . values (): for ax , ay , _ , _ in points : for cx , cy , dx , dy in points : if ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 : squaredArea = dist ( ax , ay , cx , cy ) * \\ dist ( ax , ay , dx , dy ) if squaredArea > 0 : ans = min ( ans , squaredArea ) return 0 if ans == float ( 'inf' ) else sqrt ( ans )","title":"963. Minimum Area Rectangle II"},{"location":"problems/0964/","text":"964. Least Operators to Express Number Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private : unordered_map < int , int > memo ; int dfs ( int x , int target ) { if ( memo . count ( target )) return memo [ target ]; if ( x > target ) return min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) return memo [ target ] = n ; memo [ target ] = INT_MAX ; if ( prod < 2 * target ) memo [ target ] = dfs ( x , prod - target ) + n + 1 ; memo [ target ] = min ( memo [ target ], dfs ( x , target - prod / x ) + n ); return memo [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private Map < Integer , Integer > memo = new HashMap <> (); private int dfs ( int x , int target ) { if ( memo . containsKey ( target )) return memo . get ( target ); if ( x > target ) return Math . min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) { memo . put ( target , n ); return memo . get ( target ); } memo . put ( target , Integer . MAX_VALUE ); if ( prod < 2 * target ) memo . put ( target , dfs ( x , ( int ) ( prod - ( long ) target )) + n + 1 ); memo . put ( target , Math . min ( memo . get ( target ), dfs ( x , target - ( int ) ( prod / ( long ) x )) + n )); return memo . get ( target ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def leastOpsExpressTarget ( self , x : int , target : int ) -> int : def dfs ( x : int , target : int ) -> int : if target in memo : return memo [ target ] if x > target : return min ( 2 * target - 1 , 2 * ( x - target )) if x == target : return 0 prod = x n = 0 while prod < target : prod *= x n += 1 if prod == target : memo [ target ] = n return memo [ target ] memo [ target ] = float ( 'inf' ) if prod < 2 * target : memo [ target ] = dfs ( x , prod - target ) + n + 1 memo [ target ] = min ( memo [ target ], dfs ( x , target - prod // x ) + n ) return memo [ target ] memo = {} return dfs ( x , target )","title":"964. Least Operators to Express Number"},{"location":"problems/0964/#964-least-operators-to-express-number","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private : unordered_map < int , int > memo ; int dfs ( int x , int target ) { if ( memo . count ( target )) return memo [ target ]; if ( x > target ) return min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) return memo [ target ] = n ; memo [ target ] = INT_MAX ; if ( prod < 2 * target ) memo [ target ] = dfs ( x , prod - target ) + n + 1 ; memo [ target ] = min ( memo [ target ], dfs ( x , target - prod / x ) + n ); return memo [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private Map < Integer , Integer > memo = new HashMap <> (); private int dfs ( int x , int target ) { if ( memo . containsKey ( target )) return memo . get ( target ); if ( x > target ) return Math . min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) { memo . put ( target , n ); return memo . get ( target ); } memo . put ( target , Integer . MAX_VALUE ); if ( prod < 2 * target ) memo . put ( target , dfs ( x , ( int ) ( prod - ( long ) target )) + n + 1 ); memo . put ( target , Math . min ( memo . get ( target ), dfs ( x , target - ( int ) ( prod / ( long ) x )) + n )); return memo . get ( target ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def leastOpsExpressTarget ( self , x : int , target : int ) -> int : def dfs ( x : int , target : int ) -> int : if target in memo : return memo [ target ] if x > target : return min ( 2 * target - 1 , 2 * ( x - target )) if x == target : return 0 prod = x n = 0 while prod < target : prod *= x n += 1 if prod == target : memo [ target ] = n return memo [ target ] memo [ target ] = float ( 'inf' ) if prod < 2 * target : memo [ target ] = dfs ( x , prod - target ) + n + 1 memo [ target ] = min ( memo [ target ], dfs ( x , target - prod // x ) + n ) return memo [ target ] memo = {} return dfs ( x , target )","title":"964. Least Operators to Express Number"},{"location":"problems/0965/","text":"965. Univalued Binary Tree","title":"965. Univalued Binary Tree"},{"location":"problems/0965/#965-univalued-binary-tree","text":"","title":"965. Univalued Binary Tree"},{"location":"problems/0966/","text":"966. Vowel Spellchecker Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > spellchecker ( vector < string >& wordlist , vector < string >& queries ) { vector < string > ans ; unordered_map < string , string > dict ; for ( const string & word : wordlist ) { dict . insert ({ word , word }); dict . insert ({ lowerKey ( word ), word }); dict . insert ({ vowelKey ( word ), word }); } for ( const string & query : queries ) if ( dict . count ( query )) ans . push_back ( dict [ query ]); else if ( dict . count ( lowerKey ( query ))) ans . push_back ( dict [ lowerKey ( query )]); else if ( dict . count ( vowelKey ( query ))) ans . push_back ( dict [ vowelKey ( query )]); else ans . push_back ( \"\" ); return ans ; } private : string lowerKey ( const string & word ) { string s { \"$\" }; for ( char c : word ) s += tolower ( c ); return s ; } string vowelKey ( const string & word ) { string s ; for ( char c : word ) s += string ( \"aeiou\" ). find ( tolower ( c )) != string :: npos ? '*' : tolower ( c ); return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public String [] spellchecker ( String [] wordlist , String [] queries ) { List < String > ans = new ArrayList <> (); Map < String , String > dict = new HashMap <> (); for ( final String word : wordlist ) { dict . putIfAbsent ( word , word ); dict . putIfAbsent ( lowerKey ( word ), word ); dict . putIfAbsent ( vowelKey ( word ), word ); } for ( final String query : queries ) if ( dict . containsKey ( query )) ans . add ( dict . get ( query )); else if ( dict . containsKey ( lowerKey ( query ))) ans . add ( dict . get ( lowerKey ( query ))); else if ( dict . containsKey ( vowelKey ( query ))) ans . add ( dict . get ( vowelKey ( query ))); else ans . add ( \"\" ); return ans . toArray ( new String [ 0 ] ); } private String lowerKey ( final String word ) { return \"$\" + word . toLowerCase (); } private String vowelKey ( final String word ) { String s = \"\" ; for ( char c : word . toCharArray ()) s += isVowel ( c ) ? '*' : Character . toLowerCase ( c ); return s ; } private boolean isVowel ( char c ) { c = Character . toLowerCase ( c ); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spellchecker ( self , wordlist : List [ str ], queries : List [ str ]) -> List [ str ]: def lowerKey ( word : str ) -> str : return '$' + '' . join ([ c . lower () for c in word ]) def vowelKey ( word : str ) -> str : return '' . join ([ '*' if c . lower () in 'aeiou' else c . lower () for c in word ]) ans = [] dict = {} for word in wordlist : dict . setdefault ( word , word ) dict . setdefault ( lowerKey ( word ), word ) dict . setdefault ( vowelKey ( word ), word ) for query in queries : if query in dict : ans . append ( dict [ query ]) elif lowerKey ( query ) in dict : ans . append ( dict [ lowerKey ( query )]) elif vowelKey ( query ) in dict : ans . append ( dict [ vowelKey ( query )]) else : ans . append ( '' ) return ans","title":"966. Vowel Spellchecker"},{"location":"problems/0966/#966-vowel-spellchecker","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > spellchecker ( vector < string >& wordlist , vector < string >& queries ) { vector < string > ans ; unordered_map < string , string > dict ; for ( const string & word : wordlist ) { dict . insert ({ word , word }); dict . insert ({ lowerKey ( word ), word }); dict . insert ({ vowelKey ( word ), word }); } for ( const string & query : queries ) if ( dict . count ( query )) ans . push_back ( dict [ query ]); else if ( dict . count ( lowerKey ( query ))) ans . push_back ( dict [ lowerKey ( query )]); else if ( dict . count ( vowelKey ( query ))) ans . push_back ( dict [ vowelKey ( query )]); else ans . push_back ( \"\" ); return ans ; } private : string lowerKey ( const string & word ) { string s { \"$\" }; for ( char c : word ) s += tolower ( c ); return s ; } string vowelKey ( const string & word ) { string s ; for ( char c : word ) s += string ( \"aeiou\" ). find ( tolower ( c )) != string :: npos ? '*' : tolower ( c ); return s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public String [] spellchecker ( String [] wordlist , String [] queries ) { List < String > ans = new ArrayList <> (); Map < String , String > dict = new HashMap <> (); for ( final String word : wordlist ) { dict . putIfAbsent ( word , word ); dict . putIfAbsent ( lowerKey ( word ), word ); dict . putIfAbsent ( vowelKey ( word ), word ); } for ( final String query : queries ) if ( dict . containsKey ( query )) ans . add ( dict . get ( query )); else if ( dict . containsKey ( lowerKey ( query ))) ans . add ( dict . get ( lowerKey ( query ))); else if ( dict . containsKey ( vowelKey ( query ))) ans . add ( dict . get ( vowelKey ( query ))); else ans . add ( \"\" ); return ans . toArray ( new String [ 0 ] ); } private String lowerKey ( final String word ) { return \"$\" + word . toLowerCase (); } private String vowelKey ( final String word ) { String s = \"\" ; for ( char c : word . toCharArray ()) s += isVowel ( c ) ? '*' : Character . toLowerCase ( c ); return s ; } private boolean isVowel ( char c ) { c = Character . toLowerCase ( c ); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spellchecker ( self , wordlist : List [ str ], queries : List [ str ]) -> List [ str ]: def lowerKey ( word : str ) -> str : return '$' + '' . join ([ c . lower () for c in word ]) def vowelKey ( word : str ) -> str : return '' . join ([ '*' if c . lower () in 'aeiou' else c . lower () for c in word ]) ans = [] dict = {} for word in wordlist : dict . setdefault ( word , word ) dict . setdefault ( lowerKey ( word ), word ) dict . setdefault ( vowelKey ( word ), word ) for query in queries : if query in dict : ans . append ( dict [ query ]) elif lowerKey ( query ) in dict : ans . append ( dict [ lowerKey ( query )]) elif vowelKey ( query ) in dict : ans . append ( dict [ vowelKey ( query )]) else : ans . append ( '' ) return ans","title":"966. Vowel Spellchecker"},{"location":"problems/0967/","text":"967. Numbers With Same Consecutive Differences","title":"967. Numbers With Same Consecutive Differences"},{"location":"problems/0967/#967-numbers-with-same-consecutive-differences","text":"","title":"967. Numbers With Same Consecutive Differences"},{"location":"problems/0968/","text":"968. Binary Tree Cameras","title":"968. Binary Tree Cameras"},{"location":"problems/0968/#968-binary-tree-cameras","text":"","title":"968. Binary Tree Cameras"},{"location":"problems/0969/","text":"969. Pancake Sorting Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( begin ( A ), begin ( A ) + index + 1 ); reverse ( begin ( A ), begin ( A ) + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <> (); for ( int target = A . length ; target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans","title":"969. Pancake Sorting"},{"location":"problems/0969/#969-pancake-sorting","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( begin ( A ), begin ( A ) + index + 1 ); reverse ( begin ( A ), begin ( A ) + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <> (); for ( int target = A . length ; target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans","title":"969. Pancake Sorting"},{"location":"problems/0970/","text":"970. Powerful Integers Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > powerfulIntegers ( int x , int y , int bound ) { unordered_set < int > ans ; for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . insert ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > powerfulIntegers ( int x , int y , int bound ) { Set < Integer > ans = new HashSet <> (); for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . add ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 class Solution : def powerfulIntegers ( self , x : int , y : int , bound : int ) -> List [ int ]: xs = { x ** i for i in range ( 20 ) if x ** i < bound } ys = { y ** i for i in range ( 20 ) if y ** i < bound } return list ({ i + j for i in xs for j in ys if i + j <= bound })","title":"970. Powerful Integers"},{"location":"problems/0970/#970-powerful-integers","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > powerfulIntegers ( int x , int y , int bound ) { unordered_set < int > ans ; for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . insert ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > powerfulIntegers ( int x , int y , int bound ) { Set < Integer > ans = new HashSet <> (); for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . add ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 class Solution : def powerfulIntegers ( self , x : int , y : int , bound : int ) -> List [ int ]: xs = { x ** i for i in range ( 20 ) if x ** i < bound } ys = { y ** i for i in range ( 20 ) if y ** i < bound } return list ({ i + j for i in xs for j in ys if i + j <= bound })","title":"970. Powerful Integers"},{"location":"problems/0971/","text":"971. Flip Binary Tree To Match Preorder Traversal","title":"971. Flip Binary Tree To Match Preorder Traversal"},{"location":"problems/0971/#971-flip-binary-tree-to-match-preorder-traversal","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal"},{"location":"problems/0972/","text":"972. Equal Rational Numbers Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool isRationalEqual ( string S , string T ) { return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private : vector < double > ratios { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; double valueOf ( const string & s ) { if ( s . find ( '(' ) == string :: npos ) return stod ( s ); double integer_nonRepeating = stod ( s . substr ( 0 , s . find_first_of ( '(' ))); int nonRepeatingLength = s . find_first_of ( '(' ) - s . find_first_of ( '.' ) - 1 ; int repeating = stoi ( s . substr ( s . find_first_of ( '(' ) + 1 , s . find_first_of ( ')' ))); int repeatingLength = s . find_first_of ( ')' ) - s . find_first_of ( '(' ) - 1 ; return integer_nonRepeating + repeating * pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isRationalEqual ( String S , String T ) { return Math . abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private double [] ratios = new double [] { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; private double valueOf ( final String s ) { if ( ! s . contains ( \"(\" )) return Double . valueOf ( s ); double integer_nonRepeating = Double . valueOf ( s . substring ( 0 , s . indexOf ( '(' ))); int nonRepeatingLength = s . indexOf ( '(' ) - s . indexOf ( '.' ) - 1 ; int repeating = Integer . parseInt ( s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' ))); int repeatingLength = s . indexOf ( ')' ) - s . indexOf ( '(' ) - 1 ; return integer_nonRepeating + repeating * Math . pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isRationalEqual ( self , S : str , T : str ) -> bool : def valueOf ( s : str ) -> float : if s . find ( '(' ) == - 1 : return float ( s ) integer_nonRepeating = float ( s [: s . find ( '(' )]) nonRepeatingLength = s . find ( '(' ) - s . find ( '.' ) - 1 repeating = float ( s [ s . find ( '(' ) + 1 : s . find ( ')' )]) repeatingLength = s . find ( ')' ) - s . find ( '(' ) - 1 return integer_nonRepeating + repeating * 0.1 ** nonRepeatingLength * ratios [ repeatingLength ] ratios = [ 1 , 1 / 9 , 1 / 99 , 1 / 999 , 1 / 9999 ] return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9","title":"972. Equal Rational Numbers"},{"location":"problems/0972/#972-equal-rational-numbers","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : bool isRationalEqual ( string S , string T ) { return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private : vector < double > ratios { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; double valueOf ( const string & s ) { if ( s . find ( '(' ) == string :: npos ) return stod ( s ); double integer_nonRepeating = stod ( s . substr ( 0 , s . find_first_of ( '(' ))); int nonRepeatingLength = s . find_first_of ( '(' ) - s . find_first_of ( '.' ) - 1 ; int repeating = stoi ( s . substr ( s . find_first_of ( '(' ) + 1 , s . find_first_of ( ')' ))); int repeatingLength = s . find_first_of ( ')' ) - s . find_first_of ( '(' ) - 1 ; return integer_nonRepeating + repeating * pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isRationalEqual ( String S , String T ) { return Math . abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private double [] ratios = new double [] { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; private double valueOf ( final String s ) { if ( ! s . contains ( \"(\" )) return Double . valueOf ( s ); double integer_nonRepeating = Double . valueOf ( s . substring ( 0 , s . indexOf ( '(' ))); int nonRepeatingLength = s . indexOf ( '(' ) - s . indexOf ( '.' ) - 1 ; int repeating = Integer . parseInt ( s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' ))); int repeatingLength = s . indexOf ( ')' ) - s . indexOf ( '(' ) - 1 ; return integer_nonRepeating + repeating * Math . pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isRationalEqual ( self , S : str , T : str ) -> bool : def valueOf ( s : str ) -> float : if s . find ( '(' ) == - 1 : return float ( s ) integer_nonRepeating = float ( s [: s . find ( '(' )]) nonRepeatingLength = s . find ( '(' ) - s . find ( '.' ) - 1 repeating = float ( s [ s . find ( '(' ) + 1 : s . find ( ')' )]) repeatingLength = s . find ( ')' ) - s . find ( '(' ) - 1 return integer_nonRepeating + repeating * 0.1 ** nonRepeatingLength * ratios [ repeatingLength ] ratios = [ 1 , 1 / 9 , 1 / 99 , 1 / 999 , 1 / 9999 ] return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9","title":"972. Equal Rational Numbers"},{"location":"problems/0973/","text":"973. K Closest Points to Origin Approach 1: Heap Time: $O(n\\log K)$ Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { vector < vector < int >> ans ; auto squareDistance = []( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; }; auto compare = [ & ]( const vector < int >& a , const vector < int >& b ) { return squareDistance ( a ) < squareDistance ( b ); // max-heap }; priority_queue < vector < int > , vector < vector < int >> , decltype ( compare ) > pq ( compare ); for ( const vector < int >& point : points ) { pq . push ( point ); if ( pq . size () > K ) pq . pop (); } while ( ! pq . empty ()) ans . push_back ( pq . top ()), pq . pop (); return ans ; }; }; Approach 2: Quick Select Time: $O(n) \\to O(n^2)$ Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { quickSelect ( points , 0 , points . size () - 1 , K ); return vector < vector < int >> ( begin ( points ), begin ( points ) + K ); }; private : void quickSelect ( vector < vector < int >>& points , int left , int right , int K ) { const vector < int > pivot = points [ right ]; int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( squareDistance ( points [ i ]) < squareDistance ( pivot )) swap ( points [ l ++ ], points [ i ]); swap ( points [ l ], points [ right ]); const int count = l - left + 1 ; // # of points <= pivot if ( count == K ) return ; if ( count > K ) quickSelect ( points , left , l - 1 , K ); else quickSelect ( points , l + 1 , right , K - count ); } int squareDistance ( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; } }; Approach 3: Quick Select with random pivot Time: $O(n)$ (average) Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { quickSelect ( points , 0 , points . size () - 1 , K ); return vector < vector < int >> ( begin ( points ), begin ( points ) + K ); }; private : void quickSelect ( vector < vector < int >>& points , int left , int right , int K ) { // randomly choose the pivot const int randIndex = rand () % ( right - left + 1 ) + left ; swap ( points [ randIndex ], points [ right ]); const vector < int > pivot = points [ right ]; int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( squareDistance ( points [ i ]) < squareDistance ( pivot )) swap ( points [ l ++ ], points [ i ]); swap ( points [ l ], points [ right ]); const int count = l - left + 1 ; // # of points <= pivot if ( count == K ) return ; if ( count > K ) quickSelect ( points , left , l - 1 , K ); else quickSelect ( points , l + 1 , right , K - count ); } int squareDistance ( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; } };","title":"973. K Closest Points to Origin"},{"location":"problems/0973/#973-k-closest-points-to-origin","text":"","title":"973. K Closest Points to Origin"},{"location":"problems/0973/#approach-1-heap","text":"Time: $O(n\\log K)$ Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { vector < vector < int >> ans ; auto squareDistance = []( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; }; auto compare = [ & ]( const vector < int >& a , const vector < int >& b ) { return squareDistance ( a ) < squareDistance ( b ); // max-heap }; priority_queue < vector < int > , vector < vector < int >> , decltype ( compare ) > pq ( compare ); for ( const vector < int >& point : points ) { pq . push ( point ); if ( pq . size () > K ) pq . pop (); } while ( ! pq . empty ()) ans . push_back ( pq . top ()), pq . pop (); return ans ; }; };","title":"Approach 1: Heap"},{"location":"problems/0973/#approach-2-quick-select","text":"Time: $O(n) \\to O(n^2)$ Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { quickSelect ( points , 0 , points . size () - 1 , K ); return vector < vector < int >> ( begin ( points ), begin ( points ) + K ); }; private : void quickSelect ( vector < vector < int >>& points , int left , int right , int K ) { const vector < int > pivot = points [ right ]; int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( squareDistance ( points [ i ]) < squareDistance ( pivot )) swap ( points [ l ++ ], points [ i ]); swap ( points [ l ], points [ right ]); const int count = l - left + 1 ; // # of points <= pivot if ( count == K ) return ; if ( count > K ) quickSelect ( points , left , l - 1 , K ); else quickSelect ( points , l + 1 , right , K - count ); } int squareDistance ( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; } };","title":"Approach 2: Quick Select"},{"location":"problems/0973/#approach-3-quick-select-with-random-pivot","text":"Time: $O(n)$ (average) Space: $O(K)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < vector < int >> kClosest ( vector < vector < int >>& points , int K ) { quickSelect ( points , 0 , points . size () - 1 , K ); return vector < vector < int >> ( begin ( points ), begin ( points ) + K ); }; private : void quickSelect ( vector < vector < int >>& points , int left , int right , int K ) { // randomly choose the pivot const int randIndex = rand () % ( right - left + 1 ) + left ; swap ( points [ randIndex ], points [ right ]); const vector < int > pivot = points [ right ]; int l = left ; // next swapped index for ( int i = left ; i < right ; ++ i ) if ( squareDistance ( points [ i ]) < squareDistance ( pivot )) swap ( points [ l ++ ], points [ i ]); swap ( points [ l ], points [ right ]); const int count = l - left + 1 ; // # of points <= pivot if ( count == K ) return ; if ( count > K ) quickSelect ( points , left , l - 1 , K ); else quickSelect ( points , l + 1 , right , K - count ); } int squareDistance ( const vector < int >& p ) { return p [ 0 ] * p [ 0 ] + p [ 1 ] * p [ 1 ]; } };","title":"Approach 3: Quick Select with random pivot"},{"location":"problems/0974/","text":"974. Subarray Sums Divisible by K Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int prefixSum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int prefixSum = 0 ; int [] count = new int [ K ] ; count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ] ; ++ count [ prefixSum ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 prefixSum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : prefixSum = ( prefixSum + a ) % K ans += count [ prefixSum ] count [ prefixSum ] += 1 return ans","title":"974. Subarray Sums Divisible by K"},{"location":"problems/0974/#974-subarray-sums-divisible-by-k","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int prefixSum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ]; ++ count [ prefixSum ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int prefixSum = 0 ; int [] count = new int [ K ] ; count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ] ; ++ count [ prefixSum ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 prefixSum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : prefixSum = ( prefixSum + a ) % K ans += count [ prefixSum ] count [ prefixSum ] += 1 return ans","title":"974. Subarray Sums Divisible by K"},{"location":"problems/0975/","text":"975. Odd Even Jump","title":"975. Odd Even Jump"},{"location":"problems/0975/#975-odd-even-jump","text":"","title":"975. Odd Even Jump"},{"location":"problems/0976/","text":"976. Largest Perimeter Triangle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( begin ( A ), end ( A )); for ( int i = A . size () - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ]) return A [ i - 2 ] + A [ i - 1 ] + A [ i ]; return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int largestPerimeter ( int [] A ) { Arrays . sort ( A ); for ( int i = A . length - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ] ) return A [ i - 2 ] + A [ i - 1 ] + A [ i ] ; return 0 ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def largestPerimeter ( self , A : List [ int ]) -> int : A = sorted ( A ) for i in range ( len ( A ) - 1 , 1 , - 1 ): if A [ i - 2 ] + A [ i - 1 ] > A [ i ]: return A [ i - 2 ] + A [ i - 1 ] + A [ i ] return 0","title":"976. Largest Perimeter Triangle"},{"location":"problems/0976/#976-largest-perimeter-triangle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( begin ( A ), end ( A )); for ( int i = A . size () - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ]) return A [ i - 2 ] + A [ i - 1 ] + A [ i ]; return 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int largestPerimeter ( int [] A ) { Arrays . sort ( A ); for ( int i = A . length - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ] ) return A [ i - 2 ] + A [ i - 1 ] + A [ i ] ; return 0 ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def largestPerimeter ( self , A : List [ int ]) -> int : A = sorted ( A ) for i in range ( len ( A ) - 1 , 1 , - 1 ): if A [ i - 2 ] + A [ i - 1 ] > A [ i ]: return A [ i - 2 ] + A [ i - 1 ] + A [ i ] return 0","title":"976. Largest Perimeter Triangle"},{"location":"problems/0977/","text":"977. Squares of a Sorted Array Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { const int n = A . size (); vector < int > ans ( n ); int i = n - 1 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( abs ( A [ l ]) > abs ( A [ r ])) ans [ i -- ] = A [ l ] * A [ l ++ ]; else ans [ i -- ] = A [ r ] * A [ r -- ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] sortedSquares ( int [] A ) { final int n = A . length ; int [] ans = new int [ n ] ; int i = n - 1 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( Math . abs ( A [ l ] ) > Math . abs ( A [ r ] )) ans [ i --] = A [ l ] * A [ l ++] ; else ans [ i --] = A [ r ] * A [ r --] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans","title":"977. Squares of a Sorted Array"},{"location":"problems/0977/#977-squares-of-a-sorted-array","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { const int n = A . size (); vector < int > ans ( n ); int i = n - 1 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( abs ( A [ l ]) > abs ( A [ r ])) ans [ i -- ] = A [ l ] * A [ l ++ ]; else ans [ i -- ] = A [ r ] * A [ r -- ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] sortedSquares ( int [] A ) { final int n = A . length ; int [] ans = new int [ n ] ; int i = n - 1 ; for ( int l = 0 , r = n - 1 ; l <= r ;) if ( Math . abs ( A [ l ] ) > Math . abs ( A [ r ] )) ans [ i --] = A [ l ] * A [ l ++] ; else ans [ i --] = A [ r ] * A [ r --] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans","title":"977. Squares of a Sorted Array"},{"location":"problems/0978/","text":"978. Longest Turbulent Subarray Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ({ ans , increasing , decreasing }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { if ( A [ i ] > A [ i - 1 ] ) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ] ) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans","title":"978. Longest Turbulent Subarray"},{"location":"problems/0978/#978-longest-turbulent-subarray","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ({ ans , increasing , decreasing }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { if ( A [ i ] > A [ i - 1 ] ) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ] ) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans","title":"978. Longest Turbulent Subarray"},{"location":"problems/0979/","text":"979. Distribute Coins in Binary Tree","title":"979. Distribute Coins in Binary Tree"},{"location":"problems/0979/#979-distribute-coins-in-binary-tree","text":"","title":"979. Distribute Coins in Binary Tree"},{"location":"problems/0980/","text":"980. Unique Paths III Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = -2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III"},{"location":"problems/0980/#980-unique-paths-iii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = -2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III"},{"location":"problems/0981/","text":"981. Time Based Key-Value Store Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimeMap { public : void set ( string key , string value , int timestamp ) { map [ key ][ timestamp ] = value ; } string get ( string key , int timestamp ) { auto it = map [ key ]. upper_bound ( timestamp ); return it == begin ( map [ key ]) ? \"\" : prev ( it ) -> second ; } private : unordered_map < string , std :: map < int , string >> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimeMap { public void set ( String key , String value , int timestamp ) { if ( ! map . containsKey ( key )) map . put ( key , new TreeMap <> ()); map . get ( key ). put ( timestamp , value ); } public String get ( String key , int timestamp ) { Integer floorKey = map . get ( key ). floorKey ( timestamp ); return floorKey == null ? \"\" : map . get ( key ). get ( floorKey ); } private Map < String , TreeMap < Integer , String >> map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 class TimeMap : def __init__ ( self ): self . timestamps = collections . defaultdict ( list ) self . values = collections . defaultdict ( list ) def set ( self , key : str , value : str , timestamp : int ) -> None : self . timestamps [ key ] . append ( timestamp ) self . values [ key ] . append ( value ) def get ( self , key : str , timestamp : int ) -> str : i = bisect . bisect ( self . timestamps [ key ], timestamp ) return self . values [ key ][ i - 1 ] if i > 0 else ''","title":"981. Time Based Key-Value Store"},{"location":"problems/0981/#981-time-based-key-value-store","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimeMap { public : void set ( string key , string value , int timestamp ) { map [ key ][ timestamp ] = value ; } string get ( string key , int timestamp ) { auto it = map [ key ]. upper_bound ( timestamp ); return it == begin ( map [ key ]) ? \"\" : prev ( it ) -> second ; } private : unordered_map < string , std :: map < int , string >> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TimeMap { public void set ( String key , String value , int timestamp ) { if ( ! map . containsKey ( key )) map . put ( key , new TreeMap <> ()); map . get ( key ). put ( timestamp , value ); } public String get ( String key , int timestamp ) { Integer floorKey = map . get ( key ). floorKey ( timestamp ); return floorKey == null ? \"\" : map . get ( key ). get ( floorKey ); } private Map < String , TreeMap < Integer , String >> map = new HashMap <> (); } Python 1 2 3 4 5 6 7 8 9 10 11 12 class TimeMap : def __init__ ( self ): self . timestamps = collections . defaultdict ( list ) self . values = collections . defaultdict ( list ) def set ( self , key : str , value : str , timestamp : int ) -> None : self . timestamps [ key ] . append ( timestamp ) self . values [ key ] . append ( value ) def get ( self , key : str , timestamp : int ) -> str : i = bisect . bisect ( self . timestamps [ key ], timestamp ) return self . values [ key ][ i - 1 ] if i > 0 else ''","title":"981. Time Based Key-Value Store"},{"location":"problems/0982/","text":"982. Triples with Bitwise AND Equal To Zero","title":"982. Triples with Bitwise AND Equal To Zero"},{"location":"problems/0982/#982-triples-with-bitwise-and-equal-to-zero","text":"","title":"982. Triples with Bitwise AND Equal To Zero"},{"location":"problems/0983/","text":"983. Minimum Cost For Tickets Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int mincostTickets ( vector < int >& days , vector < int >& costs ) { int ans = 0 ; queue < pair < int , int >> last7 ; queue < pair < int , int >> last30 ; for ( int day : days ) { while ( ! last7 . empty () && last7 . front (). first + 7 <= day ) last7 . pop (); while ( ! last30 . empty () && last30 . front (). first + 30 <= day ) last30 . pop (); last7 . push ({ day , ans + costs [ 1 ]}); last30 . push ({ day , ans + costs [ 2 ]}); ans = min ({ ans + costs [ 0 ], last7 . front (). second , last30 . front (). second }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int mincostTickets ( int [] days , int [] costs ) { int ans = 0 ; Queue < int []> last7 = new LinkedList <> (); // [day, cost] Queue < int []> last30 = new LinkedList <> (); for ( int day : days ) { while ( ! last7 . isEmpty () && last7 . peek () [ 0 ] + 7 <= day ) last7 . poll (); while ( ! last30 . isEmpty () && last30 . peek () [ 0 ] + 30 <= day ) last30 . poll (); last7 . offer ( new int [] { day , ans + costs [ 1 ] }); last30 . offer ( new int [] { day , ans + costs [ 2 ] }); ans = Math . min ( ans + costs [ 0 ] , Math . min ( last7 . peek () [ 1 ] , last30 . peek () [ 1 ] )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def mincostTickets ( self , days : List [ int ], costs : List [ int ]) -> int : ans = 0 last7 = collections . deque () last30 = collections . deque () for day in days : while last7 and last7 [ 0 ][ 0 ] + 7 <= day : last7 . popleft () while last30 and last30 [ 0 ][ 0 ] + 30 <= day : last30 . popleft () last7 . append ([ day , ans + costs [ 1 ]]) last30 . append ([ day , ans + costs [ 2 ]]) ans = min ( ans + costs [ 0 ], last7 [ 0 ][ 1 ], last30 [ 0 ][ 1 ]) return ans","title":"983. Minimum Cost For Tickets"},{"location":"problems/0983/#983-minimum-cost-for-tickets","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int mincostTickets ( vector < int >& days , vector < int >& costs ) { int ans = 0 ; queue < pair < int , int >> last7 ; queue < pair < int , int >> last30 ; for ( int day : days ) { while ( ! last7 . empty () && last7 . front (). first + 7 <= day ) last7 . pop (); while ( ! last30 . empty () && last30 . front (). first + 30 <= day ) last30 . pop (); last7 . push ({ day , ans + costs [ 1 ]}); last30 . push ({ day , ans + costs [ 2 ]}); ans = min ({ ans + costs [ 0 ], last7 . front (). second , last30 . front (). second }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int mincostTickets ( int [] days , int [] costs ) { int ans = 0 ; Queue < int []> last7 = new LinkedList <> (); // [day, cost] Queue < int []> last30 = new LinkedList <> (); for ( int day : days ) { while ( ! last7 . isEmpty () && last7 . peek () [ 0 ] + 7 <= day ) last7 . poll (); while ( ! last30 . isEmpty () && last30 . peek () [ 0 ] + 30 <= day ) last30 . poll (); last7 . offer ( new int [] { day , ans + costs [ 1 ] }); last30 . offer ( new int [] { day , ans + costs [ 2 ] }); ans = Math . min ( ans + costs [ 0 ] , Math . min ( last7 . peek () [ 1 ] , last30 . peek () [ 1 ] )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def mincostTickets ( self , days : List [ int ], costs : List [ int ]) -> int : ans = 0 last7 = collections . deque () last30 = collections . deque () for day in days : while last7 and last7 [ 0 ][ 0 ] + 7 <= day : last7 . popleft () while last30 and last30 [ 0 ][ 0 ] + 30 <= day : last30 . popleft () last7 . append ([ day , ans + costs [ 1 ]]) last30 . append ([ day , ans + costs [ 2 ]]) ans = min ( ans + costs [ 0 ], last7 [ 0 ][ 1 ], last30 [ 0 ][ 1 ]) return ans","title":"983. Minimum Cost For Tickets"},{"location":"problems/0984/","text":"984. String Without AAA or BBB Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string strWithout3a3b ( int A , int B , char a = 'a' , char b = 'b' ) { if ( A < B ) return strWithout3a3b ( B , A , b , a ); if ( B == 0 ) return string ( min ( A , 2 ), a ); const int useA = min ( A , 2 ); const int useB = ( A - useA >= B ) ? 1 : 0 ; return string ( useA , a ) + string ( useB , b ) + strWithout3a3b ( A - useA , B - useB , a , b ); } };","title":"984. String Without AAA or BBB"},{"location":"problems/0984/#984-string-without-aaa-or-bbb","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string strWithout3a3b ( int A , int B , char a = 'a' , char b = 'b' ) { if ( A < B ) return strWithout3a3b ( B , A , b , a ); if ( B == 0 ) return string ( min ( A , 2 ), a ); const int useA = min ( A , 2 ); const int useB = ( A - useA >= B ) ? 1 : 0 ; return string ( useA , a ) + string ( useB , b ) + strWithout3a3b ( A - useA , B - useB , a , b ); } };","title":"984. String Without AAA or BBB"},{"location":"problems/0985/","text":"985. Sum of Even Numbers After Queries Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( begin ( A ), end ( A ), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ] ; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; ++ i ) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]] ; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ] ; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]] ; ans [ i ] = sum ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] summ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : summ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : summ += A [ query [ 1 ]] ans . append ( summ ) return ans","title":"985. Sum of Even Numbers After Queries"},{"location":"problems/0985/#985-sum-of-even-numbers-after-queries","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( begin ( A ), end ( A ), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ] ; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; ++ i ) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]] ; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ] ; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]] ; ans [ i ] = sum ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] summ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : summ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : summ += A [ query [ 1 ]] ans . append ( summ ) return ans","title":"985. Sum of Even Numbers After Queries"},{"location":"problems/0986/","text":"986. Interval List Intersections Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { const int maxL = max ( A [ i ][ 0 ], B [ j ][ 0 ]); const int minR = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( maxL <= minR ) ans . push_back ({ maxL , minR }); if ( A [ i ][ 1 ] < B [ j ][ 1 ]) ++ i ; else ++ j ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [][] intervalIntersection ( int [][] A , int [][] B ) { List < int []> ans = new ArrayList <> (); short i = 0 ; short j = 0 ; while ( i < A . length && j < B . length ) { final int maxL = Math . max ( A [ i ][ 0 ] , B [ j ][ 0 ] ); final int minR = Math . min ( A [ i ][ 1 ] , B [ j ][ 1 ] ); if ( maxL <= minR ) ans . add ( new int [] { maxL , minR }); if ( A [ i ][ 1 ] < B [ j ][ 1 ] ) ++ i ; else ++ j ; } return ans . toArray ( new int [ ans . size () ][] ); } }","title":"986. Interval List Intersections"},{"location":"problems/0986/#986-interval-list-intersections","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { const int maxL = max ( A [ i ][ 0 ], B [ j ][ 0 ]); const int minR = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( maxL <= minR ) ans . push_back ({ maxL , minR }); if ( A [ i ][ 1 ] < B [ j ][ 1 ]) ++ i ; else ++ j ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [][] intervalIntersection ( int [][] A , int [][] B ) { List < int []> ans = new ArrayList <> (); short i = 0 ; short j = 0 ; while ( i < A . length && j < B . length ) { final int maxL = Math . max ( A [ i ][ 0 ] , B [ j ][ 0 ] ); final int minR = Math . min ( A [ i ][ 1 ] , B [ j ][ 1 ] ); if ( maxL <= minR ) ans . add ( new int [] { maxL , minR }); if ( A [ i ][ 1 ] < B [ j ][ 1 ] ) ++ i ; else ++ j ; } return ans . toArray ( new int [ ans . size () ][] ); } }","title":"986. Interval List Intersections"},{"location":"problems/0987/","text":"987. Vertical Order Traversal of a Binary Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> ans ; map < int , set < pair < int , int >>> xToSortedPairs ; // {x: {y, val}} function < void ( TreeNode * , int , int ) > dfs = [ & ]( TreeNode * root , int x , int y ) { if ( ! root ) return ; xToSortedPairs [ x ]. insert ({ y , root -> val }); dfs ( root -> left , x - 1 , y + 1 ); dfs ( root -> right , x + 1 , y + 1 ); }; dfs ( root , 0 , 0 ); for ( const auto & [ _ , items ] : xToSortedPairs ) { vector < int > vals ; for ( const auto & item : items ) vals . push_back ( item . second ); ans . push_back ( vals ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public List < List < Integer >> verticalTraversal ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); TreeMap < Integer , List < int []>> xToNodes = new TreeMap <> (); dfs ( root , 0 , 0 , xToNodes ); for ( List < int []> nodes : xToNodes . values ()) { Collections . sort ( nodes , new Comparator < int []> () { @Override public int compare ( int [] n1 , int [] n2 ) { return n1 [ 0 ] == n2 [ 0 ] ? n1 [ 1 ] - n2 [ 1 ] : n2 [ 0 ] - n1 [ 0 ] ; } }); List < Integer > vals = new ArrayList <> (); for ( int [] node : nodes ) vals . add ( node [ 1 ] ); ans . add ( vals ); } return ans ; } private void dfs ( TreeNode root , int x , int y , TreeMap < Integer , List < int []>> xToNodes ) { if ( root == null ) return ; if ( ! xToNodes . containsKey ( x )) xToNodes . put ( x , new ArrayList <> ()); xToNodes . get ( x ). add ( new int [] { y , root . val }); dfs ( root . left , x - 1 , y - 1 , xToNodes ); dfs ( root . right , x + 1 , y - 1 , xToNodes ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def verticalTraversal ( self , root : TreeNode ) -> List [ List [ int ]]: def dfs ( node : TreeNode , x : int , y : int ) -> None : if not node : return xToNodes [ x ] . append (( - y , node . val )) dfs ( node . left , x - 1 , y - 1 ) dfs ( node . right , x + 1 , y - 1 ) ans = [] xToNodes = collections . defaultdict ( list ) dfs ( root , 0 , 0 ) for _ , nodes in sorted ( xToNodes . items (), key = lambda item : item [ 0 ]): ans . append ([ val for _ , val in sorted ( nodes )]) return ans","title":"987. Vertical Order Traversal of a Binary Tree"},{"location":"problems/0987/#987-vertical-order-traversal-of-a-binary-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> ans ; map < int , set < pair < int , int >>> xToSortedPairs ; // {x: {y, val}} function < void ( TreeNode * , int , int ) > dfs = [ & ]( TreeNode * root , int x , int y ) { if ( ! root ) return ; xToSortedPairs [ x ]. insert ({ y , root -> val }); dfs ( root -> left , x - 1 , y + 1 ); dfs ( root -> right , x + 1 , y + 1 ); }; dfs ( root , 0 , 0 ); for ( const auto & [ _ , items ] : xToSortedPairs ) { vector < int > vals ; for ( const auto & item : items ) vals . push_back ( item . second ); ans . push_back ( vals ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public List < List < Integer >> verticalTraversal ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); TreeMap < Integer , List < int []>> xToNodes = new TreeMap <> (); dfs ( root , 0 , 0 , xToNodes ); for ( List < int []> nodes : xToNodes . values ()) { Collections . sort ( nodes , new Comparator < int []> () { @Override public int compare ( int [] n1 , int [] n2 ) { return n1 [ 0 ] == n2 [ 0 ] ? n1 [ 1 ] - n2 [ 1 ] : n2 [ 0 ] - n1 [ 0 ] ; } }); List < Integer > vals = new ArrayList <> (); for ( int [] node : nodes ) vals . add ( node [ 1 ] ); ans . add ( vals ); } return ans ; } private void dfs ( TreeNode root , int x , int y , TreeMap < Integer , List < int []>> xToNodes ) { if ( root == null ) return ; if ( ! xToNodes . containsKey ( x )) xToNodes . put ( x , new ArrayList <> ()); xToNodes . get ( x ). add ( new int [] { y , root . val }); dfs ( root . left , x - 1 , y - 1 , xToNodes ); dfs ( root . right , x + 1 , y - 1 , xToNodes ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def verticalTraversal ( self , root : TreeNode ) -> List [ List [ int ]]: def dfs ( node : TreeNode , x : int , y : int ) -> None : if not node : return xToNodes [ x ] . append (( - y , node . val )) dfs ( node . left , x - 1 , y - 1 ) dfs ( node . right , x + 1 , y - 1 ) ans = [] xToNodes = collections . defaultdict ( list ) dfs ( root , 0 , 0 ) for _ , nodes in sorted ( xToNodes . items (), key = lambda item : item [ 0 ]): ans . append ([ val for _ , val in sorted ( nodes )]) return ans","title":"987. Vertical Order Traversal of a Binary Tree"},{"location":"problems/0988/","text":"988. Smallest String Starting From Leaf","title":"988. Smallest String Starting From Leaf"},{"location":"problems/0988/#988-smallest-string-starting-from-leaf","text":"","title":"988. Smallest String Starting From Leaf"},{"location":"problems/0989/","text":"989. Add to Array-Form of Integer Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( begin ( A ), K % 10 ); K /= 10 ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <> (); for ( int i = A . length - 1 ; i >= 0 ; -- i ) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A","title":"989. Add to Array-Form of Integer"},{"location":"problems/0989/#989-add-to-array-form-of-integer","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( begin ( A ), K % 10 ); K /= 10 ; } return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <> (); for ( int i = A . length - 1 ; i >= 0 ; -- i ) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A","title":"989. Add to Array-Form of Integer"},{"location":"problems/0990/","text":"990. Satisfiability of Equality Equations","title":"990. Satisfiability of Equality Equations"},{"location":"problems/0990/#990-satisfiability-of-equality-equations","text":"","title":"990. Satisfiability of Equality Equations"},{"location":"problems/0991/","text":"991. Broken Calculator Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def brokenCalc ( self , X : int , Y : int ) -> int : ops = 0 while X < Y : if Y % 2 == 0 : Y //= 2 else : Y += 1 ops += 1 return ops + X - Y","title":"991. Broken Calculator"},{"location":"problems/0991/#991-broken-calculator","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def brokenCalc ( self , X : int , Y : int ) -> int : ops = 0 while X < Y : if Y % 2 == 0 : Y //= 2 else : Y += 1 ops += 1 return ops + X - Y","title":"991. Broken Calculator"},{"location":"problems/0992/","text":"992. Subarrays with K Different Integers Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int subarraysWithKDistinct ( vector < int >& A , int K ) { return subarrayWithAtMostKDistinct ( A , K ) - subarrayWithAtMostKDistinct ( A , K - 1 ); } private : int subarrayWithAtMostKDistinct ( vector < int >& A , int K ) { int ans = 0 ; vector < int > count ( A . size () + 1 ); for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K == -1 ) if ( -- count [ A [ l ++ ]] == 0 ) ++ K ; ans += r - l + 1 ; // A[r..l], A[r + 1..l], ..., A[l] } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int subarraysWithKDistinct ( int [] A , int K ) { return subarraysWithAtMostKDistinct ( A , K ) - subarraysWithAtMostKDistinct ( A , K - 1 ); } private int subarraysWithAtMostKDistinct ( int [] A , int K ) { int ans = 0 ; int [] count = new int [ A . length + 1 ] ; for ( int l = 0 , r = 0 ; r < A . length ; ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K == - 1 ) if ( -- count [ A [ l ++]] == 0 ) ++ K ; ans += r - l + 1 ; // A[r..l], A[r + 1..l], ..., A[l] } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def subarraysWithKDistinct ( self , A : List [ int ], K : int ) -> int : def subarraysWithAtMostKDistinct ( K : int ) -> int : ans = 0 count = collections . Counter () l = 0 for r , a in enumerate ( A ): count [ a ] += 1 if count [ a ] == 1 : K -= 1 while K < 0 : count [ A [ l ]] -= 1 if count [ A [ l ]] == 0 : K += 1 l += 1 ans += r - l + 1 return ans return subarraysWithAtMostKDistinct ( K ) - subarraysWithAtMostKDistinct ( K - 1 )","title":"992. Subarrays with K Different Integers"},{"location":"problems/0992/#992-subarrays-with-k-different-integers","text":"Time: $O(n)$ Space: $O(128) = O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int subarraysWithKDistinct ( vector < int >& A , int K ) { return subarrayWithAtMostKDistinct ( A , K ) - subarrayWithAtMostKDistinct ( A , K - 1 ); } private : int subarrayWithAtMostKDistinct ( vector < int >& A , int K ) { int ans = 0 ; vector < int > count ( A . size () + 1 ); for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K == -1 ) if ( -- count [ A [ l ++ ]] == 0 ) ++ K ; ans += r - l + 1 ; // A[r..l], A[r + 1..l], ..., A[l] } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int subarraysWithKDistinct ( int [] A , int K ) { return subarraysWithAtMostKDistinct ( A , K ) - subarraysWithAtMostKDistinct ( A , K - 1 ); } private int subarraysWithAtMostKDistinct ( int [] A , int K ) { int ans = 0 ; int [] count = new int [ A . length + 1 ] ; for ( int l = 0 , r = 0 ; r < A . length ; ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K == - 1 ) if ( -- count [ A [ l ++]] == 0 ) ++ K ; ans += r - l + 1 ; // A[r..l], A[r + 1..l], ..., A[l] } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def subarraysWithKDistinct ( self , A : List [ int ], K : int ) -> int : def subarraysWithAtMostKDistinct ( K : int ) -> int : ans = 0 count = collections . Counter () l = 0 for r , a in enumerate ( A ): count [ a ] += 1 if count [ a ] == 1 : K -= 1 while K < 0 : count [ A [ l ]] -= 1 if count [ A [ l ]] == 0 : K += 1 l += 1 ans += r - l + 1 return ans return subarraysWithAtMostKDistinct ( K ) - subarraysWithAtMostKDistinct ( K - 1 )","title":"992. Subarrays with K Different Integers"},{"location":"problems/0993/","text":"993. Cousins in Binary Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isCousins ( TreeNode * root , int x , int y ) { if ( ! root ) return false ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { bool isFindX = false ; bool isFindY = false ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); if ( root -> val == x ) isFindX = true ; else if ( root -> val == y ) isFindY = true ; else if ( root -> left && root -> right ) { if ( root -> left -> val == x && root -> right -> val == y ) return false ; if ( root -> left -> val == y && root -> right -> val == x ) return false ; } if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } if ( isFindX && isFindY ) return true ; else if ( isFindX || isFindY ) return false ; } return false ; } };","title":"993. Cousins in Binary Tree"},{"location":"problems/0993/#993-cousins-in-binary-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : bool isCousins ( TreeNode * root , int x , int y ) { if ( ! root ) return false ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { bool isFindX = false ; bool isFindY = false ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); if ( root -> val == x ) isFindX = true ; else if ( root -> val == y ) isFindY = true ; else if ( root -> left && root -> right ) { if ( root -> left -> val == x && root -> right -> val == y ) return false ; if ( root -> left -> val == y && root -> right -> val == x ) return false ; } if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } if ( isFindX && isFindY ) return true ; else if ( isFindX || isFindY ) return false ; } return false ; } };","title":"993. Cousins in Binary Tree"},{"location":"problems/0994/","text":"994. Rotting Oranges Approach 1: Brute force Time: $O(kmn)$ Space: $O(mn)$ Approach 2: BFS Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int orangesRotting ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; int countFresh = 0 ; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) ++ countFresh ; else if ( grid [ i ][ j ] == 2 ) q . push ({ i , j }); if ( countFresh == 0 ) return 0 ; while ( ! q . empty ()) { ++ ans ; for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 1 ) continue ; grid [ x ][ y ] = 2 ; // mark grid[x][y] as rotten q . push ({ x , y }); // push newly rotten orange to queue -- countFresh ; // decrease the count of fresh oranges by 1 } } } return countFresh == 0 ? ans - 1 : -1 ; } };","title":"994. Rotting Oranges"},{"location":"problems/0994/#994-rotting-oranges","text":"","title":"994. Rotting Oranges"},{"location":"problems/0994/#approach-1-brute-force","text":"Time: $O(kmn)$ Space: $O(mn)$","title":"Approach 1: Brute force"},{"location":"problems/0994/#approach-2-bfs","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int orangesRotting ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , -1 , 0 }; int ans = 0 ; int countFresh = 0 ; queue < pair < int , int >> q ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) ++ countFresh ; else if ( grid [ i ][ j ] == 2 ) q . push ({ i , j }); if ( countFresh == 0 ) return 0 ; while ( ! q . empty ()) { ++ ans ; for ( int size = q . size (); size > 0 ; -- size ) { const auto [ i , j ] = q . front (); q . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { const int x = i + dirs [ k ]; const int y = j + dirs [ k + 1 ]; if ( x < 0 || x == m || y < 0 || y == n ) continue ; if ( grid [ x ][ y ] != 1 ) continue ; grid [ x ][ y ] = 2 ; // mark grid[x][y] as rotten q . push ({ x , y }); // push newly rotten orange to queue -- countFresh ; // decrease the count of fresh oranges by 1 } } } return countFresh == 0 ? ans - 1 : -1 ; } };","title":"Approach 2: BFS"},{"location":"problems/0995/","text":"995. Minimum Number of K Consecutive Bit Flips Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minKBitFlips ( vector < int >& A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . size (); ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ]) { if ( r + K > A . size ()) return -1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int minKBitFlips ( int [] A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . length ; ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ] ) { if ( r + K > A . length ) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minKBitFlips ( self , A : List [ int ], K : int ) -> int : ans = 0 flippedTime = 0 for r , a in enumerate ( A ): if r >= K and A [ r - K ] == 2 : flippedTime -= 1 if flippedTime % 2 == a : if r + K > len ( A ): return - 1 ans += 1 flippedTime += 1 A [ r ] = 2 return ans","title":"995. Minimum Number of K Consecutive Bit Flips"},{"location":"problems/0995/#995-minimum-number-of-k-consecutive-bit-flips","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minKBitFlips ( vector < int >& A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . size (); ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ]) { if ( r + K > A . size ()) return -1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int minKBitFlips ( int [] A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . length ; ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ] ) { if ( r + K > A . length ) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minKBitFlips ( self , A : List [ int ], K : int ) -> int : ans = 0 flippedTime = 0 for r , a in enumerate ( A ): if r >= K and A [ r - K ] == 2 : flippedTime -= 1 if flippedTime % 2 == a : if r + K > len ( A ): return - 1 ans += 1 flippedTime += 1 A [ r ] = 2 return ans","title":"995. Minimum Number of K Consecutive Bit Flips"},{"location":"problems/0996/","text":"996. Number of Squareful Arrays Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int numSquarefulPerms ( vector < int >& A ) { int ans = 0 ; vector < int > path ; vector < bool > used ( A . size (), false ); sort ( begin ( A ), end ( A )); dfs ( A , used , path , ans ); return ans ; } private : void dfs ( vector < int >& A , vector < bool >& used , vector < int >& path , int & ans ) { if ( path . size () > 1 && ! isSquare ( path . back () + path [ path . size () - 2 ])) return ; if ( path . size () == A . size ()) { ++ ans ; return ; } for ( int i = 0 ; i < A . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( A [ i ]); dfs ( A , used , path , ans ); path . pop_back (); used [ i ] = false ; } } bool isSquare ( int num ) { int root = sqrt ( num ); return root * root == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int numSquarefulPerms ( int [] A ) { boolean [] used = new boolean [ A . length ] ; Arrays . sort ( A ); dfs ( A , used , new ArrayList <> ()); return ans ; } private int ans = 0 ; private void dfs ( int [] A , boolean [] used , List < Integer > path ) { if ( path . size () > 1 && ! isSquare ( path . get ( path . size () - 1 ) + path . get ( path . size () - 2 ))) return ; if ( path . size () == A . length ) { ++ ans ; return ; } for ( int i = 0 ; i < A . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( A [ i ] ); dfs ( A , used , path ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } private boolean isSquare ( int num ) { int root = ( int ) Math . sqrt ( num ); return root * root == num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numSquarefulPerms ( self , A : List [ int ]) -> int : def isSquare ( num : int ) -> bool : root = int ( sqrt ( num )) return root * root == num def dfs ( path : List [ int ]) -> None : if len ( path ) > 1 and not isSquare ( path [ - 1 ] + path [ - 2 ]): return if len ( path ) == len ( A ): self . ans += 1 return for i , a in enumerate ( A ): if used [ i ]: continue if i > 0 and A [ i ] == A [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ a ]) used [ i ] = False self . ans = 0 used = [ False ] * len ( A ) A . sort () dfs ([]) return self . ans","title":"996. Number of Squareful Arrays"},{"location":"problems/0996/#996-number-of-squareful-arrays","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int numSquarefulPerms ( vector < int >& A ) { int ans = 0 ; vector < int > path ; vector < bool > used ( A . size (), false ); sort ( begin ( A ), end ( A )); dfs ( A , used , path , ans ); return ans ; } private : void dfs ( vector < int >& A , vector < bool >& used , vector < int >& path , int & ans ) { if ( path . size () > 1 && ! isSquare ( path . back () + path [ path . size () - 2 ])) return ; if ( path . size () == A . size ()) { ++ ans ; return ; } for ( int i = 0 ; i < A . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( A [ i ]); dfs ( A , used , path , ans ); path . pop_back (); used [ i ] = false ; } } bool isSquare ( int num ) { int root = sqrt ( num ); return root * root == num ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int numSquarefulPerms ( int [] A ) { boolean [] used = new boolean [ A . length ] ; Arrays . sort ( A ); dfs ( A , used , new ArrayList <> ()); return ans ; } private int ans = 0 ; private void dfs ( int [] A , boolean [] used , List < Integer > path ) { if ( path . size () > 1 && ! isSquare ( path . get ( path . size () - 1 ) + path . get ( path . size () - 2 ))) return ; if ( path . size () == A . length ) { ++ ans ; return ; } for ( int i = 0 ; i < A . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( A [ i ] ); dfs ( A , used , path ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } private boolean isSquare ( int num ) { int root = ( int ) Math . sqrt ( num ); return root * root == num ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numSquarefulPerms ( self , A : List [ int ]) -> int : def isSquare ( num : int ) -> bool : root = int ( sqrt ( num )) return root * root == num def dfs ( path : List [ int ]) -> None : if len ( path ) > 1 and not isSquare ( path [ - 1 ] + path [ - 2 ]): return if len ( path ) == len ( A ): self . ans += 1 return for i , a in enumerate ( A ): if used [ i ]: continue if i > 0 and A [ i ] == A [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ a ]) used [ i ] = False self . ans = 0 used = [ False ] * len ( A ) A . sort () dfs ([]) return self . ans","title":"996. Number of Squareful Arrays"},{"location":"problems/0997/","text":"997. Find the Town Judge Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N + 1 ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ]]; ++ count [ t [ 1 ]]; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N + 1 ] ; for ( int [] t : trust ) { -- count [ t [ 0 ]] ; ++ count [ t [ 1 ]] ; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * ( N + 1 ) for a , b in trust : count [ a ] -= 1 count [ b ] += 1 for i in range ( 1 , N + 1 ): if count [ i ] == N - 1 : return i return - 1","title":"997. Find the Town Judge"},{"location":"problems/0997/#997-find-the-town-judge","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N + 1 ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ]]; ++ count [ t [ 1 ]]; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N + 1 ] ; for ( int [] t : trust ) { -- count [ t [ 0 ]] ; ++ count [ t [ 1 ]] ; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * ( N + 1 ) for a , b in trust : count [ a ] -= 1 count [ b ] += 1 for i in range ( 1 , N + 1 ): if count [ i ] == N - 1 : return i return - 1","title":"997. Find the Town Judge"},{"location":"problems/0998/","text":"998. Maximum Binary Tree II","title":"998. Maximum Binary Tree II"},{"location":"problems/0998/#998-maximum-binary-tree-ii","text":"","title":"998. Maximum Binary Tree II"},{"location":"problems/0999/","text":"999. Available Captures for Rook Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ] , j = j0 + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans","title":"999. Available Captures for Rook"},{"location":"problems/0999/#999-available-captures-for-rook","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { -1 , 0 }, { 0 , -1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ] , j = j0 + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans","title":"999. Available Captures for Rook"},{"location":"problems/1000/","text":"1000. Minimum Cost to Merge Stones","title":"1000. Minimum Cost to Merge Stones"},{"location":"problems/1000/#1000-minimum-cost-to-merge-stones","text":"","title":"1000. Minimum Cost to Merge Stones"},{"location":"problems/1001/","text":"1001. Grid Illumination Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < int > gridIllumination ( int N , vector < vector < int >>& lamps , vector < vector < int >>& queries ) { vector < int > ans ; unordered_map < int , int > rows ; unordered_map < int , int > cols ; unordered_map < int , int > diag1 ; unordered_map < int , int > diag2 ; unordered_set < pair < int , int > , pairHash > lampsSet ; for ( vector < int >& lamp : lamps ) { int i = lamp [ 0 ]; int j = lamp [ 1 ]; if ( lampsSet . insert ({ i , j }). second ) { ++ rows [ i ]; ++ cols [ j ]; ++ diag1 [ i + j ]; ++ diag2 [ i - j ]; } } for ( vector < int >& query : queries ) { int i = query [ 0 ]; int j = query [ 1 ]; if ( rows [ i ] || cols [ j ] || diag1 [ i + j ] || diag2 [ i - j ]) { ans . push_back ( 1 ); for ( int y = max ( 0 , i - 1 ); y < min ( N , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( N , j + 2 ); ++ x ) if ( lampsSet . erase ({ y , x })) { -- rows [ y ]; -- cols [ x ]; -- diag1 [ y + x ]; -- diag2 [ y - x ]; } } else ans . push_back ( 0 ); } return ans ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public int [] gridIllumination ( int N , int [][] lamps , int [][] queries ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > rows = new HashMap <> (); Map < Integer , Integer > cols = new HashMap <> (); Map < Integer , Integer > diag1 = new HashMap <> (); Map < Integer , Integer > diag2 = new HashMap <> (); Set < Long > lampsSet = new HashSet <> (); for ( int [] lamp : lamps ) { int i = lamp [ 0 ] ; int j = lamp [ 1 ] ; if ( lampsSet . add ( hash ( i , j ))) { rows . put ( i , rows . getOrDefault ( i , 0 ) + 1 ); cols . put ( j , cols . getOrDefault ( j , 0 ) + 1 ); diag1 . put ( i + j , diag1 . getOrDefault ( i + j , 0 ) + 1 ); diag2 . put ( i - j , diag2 . getOrDefault ( i - j , 0 ) + 1 ); } } for ( int [] query : queries ) { int i = query [ 0 ] ; int j = query [ 1 ] ; if ( rows . getOrDefault ( i , 0 ) > 0 || cols . getOrDefault ( j , 0 ) > 0 || diag1 . getOrDefault ( i + j , 0 ) > 0 || diag2 . getOrDefault ( i - j , 0 ) > 0 ) { ans . add ( 1 ); for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( N , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( N , j + 2 ); ++ x ) if ( lampsSet . remove ( hash ( y , x ))) { rows . put ( y , rows . getOrDefault ( y , 0 ) - 1 ); cols . put ( x , cols . getOrDefault ( x , 0 ) - 1 ); diag1 . put ( y + x , diag1 . getOrDefault ( y + x , 0 ) - 1 ); diag2 . put ( y - x , diag2 . getOrDefault ( y - x , 0 ) - 1 ); } } else ans . add ( 0 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def gridIllumination ( self , N : int , lamps : List [ List [ int ]], queries : List [ List [ int ]]) -> List [ int ]: ans = [] rows = collections . Counter () cols = collections . Counter () diag1 = collections . Counter () diag2 = collections . Counter () lampsSet = set () for i , j in lamps : if ( i , j ) not in lampsSet : lampsSet . add (( i , j )) rows [ i ] += 1 cols [ j ] += 1 diag1 [ i + j ] += 1 diag2 [ i - j ] += 1 for i , j in queries : if rows [ i ] or cols [ j ] or diag1 [ i + j ] or diag2 [ i - j ]: ans . append ( 1 ) for y in range ( max ( 0 , i - 1 ), min ( N , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( N , j + 2 )): if ( y , x ) in lampsSet : lampsSet . remove (( y , x )) rows [ y ] -= 1 cols [ x ] -= 1 diag1 [ y + x ] -= 1 diag2 [ y - x ] -= 1 else : ans . append ( 0 ) return ans","title":"1001. Grid Illumination"},{"location":"problems/1001/#1001-grid-illumination","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : vector < int > gridIllumination ( int N , vector < vector < int >>& lamps , vector < vector < int >>& queries ) { vector < int > ans ; unordered_map < int , int > rows ; unordered_map < int , int > cols ; unordered_map < int , int > diag1 ; unordered_map < int , int > diag2 ; unordered_set < pair < int , int > , pairHash > lampsSet ; for ( vector < int >& lamp : lamps ) { int i = lamp [ 0 ]; int j = lamp [ 1 ]; if ( lampsSet . insert ({ i , j }). second ) { ++ rows [ i ]; ++ cols [ j ]; ++ diag1 [ i + j ]; ++ diag2 [ i - j ]; } } for ( vector < int >& query : queries ) { int i = query [ 0 ]; int j = query [ 1 ]; if ( rows [ i ] || cols [ j ] || diag1 [ i + j ] || diag2 [ i - j ]) { ans . push_back ( 1 ); for ( int y = max ( 0 , i - 1 ); y < min ( N , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( N , j + 2 ); ++ x ) if ( lampsSet . erase ({ y , x })) { -- rows [ y ]; -- cols [ x ]; -- diag1 [ y + x ]; -- diag2 [ y - x ]; } } else ans . push_back ( 0 ); } return ans ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public int [] gridIllumination ( int N , int [][] lamps , int [][] queries ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > rows = new HashMap <> (); Map < Integer , Integer > cols = new HashMap <> (); Map < Integer , Integer > diag1 = new HashMap <> (); Map < Integer , Integer > diag2 = new HashMap <> (); Set < Long > lampsSet = new HashSet <> (); for ( int [] lamp : lamps ) { int i = lamp [ 0 ] ; int j = lamp [ 1 ] ; if ( lampsSet . add ( hash ( i , j ))) { rows . put ( i , rows . getOrDefault ( i , 0 ) + 1 ); cols . put ( j , cols . getOrDefault ( j , 0 ) + 1 ); diag1 . put ( i + j , diag1 . getOrDefault ( i + j , 0 ) + 1 ); diag2 . put ( i - j , diag2 . getOrDefault ( i - j , 0 ) + 1 ); } } for ( int [] query : queries ) { int i = query [ 0 ] ; int j = query [ 1 ] ; if ( rows . getOrDefault ( i , 0 ) > 0 || cols . getOrDefault ( j , 0 ) > 0 || diag1 . getOrDefault ( i + j , 0 ) > 0 || diag2 . getOrDefault ( i - j , 0 ) > 0 ) { ans . add ( 1 ); for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( N , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( N , j + 2 ); ++ x ) if ( lampsSet . remove ( hash ( y , x ))) { rows . put ( y , rows . getOrDefault ( y , 0 ) - 1 ); cols . put ( x , cols . getOrDefault ( x , 0 ) - 1 ); diag1 . put ( y + x , diag1 . getOrDefault ( y + x , 0 ) - 1 ); diag2 . put ( y - x , diag2 . getOrDefault ( y - x , 0 ) - 1 ); } } else ans . add ( 0 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def gridIllumination ( self , N : int , lamps : List [ List [ int ]], queries : List [ List [ int ]]) -> List [ int ]: ans = [] rows = collections . Counter () cols = collections . Counter () diag1 = collections . Counter () diag2 = collections . Counter () lampsSet = set () for i , j in lamps : if ( i , j ) not in lampsSet : lampsSet . add (( i , j )) rows [ i ] += 1 cols [ j ] += 1 diag1 [ i + j ] += 1 diag2 [ i - j ] += 1 for i , j in queries : if rows [ i ] or cols [ j ] or diag1 [ i + j ] or diag2 [ i - j ]: ans . append ( 1 ) for y in range ( max ( 0 , i - 1 ), min ( N , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( N , j + 2 )): if ( y , x ) in lampsSet : lampsSet . remove (( y , x )) rows [ y ] -= 1 cols [ x ] -= 1 diag1 [ y + x ] -= 1 diag2 [ y - x ] -= 1 else : ans . append ( 0 ) return ans","title":"1001. Grid Illumination"},{"location":"problems/1002/","text":"1002. Find Common Characters Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( const string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <> (); int [] commonCount = new int [ 26 ] ; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ] ; for ( char c : a . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = Math . min ( commonCount [ i ] , count [ i ] ); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ] ; ++ i ) ans . add ( String . valueOf ( c )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans","title":"1002. Find Common Characters"},{"location":"problems/1002/#1002-find-common-characters","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( const string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <> (); int [] commonCount = new int [ 26 ] ; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ] ; for ( char c : a . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = Math . min ( commonCount [ i ] , count [ i ] ); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ] ; ++ i ) ans . add ( String . valueOf ( c )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans","title":"1002. Find Common Characters"},{"location":"problems/1003/","text":"1003. Check If Word Is Valid After Substitutions Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isValid ( string S ) { stack < char > stack ; for ( char c : S ) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . top () != 'b' ) return false ; stack . pop (); if ( stack . top () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . empty (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isValid ( String S ) { Stack < Character > stack = new Stack <> (); for ( char c : S . toCharArray ()) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . peek () != 'b' ) return false ; stack . pop (); if ( stack . peek () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . isEmpty (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : if len ( stack ) < 2 or stack [ - 2 ] != 'a' or stack [ - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return not stack","title":"1003. Check If Word Is Valid After Substitutions"},{"location":"problems/1003/#1003-check-if-word-is-valid-after-substitutions","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isValid ( string S ) { stack < char > stack ; for ( char c : S ) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . top () != 'b' ) return false ; stack . pop (); if ( stack . top () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . empty (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isValid ( String S ) { Stack < Character > stack = new Stack <> (); for ( char c : S . toCharArray ()) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . peek () != 'b' ) return false ; stack . pop (); if ( stack . peek () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . isEmpty (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : if len ( stack ) < 2 or stack [ - 2 ] != 'a' or stack [ - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return not stack","title":"1003. Check If Word Is Valid After Substitutions"},{"location":"problems/1004/","text":"1004. Max Consecutive Ones III Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( A [ r ] == 0 ) -- K ; while ( K < 0 ) if ( A [ l ++ ] == 0 ) ++ K ; ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"1004. Max Consecutive Ones III"},{"location":"problems/1004/#1004-max-consecutive-ones-iii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( A [ r ] == 0 ) -- K ; while ( K < 0 ) if ( A [ l ++ ] == 0 ) ++ K ; ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"1004. Max Consecutive Ones III"},{"location":"problems/1005/","text":"1005. Maximize Sum Of Array After K Negations Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( begin ( A ), end ( A ), 0 ) - ( K % 2 ) * * min_element ( begin ( A ), end ( A )) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations"},{"location":"problems/1005/#1005-maximize-sum-of-array-after-k-negations","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( begin ( A ), end ( A ), 0 ) - ( K % 2 ) * * min_element ( begin ( A ), end ( A )) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations"},{"location":"problems/1006/","text":"1006. Clumsy Factorial Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def clumsy ( self , N : int ) -> int : if N == 1 : return 1 if N == 2 : return 2 if N == 3 : return 6 if N == 4 : return 7 if N % 4 == 1 : return N + 2 if N % 4 == 2 : return N + 2 if N % 4 == 3 : return N - 1 return N + 1","title":"1006. Clumsy Factorial"},{"location":"problems/1006/#1006-clumsy-factorial","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def clumsy ( self , N : int ) -> int : if N == 1 : return 1 if N == 2 : return 2 if N == 3 : return 6 if N == 4 : return 7 if N % 4 == 1 : return N + 2 if N % 4 == 2 : return N + 2 if N % 4 == 3 : return N - 1 return N + 1","title":"1006. Clumsy Factorial"},{"location":"problems/1007/","text":"1007. Minimum Domino Rotations For Equal Row Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return -1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row"},{"location":"problems/1007/#1007-minimum-domino-rotations-for-equal-row","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return -1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row"},{"location":"problems/1008/","text":"1008. Construct Binary Search Tree from Preorder Traversal","title":"1008. Construct Binary Search Tree from Preorder Traversal"},{"location":"problems/1008/#1008-construct-binary-search-tree-from-preorder-traversal","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal"},{"location":"problems/1009/","text":"1009. Complement of Base 10 Integer Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } } Python 1 2 3 4 5 6 7 8 class Solution : def bitwiseComplement ( self , N : int ) -> int : mask = 1 while mask < N : mask = ( mask << 1 ) + 1 return mask ^ N","title":"1009. Complement of Base 10 Integer"},{"location":"problems/1009/#1009-complement-of-base-10-integer","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } } Python 1 2 3 4 5 6 7 8 class Solution : def bitwiseComplement ( self , N : int ) -> int : mask = 1 while mask < N : mask = ( mask << 1 ) + 1 return mask ^ N","title":"1009. Complement of Base 10 Integer"},{"location":"problems/1010/","text":"1010. Pairs of Songs With Total Durations Divisible by 60 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += count [( 60 - t ) % 60 ]; ++ count [ t ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ] ; for ( int t : time ) { t %= 60 ; ans += count [ ( 60 - t ) % 60 ] ; ++ count [ t ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [( 60 - t ) % 60 ] count [ t ] += 1 return ans","title":"1010. Pairs of Songs With Total Durations Divisible by 60"},{"location":"problems/1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += count [( 60 - t ) % 60 ]; ++ count [ t ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ] ; for ( int t : time ) { t %= 60 ; ans += count [ ( 60 - t ) % 60 ] ; ++ count [ t ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [( 60 - t ) % 60 ] count [ t ] += 1 return ans","title":"1010. Pairs of Songs With Total Durations Divisible by 60"},{"location":"problems/1011/","text":"1011. Capacity To Ship Packages Within D Days Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( begin ( weights ), end ( weights )); int r = accumulate ( begin ( weights ), end ( weights ), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l","title":"1011. Capacity To Ship Packages Within D Days"},{"location":"problems/1011/#1011-capacity-to-ship-packages-within-d-days","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( begin ( weights ), end ( weights )); int r = accumulate ( begin ( weights ), end ( weights ), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l","title":"1011. Capacity To Ship Packages Within D Days"},{"location":"problems/1012/","text":"1012. Numbers With Repeated Digits Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private : int uniqueDigits = 0 ; void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if ( mask & ( 1 << digit )) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private int uniqueDigits = 0 ; private void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if (( mask & ( 1 << digit )) > 0 ) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }","title":"1012. Numbers With Repeated Digits"},{"location":"problems/1012/#1012-numbers-with-repeated-digits","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private : int uniqueDigits = 0 ; void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if ( mask & ( 1 << digit )) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private int uniqueDigits = 0 ; private void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if (( mask & ( 1 << digit )) > 0 ) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }","title":"1012. Numbers With Repeated Digits"},{"location":"problems/1013/","text":"1013. Partition Array Into Three Parts With Equal Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( begin ( A ), end ( A ), 0 ); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : summ = sum ( A ) prefixSum = 0 parts = 1 for a in A : prefixSum += a if prefixSum == summ * parts // 3 : parts += 1 return summ % 3 == 0 and parts >= 3","title":"1013. Partition Array Into Three Parts With Equal Sum"},{"location":"problems/1013/#1013-partition-array-into-three-parts-with-equal-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( begin ( A ), end ( A ), 0 ); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : summ = sum ( A ) prefixSum = 0 parts = 1 for a in A : prefixSum += a if prefixSum == summ * parts // 3 : parts += 1 return summ % 3 == 0 and parts >= 3","title":"1013. Partition Array Into Three Parts With Equal Sum"},{"location":"problems/1014/","text":"1014. Best Sightseeing Pair Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans","title":"1014. Best Sightseeing Pair"},{"location":"problems/1014/#1014-best-sightseeing-pair","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans","title":"1014. Best Sightseeing Pair"},{"location":"problems/1015/","text":"1015. Smallest Integer Divisible by K Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return -1 ; unordered_set < int > seen ; int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . count ( N )) return -1 ; seen . insert ( N ); } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > seen = new HashSet <> (); int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . contains ( N )) return - 1 ; seen . add ( N ); } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 seen = set () N = 0 for length in range ( 1 , K + 1 ): N = ( N * 10 + 1 ) % K if N == 0 : return length if N in seen : return - 1 seen . add ( N ) return - 1","title":"1015. Smallest Integer Divisible by K"},{"location":"problems/1015/#1015-smallest-integer-divisible-by-k","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return -1 ; unordered_set < int > seen ; int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . count ( N )) return -1 ; seen . insert ( N ); } return -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > seen = new HashSet <> (); int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . contains ( N )) return - 1 ; seen . add ( N ); } return - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 seen = set () N = 0 for length in range ( 1 , K + 1 ): N = ( N * 10 + 1 ) % K if N == 0 : return length if N in seen : return - 1 seen . add ( N ) return - 1","title":"1015. Smallest Integer Divisible by K"},{"location":"problems/1016/","text":"1016. Binary String With Substrings Representing 1 To N Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) if ( ! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , 'b' ) not in S : return False return True","title":"1016. Binary String With Substrings Representing 1 To N"},{"location":"problems/1016/#1016-binary-string-with-substrings-representing-1-to-n","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) if ( ! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , 'b' ) not in S : return False return True","title":"1016. Binary String With Substrings Representing 1 To N"},{"location":"problems/1017/","text":"1017. Convert to Base -2 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string baseNeg2 ( int N ) { string ans ; while ( N ) { ans = to_string ( N & 1 ) + ans ; N = - ( N >> 1 ); } return ans == \"\" ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public String baseNeg2 ( int N ) { StringBuilder ans = new StringBuilder (); while ( N != 0 ) { ans . append ( N & 1 ); N = - ( N >> 1 ); } return ans . length () > 0 ? ans . reverse (). toString () : \"0\" ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def baseNeg2 ( self , N : int ) -> str : ans = '' while N : ans = str ( N & 1 ) + ans N = - ( N >> 1 ) return '0' if ans == '' else ans","title":"1017. Convert to Base -2"},{"location":"problems/1017/#1017-convert-to-base-2","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string baseNeg2 ( int N ) { string ans ; while ( N ) { ans = to_string ( N & 1 ) + ans ; N = - ( N >> 1 ); } return ans == \"\" ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public String baseNeg2 ( int N ) { StringBuilder ans = new StringBuilder (); while ( N != 0 ) { ans . append ( N & 1 ); N = - ( N >> 1 ); } return ans . length () > 0 ? ans . reverse (). toString () : \"0\" ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def baseNeg2 ( self , N : int ) -> str : ans = '' while N : ans = str ( N & 1 ) + ans N = - ( N >> 1 ) return '0' if ans == '' else ans","title":"1017. Convert to Base -2"},{"location":"problems/1018/","text":"1018. Binary Prefix Divisible By 5 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <> (); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans","title":"1018. Binary Prefix Divisible By 5"},{"location":"problems/1018/#1018-binary-prefix-divisible-by-5","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <> (); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans","title":"1018. Binary Prefix Divisible By 5"},{"location":"problems/1019/","text":"1019. Next Greater Node In Linked List Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; stack < int > stack ; for (; head ; head = head -> next ) { while ( ! stack . empty () && head -> val > ans [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = head -> val ; } stack . push ( ans . size ()); ans . push_back ( head -> val ); } for (; ! stack . empty (); stack . pop ()) ans [ stack . top ()] = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] nextLargerNodes ( ListNode head ) { List < Integer > ans = new ArrayList <> (); Stack < Integer > stack = new Stack <> (); for (; head != null ; head = head . next ) { while ( ! stack . isEmpty () && head . val > ans . get ( stack . peek ())) { int index = stack . pop (); ans . set ( index , head . val ); } stack . push ( ans . size ()); ans . add ( head . val ); } while ( ! stack . isEmpty ()) ans . set ( stack . pop (), 0 ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] while head : while stack and head . val > ans [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = head . val stack . append ( len ( ans )) ans . append ( head . val ) head = head . next for i in stack : ans [ i ] = 0 return ans","title":"1019. Next Greater Node In Linked List"},{"location":"problems/1019/#1019-next-greater-node-in-linked-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; stack < int > stack ; for (; head ; head = head -> next ) { while ( ! stack . empty () && head -> val > ans [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = head -> val ; } stack . push ( ans . size ()); ans . push_back ( head -> val ); } for (; ! stack . empty (); stack . pop ()) ans [ stack . top ()] = 0 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] nextLargerNodes ( ListNode head ) { List < Integer > ans = new ArrayList <> (); Stack < Integer > stack = new Stack <> (); for (; head != null ; head = head . next ) { while ( ! stack . isEmpty () && head . val > ans . get ( stack . peek ())) { int index = stack . pop (); ans . set ( index , head . val ); } stack . push ( ans . size ()); ans . add ( head . val ); } while ( ! stack . isEmpty ()) ans . set ( stack . pop (), 0 ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] while head : while stack and head . val > ans [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = head . val stack . append ( len ( ans )) ans . append ( head . val ) head = head . next for i in stack : ans [ i ] = 0 return ans","title":"1019. Next Greater Node In Linked List"},{"location":"problems/1020/","text":"1020. Number of Enclaves","title":"1020. Number of Enclaves"},{"location":"problems/1020/#1020-number-of-enclaves","text":"","title":"1020. Number of Enclaves"},{"location":"problems/1021/","text":"1021. Remove Outermost Parentheses","title":"1021. Remove Outermost Parentheses"},{"location":"problems/1021/#1021-remove-outermost-parentheses","text":"","title":"1021. Remove Outermost Parentheses"},{"location":"problems/1022/","text":"1022. Sum of Root To Leaf Binary Numbers","title":"1022. Sum of Root To Leaf Binary Numbers"},{"location":"problems/1022/#1022-sum-of-root-to-leaf-binary-numbers","text":"","title":"1022. Sum of Root To Leaf Binary Numbers"},{"location":"problems/1023/","text":"1023. Camelcase Matching Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < bool > camelMatch ( vector < string >& queries , string pattern ) { vector < bool > ans ; for ( const string & query : queries ) ans . push_back ( isMatch ( query , pattern )); return ans ; } private : bool isMatch ( const string & query , const string & pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query [ i ] == pattern [ j ]) ++ j ; else if ( isupper ( query [ i ])) return false ; return j == pattern . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < Boolean > camelMatch ( String [] queries , String pattern ) { List < Boolean > ans = new ArrayList <> (); for ( final String query : queries ) ans . add ( isMatch ( query , pattern )); return ans ; } private boolean isMatch ( final String query , final String pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query . charAt ( i ) == pattern . charAt ( j )) ++ j ; else if ( Character . isUpperCase ( query . charAt ( i ))) return false ; return j == pattern . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def camelMatch ( self , queries : List [ str ], pattern : str ) -> List [ bool ]: def isMatch ( query : str ) -> bool : j = 0 for i , c in enumerate ( query ): if j < len ( pattern ) and c == pattern [ j ]: j += 1 elif c . isupper (): return False return j == len ( pattern ) return [ isMatch ( query ) for query in queries ]","title":"1023. Camelcase Matching"},{"location":"problems/1023/#1023-camelcase-matching","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < bool > camelMatch ( vector < string >& queries , string pattern ) { vector < bool > ans ; for ( const string & query : queries ) ans . push_back ( isMatch ( query , pattern )); return ans ; } private : bool isMatch ( const string & query , const string & pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query [ i ] == pattern [ j ]) ++ j ; else if ( isupper ( query [ i ])) return false ; return j == pattern . length (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < Boolean > camelMatch ( String [] queries , String pattern ) { List < Boolean > ans = new ArrayList <> (); for ( final String query : queries ) ans . add ( isMatch ( query , pattern )); return ans ; } private boolean isMatch ( final String query , final String pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query . charAt ( i ) == pattern . charAt ( j )) ++ j ; else if ( Character . isUpperCase ( query . charAt ( i ))) return false ; return j == pattern . length (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def camelMatch ( self , queries : List [ str ], pattern : str ) -> List [ bool ]: def isMatch ( query : str ) -> bool : j = 0 for i , c in enumerate ( query ): if j < len ( pattern ) and c == pattern [ j ]: j += 1 elif c . isupper (): return False return j == len ( pattern ) return [ isMatch ( query ) for query in queries ]","title":"1023. Camelcase Matching"},{"location":"problems/1024/","text":"1024. Video Stitching Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int videoStitching ( vector < vector < int >>& clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; sort ( begin ( clips ), end ( clips )); int i = 0 ; while ( farthest < T ) { while ( i < clips . size () && clips [ i ][ 0 ] <= end ) farthest = max ( farthest , clips [ i ++ ][ 1 ]); if ( end == farthest ) return -1 ; ++ ans ; end = farthest ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int videoStitching ( int [][] clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; Arrays . sort ( clips , ( a , b ) -> a [ 0 ] - b [ 0 ] ); int i = 0 ; while ( farthest < T ) { while ( i < clips . length && clips [ i ][ 0 ] <= end ) farthest = Math . max ( farthest , clips [ i ++][ 1 ] ); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def videoStitching ( self , clips : List [ List [ int ]], T : int ) -> int : ans = 0 end = 0 farthest = 0 clips . sort () i = 0 while farthest < T : while i < len ( clips ) and clips [ i ][ 0 ] <= end : farthest = max ( farthest , clips [ i ][ 1 ]) i += 1 if end == farthest : return - 1 ans += 1 end = farthest return ans","title":"1024. Video Stitching"},{"location":"problems/1024/#1024-video-stitching","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int videoStitching ( vector < vector < int >>& clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; sort ( begin ( clips ), end ( clips )); int i = 0 ; while ( farthest < T ) { while ( i < clips . size () && clips [ i ][ 0 ] <= end ) farthest = max ( farthest , clips [ i ++ ][ 1 ]); if ( end == farthest ) return -1 ; ++ ans ; end = farthest ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int videoStitching ( int [][] clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; Arrays . sort ( clips , ( a , b ) -> a [ 0 ] - b [ 0 ] ); int i = 0 ; while ( farthest < T ) { while ( i < clips . length && clips [ i ][ 0 ] <= end ) farthest = Math . max ( farthest , clips [ i ++][ 1 ] ); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def videoStitching ( self , clips : List [ List [ int ]], T : int ) -> int : ans = 0 end = 0 farthest = 0 clips . sort () i = 0 while farthest < T : while i < len ( clips ) and clips [ i ][ 0 ] <= end : farthest = max ( farthest , clips [ i ][ 1 ]) i += 1 if end == farthest : return - 1 ans += 1 end = farthest return ans","title":"1024. Video Stitching"},{"location":"problems/1025/","text":"1025. Divisor Game Time: Space: C++ 1 2 3 4 class Solution { public : bool divisorGame ( int N ) { return N % 2 == 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean divisorGame ( int N ) { return N % 2 == 0 ; } } Python 1 2 3 class Solution : def divisorGame ( self , N : int ) -> bool : return N % 2 == 0","title":"1025. Divisor Game"},{"location":"problems/1025/#1025-divisor-game","text":"Time: Space: C++ 1 2 3 4 class Solution { public : bool divisorGame ( int N ) { return N % 2 == 0 ; } }; Java 1 2 3 4 5 class Solution { public boolean divisorGame ( int N ) { return N % 2 == 0 ; } } Python 1 2 3 class Solution : def divisorGame ( self , N : int ) -> bool : return N % 2 == 0","title":"1025. Divisor Game"},{"location":"problems/1026/","text":"1026. Maximum Difference Between Node and Ancestor Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxAncestorDiff ( TreeNode * root ) { return dfs ( root , root -> val , root -> val ); } private : // return |max - min| of the tree w/ root int dfs ( TreeNode * root , int mini , int maxi ) { if ( ! root ) return 0 ; mini = min ( mini , root -> val ); maxi = max ( maxi , root -> val ); const int leftMaxDiff = dfs ( root -> left , mini , maxi ); const int rightMaxDiff = dfs ( root -> right , mini , maxi ); return max ({ maxi - mini , leftMaxDiff , rightMaxDiff }); } };","title":"1026. Maximum Difference Between Node and Ancestor"},{"location":"problems/1026/#1026-maximum-difference-between-node-and-ancestor","text":"Time: $O(n)$ Space: $O(h)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxAncestorDiff ( TreeNode * root ) { return dfs ( root , root -> val , root -> val ); } private : // return |max - min| of the tree w/ root int dfs ( TreeNode * root , int mini , int maxi ) { if ( ! root ) return 0 ; mini = min ( mini , root -> val ); maxi = max ( maxi , root -> val ); const int leftMaxDiff = dfs ( root -> left , mini , maxi ); const int rightMaxDiff = dfs ( root -> right , mini , maxi ); return max ({ maxi - mini , leftMaxDiff , rightMaxDiff }); } };","title":"1026. Maximum Difference Between Node and Ancestor"},{"location":"problems/1027/","text":"1027. Longest Arithmetic Sequence","title":"1027. Longest Arithmetic Sequence"},{"location":"problems/1027/#1027-longest-arithmetic-sequence","text":"","title":"1027. Longest Arithmetic Sequence"},{"location":"problems/1028/","text":"1028. Recover a Tree From Preorder Traversal","title":"1028. Recover a Tree From Preorder Traversal"},{"location":"problems/1028/#1028-recover-a-tree-from-preorder-traversal","text":"","title":"1028. Recover a Tree From Preorder Traversal"},{"location":"problems/1029/","text":"1029. Two City Scheduling","title":"1029. Two City Scheduling"},{"location":"problems/1029/#1029-two-city-scheduling","text":"","title":"1029. Two City Scheduling"},{"location":"problems/1030/","text":"1030. Matrix Cells in Distance Order","title":"1030. Matrix Cells in Distance Order"},{"location":"problems/1030/#1030-matrix-cells-in-distance-order","text":"","title":"1030. Matrix Cells in Distance Order"},{"location":"problems/1031/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int maxSumTwoNoOverlap ( int [] A , int L , int M ) { return Math . max ( helper ( A , L , M ), helper ( A , M , L )); } private int helper ( int [] A , int l , int r ) { final int n = A . length ; int [] left = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ] ; if ( i >= l ) sum -= A [ i - l ] ; if ( i >= l - 1 ) left [ i ] = i > 0 ? Math . max ( left [ i - 1 ] , sum ) : sum ; } int [] right = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ] ; if ( i <= n - r - 1 ) sum -= A [ i + r ] ; if ( i <= n - r ) right [ i ] = i < n - 1 ? Math . max ( right [ i + 1 ] , sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = Math . max ( ans , left [ i ] + right [ i + 1 ] ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def maxSumTwoNoOverlap ( self , A : List [ int ], L : int , M : int ) -> int : def helper ( l : int , r : int ) -> int : n = len ( A ) left = [ 0 ] * n sum = 0 for i in range ( n ): sum += A [ i ] if i >= l : sum -= A [ i - l ] if i >= l - 1 : left [ i ] = max ( left [ i - 1 ], sum ) if i > 0 else sum right = [ 0 ] * n sum = 0 for i in range ( n )[:: - 1 ]: sum += A [ i ] if i <= n - r - 1 : sum -= A [ i + r ] if i <= n - r : right [ i ] = max ( right [ i + 1 ], sum ) if i < n - 1 else sum return max ( left [ i ] + right [ i + 1 ] for i in range ( n - 1 )) return max ( helper ( L , M ), helper ( M , L ))","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays"},{"location":"problems/1031/#1031-maximum-sum-of-two-non-overlapping-subarrays","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int maxSumTwoNoOverlap ( int [] A , int L , int M ) { return Math . max ( helper ( A , L , M ), helper ( A , M , L )); } private int helper ( int [] A , int l , int r ) { final int n = A . length ; int [] left = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ] ; if ( i >= l ) sum -= A [ i - l ] ; if ( i >= l - 1 ) left [ i ] = i > 0 ? Math . max ( left [ i - 1 ] , sum ) : sum ; } int [] right = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ] ; if ( i <= n - r - 1 ) sum -= A [ i + r ] ; if ( i <= n - r ) right [ i ] = i < n - 1 ? Math . max ( right [ i + 1 ] , sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = Math . max ( ans , left [ i ] + right [ i + 1 ] ); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def maxSumTwoNoOverlap ( self , A : List [ int ], L : int , M : int ) -> int : def helper ( l : int , r : int ) -> int : n = len ( A ) left = [ 0 ] * n sum = 0 for i in range ( n ): sum += A [ i ] if i >= l : sum -= A [ i - l ] if i >= l - 1 : left [ i ] = max ( left [ i - 1 ], sum ) if i > 0 else sum right = [ 0 ] * n sum = 0 for i in range ( n )[:: - 1 ]: sum += A [ i ] if i <= n - r - 1 : sum -= A [ i + r ] if i <= n - r : right [ i ] = max ( right [ i + 1 ], sum ) if i < n - 1 else sum return max ( left [ i ] + right [ i + 1 ] for i in range ( n - 1 )) return max ( helper ( L , M ), helper ( M , L ))","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays"},{"location":"problems/1032/","text":"1032. Stream of Characters","title":"1032. Stream of Characters"},{"location":"problems/1032/#1032-stream-of-characters","text":"","title":"1032. Stream of Characters"},{"location":"problems/1033/","text":"1033. Moving Stones Until Consecutive Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( begin ( nums ), end ( nums )); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] numMovesStones ( int a , int b , int c ) { int [] nums = new int [] { a , b , c }; Arrays . sort ( nums ); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return new int [] { 0 , 0 }; return new int [] { Math . min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } } Python 1 2 3 4 5 6 7 8 class Solution : def numMovesStones ( self , a : int , b : int , c : int ) -> List [ int ]: nums = sorted ([ a , b , c ]) if nums [ 2 ] - nums [ 0 ] == 2 : return [ 0 , 0 ] return [ 1 if min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 else 2 , nums [ 2 ] - nums [ 0 ] - 2 ]","title":"1033. Moving Stones Until Consecutive"},{"location":"problems/1033/#1033-moving-stones-until-consecutive","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( begin ( nums ), end ( nums )); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] numMovesStones ( int a , int b , int c ) { int [] nums = new int [] { a , b , c }; Arrays . sort ( nums ); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return new int [] { 0 , 0 }; return new int [] { Math . min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } } Python 1 2 3 4 5 6 7 8 class Solution : def numMovesStones ( self , a : int , b : int , c : int ) -> List [ int ]: nums = sorted ([ a , b , c ]) if nums [ 2 ] - nums [ 0 ] == 2 : return [ 0 , 0 ] return [ 1 if min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 else 2 , nums [ 2 ] - nums [ 0 ] - 2 ]","title":"1033. Moving Stones Until Consecutive"},{"location":"problems/1034/","text":"1034. Coloring A Border Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < int >> colorBorder ( vector < vector < int >>& grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ]); for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private : void dfs ( vector < vector < int >>& grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . size () && j > 0 && j + 1 < grid [ 0 ]. size () && abs ( grid [ i + 1 ][ j ]) == originalColor && abs ( grid [ i - 1 ][ j ]) == originalColor && abs ( grid [ i ][ j + 1 ]) == originalColor && abs ( grid [ i ][ j - 1 ]) == originalColor ) grid [ i ][ j ] = originalColor ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] colorBorder ( int [][] grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ] ); for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private void dfs ( int [][] grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . length && j > 0 && j + 1 < grid [ 0 ] . length && Math . abs ( grid [ i + 1 ][ j ] ) == originalColor && Math . abs ( grid [ i - 1 ][ j ] ) == originalColor && Math . abs ( grid [ i ][ j + 1 ] ) == originalColor && Math . abs ( grid [ i ][ j - 1 ] ) == originalColor ) grid [ i ][ j ] = originalColor ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int , originalColor : int ) -> None : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or grid [ i ][ j ] != originalColor : return grid [ i ][ j ] = - originalColor dfs ( i + 1 , j , originalColor ) dfs ( i - 1 , j , originalColor ) dfs ( i , j + 1 , originalColor ) dfs ( i , j - 1 , originalColor ) if 0 < i < len ( grid ) - 1 and 0 < j < len ( grid [ 0 ]) - 1 and \\ abs ( grid [ i + 1 ][ j ]) == originalColor and \\ abs ( grid [ i - 1 ][ j ]) == originalColor and \\ abs ( grid [ i ][ j + 1 ]) == originalColor and \\ abs ( grid [ i ][ j - 1 ]) == originalColor : grid [ i ][ j ] = originalColor dfs ( r0 , c0 , grid [ r0 ][ c0 ]) for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] < 0 : grid [ i ][ j ] = color return grid","title":"1034. Coloring A Border"},{"location":"problems/1034/#1034-coloring-a-border","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < int >> colorBorder ( vector < vector < int >>& grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ]); for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private : void dfs ( vector < vector < int >>& grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . size () && j > 0 && j + 1 < grid [ 0 ]. size () && abs ( grid [ i + 1 ][ j ]) == originalColor && abs ( grid [ i - 1 ][ j ]) == originalColor && abs ( grid [ i ][ j + 1 ]) == originalColor && abs ( grid [ i ][ j - 1 ]) == originalColor ) grid [ i ][ j ] = originalColor ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int [][] colorBorder ( int [][] grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ] ); for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private void dfs ( int [][] grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . length && j > 0 && j + 1 < grid [ 0 ] . length && Math . abs ( grid [ i + 1 ][ j ] ) == originalColor && Math . abs ( grid [ i - 1 ][ j ] ) == originalColor && Math . abs ( grid [ i ][ j + 1 ] ) == originalColor && Math . abs ( grid [ i ][ j - 1 ] ) == originalColor ) grid [ i ][ j ] = originalColor ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int , originalColor : int ) -> None : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or grid [ i ][ j ] != originalColor : return grid [ i ][ j ] = - originalColor dfs ( i + 1 , j , originalColor ) dfs ( i - 1 , j , originalColor ) dfs ( i , j + 1 , originalColor ) dfs ( i , j - 1 , originalColor ) if 0 < i < len ( grid ) - 1 and 0 < j < len ( grid [ 0 ]) - 1 and \\ abs ( grid [ i + 1 ][ j ]) == originalColor and \\ abs ( grid [ i - 1 ][ j ]) == originalColor and \\ abs ( grid [ i ][ j + 1 ]) == originalColor and \\ abs ( grid [ i ][ j - 1 ]) == originalColor : grid [ i ][ j ] = originalColor dfs ( r0 , c0 , grid [ r0 ][ c0 ]) for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] < 0 : grid [ i ][ j ] = color return grid","title":"1034. Coloring A Border"},{"location":"problems/1035/","text":"1035. Uncrossed Lines Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxUncrossedLines ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxUncrossedLines ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 if A [ i - 1 ] == B [ j - 1 ] \\ else max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) return dp [ m ][ n ]","title":"1035. Uncrossed Lines"},{"location":"problems/1035/#1035-uncrossed-lines","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxUncrossedLines ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxUncrossedLines ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 if A [ i - 1 ] == B [ j - 1 ] \\ else max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) return dp [ m ][ n ]","title":"1035. Uncrossed Lines"},{"location":"problems/1036/","text":"1036. Escape a Large Maze Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : bool isEscapePossible ( vector < vector < int >>& blocked , vector < int >& source , vector < int >& target ) { unordered_set < long > blockedSet ; for ( vector < int >& b : blocked ) blockedSet . insert ( hash ( b [ 0 ], b [ 1 ])); unordered_set < long > visited1 ; unordered_set < long > visited2 ; return dfs ( blockedSet , source [ 0 ], source [ 1 ], hash ( target [ 0 ], target [ 1 ]), visited1 ) && dfs ( blockedSet , target [ 0 ], target [ 1 ], hash ( source [ 0 ], source [ 1 ]), visited2 ); } private : bool dfs ( unordered_set < long >& blockedSet , int i , int j , long target , unordered_set < long >& visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . count ( hash ( i , j )) || visited . count ( hash ( i , j ))) return false ; visited . insert ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } long hash ( int i , int j ) { return (( long ) i << 16 ) + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean isEscapePossible ( int [][] blocked , int [] source , int [] target ) { Set < Long > blockedSet = new HashSet <> (); for ( int [] b : blocked ) blockedSet . add ( hash ( b [ 0 ] , b [ 1 ] )); return dfs ( blockedSet , source [ 0 ] , source [ 1 ] , hash ( target [ 0 ] , target [ 1 ] ), new HashSet <> ()) && dfs ( blockedSet , target [ 0 ] , target [ 1 ] , hash ( source [ 0 ] , source [ 1 ] ), new HashSet <> ()); } private boolean dfs ( Set < Long > blockedSet , int i , int j , long target , Set < Long > visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . contains ( hash ( i , j )) || visited . contains ( hash ( i , j ))) return false ; visited . add ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isEscapePossible ( self , blocked : List [ List [ int ]], source : List [ int ], target : List [ int ]) -> bool : def dfs ( i : int , j : int , target : List [ int ], visited : set ) -> bool : if not 0 <= i < 10 ** 6 or not 0 <= j < 10 ** 6 or ( i , j ) in blocked or ( i , j ) in visited : return False visited . add (( i , j )) if len ( visited ) > ( 1 + 199 ) * 199 // 2 or [ i , j ] == target : return True return dfs ( i + 1 , j , target , visited ) or \\ dfs ( i - 1 , j , target , visited ) or \\ dfs ( i , j + 1 , target , visited ) or \\ dfs ( i , j - 1 , target , visited ) blocked = set ( tuple ( b ) for b in blocked ) return dfs ( source [ 0 ], source [ 1 ], target , set ()) and dfs ( target [ 0 ], target [ 1 ], source , set ())","title":"1036. Escape a Large Maze"},{"location":"problems/1036/#1036-escape-a-large-maze","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : bool isEscapePossible ( vector < vector < int >>& blocked , vector < int >& source , vector < int >& target ) { unordered_set < long > blockedSet ; for ( vector < int >& b : blocked ) blockedSet . insert ( hash ( b [ 0 ], b [ 1 ])); unordered_set < long > visited1 ; unordered_set < long > visited2 ; return dfs ( blockedSet , source [ 0 ], source [ 1 ], hash ( target [ 0 ], target [ 1 ]), visited1 ) && dfs ( blockedSet , target [ 0 ], target [ 1 ], hash ( source [ 0 ], source [ 1 ]), visited2 ); } private : bool dfs ( unordered_set < long >& blockedSet , int i , int j , long target , unordered_set < long >& visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . count ( hash ( i , j )) || visited . count ( hash ( i , j ))) return false ; visited . insert ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } long hash ( int i , int j ) { return (( long ) i << 16 ) + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean isEscapePossible ( int [][] blocked , int [] source , int [] target ) { Set < Long > blockedSet = new HashSet <> (); for ( int [] b : blocked ) blockedSet . add ( hash ( b [ 0 ] , b [ 1 ] )); return dfs ( blockedSet , source [ 0 ] , source [ 1 ] , hash ( target [ 0 ] , target [ 1 ] ), new HashSet <> ()) && dfs ( blockedSet , target [ 0 ] , target [ 1 ] , hash ( source [ 0 ] , source [ 1 ] ), new HashSet <> ()); } private boolean dfs ( Set < Long > blockedSet , int i , int j , long target , Set < Long > visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . contains ( hash ( i , j )) || visited . contains ( hash ( i , j ))) return false ; visited . add ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isEscapePossible ( self , blocked : List [ List [ int ]], source : List [ int ], target : List [ int ]) -> bool : def dfs ( i : int , j : int , target : List [ int ], visited : set ) -> bool : if not 0 <= i < 10 ** 6 or not 0 <= j < 10 ** 6 or ( i , j ) in blocked or ( i , j ) in visited : return False visited . add (( i , j )) if len ( visited ) > ( 1 + 199 ) * 199 // 2 or [ i , j ] == target : return True return dfs ( i + 1 , j , target , visited ) or \\ dfs ( i - 1 , j , target , visited ) or \\ dfs ( i , j + 1 , target , visited ) or \\ dfs ( i , j - 1 , target , visited ) blocked = set ( tuple ( b ) for b in blocked ) return dfs ( source [ 0 ], source [ 1 ], target , set ()) and dfs ( target [ 0 ], target [ 1 ], source , set ())","title":"1036. Escape a Large Maze"},{"location":"problems/1037/","text":"1037. Valid Boomerang Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool isBoomerang ( vector < vector < int >>& points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ]); } }; Java 1 2 3 4 5 6 class Solution { public boolean isBoomerang ( int [][] points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ] ) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ] ) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ] ) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ] ); } } Python 1 2 3 4 class Solution : def isBoomerang ( self , points : List [ List [ int ]]) -> bool : return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != \\ ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ])","title":"1037. Valid Boomerang"},{"location":"problems/1037/#1037-valid-boomerang","text":"Time: Space: C++ 1 2 3 4 5 6 7 class Solution { public : bool isBoomerang ( vector < vector < int >>& points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ]); } }; Java 1 2 3 4 5 6 class Solution { public boolean isBoomerang ( int [][] points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ] ) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ] ) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ] ) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ] ); } } Python 1 2 3 4 class Solution : def isBoomerang ( self , points : List [ List [ int ]]) -> bool : return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != \\ ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ])","title":"1037. Valid Boomerang"},{"location":"problems/1038/","text":"1038. Binary Search Tree to Greater Sum Tree Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : TreeNode * bstToGst ( TreeNode * root ) { int prefixSum = 0 ; function < void ( TreeNode * ) > reversedInorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; reversedInorder ( root -> right ); root -> val += prefixSum ; prefixSum = root -> val ; reversedInorder ( root -> left ); }; reversedInorder ( root ); return root ; } };","title":"1038. Binary Search Tree to Greater Sum Tree"},{"location":"problems/1038/#1038-binary-search-tree-to-greater-sum-tree","text":"Time: $O(n)$ Space: $O(\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : TreeNode * bstToGst ( TreeNode * root ) { int prefixSum = 0 ; function < void ( TreeNode * ) > reversedInorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; reversedInorder ( root -> right ); root -> val += prefixSum ; prefixSum = root -> val ; reversedInorder ( root -> left ); }; reversedInorder ( root ); return root ; } };","title":"1038. Binary Search Tree to Greater Sum Tree"},{"location":"problems/1039/","text":"1039. Minimum Score Triangulation of Polygon Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minScoreTriangulation ( vector < int >& A ) { vector < vector < int >> dp ( A . size (), vector < int > ( A . size (), 0 )); for ( int j = 2 ; j < A . size (); ++ j ) for ( int i = j - 2 ; i >= 0 ; -- i ) { dp [ i ][ j ] = INT_MAX ; for ( int k = i + 1 ; k < j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i ][ k ] + A [ i ] * A [ k ] * A [ j ] + dp [ k ][ j ]); } return dp [ 0 ][ A . size () - 1 ]; } };","title":"1039. Minimum Score Triangulation of Polygon"},{"location":"problems/1039/#1039-minimum-score-triangulation-of-polygon","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minScoreTriangulation ( vector < int >& A ) { vector < vector < int >> dp ( A . size (), vector < int > ( A . size (), 0 )); for ( int j = 2 ; j < A . size (); ++ j ) for ( int i = j - 2 ; i >= 0 ; -- i ) { dp [ i ][ j ] = INT_MAX ; for ( int k = i + 1 ; k < j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], dp [ i ][ k ] + A [ i ] * A [ k ] * A [ j ] + dp [ k ][ j ]); } return dp [ 0 ][ A . size () - 1 ]; } };","title":"1039. Minimum Score Triangulation of Polygon"},{"location":"problems/1040/","text":"1040. Moving Stones Until Consecutive II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > numMovesStonesII ( vector < int >& stones ) { const int n = stones . size (); int minMoves = n ; sort ( begin ( stones ), end ( stones )); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = min ( minMoves , 2 ); else minMoves = min ( minMoves , n - alreadyStored ); } return { minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] numMovesStonesII ( int [] stones ) { final int n = stones . length ; int minMoves = n ; Arrays . sort ( stones ); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = Math . min ( minMoves , 2 ); else minMoves = Math . min ( minMoves , n - alreadyStored ); } return new int [] { minMoves , Math . max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def numMovesStonesII ( self , stones : List [ int ]) -> List [ int ]: n = len ( stones ) minMoves = n stones . sort () l = 0 for r , stone in enumerate ( stones ): while stone - stones [ l ] + 1 > n : l += 1 alreadyStored = r - l + 1 if alreadyStored == n - 1 and stone - stones [ l ] + 1 == n - 1 : minMoves = 2 else : minMoves = min ( minMoves , n - alreadyStored ) return [ minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )]","title":"1040. Moving Stones Until Consecutive II"},{"location":"problems/1040/#1040-moving-stones-until-consecutive-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > numMovesStonesII ( vector < int >& stones ) { const int n = stones . size (); int minMoves = n ; sort ( begin ( stones ), end ( stones )); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = min ( minMoves , 2 ); else minMoves = min ( minMoves , n - alreadyStored ); } return { minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] numMovesStonesII ( int [] stones ) { final int n = stones . length ; int minMoves = n ; Arrays . sort ( stones ); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = Math . min ( minMoves , 2 ); else minMoves = Math . min ( minMoves , n - alreadyStored ); } return new int [] { minMoves , Math . max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def numMovesStonesII ( self , stones : List [ int ]) -> List [ int ]: n = len ( stones ) minMoves = n stones . sort () l = 0 for r , stone in enumerate ( stones ): while stone - stones [ l ] + 1 > n : l += 1 alreadyStored = r - l + 1 if alreadyStored == n - 1 and stone - stones [ l ] + 1 == n - 1 : minMoves = 2 else : minMoves = min ( minMoves , n - alreadyStored ) return [ minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )]","title":"1040. Moving Stones Until Consecutive II"},{"location":"problems/1041/","text":"1041. Robot Bounded In Circle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isRobotBounded ( string instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; vector < vector < int >> directions {{ 0 , 1 }, { 1 , 0 }, { 0 , -1 }, { -1 , 0 }}; for ( char instruction : instructions ) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ]; y += directions [ d ][ 1 ]; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isRobotBounded ( String instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; int [][] directions = new int [][] { { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 } }; for ( char instruction : instructions . toCharArray ()) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ] ; y += directions [ d ][ 1 ] ; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def isRobotBounded ( self , instructions : str ) -> bool : x = 0 y = 0 d = 0 directions = [( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 ), ( - 1 , 0 )] for instruction in instructions : if instruction == 'G' : x += directions [ d ][ 0 ] y += directions [ d ][ 1 ] elif instruction == 'L' : d = ( d + 3 ) % 4 else : d = ( d + 1 ) % 4 return ( x , y ) == ( 0 , 0 ) or d > 0","title":"1041. Robot Bounded In Circle"},{"location":"problems/1041/#1041-robot-bounded-in-circle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isRobotBounded ( string instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; vector < vector < int >> directions {{ 0 , 1 }, { 1 , 0 }, { 0 , -1 }, { -1 , 0 }}; for ( char instruction : instructions ) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ]; y += directions [ d ][ 1 ]; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isRobotBounded ( String instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; int [][] directions = new int [][] { { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 } }; for ( char instruction : instructions . toCharArray ()) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ] ; y += directions [ d ][ 1 ] ; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def isRobotBounded ( self , instructions : str ) -> bool : x = 0 y = 0 d = 0 directions = [( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 ), ( - 1 , 0 )] for instruction in instructions : if instruction == 'G' : x += directions [ d ][ 0 ] y += directions [ d ][ 1 ] elif instruction == 'L' : d = ( d + 3 ) % 4 else : d = ( d + 1 ) % 4 return ( x , y ) == ( 0 , 0 ) or d > 0","title":"1041. Robot Bounded In Circle"},{"location":"problems/1042/","text":"1042. Flower Planting With No Adjacent","title":"1042. Flower Planting With No Adjacent"},{"location":"problems/1042/#1042-flower-planting-with-no-adjacent","text":"","title":"1042. Flower Planting With No Adjacent"},{"location":"problems/1043/","text":"1043. Partition Array for Maximum Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum"},{"location":"problems/1043/#1043-partition-array-for-maximum-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum"},{"location":"problems/1044/","text":"1044. Longest Duplicate Substring","title":"1044. Longest Duplicate Substring"},{"location":"problems/1044/#1044-longest-duplicate-substring","text":"","title":"1044. Longest Duplicate Substring"},{"location":"problems/1045/","text":"1045. Customers Who Bought All Products \ud83d\udd12","title":"1045. Customers Who Bought All Products"},{"location":"problems/1045/#1045-customers-who-bought-all-products","text":"","title":"1045. Customers Who Bought All Products \ud83d\udd12"},{"location":"problems/1046/","text":"1046. Last Stone Weight","title":"1046. Last Stone Weight"},{"location":"problems/1046/#1046-last-stone-weight","text":"","title":"1046. Last Stone Weight"},{"location":"problems/1047/","text":"1047. Remove All Adjacent Duplicates In String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string removeDuplicates ( const string & S ) { string ans ; for ( const char c : S ) if ( ! ans . empty () && ans . back () == c ) ans . pop_back (); else ans . push_back ( c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String removeDuplicates ( final String S ) { StringBuilder sb = new StringBuilder (); for ( final char c : S . toCharArray ()) { final int n = sb . length (); if ( n > 0 && sb . charAt ( n - 1 ) == c ) sb . deleteCharAt ( n - 1 ); else sb . append ( c ); } return sb . toString (); } }","title":"1047. Remove All Adjacent Duplicates In String"},{"location":"problems/1047/#1047-remove-all-adjacent-duplicates-in-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string removeDuplicates ( const string & S ) { string ans ; for ( const char c : S ) if ( ! ans . empty () && ans . back () == c ) ans . pop_back (); else ans . push_back ( c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public String removeDuplicates ( final String S ) { StringBuilder sb = new StringBuilder (); for ( final char c : S . toCharArray ()) { final int n = sb . length (); if ( n > 0 && sb . charAt ( n - 1 ) == c ) sb . deleteCharAt ( n - 1 ); else sb . append ( c ); } return sb . toString (); } }","title":"1047. Remove All Adjacent Duplicates In String"},{"location":"problems/1048/","text":"1048. Longest String Chain Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestStrChain ( vector < string >& words ) { int ans = 0 ; unordered_map < string , int > dp ; sort ( begin ( words ), end ( words ), []( const auto & a , const auto & b ) { return a . length () < b . length (); }); for ( const string & word : words ) { for ( int i = 0 ; i < word . length (); ++ i ) { string pred = word . substr ( 0 , i ) + word . substr ( i + 1 ); dp [ word ] = max ( dp [ word ], dp [ pred ] + 1 ); } ans = max ( ans , dp [ word ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestStrChain ( String [] words ) { int ans = 0 ; Map < String , Integer > dp = new HashMap <> (); Arrays . sort ( words , ( a , b ) -> a . length () - b . length ()); for ( final String word : words ) { int bestLength = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) { String pred = word . substring ( 0 , i ) + word . substring ( i + 1 ); bestLength = Math . max ( bestLength , dp . getOrDefault ( pred , 0 ) + 1 ); } dp . put ( word , bestLength ); ans = Math . max ( ans , bestLength ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def longestStrChain ( self , words : List [ str ]) -> int : dp = {} for word in sorted ( words , key = len ): dp [ word ] = max ( dp . get ( word [: i ] + word [ i + 1 :], 0 ) + 1 for i in range ( len ( word ))) return max ( dp . values ())","title":"1048. Longest String Chain"},{"location":"problems/1048/#1048-longest-string-chain","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestStrChain ( vector < string >& words ) { int ans = 0 ; unordered_map < string , int > dp ; sort ( begin ( words ), end ( words ), []( const auto & a , const auto & b ) { return a . length () < b . length (); }); for ( const string & word : words ) { for ( int i = 0 ; i < word . length (); ++ i ) { string pred = word . substr ( 0 , i ) + word . substr ( i + 1 ); dp [ word ] = max ( dp [ word ], dp [ pred ] + 1 ); } ans = max ( ans , dp [ word ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int longestStrChain ( String [] words ) { int ans = 0 ; Map < String , Integer > dp = new HashMap <> (); Arrays . sort ( words , ( a , b ) -> a . length () - b . length ()); for ( final String word : words ) { int bestLength = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) { String pred = word . substring ( 0 , i ) + word . substring ( i + 1 ); bestLength = Math . max ( bestLength , dp . getOrDefault ( pred , 0 ) + 1 ); } dp . put ( word , bestLength ); ans = Math . max ( ans , bestLength ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def longestStrChain ( self , words : List [ str ]) -> int : dp = {} for word in sorted ( words , key = len ): dp [ word ] = max ( dp . get ( word [: i ] + word [ i + 1 :], 0 ) + 1 for i in range ( len ( word ))) return max ( dp . values ())","title":"1048. Longest String Chain"},{"location":"problems/1049/","text":"1049. Last Stone Weight II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lastStoneWeightII ( vector < int >& stones ) { const int sum = accumulate ( begin ( stones ), end ( stones ), 0 ); vector < bool > dp ( sum + 1 ); dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ]; if ( dp [ w ]) s = max ( s , w ); } return sum - 2 * s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int lastStoneWeightII ( int [] stones ) { final int sum = Arrays . stream ( stones ). sum (); boolean [] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ] ; if ( dp [ w ] ) s = Math . max ( s , w ); } return sum - 2 * s ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lastStoneWeightII ( self , stones : List [ int ]) -> int : summ = sum ( stones ) s = 0 dp = [ True ] + [ False ] * summ for stone in stones : for w in range ( summ // 2 + 1 )[:: - 1 ]: if w >= stone : dp [ w ] = dp [ w ] or dp [ w - stone ] if dp [ w ]: s = max ( s , w ) return summ - 2 * s","title":"1049. Last Stone Weight II"},{"location":"problems/1049/#1049-last-stone-weight-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lastStoneWeightII ( vector < int >& stones ) { const int sum = accumulate ( begin ( stones ), end ( stones ), 0 ); vector < bool > dp ( sum + 1 ); dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ]; if ( dp [ w ]) s = max ( s , w ); } return sum - 2 * s ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int lastStoneWeightII ( int [] stones ) { final int sum = Arrays . stream ( stones ). sum (); boolean [] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ] ; if ( dp [ w ] ) s = Math . max ( s , w ); } return sum - 2 * s ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lastStoneWeightII ( self , stones : List [ int ]) -> int : summ = sum ( stones ) s = 0 dp = [ True ] + [ False ] * summ for stone in stones : for w in range ( summ // 2 + 1 )[:: - 1 ]: if w >= stone : dp [ w ] = dp [ w ] or dp [ w - stone ] if dp [ w ]: s = max ( s , w ) return summ - 2 * s","title":"1049. Last Stone Weight II"},{"location":"problems/1050/","text":"1050. Actors and Directors Who Cooperated At Least Three Times \ud83d\udd12","title":"1050. Actors and Directors Who Cooperated At Least Three Times"},{"location":"problems/1050/#1050-actors-and-directors-who-cooperated-at-least-three-times","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times \ud83d\udd12"},{"location":"problems/1051/","text":"1051. Height Checker Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int heightChecker ( vector < int >& heights ) { int ans = 0 ; int currentHeight = 1 ; vector < int > count ( 101 ); for ( int height : heights ) ++ count [ height ]; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int heightChecker ( int [] heights ) { int ans = 0 ; int currentHeight = 1 ; int [] count = new int [ 101 ] ; for ( int height : heights ) ++ count [ height ] ; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def heightChecker ( self , heights : List [ int ]) -> int : ans = 0 currentHeight = 1 count = [ 0 ] * 101 for height in heights : count [ height ] += 1 for height in heights : while count [ currentHeight ] == 0 : currentHeight += 1 if height != currentHeight : ans += 1 count [ currentHeight ] -= 1 return ans","title":"1051. Height Checker"},{"location":"problems/1051/#1051-height-checker","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int heightChecker ( vector < int >& heights ) { int ans = 0 ; int currentHeight = 1 ; vector < int > count ( 101 ); for ( int height : heights ) ++ count [ height ]; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int heightChecker ( int [] heights ) { int ans = 0 ; int currentHeight = 1 ; int [] count = new int [ 101 ] ; for ( int height : heights ) ++ count [ height ] ; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def heightChecker ( self , heights : List [ int ]) -> int : ans = 0 currentHeight = 1 count = [ 0 ] * 101 for height in heights : count [ height ] += 1 for height in heights : while count [ currentHeight ] == 0 : currentHeight += 1 if height != currentHeight : ans += 1 count [ currentHeight ] -= 1 return ans","title":"1051. Height Checker"},{"location":"problems/1052/","text":"1052. Grumpy Bookstore Owner Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . size (); ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ]; else windowSatisfied += customers [ i ]; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ]; madeSatisfied = max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSatisfied ( int [] customers , int [] grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . length ; ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ] ; else windowSatisfied += customers [ i ] ; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ] ; madeSatisfied = Math . max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxSatisfied ( self , customers : List [ int ], grumpy : List [ int ], X : int ) -> int : satisfied = sum ( c for i , c in enumerate ( customers ) if grumpy [ i ] == 0 ) madeSatisfied = 0 windowSatisfied = 0 for i , customer in enumerate ( customers ): if grumpy [ i ] == 1 : windowSatisfied += customer if i >= X and grumpy [ i - X ] == 1 : windowSatisfied -= customers [ i - X ] madeSatisfied = max ( madeSatisfied , windowSatisfied ) return satisfied + madeSatisfied","title":"1052. Grumpy Bookstore Owner"},{"location":"problems/1052/#1052-grumpy-bookstore-owner","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . size (); ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ]; else windowSatisfied += customers [ i ]; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ]; madeSatisfied = max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSatisfied ( int [] customers , int [] grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . length ; ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ] ; else windowSatisfied += customers [ i ] ; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ] ; madeSatisfied = Math . max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxSatisfied ( self , customers : List [ int ], grumpy : List [ int ], X : int ) -> int : satisfied = sum ( c for i , c in enumerate ( customers ) if grumpy [ i ] == 0 ) madeSatisfied = 0 windowSatisfied = 0 for i , customer in enumerate ( customers ): if grumpy [ i ] == 1 : windowSatisfied += customer if i >= X and grumpy [ i - X ] == 1 : windowSatisfied -= customers [ i - X ] madeSatisfied = max ( madeSatisfied , windowSatisfied ) return satisfied + madeSatisfied","title":"1052. Grumpy Bookstore Owner"},{"location":"problems/1053/","text":"1053. Previous Permutation With One Swap Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > prevPermOpt1 ( vector < int >& A ) { const int n = A . size (); int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ]) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ]) r -- ; swap ( A [ l ], A [ r ]); return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [] prevPermOpt1 ( int [] A ) { final int n = A . length ; int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ] ) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ] ) r -- ; swap ( A , l , r ); return A ; } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def prevPermOpt1 ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = n - 2 r = n - 1 while l >= 0 and A [ l ] <= A [ l + 1 ]: l -= 1 if l < 0 : return A while A [ r ] >= A [ l ] or A [ r ] == A [ r - 1 ]: r -= 1 A [ l ], A [ r ] = A [ r ], A [ l ] return A","title":"1053. Previous Permutation With One Swap"},{"location":"problems/1053/#1053-previous-permutation-with-one-swap","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > prevPermOpt1 ( vector < int >& A ) { const int n = A . size (); int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ]) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ]) r -- ; swap ( A [ l ], A [ r ]); return A ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int [] prevPermOpt1 ( int [] A ) { final int n = A . length ; int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ] ) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ] ) r -- ; swap ( A , l , r ); return A ; } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def prevPermOpt1 ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = n - 2 r = n - 1 while l >= 0 and A [ l ] <= A [ l + 1 ]: l -= 1 if l < 0 : return A while A [ r ] >= A [ l ] or A [ r ] == A [ r - 1 ]: r -= 1 A [ l ], A [ r ] = A [ r ], A [ l ] return A","title":"1053. Previous Permutation With One Swap"},{"location":"problems/1054/","text":"1054. Distant Barcodes","title":"1054. Distant Barcodes"},{"location":"problems/1054/#1054-distant-barcodes","text":"","title":"1054. Distant Barcodes"},{"location":"problems/1055/","text":"1055. Shortest Way to Form String \ud83d\udd12","title":"1055. Shortest Way to Form String"},{"location":"problems/1055/#1055-shortest-way-to-form-string","text":"","title":"1055. Shortest Way to Form String \ud83d\udd12"},{"location":"problems/1056/","text":"1056. Confusing Number \ud83d\udd12","title":"1056. Confusing Number"},{"location":"problems/1056/#1056-confusing-number","text":"","title":"1056. Confusing Number \ud83d\udd12"},{"location":"problems/1057/","text":"1057. Campus Bikes \ud83d\udd12","title":"1057. Campus Bikes"},{"location":"problems/1057/#1057-campus-bikes","text":"","title":"1057. Campus Bikes \ud83d\udd12"},{"location":"problems/1058/","text":"1058. Minimize Rounding Error to Meet Target \ud83d\udd12","title":"1058. Minimize Rounding Error to Meet Target"},{"location":"problems/1058/#1058-minimize-rounding-error-to-meet-target","text":"","title":"1058. Minimize Rounding Error to Meet Target \ud83d\udd12"},{"location":"problems/1059/","text":"1059. All Paths from Source Lead to Destination \ud83d\udd12","title":"1059. All Paths from Source Lead to Destination"},{"location":"problems/1059/#1059-all-paths-from-source-lead-to-destination","text":"","title":"1059. All Paths from Source Lead to Destination \ud83d\udd12"},{"location":"problems/1060/","text":"1060. Missing Element in Sorted Array \ud83d\udd12 Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int missingElement ( vector < int >& nums , int k ) { int l = 0 ; int r = nums . size (); // # of missing numbers in [nums[0], nums[i]] auto countMissing = [ & ]( int i ) { return nums [ i ] - nums [ 0 ] - i ; }; // find the first index l s.t. countMissing(l) >= k while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( countMissing ( m ) < k ) l = m + 1 ; else r = m ; } return nums [ l - 1 ] + ( k - countMissing ( l - 1 )); } };","title":"1060. Missing Element in Sorted Array"},{"location":"problems/1060/#1060-missing-element-in-sorted-array","text":"Time: $O(\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int missingElement ( vector < int >& nums , int k ) { int l = 0 ; int r = nums . size (); // # of missing numbers in [nums[0], nums[i]] auto countMissing = [ & ]( int i ) { return nums [ i ] - nums [ 0 ] - i ; }; // find the first index l s.t. countMissing(l) >= k while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( countMissing ( m ) < k ) l = m + 1 ; else r = m ; } return nums [ l - 1 ] + ( k - countMissing ( l - 1 )); } };","title":"1060. Missing Element in Sorted Array \ud83d\udd12"},{"location":"problems/1061/","text":"1061. Lexicographically Smallest Equivalent String \ud83d\udd12","title":"1061. Lexicographically Smallest Equivalent String"},{"location":"problems/1061/#1061-lexicographically-smallest-equivalent-string","text":"","title":"1061. Lexicographically Smallest Equivalent String \ud83d\udd12"},{"location":"problems/1062/","text":"1062. Longest Repeating Substring \ud83d\udd12 Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int longestRepeatingSubstring ( string S ) { const int n = S . length (); int ans = 0 ; // dp[i][j] := # of repeating chars of S[0..i) and S[0..j) vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = i + 1 ; j <= n ; ++ j ) if ( S [ i - 1 ] == S [ j - 1 ]) { dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; ans = max ( ans , dp [ i ][ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int longestRepeatingSubstring ( String S ) { final int n = S . length (); int ans = 0 ; // dp[i][j] := # of repeating chars of S[0..i) and S[0..j) int [][] dp = new int [ n + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = i + 1 ; j <= n ; ++ j ) if ( S . charAt ( i - 1 ) == S . charAt ( j - 1 )) { dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; ans = Math . max ( ans , dp [ i ][ j ] ); } return ans ; } }","title":"1062. Longest Repeating Substring"},{"location":"problems/1062/#1062-longest-repeating-substring","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int longestRepeatingSubstring ( string S ) { const int n = S . length (); int ans = 0 ; // dp[i][j] := # of repeating chars of S[0..i) and S[0..j) vector < vector < int >> dp ( n + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = i + 1 ; j <= n ; ++ j ) if ( S [ i - 1 ] == S [ j - 1 ]) { dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; ans = max ( ans , dp [ i ][ j ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int longestRepeatingSubstring ( String S ) { final int n = S . length (); int ans = 0 ; // dp[i][j] := # of repeating chars of S[0..i) and S[0..j) int [][] dp = new int [ n + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = i + 1 ; j <= n ; ++ j ) if ( S . charAt ( i - 1 ) == S . charAt ( j - 1 )) { dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; ans = Math . max ( ans , dp [ i ][ j ] ); } return ans ; } }","title":"1062. Longest Repeating Substring \ud83d\udd12"},{"location":"problems/1063/","text":"1063. Number of Valid Subarrays \ud83d\udd12","title":"1063. Number of Valid Subarrays"},{"location":"problems/1063/#1063-number-of-valid-subarrays","text":"","title":"1063. Number of Valid Subarrays \ud83d\udd12"},{"location":"problems/1064/","text":"1064. Fixed Point \ud83d\udd12","title":"1064. Fixed Point"},{"location":"problems/1064/#1064-fixed-point","text":"","title":"1064. Fixed Point \ud83d\udd12"},{"location":"problems/1065/","text":"1065. Index Pairs of a String \ud83d\udd12","title":"1065. Index Pairs of a String"},{"location":"problems/1065/#1065-index-pairs-of-a-string","text":"","title":"1065. Index Pairs of a String \ud83d\udd12"},{"location":"problems/1066/","text":"1066. Campus Bikes II \ud83d\udd12","title":"1066. Campus Bikes II"},{"location":"problems/1066/#1066-campus-bikes-ii","text":"","title":"1066. Campus Bikes II \ud83d\udd12"},{"location":"problems/1067/","text":"1067. Digit Count in Range \ud83d\udd12","title":"1067. Digit Count in Range"},{"location":"problems/1067/#1067-digit-count-in-range","text":"","title":"1067. Digit Count in Range \ud83d\udd12"},{"location":"problems/1068/","text":"1068. Product Sales Analysis I \ud83d\udd12","title":"1068. Product Sales Analysis I"},{"location":"problems/1068/#1068-product-sales-analysis-i","text":"","title":"1068. Product Sales Analysis I \ud83d\udd12"},{"location":"problems/1069/","text":"1069. Product Sales Analysis II \ud83d\udd12","title":"1069. Product Sales Analysis II"},{"location":"problems/1069/#1069-product-sales-analysis-ii","text":"","title":"1069. Product Sales Analysis II \ud83d\udd12"},{"location":"problems/1070/","text":"1070. Product Sales Analysis III \ud83d\udd12","title":"1070. Product Sales Analysis III"},{"location":"problems/1070/#1070-product-sales-analysis-iii","text":"","title":"1070. Product Sales Analysis III \ud83d\udd12"},{"location":"problems/1071/","text":"1071. Greatest Common Divisor of Strings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( str1 . find ( str2 ) == string :: npos ) return \"\" ; if ( str2 . empty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private : string mod ( string & s1 , const string & s2 ) { while ( s1 . find ( s2 ) == 0 ) s1 = s1 . substr ( s2 . length ()); return s1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String gcdOfStrings ( String str1 , String str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( ! str1 . startsWith ( str2 )) return \"\" ; if ( str2 . isEmpty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private String mod ( String s1 , final String s2 ) { while ( s1 . startsWith ( s2 )) s1 = s1 . substring ( s2 . length ()); return s1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def gcdOfStrings ( self , str1 : str , str2 : str ) -> str : def mod ( s1 : str , s2 : str ) -> str : while s1 . startswith ( s2 ): s1 = s1 [ len ( s2 ):] return s1 if len ( str1 ) < len ( str2 ): return self . gcdOfStrings ( str2 , str1 ) if not str1 . startswith ( str2 ): return '' if not str2 : return str1 return self . gcdOfStrings ( str2 , mod ( str1 , str2 ))","title":"1071. Greatest Common Divisor of Strings"},{"location":"problems/1071/#1071-greatest-common-divisor-of-strings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( str1 . find ( str2 ) == string :: npos ) return \"\" ; if ( str2 . empty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private : string mod ( string & s1 , const string & s2 ) { while ( s1 . find ( s2 ) == 0 ) s1 = s1 . substr ( s2 . length ()); return s1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public String gcdOfStrings ( String str1 , String str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( ! str1 . startsWith ( str2 )) return \"\" ; if ( str2 . isEmpty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private String mod ( String s1 , final String s2 ) { while ( s1 . startsWith ( s2 )) s1 = s1 . substring ( s2 . length ()); return s1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def gcdOfStrings ( self , str1 : str , str2 : str ) -> str : def mod ( s1 : str , s2 : str ) -> str : while s1 . startswith ( s2 ): s1 = s1 [ len ( s2 ):] return s1 if len ( str1 ) < len ( str2 ): return self . gcdOfStrings ( str2 , str1 ) if not str1 . startswith ( str2 ): return '' if not str2 : return str1 return self . gcdOfStrings ( str2 , mod ( str1 , str2 ))","title":"1071. Greatest Common Divisor of Strings"},{"location":"problems/1072/","text":"1072. Flip Columns For Maximum Number of Equal Rows Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxEqualRowsAfterFlips ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < int > flip ( n ); unordered_set < int > seen ; for ( int i = 0 ; i < m ; ++ i ) { if ( seen . count ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ]; for ( int k = 0 ; k < m ; ++ k ) if ( matrix [ k ] == matrix [ i ] || matrix [ k ] == flip ) { seen . insert ( k ); ++ count ; } ans = max ( ans , count ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maxEqualRowsAfterFlips ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [] flip = new int [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < m ; ++ i ) { if ( seen . contains ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ] ; for ( int k = 0 ; k < m ; ++ k ) if ( Arrays . equals ( matrix [ k ] , matrix [ i ] ) || Arrays . equals ( matrix [ k ] , flip )) { seen . add ( k ); ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } Python 1 2 3 4 class Solution : def maxEqualRowsAfterFlips ( self , matrix : List [ List [ int ]]) -> int : patterns = [ tuple ( a ^ row [ 0 ] for a in row ) for row in matrix ] return max ( collections . Counter ( patterns ) . values ())","title":"1072. Flip Columns For Maximum Number of Equal Rows"},{"location":"problems/1072/#1072-flip-columns-for-maximum-number-of-equal-rows","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maxEqualRowsAfterFlips ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < int > flip ( n ); unordered_set < int > seen ; for ( int i = 0 ; i < m ; ++ i ) { if ( seen . count ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ]; for ( int k = 0 ; k < m ; ++ k ) if ( matrix [ k ] == matrix [ i ] || matrix [ k ] == flip ) { seen . insert ( k ); ++ count ; } ans = max ( ans , count ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maxEqualRowsAfterFlips ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [] flip = new int [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < m ; ++ i ) { if ( seen . contains ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ] ; for ( int k = 0 ; k < m ; ++ k ) if ( Arrays . equals ( matrix [ k ] , matrix [ i ] ) || Arrays . equals ( matrix [ k ] , flip )) { seen . add ( k ); ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } Python 1 2 3 4 class Solution : def maxEqualRowsAfterFlips ( self , matrix : List [ List [ int ]]) -> int : patterns = [ tuple ( a ^ row [ 0 ] for a in row ) for row in matrix ] return max ( collections . Counter ( patterns ) . values ())","title":"1072. Flip Columns For Maximum Number of Equal Rows"},{"location":"problems/1073/","text":"1073. Adding Two Negabinary Numbers Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > addNegabinary ( vector < int >& arr1 , vector < int >& arr2 ) { deque < int > ans ; int carry = 0 ; int i = arr1 . size () - 1 ; int j = arr2 . size () - 1 ; while ( carry || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i -- ]; if ( j >= 0 ) carry += arr2 [ j -- ]; ans . push_front ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . front () == 0 ) ans . pop_front (); return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] addNegabinary ( int [] arr1 , int [] arr2 ) { Deque < Integer > ans = new ArrayDeque <> (); int carry = 0 ; int i = arr1 . length - 1 ; int j = arr2 . length - 1 ; while ( carry != 0 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i --] ; if ( j >= 0 ) carry += arr2 [ j --] ; ans . addFirst ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . getFirst () == 0 ) ans . pollFirst (); return ans . stream (). mapToInt ( Integer :: intValue ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addNegabinary ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] carry = 0 while carry or arr1 or arr2 : if arr1 : carry += arr1 . pop () if arr2 : carry += arr2 . pop () ans . append ( carry & 1 ) carry = - ( carry >> 1 ) while len ( ans ) > 1 and ans [ - 1 ] == 0 : ans . pop () return ans [:: - 1 ]","title":"1073. Adding Two Negabinary Numbers"},{"location":"problems/1073/#1073-adding-two-negabinary-numbers","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > addNegabinary ( vector < int >& arr1 , vector < int >& arr2 ) { deque < int > ans ; int carry = 0 ; int i = arr1 . size () - 1 ; int j = arr2 . size () - 1 ; while ( carry || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i -- ]; if ( j >= 0 ) carry += arr2 [ j -- ]; ans . push_front ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . front () == 0 ) ans . pop_front (); return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [] addNegabinary ( int [] arr1 , int [] arr2 ) { Deque < Integer > ans = new ArrayDeque <> (); int carry = 0 ; int i = arr1 . length - 1 ; int j = arr2 . length - 1 ; while ( carry != 0 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i --] ; if ( j >= 0 ) carry += arr2 [ j --] ; ans . addFirst ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . getFirst () == 0 ) ans . pollFirst (); return ans . stream (). mapToInt ( Integer :: intValue ). toArray (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addNegabinary ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] carry = 0 while carry or arr1 or arr2 : if arr1 : carry += arr1 . pop () if arr2 : carry += arr2 . pop () ans . append ( carry & 1 ) carry = - ( carry >> 1 ) while len ( ans ) > 1 and ans [ - 1 ] == 0 : ans . pop () return ans [:: - 1 ]","title":"1073. Adding Two Negabinary Numbers"},{"location":"problems/1074/","text":"1074. Number of Submatrices That Sum to Target Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numSubmatrixSumTarget ( vector < vector < int >>& matrix , int target ) { int ans = 0 ; for ( vector < int >& row : matrix ) for ( int i = 1 ; i < row . size (); ++ i ) row [ i ] += row [ i - 1 ]; for ( int baseCol = 0 ; baseCol < matrix [ 0 ]. size (); ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ]. size (); ++ j ) { unordered_map < int , int > prefixSumCount {{ 0 , 1 }}; int sum = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ]; sum += matrix [ i ][ j ]; if ( prefixSumCount . count ( sum - target )) ans += prefixSumCount [ sum - target ]; ++ prefixSumCount [ sum ]; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numSubmatrixSumTarget ( int [][] matrix , int target ) { int ans = 0 ; for ( int [] row : matrix ) for ( int i = 1 ; i < row . length ; ++ i ) row [ i ] += row [ i - 1 ] ; for ( int baseCol = 0 ; baseCol < matrix [ 0 ] . length ; ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ] . length ; ++ j ) { Map < Integer , Integer > prefixSumCount = new HashMap <> (); prefixSumCount . put ( 0 , 1 ); int sum = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ] ; sum += matrix [ i ][ j ] ; ans += prefixSumCount . getOrDefault ( sum - target , 0 ); prefixSumCount . put ( sum , prefixSumCount . getOrDefault ( sum , 0 ) + 1 ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numSubmatrixSumTarget ( self , matrix : List [ List [ int ]], target : int ) -> int : m = len ( matrix ) n = len ( matrix [ 0 ]) ans = 0 for row in matrix : for j in range ( 1 , n ): row [ j ] += row [ j - 1 ] for col in range ( n ): for j in range ( col , n ): count = { 0 : 1 } sum = 0 for i in range ( m ): sum += matrix [ i ][ j ] - \\ ( matrix [ i ][ col - 1 ] if col > 0 else 0 ) ans += count . get ( sum - target , 0 ) count [ sum ] = count . get ( sum , 0 ) + 1 return ans","title":"1074. Number of Submatrices That Sum to Target"},{"location":"problems/1074/#1074-number-of-submatrices-that-sum-to-target","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numSubmatrixSumTarget ( vector < vector < int >>& matrix , int target ) { int ans = 0 ; for ( vector < int >& row : matrix ) for ( int i = 1 ; i < row . size (); ++ i ) row [ i ] += row [ i - 1 ]; for ( int baseCol = 0 ; baseCol < matrix [ 0 ]. size (); ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ]. size (); ++ j ) { unordered_map < int , int > prefixSumCount {{ 0 , 1 }}; int sum = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ]; sum += matrix [ i ][ j ]; if ( prefixSumCount . count ( sum - target )) ans += prefixSumCount [ sum - target ]; ++ prefixSumCount [ sum ]; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numSubmatrixSumTarget ( int [][] matrix , int target ) { int ans = 0 ; for ( int [] row : matrix ) for ( int i = 1 ; i < row . length ; ++ i ) row [ i ] += row [ i - 1 ] ; for ( int baseCol = 0 ; baseCol < matrix [ 0 ] . length ; ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ] . length ; ++ j ) { Map < Integer , Integer > prefixSumCount = new HashMap <> (); prefixSumCount . put ( 0 , 1 ); int sum = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ] ; sum += matrix [ i ][ j ] ; ans += prefixSumCount . getOrDefault ( sum - target , 0 ); prefixSumCount . put ( sum , prefixSumCount . getOrDefault ( sum , 0 ) + 1 ); } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numSubmatrixSumTarget ( self , matrix : List [ List [ int ]], target : int ) -> int : m = len ( matrix ) n = len ( matrix [ 0 ]) ans = 0 for row in matrix : for j in range ( 1 , n ): row [ j ] += row [ j - 1 ] for col in range ( n ): for j in range ( col , n ): count = { 0 : 1 } sum = 0 for i in range ( m ): sum += matrix [ i ][ j ] - \\ ( matrix [ i ][ col - 1 ] if col > 0 else 0 ) ans += count . get ( sum - target , 0 ) count [ sum ] = count . get ( sum , 0 ) + 1 return ans","title":"1074. Number of Submatrices That Sum to Target"},{"location":"problems/1075/","text":"1075. Project Employees I \ud83d\udd12","title":"1075. Project Employees I"},{"location":"problems/1075/#1075-project-employees-i","text":"","title":"1075. Project Employees I \ud83d\udd12"},{"location":"problems/1076/","text":"1076. Project Employees II \ud83d\udd12","title":"1076. Project Employees II"},{"location":"problems/1076/#1076-project-employees-ii","text":"","title":"1076. Project Employees II \ud83d\udd12"},{"location":"problems/1077/","text":"1077. Project Employees III \ud83d\udd12","title":"1077. Project Employees III"},{"location":"problems/1077/#1077-project-employees-iii","text":"","title":"1077. Project Employees III \ud83d\udd12"},{"location":"problems/1078/","text":"1078. Occurrences After Bigram Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < string > findOcurrences ( string text , string first , string second ) { vector < string > ans ; stringstream ss ( text ); for ( string prev2 , prev , word ; ss >> word ;) { if ( prev2 == first && prev == second ) ans . push_back ( word ); prev2 = prev ; prev = word ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public String [] findOcurrences ( String text , String first , String second ) { List < String > ans = new ArrayList <> (); String [] words = text . split ( \" \" ); for ( int i = 0 ; i + 2 < words . length ; ++ i ) if ( first . equals ( words [ i ] ) && second . equals ( words [ i + 1 ] )) ans . add ( words [ i + 2 ] ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 class Solution : def findOcurrences ( self , text : str , first : str , second : str ) -> List [ str ]: words = text . split () return [ c for a , b , c in zip ( words , words [ 1 :], words [ 2 :]) if a == first and b == second ]","title":"1078. Occurrences After Bigram"},{"location":"problems/1078/#1078-occurrences-after-bigram","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < string > findOcurrences ( string text , string first , string second ) { vector < string > ans ; stringstream ss ( text ); for ( string prev2 , prev , word ; ss >> word ;) { if ( prev2 == first && prev == second ) ans . push_back ( word ); prev2 = prev ; prev = word ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public String [] findOcurrences ( String text , String first , String second ) { List < String > ans = new ArrayList <> (); String [] words = text . split ( \" \" ); for ( int i = 0 ; i + 2 < words . length ; ++ i ) if ( first . equals ( words [ i ] ) && second . equals ( words [ i + 1 ] )) ans . add ( words [ i + 2 ] ); return ans . toArray ( new String [ 0 ] ); } } Python 1 2 3 4 class Solution : def findOcurrences ( self , text : str , first : str , second : str ) -> List [ str ]: words = text . split () return [ c for a , b , c in zip ( words , words [ 1 :], words [ 2 :]) if a == first and b == second ]","title":"1078. Occurrences After Bigram"},{"location":"problems/1079/","text":"1079. Letter Tile Possibilities","title":"1079. Letter Tile Possibilities"},{"location":"problems/1079/#1079-letter-tile-possibilities","text":"","title":"1079. Letter Tile Possibilities"},{"location":"problems/1080/","text":"1080. Insufficient Nodes in Root to Leaf Paths","title":"1080. Insufficient Nodes in Root to Leaf Paths"},{"location":"problems/1080/#1080-insufficient-nodes-in-root-to-leaf-paths","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths"},{"location":"problems/1081/","text":"1081. Smallest Subsequence of Distinct Characters Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string smallestSubsequence ( string text ) { string ans ; vector < int > count ( 128 ); vector < bool > used ( 128 ); for ( const char c : text ) ++ count [ c ]; for ( const char c : text ) { -- count [ c ]; if ( used [ c ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back ()] > 0 ) { used [ ans . back ()] = false ; ans . pop_back (); } used [ c ] = true ; ans . push_back ( c ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String smallestSubsequence ( String text ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; boolean [] used = new boolean [ 128 ] ; for ( final char c : text . toCharArray ()) ++ count [ c ] ; for ( final char c : text . toCharArray ()) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length () > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length () - 1 ); } used [ c ] = true ; sb . append ( c ); } return sb . toString (); } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestSubsequence ( self , text : str ) -> str : ans = [] count = collections . Counter ( text ) used = [ False ] * 26 for c in text : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"1081. Smallest Subsequence of Distinct Characters"},{"location":"problems/1081/#1081-smallest-subsequence-of-distinct-characters","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string smallestSubsequence ( string text ) { string ans ; vector < int > count ( 128 ); vector < bool > used ( 128 ); for ( const char c : text ) ++ count [ c ]; for ( const char c : text ) { -- count [ c ]; if ( used [ c ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back ()] > 0 ) { used [ ans . back ()] = false ; ans . pop_back (); } used [ c ] = true ; ans . push_back ( c ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public String smallestSubsequence ( String text ) { StringBuilder sb = new StringBuilder (); int [] count = new int [ 128 ] ; boolean [] used = new boolean [ 128 ] ; for ( final char c : text . toCharArray ()) ++ count [ c ] ; for ( final char c : text . toCharArray ()) { -- count [ c ] ; if ( used [ c ] ) continue ; while ( sb . length () > 0 && last ( sb ) > c && count [ last ( sb ) ] > 0 ) { used [ last ( sb ) ] = false ; sb . setLength ( sb . length () - 1 ); } used [ c ] = true ; sb . append ( c ); } return sb . toString (); } private char last ( StringBuilder sb ) { return sb . charAt ( sb . length () - 1 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestSubsequence ( self , text : str ) -> str : ans = [] count = collections . Counter ( text ) used = [ False ] * 26 for c in text : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"1081. Smallest Subsequence of Distinct Characters"},{"location":"problems/1082/","text":"1082. Sales Analysis I \ud83d\udd12","title":"1082. Sales Analysis I"},{"location":"problems/1082/#1082-sales-analysis-i","text":"","title":"1082. Sales Analysis I \ud83d\udd12"},{"location":"problems/1083/","text":"1083. Sales Analysis II \ud83d\udd12","title":"1083. Sales Analysis II"},{"location":"problems/1083/#1083-sales-analysis-ii","text":"","title":"1083. Sales Analysis II \ud83d\udd12"},{"location":"problems/1084/","text":"1084. Sales Analysis III \ud83d\udd12","title":"1084. Sales Analysis III"},{"location":"problems/1084/#1084-sales-analysis-iii","text":"","title":"1084. Sales Analysis III \ud83d\udd12"},{"location":"problems/1085/","text":"1085. Sum of Digits in the Minimum Number \ud83d\udd12","title":"1085. Sum of Digits in the Minimum Number"},{"location":"problems/1085/#1085-sum-of-digits-in-the-minimum-number","text":"","title":"1085. Sum of Digits in the Minimum Number \ud83d\udd12"},{"location":"problems/1086/","text":"1086. High Five \ud83d\udd12","title":"1086. High Five"},{"location":"problems/1086/#1086-high-five","text":"","title":"1086. High Five \ud83d\udd12"},{"location":"problems/1087/","text":"1087. Brace Expansion \ud83d\udd12","title":"1087. Brace Expansion"},{"location":"problems/1087/#1087-brace-expansion","text":"","title":"1087. Brace Expansion \ud83d\udd12"},{"location":"problems/1088/","text":"1088. Confusing Number II \ud83d\udd12","title":"1088. Confusing Number II"},{"location":"problems/1088/#1088-confusing-number-ii","text":"","title":"1088. Confusing Number II \ud83d\udd12"},{"location":"problems/1089/","text":"1089. Duplicate Zeros Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void duplicateZeros ( vector < int >& arr ) { int zeros = count_if ( begin ( arr ), end ( arr ), []( int a ) { return a == 0 ; }); for ( int i = arr . size () - 1 , j = arr . size () + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . size ()) arr [ j ] = arr [ i ]; if ( arr [ i ] == 0 ) if ( -- j < arr . size ()) arr [ j ] = arr [ i ]; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public void duplicateZeros ( int [] arr ) { int zeros = 0 ; for ( int a : arr ) if ( a == 0 ) ++ zeros ; for ( int i = arr . length - 1 , j = arr . length + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . length ) arr [ j ] = arr [ i ] ; if ( arr [ i ] == 0 ) if ( -- j < arr . length ) arr [ j ] = arr [ i ] ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def duplicateZeros ( self , arr : List [ int ]) -> None : zeros = arr . count ( 0 ) i = len ( arr ) - 1 j = len ( arr ) + zeros - 1 while i < j : if j < len ( arr ): arr [ j ] = arr [ i ] if arr [ i ] == 0 : j -= 1 if j < len ( arr ): arr [ j ] = arr [ i ] i -= 1 j -= 1","title":"1089. Duplicate Zeros"},{"location":"problems/1089/#1089-duplicate-zeros","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void duplicateZeros ( vector < int >& arr ) { int zeros = count_if ( begin ( arr ), end ( arr ), []( int a ) { return a == 0 ; }); for ( int i = arr . size () - 1 , j = arr . size () + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . size ()) arr [ j ] = arr [ i ]; if ( arr [ i ] == 0 ) if ( -- j < arr . size ()) arr [ j ] = arr [ i ]; } } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public void duplicateZeros ( int [] arr ) { int zeros = 0 ; for ( int a : arr ) if ( a == 0 ) ++ zeros ; for ( int i = arr . length - 1 , j = arr . length + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . length ) arr [ j ] = arr [ i ] ; if ( arr [ i ] == 0 ) if ( -- j < arr . length ) arr [ j ] = arr [ i ] ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def duplicateZeros ( self , arr : List [ int ]) -> None : zeros = arr . count ( 0 ) i = len ( arr ) - 1 j = len ( arr ) + zeros - 1 while i < j : if j < len ( arr ): arr [ j ] = arr [ i ] if arr [ i ] == 0 : j -= 1 if j < len ( arr ): arr [ j ] = arr [ i ] i -= 1 j -= 1","title":"1089. Duplicate Zeros"},{"location":"problems/1090/","text":"1090. Largest Values From Labels Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestValsFromLabels ( vector < int >& values , vector < int >& labels , int num_wanted , int use_limit ) { const int n = values . size (); int ans = 0 ; vector < pair < int , int >> items ( n ); unordered_map < int , int > labelsUsed ; for ( int i = 0 ; i < n ; ++ i ) items [ i ] = make_pair ( values [ i ], labels [ i ]); sort ( begin ( items ), end ( items ), []( const auto & a , const auto & b ) { return a . first > b . first ; }); for ( auto && [ value , label ] : items ) { if ( labelsUsed [ label ] < use_limit ) { ans += value ; ++ labelsUsed [ label ]; if ( -- num_wanted == 0 ) break ; } } return ans ; } };","title":"1090. Largest Values From Labels"},{"location":"problems/1090/#1090-largest-values-from-labels","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestValsFromLabels ( vector < int >& values , vector < int >& labels , int num_wanted , int use_limit ) { const int n = values . size (); int ans = 0 ; vector < pair < int , int >> items ( n ); unordered_map < int , int > labelsUsed ; for ( int i = 0 ; i < n ; ++ i ) items [ i ] = make_pair ( values [ i ], labels [ i ]); sort ( begin ( items ), end ( items ), []( const auto & a , const auto & b ) { return a . first > b . first ; }); for ( auto && [ value , label ] : items ) { if ( labelsUsed [ label ] < use_limit ) { ans += value ; ++ labelsUsed [ label ]; if ( -- num_wanted == 0 ) break ; } } return ans ; } };","title":"1090. Largest Values From Labels"},{"location":"problems/1091/","text":"1091. Shortest Path in Binary Matrix","title":"1091. Shortest Path in Binary Matrix"},{"location":"problems/1091/#1091-shortest-path-in-binary-matrix","text":"","title":"1091. Shortest Path in Binary Matrix"},{"location":"problems/1092/","text":"1092. Shortest Common Supersequence Time: $O(mn)$ Space: $O(mn^2 \\cdot |string|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string shortestCommonSupersequence ( string str1 , string str2 ) { string ans ; int i = 0 ; // str1's pointer int j = 0 ; // str2's pointer for ( const char c : lcs ( str1 , str2 )) { // append chars that are not part of the LCS while ( str1 [ i ] != c ) ans += str1 [ i ++ ]; while ( str2 [ j ] != c ) ans += str2 [ j ++ ]; // append the char of the LCS and match str1 and str2 ans += c ; ++ i ; ++ j ; } // append remaining chars return ans + str1 . substr ( i ) + str2 . substr ( j ); } private : string lcs ( const string & A , const string & B ) { const int m = A . length (); const int n = B . length (); // dp[i][j] := LCS of A[0..i) and B[0..j) vector < vector < string >> dp ( m + 1 , vector < string > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A [ i - 1 ] == B [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + A [ i - 1 ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]. length () > dp [ i ][ j - 1 ]. length () ? dp [ i - 1 ][ j ] : dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public String shortestCommonSupersequence ( String str1 , String str2 ) { StringBuilder sb = new StringBuilder (); int i = 0 ; // str1's pointer int j = 0 ; // str2's pointer for ( final char c : lcs ( str1 , str2 ). toCharArray ()) { // append chars that are not part of the LCS while ( str1 . charAt ( i ) != c ) sb . append ( str1 . charAt ( i ++ )); while ( str2 . charAt ( j ) != c ) sb . append ( str2 . charAt ( j ++ )); // append the char of the LCS and match str1 and str2 sb . append ( c ); ++ i ; ++ j ; } // append remaining chars return sb . toString () + str1 . substring ( i ) + str2 . substring ( j ); } private String lcs ( final String A , final String B ) { final int m = A . length (); final int n = B . length (); // dp[i][j] := LCS of A[0..i) and B[0..j) StringBuilder [][] dp = new StringBuilder [ m + 1 ][ n + 1 ] ; for ( final StringBuilder [] row : dp ) for ( int i = 0 ; i < row . length ; ++ i ) row [ i ] = new StringBuilder (); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 )) dp [ i ][ j ] . append ( dp [ i - 1 ][ j - 1 ] ). append ( A . charAt ( i - 1 )); else dp [ i ][ j ] = dp [ i - 1 ][ j ] . length () > dp [ i ][ j - 1 ] . length () ? dp [ i - 1 ][ j ] : dp [ i ][ j - 1 ] ; return dp [ m ][ n ] . toString (); } }","title":"1092. Shortest Common Supersequence"},{"location":"problems/1092/#1092-shortest-common-supersequence","text":"Time: $O(mn)$ Space: $O(mn^2 \\cdot |string|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public : string shortestCommonSupersequence ( string str1 , string str2 ) { string ans ; int i = 0 ; // str1's pointer int j = 0 ; // str2's pointer for ( const char c : lcs ( str1 , str2 )) { // append chars that are not part of the LCS while ( str1 [ i ] != c ) ans += str1 [ i ++ ]; while ( str2 [ j ] != c ) ans += str2 [ j ++ ]; // append the char of the LCS and match str1 and str2 ans += c ; ++ i ; ++ j ; } // append remaining chars return ans + str1 . substr ( i ) + str2 . substr ( j ); } private : string lcs ( const string & A , const string & B ) { const int m = A . length (); const int n = B . length (); // dp[i][j] := LCS of A[0..i) and B[0..j) vector < vector < string >> dp ( m + 1 , vector < string > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A [ i - 1 ] == B [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + A [ i - 1 ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]. length () > dp [ i ][ j - 1 ]. length () ? dp [ i - 1 ][ j ] : dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public String shortestCommonSupersequence ( String str1 , String str2 ) { StringBuilder sb = new StringBuilder (); int i = 0 ; // str1's pointer int j = 0 ; // str2's pointer for ( final char c : lcs ( str1 , str2 ). toCharArray ()) { // append chars that are not part of the LCS while ( str1 . charAt ( i ) != c ) sb . append ( str1 . charAt ( i ++ )); while ( str2 . charAt ( j ) != c ) sb . append ( str2 . charAt ( j ++ )); // append the char of the LCS and match str1 and str2 sb . append ( c ); ++ i ; ++ j ; } // append remaining chars return sb . toString () + str1 . substring ( i ) + str2 . substring ( j ); } private String lcs ( final String A , final String B ) { final int m = A . length (); final int n = B . length (); // dp[i][j] := LCS of A[0..i) and B[0..j) StringBuilder [][] dp = new StringBuilder [ m + 1 ][ n + 1 ] ; for ( final StringBuilder [] row : dp ) for ( int i = 0 ; i < row . length ; ++ i ) row [ i ] = new StringBuilder (); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 )) dp [ i ][ j ] . append ( dp [ i - 1 ][ j - 1 ] ). append ( A . charAt ( i - 1 )); else dp [ i ][ j ] = dp [ i - 1 ][ j ] . length () > dp [ i ][ j - 1 ] . length () ? dp [ i - 1 ][ j ] : dp [ i ][ j - 1 ] ; return dp [ m ][ n ] . toString (); } }","title":"1092. Shortest Common Supersequence"},{"location":"problems/1093/","text":"1093. Statistics from a Large Sample Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public : vector < double > sampleStats ( vector < int >& count ) { double minimum = 0 ; double maximum = 0 ; double mean = 0 ; double leftMedian = 0 ; double rightMedian = 0 ; double mode = -1 ; int numCount = accumulate ( begin ( count ), end ( count ), 0 ); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . size () - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . size (); ++ i ) mean += ( i * count [ i ]) / ( double ) numCount ; for ( int i = 0 ; i < count . size (); ++ i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . size () - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ]; mode = i ; } return { minimum , maximum , mean , ( leftMedian + rightMedian ) / 2.0 , mode }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public double [] sampleStats ( int [] count ) { int minimum = 0 ; int maximum = 0 ; double mean = 0 ; int leftMedian = 0 ; int rightMedian = 0 ; int mode = - 1 ; int numCount = Arrays . stream ( count ). sum (); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . length - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . length ; ++ i ) mean += ( double ) ( i * count [ i ] ) / ( double ) numCount ; for ( int i = 0 ; i < count . length ; ++ i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . length - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; mode = i ; } return new double [] { minimum , maximum , mean , ( double ) ( leftMedian + rightMedian ) / 2.0 , mode }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution : def sampleStats ( self , count : List [ int ]) -> List [ float ]: minimum = 0 maximum = 0 mean = 0 leftMedian = 0 rightMedian = 0 mode = - 1 numCount = sum ( count ) newNumCount = 0 maxCount = 0 for i , c in enumerate ( count ): if c > 0 : minimum = i break for i in range ( len ( count ) - 1 , - 1 , - 1 ): if count [ i ] > 0 : maximum = i break for i , c in enumerate ( count ): mean += ( i * c ) / numCount for i , c in enumerate ( count ): newNumCount += c if newNumCount >= numCount // 2 : leftMedian = i break newNumCount = 0 for i in range ( len ( count ) - 1 , - 1 , - 1 ): newNumCount += count [ i ] if newNumCount >= numCount // 2 : rightMedian = i break for i , c in enumerate ( count ): if c > maxCount : maxCount = c mode = i return [ minimum , maximum , mean , ( leftMedian + rightMedian ) / 2 , mode ]","title":"1093. Statistics from a Large Sample"},{"location":"problems/1093/#1093-statistics-from-a-large-sample","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public : vector < double > sampleStats ( vector < int >& count ) { double minimum = 0 ; double maximum = 0 ; double mean = 0 ; double leftMedian = 0 ; double rightMedian = 0 ; double mode = -1 ; int numCount = accumulate ( begin ( count ), end ( count ), 0 ); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . size () - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . size (); ++ i ) mean += ( i * count [ i ]) / ( double ) numCount ; for ( int i = 0 ; i < count . size (); ++ i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . size () - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ]; mode = i ; } return { minimum , maximum , mean , ( leftMedian + rightMedian ) / 2.0 , mode }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public double [] sampleStats ( int [] count ) { int minimum = 0 ; int maximum = 0 ; double mean = 0 ; int leftMedian = 0 ; int rightMedian = 0 ; int mode = - 1 ; int numCount = Arrays . stream ( count ). sum (); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . length - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . length ; ++ i ) mean += ( double ) ( i * count [ i ] ) / ( double ) numCount ; for ( int i = 0 ; i < count . length ; ++ i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . length - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; mode = i ; } return new double [] { minimum , maximum , mean , ( double ) ( leftMedian + rightMedian ) / 2.0 , mode }; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution : def sampleStats ( self , count : List [ int ]) -> List [ float ]: minimum = 0 maximum = 0 mean = 0 leftMedian = 0 rightMedian = 0 mode = - 1 numCount = sum ( count ) newNumCount = 0 maxCount = 0 for i , c in enumerate ( count ): if c > 0 : minimum = i break for i in range ( len ( count ) - 1 , - 1 , - 1 ): if count [ i ] > 0 : maximum = i break for i , c in enumerate ( count ): mean += ( i * c ) / numCount for i , c in enumerate ( count ): newNumCount += c if newNumCount >= numCount // 2 : leftMedian = i break newNumCount = 0 for i in range ( len ( count ) - 1 , - 1 , - 1 ): newNumCount += count [ i ] if newNumCount >= numCount // 2 : rightMedian = i break for i , c in enumerate ( count ): if c > maxCount : maxCount = c mode = i return [ minimum , maximum , mean , ( leftMedian + rightMedian ) / 2 , mode ]","title":"1093. Statistics from a Large Sample"},{"location":"problems/1094/","text":"1094. Car Pooling","title":"1094. Car Pooling"},{"location":"problems/1094/#1094-car-pooling","text":"","title":"1094. Car Pooling"},{"location":"problems/1095/","text":"1095. Find in Mountain Array","title":"1095. Find in Mountain Array"},{"location":"problems/1095/#1095-find-in-mountain-array","text":"","title":"1095. Find in Mountain Array"},{"location":"problems/1096/","text":"1096. Brace Expansion II Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < string > braceExpansionII ( string expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private : vector < string > dfs ( const string & expression , int s , int e ) { set < string > ans ; vector < vector < string >> groups {{}}; int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression [ i ] == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression [ i ] == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression [ i ] == ',' && layer == 0 ) groups . push_back ({}); else if ( layer == 0 ) merge ( groups , { string ( 1 , expression [ i ])}); for ( const vector < string >& group : groups ) for ( const string & word : group ) ans . insert ( word ); return { begin ( ans ), end ( ans )}; } void merge ( vector < vector < string >>& groups , const vector < string > group ) { if ( groups . back (). empty ()) { groups [ groups . size () - 1 ] = group ; return ; } vector < string > mergedGroup ; for ( auto & word1 : groups . back ()) for ( auto & word2 : group ) mergedGroup . push_back ( word1 + word2 ); groups [ groups . size () - 1 ] = mergedGroup ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public List < String > braceExpansionII ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private List < String > dfs ( final String expression , int s , int e ) { TreeSet < String > ans = new TreeSet <> (); List < List < String >> groups = new ArrayList <> (); groups . add ( new ArrayList <> ()); int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression . charAt ( i ) == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression . charAt ( i ) == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression . charAt ( i ) == ',' && layer == 0 ) groups . add ( new ArrayList <> ()); else if ( layer == 0 ) merge ( groups , new ArrayList <> ( Arrays . asList ( String . valueOf ( expression . charAt ( i ))))); for ( final List < String > group : groups ) for ( final String word : group ) ans . add ( word ); return new ArrayList <> ( ans ); } void merge ( List < List < String >> groups , List < String > group ) { if ( groups . get ( groups . size () - 1 ). isEmpty ()) { groups . set ( groups . size () - 1 , group ); return ; } List < String > mergedGroup = new ArrayList <> (); for ( final String word1 : groups . get ( groups . size () - 1 )) for ( final String word2 : group ) mergedGroup . add ( word1 + word2 ); groups . set ( groups . size () - 1 , mergedGroup ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def braceExpansionII ( self , expression : str ) -> List [ str ]: def merge ( groups : List [ List [ str ]], group : List [ str ]) -> None : if not groups [ - 1 ]: groups [ - 1 ] = group return groups [ - 1 ] = [ word1 + word2 for word1 in groups [ - 1 ] for word2 in group ] def dfs ( s : int , e : int ) -> List [ str ]: ans = [] groups = [[]] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if c == '{' : layer += 1 if layer == 1 : left = i + 1 elif c == '}' : layer -= 1 if layer == 0 : group = dfs ( left , i - 1 ) merge ( groups , group ) elif c == ',' and layer == 0 : groups . append ([]) elif layer == 0 : merge ( groups , [ c ]) return sorted ( list ({ word for group in groups for word in group })) return dfs ( 0 , len ( expression ) - 1 )","title":"1096. Brace Expansion II"},{"location":"problems/1096/#1096-brace-expansion-ii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector < string > braceExpansionII ( string expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private : vector < string > dfs ( const string & expression , int s , int e ) { set < string > ans ; vector < vector < string >> groups {{}}; int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression [ i ] == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression [ i ] == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression [ i ] == ',' && layer == 0 ) groups . push_back ({}); else if ( layer == 0 ) merge ( groups , { string ( 1 , expression [ i ])}); for ( const vector < string >& group : groups ) for ( const string & word : group ) ans . insert ( word ); return { begin ( ans ), end ( ans )}; } void merge ( vector < vector < string >>& groups , const vector < string > group ) { if ( groups . back (). empty ()) { groups [ groups . size () - 1 ] = group ; return ; } vector < string > mergedGroup ; for ( auto & word1 : groups . back ()) for ( auto & word2 : group ) mergedGroup . push_back ( word1 + word2 ); groups [ groups . size () - 1 ] = mergedGroup ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public List < String > braceExpansionII ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private List < String > dfs ( final String expression , int s , int e ) { TreeSet < String > ans = new TreeSet <> (); List < List < String >> groups = new ArrayList <> (); groups . add ( new ArrayList <> ()); int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression . charAt ( i ) == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression . charAt ( i ) == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression . charAt ( i ) == ',' && layer == 0 ) groups . add ( new ArrayList <> ()); else if ( layer == 0 ) merge ( groups , new ArrayList <> ( Arrays . asList ( String . valueOf ( expression . charAt ( i ))))); for ( final List < String > group : groups ) for ( final String word : group ) ans . add ( word ); return new ArrayList <> ( ans ); } void merge ( List < List < String >> groups , List < String > group ) { if ( groups . get ( groups . size () - 1 ). isEmpty ()) { groups . set ( groups . size () - 1 , group ); return ; } List < String > mergedGroup = new ArrayList <> (); for ( final String word1 : groups . get ( groups . size () - 1 )) for ( final String word2 : group ) mergedGroup . add ( word1 + word2 ); groups . set ( groups . size () - 1 , mergedGroup ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def braceExpansionII ( self , expression : str ) -> List [ str ]: def merge ( groups : List [ List [ str ]], group : List [ str ]) -> None : if not groups [ - 1 ]: groups [ - 1 ] = group return groups [ - 1 ] = [ word1 + word2 for word1 in groups [ - 1 ] for word2 in group ] def dfs ( s : int , e : int ) -> List [ str ]: ans = [] groups = [[]] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if c == '{' : layer += 1 if layer == 1 : left = i + 1 elif c == '}' : layer -= 1 if layer == 0 : group = dfs ( left , i - 1 ) merge ( groups , group ) elif c == ',' and layer == 0 : groups . append ([]) elif layer == 0 : merge ( groups , [ c ]) return sorted ( list ({ word for group in groups for word in group })) return dfs ( 0 , len ( expression ) - 1 )","title":"1096. Brace Expansion II"},{"location":"problems/1097/","text":"1097. Game Play Analysis V \ud83d\udd12","title":"1097. Game Play Analysis V"},{"location":"problems/1097/#1097-game-play-analysis-v","text":"","title":"1097. Game Play Analysis V \ud83d\udd12"},{"location":"problems/1098/","text":"1098. Unpopular Books \ud83d\udd12","title":"1098. Unpopular Books"},{"location":"problems/1098/#1098-unpopular-books","text":"","title":"1098. Unpopular Books \ud83d\udd12"},{"location":"problems/1099/","text":"1099. Two Sum Less Than K \ud83d\udd12 Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int twoSumLessThanK ( vector < int >& A , int K ) { if ( A . size () < 2 ) return -1 ; int ans = -1 ; // note the constraint that A[i] > 0 int l = 0 ; int r = A . size () - 1 ; sort ( begin ( A ), end ( A )); while ( l < r ) if ( A [ l ] + A [ r ] < K ) { ans = max ( ans , A [ l ] + A [ r ]); ++ l ; } else { -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int twoSumLessThanK ( int [] A , int K ) { if ( A . length < 2 ) return - 1 ; int ans = - 1 ; // note the constraint that A[i] > 0 int l = 0 ; int r = A . length - 1 ; Arrays . sort ( A ); while ( l < r ) if ( A [ l ] + A [ r ] < K ) { ans = Math . max ( ans , A [ l ] + A [ r ] ); ++ l ; } else { -- r ; } return ans ; } }","title":"1099. Two Sum Less Than K"},{"location":"problems/1099/#1099-two-sum-less-than-k","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int twoSumLessThanK ( vector < int >& A , int K ) { if ( A . size () < 2 ) return -1 ; int ans = -1 ; // note the constraint that A[i] > 0 int l = 0 ; int r = A . size () - 1 ; sort ( begin ( A ), end ( A )); while ( l < r ) if ( A [ l ] + A [ r ] < K ) { ans = max ( ans , A [ l ] + A [ r ]); ++ l ; } else { -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int twoSumLessThanK ( int [] A , int K ) { if ( A . length < 2 ) return - 1 ; int ans = - 1 ; // note the constraint that A[i] > 0 int l = 0 ; int r = A . length - 1 ; Arrays . sort ( A ); while ( l < r ) if ( A [ l ] + A [ r ] < K ) { ans = Math . max ( ans , A [ l ] + A [ r ] ); ++ l ; } else { -- r ; } return ans ; } }","title":"1099. Two Sum Less Than K \ud83d\udd12"},{"location":"problems/1100/","text":"1100. Find K-Length Substrings With No Repeated Characters \ud83d\udd12","title":"1100. Find K-Length Substrings With No Repeated Characters"},{"location":"problems/1100/#1100-find-k-length-substrings-with-no-repeated-characters","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters \ud83d\udd12"},{"location":"problems/1101/","text":"1101. The Earliest Moment When Everyone Become Friends \ud83d\udd12","title":"1101. The Earliest Moment When Everyone Become Friends"},{"location":"problems/1101/#1101-the-earliest-moment-when-everyone-become-friends","text":"","title":"1101. The Earliest Moment When Everyone Become Friends \ud83d\udd12"},{"location":"problems/1102/","text":"1102. Path With Maximum Minimum Value \ud83d\udd12","title":"1102. Path With Maximum Minimum Value"},{"location":"problems/1102/#1102-path-with-maximum-minimum-value","text":"","title":"1102. Path With Maximum Minimum Value \ud83d\udd12"},{"location":"problems/1103/","text":"1103. Distribute Candies to People Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > distributeCandies ( int candies , long n ) { vector < int > ans ( n ); int rows = ( - n + sqrt ( n * n + 8 * n * n * candies )) / ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * n / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( n * n * rows * rows + n * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * n + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [] distributeCandies ( int candies , int num_people ) { int [] ans = new int [ num_people ] ; long c = ( long ) candies ; long n = ( long ) num_people ; int rows = ( int ) ( - n + Math . sqrt ( n * n + 8 * n * n * c )) / ( int ) ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * num_people / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( num_people * num_people * rows * rows + num_people * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * num_people + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = Math . min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def distributeCandies ( self , candies : int , n : int ) -> List [ int ]: ans = [ 0 ] * n rows = int (( - n + ( n ** 2 + 8 * n ** 2 * candies ) ** 0.5 ) / ( 2 * n ** 2 )) accumN = rows * ( rows - 1 ) * n // 2 for i in range ( n ): ans [ i ] = accumN + rows * ( i + 1 ) givenCandies = ( n ** 2 * rows ** 2 + n * rows ) // 2 candies -= givenCandies lastGiven = rows * n i = 0 while candies > 0 : lastGiven += 1 actualGiven = min ( lastGiven , candies ) candies -= actualGiven ans [ i ] += actualGiven i += 1 return ans","title":"1103. Distribute Candies to People"},{"location":"problems/1103/#1103-distribute-candies-to-people","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > distributeCandies ( int candies , long n ) { vector < int > ans ( n ); int rows = ( - n + sqrt ( n * n + 8 * n * n * candies )) / ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * n / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( n * n * rows * rows + n * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * n + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [] distributeCandies ( int candies , int num_people ) { int [] ans = new int [ num_people ] ; long c = ( long ) candies ; long n = ( long ) num_people ; int rows = ( int ) ( - n + Math . sqrt ( n * n + 8 * n * n * c )) / ( int ) ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * num_people / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( num_people * num_people * rows * rows + num_people * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * num_people + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = Math . min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def distributeCandies ( self , candies : int , n : int ) -> List [ int ]: ans = [ 0 ] * n rows = int (( - n + ( n ** 2 + 8 * n ** 2 * candies ) ** 0.5 ) / ( 2 * n ** 2 )) accumN = rows * ( rows - 1 ) * n // 2 for i in range ( n ): ans [ i ] = accumN + rows * ( i + 1 ) givenCandies = ( n ** 2 * rows ** 2 + n * rows ) // 2 candies -= givenCandies lastGiven = rows * n i = 0 while candies > 0 : lastGiven += 1 actualGiven = min ( lastGiven , candies ) candies -= actualGiven ans [ i ] += actualGiven i += 1 return ans","title":"1103. Distribute Candies to People"},{"location":"problems/1104/","text":"1104. Path In Zigzag Labelled Binary Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > pathInZigZagTree ( int label ) { deque < int > ans ; int level ; for ( int l = 0 ; l < 21 ; ++ l ) if ( pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level & 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . push_front ( l & 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return { begin ( ans ), end ( ans )}; } private : int boundarySum ( int level ) { return pow ( 2 , level ) + pow ( 2 , level + 1 ) - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < Integer > pathInZigZagTree ( int label ) { LinkedList < Integer > ans = new LinkedList <> (); int level = 0 ; for ( int l = 0 ; l < 21 ; ++ l ) if ( Math . pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level % 2 == 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . addFirst ( l % 2 == 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return new ArrayList <> ( ans ); } private int boundarySum ( int level ) { return ( int ) Math . pow ( 2 , level ) + ( int ) Math . pow ( 2 , level + 1 ) - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def pathInZigZagTree ( self , label : int ) -> List [ int ]: def boundarySum ( level : int ): return 2 ** level + 2 ** ( level + 1 ) - 1 ans = [] for l in range ( 21 ): if 2 ** l > label : level = l - 1 break if level & 1 : label = boundarySum ( level ) - label for l in range ( level + 1 )[:: - 1 ]: ans . append ( boundarySum ( l ) - label if l & 1 else label ) label //= 2 return ans [:: - 1 ]","title":"1104. Path In Zigzag Labelled Binary Tree"},{"location":"problems/1104/#1104-path-in-zigzag-labelled-binary-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < int > pathInZigZagTree ( int label ) { deque < int > ans ; int level ; for ( int l = 0 ; l < 21 ; ++ l ) if ( pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level & 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . push_front ( l & 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return { begin ( ans ), end ( ans )}; } private : int boundarySum ( int level ) { return pow ( 2 , level ) + pow ( 2 , level + 1 ) - 1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < Integer > pathInZigZagTree ( int label ) { LinkedList < Integer > ans = new LinkedList <> (); int level = 0 ; for ( int l = 0 ; l < 21 ; ++ l ) if ( Math . pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level % 2 == 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . addFirst ( l % 2 == 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return new ArrayList <> ( ans ); } private int boundarySum ( int level ) { return ( int ) Math . pow ( 2 , level ) + ( int ) Math . pow ( 2 , level + 1 ) - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def pathInZigZagTree ( self , label : int ) -> List [ int ]: def boundarySum ( level : int ): return 2 ** level + 2 ** ( level + 1 ) - 1 ans = [] for l in range ( 21 ): if 2 ** l > label : level = l - 1 break if level & 1 : label = boundarySum ( level ) - label for l in range ( level + 1 )[:: - 1 ]: ans . append ( boundarySum ( l ) - label if l & 1 else label ) label //= 2 return ans [:: - 1 ]","title":"1104. Path In Zigzag Labelled Binary Tree"},{"location":"problems/1105/","text":"1105. Filling Bookcase Shelves","title":"1105. Filling Bookcase Shelves"},{"location":"problems/1105/#1105-filling-bookcase-shelves","text":"","title":"1105. Filling Bookcase Shelves"},{"location":"problems/1106/","text":"1106. Parsing A Boolean Expression Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : bool parseBoolExpr ( string expression ) { int i = 0 ; return parse ( expression , i ); } private : bool parse ( const string & exp , int & i ) { if ( exp [ i ] == 't' ) { ++ i ; return true ; } if ( exp [ i ] == 'f' ) { ++ i ; return false ; } if ( exp [ i ] == '!' ) { i += 2 ; bool ans = ! parse ( exp , i ); ++ i ; return ans ; } bool isAnd = exp [ i ] == '&' ; bool ans = isAnd ; i += 2 ; while ( exp [ i ] != ')' ) { bool parsed = parse ( exp , i ); if ( isAnd ) ans &= parsed ; else ans |= parsed ; if ( exp [ i ] == ',' ) ++ i ; } ++ i ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public boolean parseBoolExpr ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private boolean dfs ( final String expression , int s , int e ) { if ( s == e ) return expression . charAt ( s ) == 't' ; List < Boolean > exps = new ArrayList <> (); int layer = 0 ; int left = 0 ; char op = ' ' ; for ( int i = s ; i <= e ; ++ i ) { char c = expression . charAt ( i ); if ( layer == 0 && ( c == '!' || c == '&' || c == '|' )) op = c ; else if ( c == '(' && ++ layer == 1 ) left = i + 1 ; else if ( c == ')' && -- layer == 0 ) exps . add ( dfs ( expression , left , i - 1 )); else if ( c == ',' && layer == 1 ) { exps . add ( dfs ( expression , left , i - 1 )); left = i + 1 ; } } if ( op == '&' ) { boolean ans = true ; for ( boolean exp : exps ) ans &= exp ; return ans ; } if ( op == '|' ) { boolean ans = false ; for ( boolean exp : exps ) ans |= exp ; return ans ; } return ! exps . get ( 0 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def parseBoolExpr ( self , expression : str ) -> bool : def dfs ( s : int , e : int ) -> List [ str ]: if s == e : return True if expression [ s ] == 't' else False exps = [] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if layer == 0 and c in '!&|' : op = c elif c == '(' : layer += 1 if layer == 1 : left = i + 1 elif c == ')' : layer -= 1 if layer == 0 : exps . append ( dfs ( left , i - 1 )) elif c == ',' and layer == 1 : exps . append ( dfs ( left , i - 1 )) left = i + 1 if op == '|' : return functools . reduce ( lambda x , y : x | y , exps ) if op == '&' : return functools . reduce ( lambda x , y : x & y , exps ) if op == '!' : return not exps [ 0 ] return dfs ( 0 , len ( expression ) - 1 )","title":"1106. Parsing A Boolean Expression"},{"location":"problems/1106/#1106-parsing-a-boolean-expression","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : bool parseBoolExpr ( string expression ) { int i = 0 ; return parse ( expression , i ); } private : bool parse ( const string & exp , int & i ) { if ( exp [ i ] == 't' ) { ++ i ; return true ; } if ( exp [ i ] == 'f' ) { ++ i ; return false ; } if ( exp [ i ] == '!' ) { i += 2 ; bool ans = ! parse ( exp , i ); ++ i ; return ans ; } bool isAnd = exp [ i ] == '&' ; bool ans = isAnd ; i += 2 ; while ( exp [ i ] != ')' ) { bool parsed = parse ( exp , i ); if ( isAnd ) ans &= parsed ; else ans |= parsed ; if ( exp [ i ] == ',' ) ++ i ; } ++ i ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public boolean parseBoolExpr ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private boolean dfs ( final String expression , int s , int e ) { if ( s == e ) return expression . charAt ( s ) == 't' ; List < Boolean > exps = new ArrayList <> (); int layer = 0 ; int left = 0 ; char op = ' ' ; for ( int i = s ; i <= e ; ++ i ) { char c = expression . charAt ( i ); if ( layer == 0 && ( c == '!' || c == '&' || c == '|' )) op = c ; else if ( c == '(' && ++ layer == 1 ) left = i + 1 ; else if ( c == ')' && -- layer == 0 ) exps . add ( dfs ( expression , left , i - 1 )); else if ( c == ',' && layer == 1 ) { exps . add ( dfs ( expression , left , i - 1 )); left = i + 1 ; } } if ( op == '&' ) { boolean ans = true ; for ( boolean exp : exps ) ans &= exp ; return ans ; } if ( op == '|' ) { boolean ans = false ; for ( boolean exp : exps ) ans |= exp ; return ans ; } return ! exps . get ( 0 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def parseBoolExpr ( self , expression : str ) -> bool : def dfs ( s : int , e : int ) -> List [ str ]: if s == e : return True if expression [ s ] == 't' else False exps = [] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if layer == 0 and c in '!&|' : op = c elif c == '(' : layer += 1 if layer == 1 : left = i + 1 elif c == ')' : layer -= 1 if layer == 0 : exps . append ( dfs ( left , i - 1 )) elif c == ',' and layer == 1 : exps . append ( dfs ( left , i - 1 )) left = i + 1 if op == '|' : return functools . reduce ( lambda x , y : x | y , exps ) if op == '&' : return functools . reduce ( lambda x , y : x & y , exps ) if op == '!' : return not exps [ 0 ] return dfs ( 0 , len ( expression ) - 1 )","title":"1106. Parsing A Boolean Expression"},{"location":"problems/1107/","text":"1107. New Users Daily Count \ud83d\udd12","title":"1107. New Users Daily Count"},{"location":"problems/1107/#1107-new-users-daily-count","text":"","title":"1107. New Users Daily Count \ud83d\udd12"},{"location":"problems/1108/","text":"1108. Defanging an IP Address Time: Space: C++ 1 2 3 4 5 6 class Solution { public : string defangIPaddr ( string address ) { return regex_replace ( address , regex ( \"[.]\" ), \"[.]\" ); } }; Java 1 2 3 4 5 class Solution { public String defangIPaddr ( String address ) { return address . replace ( \".\" , \"[.]\" ); } } Python 1 2 3 class Solution : def defangIPaddr ( self , address : str ) -> str : return address . replace ( '.' , '[.]' )","title":"1108. Defanging an IP Address"},{"location":"problems/1108/#1108-defanging-an-ip-address","text":"Time: Space: C++ 1 2 3 4 5 6 class Solution { public : string defangIPaddr ( string address ) { return regex_replace ( address , regex ( \"[.]\" ), \"[.]\" ); } }; Java 1 2 3 4 5 class Solution { public String defangIPaddr ( String address ) { return address . replace ( \".\" , \"[.]\" ); } } Python 1 2 3 class Solution : def defangIPaddr ( self , address : str ) -> str : return address . replace ( '.' , '[.]' )","title":"1108. Defanging an IP Address"},{"location":"problems/1109/","text":"1109. Corporate Flight Bookings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] corpFlightBookings ( int [][] bookings , int n ) { int [] ans = new int [ n ] ; for ( int [] booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ] ; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ] ; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans","title":"1109. Corporate Flight Bookings"},{"location":"problems/1109/#1109-corporate-flight-bookings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] corpFlightBookings ( int [][] bookings , int n ) { int [] ans = new int [ n ] ; for ( int [] booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ] ; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ] ; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans","title":"1109. Corporate Flight Bookings"},{"location":"problems/1110/","text":"1110. Delete Nodes And Return Forest","title":"1110. Delete Nodes And Return Forest"},{"location":"problems/1110/#1110-delete-nodes-and-return-forest","text":"","title":"1110. Delete Nodes And Return Forest"},{"location":"problems/1111/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings"},{"location":"problems/1111/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings"},{"location":"problems/1112/","text":"1112. Highest Grade For Each Student \ud83d\udd12","title":"1112. Highest Grade For Each Student"},{"location":"problems/1112/#1112-highest-grade-for-each-student","text":"","title":"1112. Highest Grade For Each Student \ud83d\udd12"},{"location":"problems/1113/","text":"1113. Reported Posts \ud83d\udd12","title":"1113. Reported Posts"},{"location":"problems/1113/#1113-reported-posts","text":"","title":"1113. Reported Posts \ud83d\udd12"},{"location":"problems/1114/","text":"1114. Print in Order Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order"},{"location":"problems/1114/#1114-print-in-order","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order"},{"location":"problems/1115/","text":"1115. Print FooBar Alternately","title":"1115. Print FooBar Alternately"},{"location":"problems/1115/#1115-print-foobar-alternately","text":"","title":"1115. Print FooBar Alternately"},{"location":"problems/1116/","text":"1116. Print Zero Even Odd","title":"1116. Print Zero Even Odd"},{"location":"problems/1116/#1116-print-zero-even-odd","text":"","title":"1116. Print Zero Even Odd"},{"location":"problems/1117/","text":"1117. Building H2O","title":"1117. Building H2O"},{"location":"problems/1117/#1117-building-h2o","text":"","title":"1117. Building H2O"},{"location":"problems/1118/","text":"1118. Number of Days in a Month \ud83d\udd12","title":"1118. Number of Days in a Month"},{"location":"problems/1118/#1118-number-of-days-in-a-month","text":"","title":"1118. Number of Days in a Month \ud83d\udd12"},{"location":"problems/1119/","text":"1119. Remove Vowels from a String \ud83d\udd12","title":"1119. Remove Vowels from a String"},{"location":"problems/1119/#1119-remove-vowels-from-a-string","text":"","title":"1119. Remove Vowels from a String \ud83d\udd12"},{"location":"problems/1120/","text":"1120. Maximum Average Subtree \ud83d\udd12","title":"1120. Maximum Average Subtree"},{"location":"problems/1120/#1120-maximum-average-subtree","text":"","title":"1120. Maximum Average Subtree \ud83d\udd12"},{"location":"problems/1121/","text":"1121. Divide Array Into Increasing Sequences \ud83d\udd12","title":"1121. Divide Array Into Increasing Sequences"},{"location":"problems/1121/#1121-divide-array-into-increasing-sequences","text":"","title":"1121. Divide Array Into Increasing Sequences \ud83d\udd12"},{"location":"problems/1122/","text":"1122. Relative Sort Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > relativeSortArray ( vector < int >& arr1 , vector < int >& arr2 ) { vector < int > ans ; vector < int > count ( 1001 ); for ( int a : arr1 ) ++ count [ a ]; for ( int a : arr2 ) while ( count [ a ] -- > 0 ) ans . push_back ( a ); for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] relativeSortArray ( int [] arr1 , int [] arr2 ) { int [] ans = new int [ arr1 . length ] ; int [] count = new int [ 1001 ] ; int i = 0 ; for ( int a : arr1 ) ++ count [ a ] ; for ( int a : arr2 ) while ( count [ a ]-- > 0 ) ans [ i ++] = a ; for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ]-- > 0 ) ans [ i ++] = num ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def relativeSortArray ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] count = [ 0 ] * 1001 for a in arr1 : count [ a ] += 1 for a in arr2 : while count [ a ] > 0 : ans . append ( a ) count [ a ] -= 1 for num in range ( 1001 ): for _ in range ( count [ num ]): ans . append ( num ) return ans","title":"1122. Relative Sort Array"},{"location":"problems/1122/#1122-relative-sort-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > relativeSortArray ( vector < int >& arr1 , vector < int >& arr2 ) { vector < int > ans ; vector < int > count ( 1001 ); for ( int a : arr1 ) ++ count [ a ]; for ( int a : arr2 ) while ( count [ a ] -- > 0 ) ans . push_back ( a ); for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] relativeSortArray ( int [] arr1 , int [] arr2 ) { int [] ans = new int [ arr1 . length ] ; int [] count = new int [ 1001 ] ; int i = 0 ; for ( int a : arr1 ) ++ count [ a ] ; for ( int a : arr2 ) while ( count [ a ]-- > 0 ) ans [ i ++] = a ; for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ]-- > 0 ) ans [ i ++] = num ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def relativeSortArray ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] count = [ 0 ] * 1001 for a in arr1 : count [ a ] += 1 for a in arr2 : while count [ a ] > 0 : ans . append ( a ) count [ a ] -= 1 for num in range ( 1001 ): for _ in range ( count [ num ]): ans . append ( num ) return ans","title":"1122. Relative Sort Array"},{"location":"problems/1123/","text":"1123. Lowest Common Ancestor of Deepest Leaves Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Info { TreeNode * lca ; int height ; }; class Solution { public : TreeNode * lcaDeepestLeaves ( TreeNode * root ) { return helper ( root ). lca ; } private : Info helper ( TreeNode * root ) { if ( ! root ) return { nullptr , 0 }; const Info l = helper ( root -> left ); const Info r = helper ( root -> right ); if ( l . height > r . height ) return { l . lca , l . height + 1 }; if ( l . height < r . height ) return { r . lca , r . height + 1 }; return { root , l . height + 1 }; } };","title":"1123. Lowest Common Ancestor of Deepest Leaves"},{"location":"problems/1123/#1123-lowest-common-ancestor-of-deepest-leaves","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Info { TreeNode * lca ; int height ; }; class Solution { public : TreeNode * lcaDeepestLeaves ( TreeNode * root ) { return helper ( root ). lca ; } private : Info helper ( TreeNode * root ) { if ( ! root ) return { nullptr , 0 }; const Info l = helper ( root -> left ); const Info r = helper ( root -> right ); if ( l . height > r . height ) return { l . lca , l . height + 1 }; if ( l . height < r . height ) return { r . lca , r . height + 1 }; return { root , l . height + 1 }; } };","title":"1123. Lowest Common Ancestor of Deepest Leaves"},{"location":"problems/1124/","text":"1124. Longest Well-Performing Interval Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { prefixSum += hours [ i ] > 8 ? 1 : -1 ; if ( prefixSum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( prefixSum )) map [ prefixSum ] = i ; if ( map . count ( prefixSum - 1 )) ans = max ( ans , i - map [ prefixSum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval"},{"location":"problems/1124/#1124-longest-well-performing-interval","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { prefixSum += hours [ i ] > 8 ? 1 : -1 ; if ( prefixSum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( prefixSum )) map [ prefixSum ] = i ; if ( map . count ( prefixSum - 1 )) ans = max ( ans , i - map [ prefixSum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval"},{"location":"problems/1125/","text":"1125. Smallest Sufficient Team","title":"1125. Smallest Sufficient Team"},{"location":"problems/1125/#1125-smallest-sufficient-team","text":"","title":"1125. Smallest Sufficient Team"},{"location":"problems/1126/","text":"1126. Active Businesses \ud83d\udd12","title":"1126. Active Businesses"},{"location":"problems/1126/#1126-active-businesses","text":"","title":"1126. Active Businesses \ud83d\udd12"},{"location":"problems/1127/","text":"1127. User Purchase Platform \ud83d\udd12","title":"1127. User Purchase Platform"},{"location":"problems/1127/#1127-user-purchase-platform","text":"","title":"1127. User Purchase Platform \ud83d\udd12"},{"location":"problems/1128/","text":"1128. Number of Equivalent Domino Pairs Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numEquivDominoPairs ( vector < vector < int >>& dominoes ) { int ans = 0 ; unordered_map < int , int > count ; for ( vector < int >& domino : dominoes ) { int key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]); ans += count [ key ]; ++ count [ key ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numEquivDominoPairs ( int [][] dominoes ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int [] domino : dominoes ) { int key = Math . min ( domino [ 0 ] , domino [ 1 ] ) * 10 + Math . max ( domino [ 0 ] , domino [ 1 ] ); ans += count . getOrDefault ( key , 0 ); count . put ( key , count . getOrDefault ( key , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numEquivDominoPairs ( self , dominoes : List [ List [ int ]]) -> int : ans = 0 count = collections . Counter () for domino in dominoes : key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]) ans += count [ key ] count [ key ] += 1 return ans","title":"1128. Number of Equivalent Domino Pairs"},{"location":"problems/1128/#1128-number-of-equivalent-domino-pairs","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numEquivDominoPairs ( vector < vector < int >>& dominoes ) { int ans = 0 ; unordered_map < int , int > count ; for ( vector < int >& domino : dominoes ) { int key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]); ans += count [ key ]; ++ count [ key ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numEquivDominoPairs ( int [][] dominoes ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int [] domino : dominoes ) { int key = Math . min ( domino [ 0 ] , domino [ 1 ] ) * 10 + Math . max ( domino [ 0 ] , domino [ 1 ] ); ans += count . getOrDefault ( key , 0 ); count . put ( key , count . getOrDefault ( key , 0 ) + 1 ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numEquivDominoPairs ( self , dominoes : List [ List [ int ]]) -> int : ans = 0 count = collections . Counter () for domino in dominoes : key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]) ans += count [ key ] count [ key ] += 1 return ans","title":"1128. Number of Equivalent Domino Pairs"},{"location":"problems/1129/","text":"1129. Shortest Path with Alternating Colors","title":"1129. Shortest Path with Alternating Colors"},{"location":"problems/1129/#1129-shortest-path-with-alternating-colors","text":"","title":"1129. Shortest Path with Alternating Colors"},{"location":"problems/1130/","text":"1130. Minimum Cost Tree From Leaf Values Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int mctFromLeafValues ( vector < int >& arr ) { int ans = 0 ; vector < int > maxStack { INT_MAX }; for ( int a : arr ) { while ( maxStack . back () <= a ) { int mid = maxStack . back (); maxStack . pop_back (); ans += mid * min ( maxStack . back (), a ); } maxStack . push_back ( a ); } for ( int i = 2 ; i < maxStack . size (); ++ i ) ans += maxStack [ i ] * maxStack [ i - 1 ]; return ans ; } };","title":"1130. Minimum Cost Tree From Leaf Values"},{"location":"problems/1130/#1130-minimum-cost-tree-from-leaf-values","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int mctFromLeafValues ( vector < int >& arr ) { int ans = 0 ; vector < int > maxStack { INT_MAX }; for ( int a : arr ) { while ( maxStack . back () <= a ) { int mid = maxStack . back (); maxStack . pop_back (); ans += mid * min ( maxStack . back (), a ); } maxStack . push_back ( a ); } for ( int i = 2 ; i < maxStack . size (); ++ i ) ans += maxStack [ i ] * maxStack [ i - 1 ]; return ans ; } };","title":"1130. Minimum Cost Tree From Leaf Values"},{"location":"problems/1131/","text":"1131. Maximum of Absolute Value Expression Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { const int n = arr1 . size (); vector < int > a ( n ); vector < int > b ( n ); vector < int > c ( n ); vector < int > d ( n ); for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return max ( max ( diff ( a ), diff ( b )), max ( diff ( c ), diff ( d ))); } private : int diff ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); const int max = * max_element ( begin ( nums ), end ( nums )); return max - min ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int maxAbsValExpr ( int [] arr1 , int [] arr2 ) { final int n = arr1 . length ; int [] a = new int [ n ] ; int [] b = new int [ n ] ; int [] c = new int [ n ] ; int [] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return Math . max ( Math . max ( diff ( a ), diff ( b )), Math . max ( diff ( c ), diff ( d ))); } private int diff ( int [] nums ) { final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); return max - min ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxAbsValExpr ( self , arr1 : List [ int ], arr2 : List [ int ]) -> int : n = len ( arr1 ) a = [ arr1 [ i ] + arr2 [ i ] + i for i in range ( n )] b = [ arr1 [ i ] + arr2 [ i ] - i for i in range ( n )] c = [ arr1 [ i ] - arr2 [ i ] + i for i in range ( n )] d = [ arr1 [ i ] - arr2 [ i ] - i for i in range ( n )] return max ( map ( lambda x : max ( x ) - min ( x ), ( a , b , c , d )))","title":"1131. Maximum of Absolute Value Expression"},{"location":"problems/1131/#1131-maximum-of-absolute-value-expression","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { const int n = arr1 . size (); vector < int > a ( n ); vector < int > b ( n ); vector < int > c ( n ); vector < int > d ( n ); for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return max ( max ( diff ( a ), diff ( b )), max ( diff ( c ), diff ( d ))); } private : int diff ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); const int max = * max_element ( begin ( nums ), end ( nums )); return max - min ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int maxAbsValExpr ( int [] arr1 , int [] arr2 ) { final int n = arr1 . length ; int [] a = new int [ n ] ; int [] b = new int [ n ] ; int [] c = new int [ n ] ; int [] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return Math . max ( Math . max ( diff ( a ), diff ( b )), Math . max ( diff ( c ), diff ( d ))); } private int diff ( int [] nums ) { final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); return max - min ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def maxAbsValExpr ( self , arr1 : List [ int ], arr2 : List [ int ]) -> int : n = len ( arr1 ) a = [ arr1 [ i ] + arr2 [ i ] + i for i in range ( n )] b = [ arr1 [ i ] + arr2 [ i ] - i for i in range ( n )] c = [ arr1 [ i ] - arr2 [ i ] + i for i in range ( n )] d = [ arr1 [ i ] - arr2 [ i ] - i for i in range ( n )] return max ( map ( lambda x : max ( x ) - min ( x ), ( a , b , c , d )))","title":"1131. Maximum of Absolute Value Expression"},{"location":"problems/1132/","text":"1132. Reported Posts II \ud83d\udd12","title":"1132. Reported Posts II"},{"location":"problems/1132/#1132-reported-posts-ii","text":"","title":"1132. Reported Posts II \ud83d\udd12"},{"location":"problems/1133/","text":"1133. Largest Unique Number \ud83d\udd12","title":"1133. Largest Unique Number"},{"location":"problems/1133/#1133-largest-unique-number","text":"","title":"1133. Largest Unique Number \ud83d\udd12"},{"location":"problems/1134/","text":"1134. Armstrong Number \ud83d\udd12","title":"1134. Armstrong Number"},{"location":"problems/1134/#1134-armstrong-number","text":"","title":"1134. Armstrong Number \ud83d\udd12"},{"location":"problems/1135/","text":"1135. Connecting Cities With Minimum Cost \ud83d\udd12","title":"1135. Connecting Cities With Minimum Cost"},{"location":"problems/1135/#1135-connecting-cities-with-minimum-cost","text":"","title":"1135. Connecting Cities With Minimum Cost \ud83d\udd12"},{"location":"problems/1136/","text":"1136. Parallel Courses \ud83d\udd12","title":"1136. Parallel Courses"},{"location":"problems/1136/#1136-parallel-courses","text":"","title":"1136. Parallel Courses \ud83d\udd12"},{"location":"problems/1137/","text":"1137. N-th Tribonacci Number","title":"1137. N-th Tribonacci Number"},{"location":"problems/1137/#1137-n-th-tribonacci-number","text":"","title":"1137. N-th Tribonacci Number"},{"location":"problems/1138/","text":"1138. Alphabet Board Path Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : string alphabetBoardPath ( string target ) { string ans ; int x = 0 ; int y = 0 ; for ( char c : target ) { int newX = ( c - 'a' ) % 5 ; int newY = ( c - 'a' ) / 5 ; ans += string ( max ( 0 , y - newY ), 'U' ) + string ( max ( 0 , newX - x ), 'R' ) + string ( max ( 0 , x - newX ), 'L' ) + string ( max ( 0 , newY - y ), 'D' ) + '!' ; x = newX ; y = newY ; } return ans ; } };","title":"1138. Alphabet Board Path"},{"location":"problems/1138/#1138-alphabet-board-path","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : string alphabetBoardPath ( string target ) { string ans ; int x = 0 ; int y = 0 ; for ( char c : target ) { int newX = ( c - 'a' ) % 5 ; int newY = ( c - 'a' ) / 5 ; ans += string ( max ( 0 , y - newY ), 'U' ) + string ( max ( 0 , newX - x ), 'R' ) + string ( max ( 0 , x - newX ), 'L' ) + string ( max ( 0 , newY - y ), 'D' ) + '!' ; x = newX ; y = newY ; } return ans ; } };","title":"1138. Alphabet Board Path"},{"location":"problems/1139/","text":"1139. Largest 1-Bordered Square","title":"1139. Largest 1-Bordered Square"},{"location":"problems/1139/#1139-largest-1-bordered-square","text":"","title":"1139. Largest 1-Bordered Square"},{"location":"problems/1140/","text":"1140. Stone Game II","title":"1140. Stone Game II"},{"location":"problems/1140/#1140-stone-game-ii","text":"","title":"1140. Stone Game II"},{"location":"problems/1141/","text":"1141. User Activity for the Past 30 Days I \ud83d\udd12","title":"1141. User Activity for the Past 30 Days I"},{"location":"problems/1141/#1141-user-activity-for-the-past-30-days-i","text":"","title":"1141. User Activity for the Past 30 Days I \ud83d\udd12"},{"location":"problems/1142/","text":"1142. User Activity for the Past 30 Days II \ud83d\udd12","title":"1142. User Activity for the Past 30 Days II"},{"location":"problems/1142/#1142-user-activity-for-the-past-30-days-ii","text":"","title":"1142. User Activity for the Past 30 Days II \ud83d\udd12"},{"location":"problems/1143/","text":"1143. Longest Common Subsequence Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int longestCommonSubsequence ( string text1 , string text2 ) { const int m = text1 . length (); const int n = text2 . length (); // dp[i][j] := LCS's length of text1[0..i) and text2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( text1 [ i - 1 ] == text2 [ j - 1 ]) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { final int m = text1 . length (); final int n = text2 . length (); // dp[i][j] := LCS's length of text1[0..i) and text2[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( text1 . charAt ( i - 1 ) == text2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } }","title":"1143. Longest Common Subsequence"},{"location":"problems/1143/#1143-longest-common-subsequence","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int longestCommonSubsequence ( string text1 , string text2 ) { const int m = text1 . length (); const int n = text2 . length (); // dp[i][j] := LCS's length of text1[0..i) and text2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( text1 [ i - 1 ] == text2 [ j - 1 ]) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int longestCommonSubsequence ( String text1 , String text2 ) { final int m = text1 . length (); final int n = text2 . length (); // dp[i][j] := LCS's length of text1[0..i) and text2[0..j) int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( text1 . charAt ( i - 1 ) == text2 . charAt ( j - 1 )) dp [ i ][ j ] = 1 + dp [ i - 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } }","title":"1143. Longest Common Subsequence"},{"location":"problems/1144/","text":"1144. Decrease Elements To Make Array Zigzag Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int movesToMakeZigzag ( vector < int >& nums ) { vector < int > decreasing ( 2 ); for ( int i = 0 ; i < nums . size (); ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . size () ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += max ( 0 , nums [ i ] - min ( l , r ) + 1 ); } return min ( decreasing [ 0 ], decreasing [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int movesToMakeZigzag ( int [] nums ) { int [] decreasing = new int [ 2 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . length ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += Math . max ( 0 , nums [ i ] - Math . min ( l , r ) + 1 ); } return Math . min ( decreasing [ 0 ] , decreasing [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def movesToMakeZigzag ( self , nums : List [ int ]) -> int : decreasing = [ 0 ] * 2 for i , num in enumerate ( nums ): l = nums [ i - 1 ] if i > 0 else 1001 r = nums [ i + 1 ] if i + 1 < len ( nums ) else 1001 decreasing [ i % 2 ] += max ( 0 , num - min ( l , r ) + 1 ) return min ( decreasing [ 0 ], decreasing [ 1 ])","title":"1144. Decrease Elements To Make Array Zigzag"},{"location":"problems/1144/#1144-decrease-elements-to-make-array-zigzag","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int movesToMakeZigzag ( vector < int >& nums ) { vector < int > decreasing ( 2 ); for ( int i = 0 ; i < nums . size (); ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . size () ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += max ( 0 , nums [ i ] - min ( l , r ) + 1 ); } return min ( decreasing [ 0 ], decreasing [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int movesToMakeZigzag ( int [] nums ) { int [] decreasing = new int [ 2 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . length ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += Math . max ( 0 , nums [ i ] - Math . min ( l , r ) + 1 ); } return Math . min ( decreasing [ 0 ] , decreasing [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def movesToMakeZigzag ( self , nums : List [ int ]) -> int : decreasing = [ 0 ] * 2 for i , num in enumerate ( nums ): l = nums [ i - 1 ] if i > 0 else 1001 r = nums [ i + 1 ] if i + 1 < len ( nums ) else 1001 decreasing [ i % 2 ] += max ( 0 , num - min ( l , r ) + 1 ) return min ( decreasing [ 0 ], decreasing [ 1 ])","title":"1144. Decrease Elements To Make Array Zigzag"},{"location":"problems/1145/","text":"1145. Binary Tree Coloring Game","title":"1145. Binary Tree Coloring Game"},{"location":"problems/1145/#1145-binary-tree-coloring-game","text":"","title":"1145. Binary Tree Coloring Game"},{"location":"problems/1146/","text":"1146. Snapshot Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class SnapshotArray { public : SnapshotArray ( int length ) { map = vector < std :: map < int , int >> ( length ); for ( int i = 0 ; i < length ; ++ i ) map [ i ][ 0 ] = 0 ; } void set ( int index , int val ) { map [ index ][ snap_id ] = val ; } int snap () { return snap_id ++ ; } int get ( int index , int snap_id ) { auto it = map [ index ]. upper_bound ( snap_id ); return prev ( it ) -> second ; } private : vector < std :: map < int , int >> map ; int snap_id = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class SnapshotArray { public SnapshotArray ( int length ) { map = new TreeMap [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { map [ i ] = new TreeMap <> (); map [ i ] . put ( 0 , 0 ); } } public void set ( int index , int val ) { map [ index ] . put ( snap_id , val ); } public int snap () { return snap_id ++ ; } public int get ( int index , int snap_id ) { return map [ index ] . floorEntry ( snap_id ). getValue (); } private TreeMap < Integer , Integer >[] map ; private int snap_id = 0 ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SnapshotArray : def __init__ ( self , length : int ): self . map = [[[ 0 , 0 ]] for _ in range ( length )] self . snap_id = 0 def set ( self , index : int , val : int ) -> None : self . map [ index ] . append ([ self . snap_id , val ]) def snap ( self ) -> int : self . snap_id += 1 return self . snap_id - 1 def get ( self , index : int , snap_id : int ) -> int : i = bisect . bisect ( self . map [ index ], [ snap_id + 1 ]) - 1 return self . map [ index ][ i ][ 1 ]","title":"1146. Snapshot Array"},{"location":"problems/1146/#1146-snapshot-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class SnapshotArray { public : SnapshotArray ( int length ) { map = vector < std :: map < int , int >> ( length ); for ( int i = 0 ; i < length ; ++ i ) map [ i ][ 0 ] = 0 ; } void set ( int index , int val ) { map [ index ][ snap_id ] = val ; } int snap () { return snap_id ++ ; } int get ( int index , int snap_id ) { auto it = map [ index ]. upper_bound ( snap_id ); return prev ( it ) -> second ; } private : vector < std :: map < int , int >> map ; int snap_id = 0 ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class SnapshotArray { public SnapshotArray ( int length ) { map = new TreeMap [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { map [ i ] = new TreeMap <> (); map [ i ] . put ( 0 , 0 ); } } public void set ( int index , int val ) { map [ index ] . put ( snap_id , val ); } public int snap () { return snap_id ++ ; } public int get ( int index , int snap_id ) { return map [ index ] . floorEntry ( snap_id ). getValue (); } private TreeMap < Integer , Integer >[] map ; private int snap_id = 0 ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class SnapshotArray : def __init__ ( self , length : int ): self . map = [[[ 0 , 0 ]] for _ in range ( length )] self . snap_id = 0 def set ( self , index : int , val : int ) -> None : self . map [ index ] . append ([ self . snap_id , val ]) def snap ( self ) -> int : self . snap_id += 1 return self . snap_id - 1 def get ( self , index : int , snap_id : int ) -> int : i = bisect . bisect ( self . map [ index ], [ snap_id + 1 ]) - 1 return self . map [ index ][ i ][ 1 ]","title":"1146. Snapshot Array"},{"location":"problems/1147/","text":"1147. Longest Chunked Palindrome Decomposition","title":"1147. Longest Chunked Palindrome Decomposition"},{"location":"problems/1147/#1147-longest-chunked-palindrome-decomposition","text":"","title":"1147. Longest Chunked Palindrome Decomposition"},{"location":"problems/1148/","text":"1148. Article Views I \ud83d\udd12","title":"1148. Article Views I"},{"location":"problems/1148/#1148-article-views-i","text":"","title":"1148. Article Views I \ud83d\udd12"},{"location":"problems/1149/","text":"1149. Article Views II \ud83d\udd12","title":"1149. Article Views II"},{"location":"problems/1149/#1149-article-views-ii","text":"","title":"1149. Article Views II \ud83d\udd12"},{"location":"problems/1150/","text":"1150. Check If a Number Is Majority Element in a Sorted Array \ud83d\udd12","title":"1150. Check If a Number Is Majority Element in a Sorted Array"},{"location":"problems/1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array \ud83d\udd12"},{"location":"problems/1151/","text":"1151. Minimum Swaps to Group All 1's Together \ud83d\udd12","title":"1151. Minimum Swaps to Group All 1's Together"},{"location":"problems/1151/#1151-minimum-swaps-to-group-all-1s-together","text":"","title":"1151. Minimum Swaps to Group All 1's Together \ud83d\udd12"},{"location":"problems/1152/","text":"1152. Analyze User Website Visit Pattern \ud83d\udd12","title":"1152. Analyze User Website Visit Pattern"},{"location":"problems/1152/#1152-analyze-user-website-visit-pattern","text":"","title":"1152. Analyze User Website Visit Pattern \ud83d\udd12"},{"location":"problems/1153/","text":"1153. String Transforms Into Another String \ud83d\udd12","title":"1153. String Transforms Into Another String"},{"location":"problems/1153/#1153-string-transforms-into-another-string","text":"","title":"1153. String Transforms Into Another String \ud83d\udd12"},{"location":"problems/1154/","text":"1154. Day of the Year Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 )); int month = stoi ( date . substr ( 5 , 2 )); int day = stoi ( date . substr ( 8 )); vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; return accumulate ( begin ( days ), begin ( days ) + month - 1 , 0 ) + day ; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dayOfYear ( String date ) { int ans = 0 ; int year = Integer . valueOf ( date . substring ( 0 , 4 )); int month = Integer . valueOf ( date . substring ( 5 , 7 )); int day = Integer . valueOf ( date . substring ( 8 )); int [] days = new int [] { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; for ( int i = 0 ; i < month - 1 ; ++ i ) ans += days [ i ] ; return ans + day ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def dayOfYear ( self , date : str ) -> int : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 year = int ( date [: 4 ]) month = int ( date [ 5 : 7 ]) day = int ( date [ 8 :]) days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] return sum ( days [: month - 1 ]) + day","title":"1154. Day of the Year"},{"location":"problems/1154/#1154-day-of-the-year","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 )); int month = stoi ( date . substr ( 5 , 2 )); int day = stoi ( date . substr ( 8 )); vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; return accumulate ( begin ( days ), begin ( days ) + month - 1 , 0 ) + day ; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dayOfYear ( String date ) { int ans = 0 ; int year = Integer . valueOf ( date . substring ( 0 , 4 )); int month = Integer . valueOf ( date . substring ( 5 , 7 )); int day = Integer . valueOf ( date . substring ( 8 )); int [] days = new int [] { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; for ( int i = 0 ; i < month - 1 ; ++ i ) ans += days [ i ] ; return ans + day ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def dayOfYear ( self , date : str ) -> int : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 year = int ( date [: 4 ]) month = int ( date [ 5 : 7 ]) day = int ( date [ 8 :]) days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] return sum ( days [: month - 1 ]) + day","title":"1154. Day of the Year"},{"location":"problems/1155/","text":"1155. Number of Dice Rolls With Target Sum Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numRollsToTarget ( int d , int f , int target ) { const int kMod = 1e9 + 7 ; vector < int > dp ( target + 1 ); dp [ 0 ] = 1 ; while ( d -- ) { // d dices vector < int > newDp ( target + 1 ); for ( int i = 1 ; i <= f ; ++ i ) // number 1, 2, ..., f for ( int t = i ; t <= target ; ++ t ) // possible targets newDp [ t ] = ( newDp [ t ] + dp [ t - i ]) % kMod ; swap ( dp , newDp ); } return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numRollsToTarget ( int d , int f , int target ) { final int kMod = ( int ) 1e9 + 7 ; int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; while ( d -- > 0 ) { int [] newDp = new int [ target + 1 ] ; for ( int i = 1 ; i <= f ; ++ i ) for ( int t = i ; t <= target ; ++ t ) newDp [ t ] = ( newDp [ t ] + dp [ t - i ] ) % kMod ; dp = newDp ; } return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def numRollsToTarget ( self , d : int , f : int , target : int ) -> int : def dfs ( d : int , target : int ) -> int : if d == 0 or target <= 0 : return d == 0 and target == 0 if dp [ d ][ target ]: return dp [ d ][ target ] - 1 # -1 here ans = 0 for i in range ( 1 , f + 1 ): ans = ( ans + dfs ( d - 1 , target - i )) % kMod dp [ d ][ target ] = ans + 1 # +1 here return ans kMod = int ( 1e9 + 7 ) dp = [[ 0 ] * ( target + 1 ) for _ in range ( d + 1 )] return dfs ( d , target )","title":"1155. Number of Dice Rolls With Target Sum"},{"location":"problems/1155/#1155-number-of-dice-rolls-with-target-sum","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numRollsToTarget ( int d , int f , int target ) { const int kMod = 1e9 + 7 ; vector < int > dp ( target + 1 ); dp [ 0 ] = 1 ; while ( d -- ) { // d dices vector < int > newDp ( target + 1 ); for ( int i = 1 ; i <= f ; ++ i ) // number 1, 2, ..., f for ( int t = i ; t <= target ; ++ t ) // possible targets newDp [ t ] = ( newDp [ t ] + dp [ t - i ]) % kMod ; swap ( dp , newDp ); } return dp [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numRollsToTarget ( int d , int f , int target ) { final int kMod = ( int ) 1e9 + 7 ; int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; while ( d -- > 0 ) { int [] newDp = new int [ target + 1 ] ; for ( int i = 1 ; i <= f ; ++ i ) for ( int t = i ; t <= target ; ++ t ) newDp [ t ] = ( newDp [ t ] + dp [ t - i ] ) % kMod ; dp = newDp ; } return dp [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def numRollsToTarget ( self , d : int , f : int , target : int ) -> int : def dfs ( d : int , target : int ) -> int : if d == 0 or target <= 0 : return d == 0 and target == 0 if dp [ d ][ target ]: return dp [ d ][ target ] - 1 # -1 here ans = 0 for i in range ( 1 , f + 1 ): ans = ( ans + dfs ( d - 1 , target - i )) % kMod dp [ d ][ target ] = ans + 1 # +1 here return ans kMod = int ( 1e9 + 7 ) dp = [[ 0 ] * ( target + 1 ) for _ in range ( d + 1 )] return dfs ( d , target )","title":"1155. Number of Dice Rolls With Target Sum"},{"location":"problems/1156/","text":"1156. Swap For Longest Repeated Character Substring Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maxRepOpt1 ( string text ) { int ans = 0 ; vector < int > count ( 26 ); vector < pair < char , int >> groups {{ text [ 0 ], 1 }}; for ( char c : text ) ++ count [ c - 'a' ]; for ( int i = 1 ; i < text . length (); ++ i ) if ( text [ i ] == text [ i - 1 ]) ++ groups [ groups . size () - 1 ]. second ; else groups . push_back ({ text [ i ], 1 }); for ( const auto & [ c , length ] : groups ) ans = max ( ans , min ( length + 1 , count [ c - 'a' ])); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups [ i - 1 ]. first == groups [ i + 1 ]. first && groups [ i ]. second == 1 ) ans = max ( ans , min ( groups [ i - 1 ]. second + groups [ i + 1 ]. second + 1 , count [ groups [ i - 1 ]. first - 'a' ])); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxRepOpt1 ( String text ) { int ans = 0 ; int [] count = new int [ 26 ] ; List < int []> groups = new ArrayList <> (); for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; groups . add ( new int [] { text . charAt ( 0 ), 1 }); for ( int i = 1 ; i < text . length (); ++ i ) if ( text . charAt ( i ) == text . charAt ( i - 1 )) ++ groups . get ( groups . size () - 1 ) [ 1 ] ; else groups . add ( new int [] { text . charAt ( i ), 1 }); for ( int [] group : groups ) ans = Math . max ( ans , Math . min ( group [ 1 ] + 1 , count [ group [ 0 ] - 'a' ] )); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups . get ( i - 1 ) [ 0 ] == groups . get ( i + 1 ) [ 0 ] && groups . get ( i ) [ 1 ] == 1 ) ans = Math . max ( ans , Math . min ( groups . get ( i - 1 ) [ 1 ] + groups . get ( i + 1 ) [ 1 ] + 1 , count [ groups . get ( i - 1 ) [ 0 ] - 'a' ] )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxRepOpt1 ( self , text : str ) -> int : count = collections . Counter ( text ) groups = [[ c , len ( list ( group ))] for c , group in itertools . groupby ( text )] ans = max ( min ( length + 1 , count [ c ]) for c , length in groups ) for i in range ( 1 , len ( groups ) - 1 ): if groups [ i - 1 ][ 0 ] == groups [ i + 1 ][ 0 ] and groups [ i ][ 1 ] == 1 : ans = max ( ans , min ( groups [ i - 1 ][ 1 ] + groups [ i + 1 ][ 1 ] + 1 , count [ groups [ i - 1 ][ 0 ]])) return ans","title":"1156. Swap For Longest Repeated Character Substring"},{"location":"problems/1156/#1156-swap-for-longest-repeated-character-substring","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maxRepOpt1 ( string text ) { int ans = 0 ; vector < int > count ( 26 ); vector < pair < char , int >> groups {{ text [ 0 ], 1 }}; for ( char c : text ) ++ count [ c - 'a' ]; for ( int i = 1 ; i < text . length (); ++ i ) if ( text [ i ] == text [ i - 1 ]) ++ groups [ groups . size () - 1 ]. second ; else groups . push_back ({ text [ i ], 1 }); for ( const auto & [ c , length ] : groups ) ans = max ( ans , min ( length + 1 , count [ c - 'a' ])); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups [ i - 1 ]. first == groups [ i + 1 ]. first && groups [ i ]. second == 1 ) ans = max ( ans , min ( groups [ i - 1 ]. second + groups [ i + 1 ]. second + 1 , count [ groups [ i - 1 ]. first - 'a' ])); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxRepOpt1 ( String text ) { int ans = 0 ; int [] count = new int [ 26 ] ; List < int []> groups = new ArrayList <> (); for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; groups . add ( new int [] { text . charAt ( 0 ), 1 }); for ( int i = 1 ; i < text . length (); ++ i ) if ( text . charAt ( i ) == text . charAt ( i - 1 )) ++ groups . get ( groups . size () - 1 ) [ 1 ] ; else groups . add ( new int [] { text . charAt ( i ), 1 }); for ( int [] group : groups ) ans = Math . max ( ans , Math . min ( group [ 1 ] + 1 , count [ group [ 0 ] - 'a' ] )); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups . get ( i - 1 ) [ 0 ] == groups . get ( i + 1 ) [ 0 ] && groups . get ( i ) [ 1 ] == 1 ) ans = Math . max ( ans , Math . min ( groups . get ( i - 1 ) [ 1 ] + groups . get ( i + 1 ) [ 1 ] + 1 , count [ groups . get ( i - 1 ) [ 0 ] - 'a' ] )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxRepOpt1 ( self , text : str ) -> int : count = collections . Counter ( text ) groups = [[ c , len ( list ( group ))] for c , group in itertools . groupby ( text )] ans = max ( min ( length + 1 , count [ c ]) for c , length in groups ) for i in range ( 1 , len ( groups ) - 1 ): if groups [ i - 1 ][ 0 ] == groups [ i + 1 ][ 0 ] and groups [ i ][ 1 ] == 1 : ans = max ( ans , min ( groups [ i - 1 ][ 1 ] + groups [ i + 1 ][ 1 ] + 1 , count [ groups [ i - 1 ][ 0 ]])) return ans","title":"1156. Swap For Longest Repeated Character Substring"},{"location":"problems/1157/","text":"1157. Online Majority Element In Subarray Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MajorityChecker { public : MajorityChecker ( vector < int >& arr ) { for ( int i = 0 ; i < arr . size (); ++ i ) map [ arr [ i ]]. push_back ( i ); } int query ( int left , int right , int threshold ) { for ( auto & [ num , indices ] : map ) { if ( indices . size () < threshold ) continue ; auto it1 = lower_bound ( indices . begin (), indices . end (), left ); auto it2 = upper_bound ( indices . begin (), indices . end (), right ); if ( it2 - it1 >= threshold ) return num ; } return -1 ; } private : unordered_map < int , vector < int >> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MajorityChecker { public MajorityChecker ( int [] arr ) { map = new HashMap <> (); for ( int i = 0 ; i < arr . length ; ++ i ) { List < Integer > list = map . getOrDefault ( arr [ i ] , new ArrayList <> ()); list . add ( i ); map . put ( arr [ i ] , list ); } } public int query ( int left , int right , int threshold ) { for ( int num : map . keySet ()) { if ( map . get ( num ). size () < threshold ) continue ; int l = Collections . binarySearch ( map . get ( num ), left ); int r = Collections . binarySearch ( map . get ( num ), right + 1 ); if ( l < 0 ) l = - l - 1 ; if ( r < 0 ) r = - r - 1 ; if ( r - l >= threshold ) return num ; } return - 1 ; } private Map < Integer , List < Integer >> map ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MajorityChecker : def __init__ ( self , arr : List [ int ]): self . map = collections . defaultdict ( list ) for i , a in enumerate ( arr ): self . map [ a ] . append ( i ) def query ( self , left : int , right : int , threshold : int ) -> int : for num , indices in self . map . items (): if len ( indices ) < threshold : continue l = bisect . bisect ( indices , left - 1 ) r = bisect . bisect ( indices , right ) if r - l >= threshold : return num return - 1","title":"1157. Online Majority Element In Subarray"},{"location":"problems/1157/#1157-online-majority-element-in-subarray","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MajorityChecker { public : MajorityChecker ( vector < int >& arr ) { for ( int i = 0 ; i < arr . size (); ++ i ) map [ arr [ i ]]. push_back ( i ); } int query ( int left , int right , int threshold ) { for ( auto & [ num , indices ] : map ) { if ( indices . size () < threshold ) continue ; auto it1 = lower_bound ( indices . begin (), indices . end (), left ); auto it2 = upper_bound ( indices . begin (), indices . end (), right ); if ( it2 - it1 >= threshold ) return num ; } return -1 ; } private : unordered_map < int , vector < int >> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class MajorityChecker { public MajorityChecker ( int [] arr ) { map = new HashMap <> (); for ( int i = 0 ; i < arr . length ; ++ i ) { List < Integer > list = map . getOrDefault ( arr [ i ] , new ArrayList <> ()); list . add ( i ); map . put ( arr [ i ] , list ); } } public int query ( int left , int right , int threshold ) { for ( int num : map . keySet ()) { if ( map . get ( num ). size () < threshold ) continue ; int l = Collections . binarySearch ( map . get ( num ), left ); int r = Collections . binarySearch ( map . get ( num ), right + 1 ); if ( l < 0 ) l = - l - 1 ; if ( r < 0 ) r = - r - 1 ; if ( r - l >= threshold ) return num ; } return - 1 ; } private Map < Integer , List < Integer >> map ; } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MajorityChecker : def __init__ ( self , arr : List [ int ]): self . map = collections . defaultdict ( list ) for i , a in enumerate ( arr ): self . map [ a ] . append ( i ) def query ( self , left : int , right : int , threshold : int ) -> int : for num , indices in self . map . items (): if len ( indices ) < threshold : continue l = bisect . bisect ( indices , left - 1 ) r = bisect . bisect ( indices , right ) if r - l >= threshold : return num return - 1","title":"1157. Online Majority Element In Subarray"},{"location":"problems/1158/","text":"1158. Market Analysis I \ud83d\udd12","title":"1158. Market Analysis I"},{"location":"problems/1158/#1158-market-analysis-i","text":"","title":"1158. Market Analysis I \ud83d\udd12"},{"location":"problems/1159/","text":"1159. Market Analysis II \ud83d\udd12","title":"1159. Market Analysis II"},{"location":"problems/1159/#1159-market-analysis-ii","text":"","title":"1159. Market Analysis II \ud83d\udd12"},{"location":"problems/1160/","text":"1160. Find Words That Can Be Formed by Characters Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countCharacters ( vector < string >& words , string chars ) { int ans = 0 ; vector < int > count ( 26 ); for ( char c : chars ) ++ count [ c - 'a' ]; for ( const string & word : words ) { vector < int > tempCount = count ; for ( char c : word ) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countCharacters ( String [] words , String chars ) { int ans = 0 ; int [] count = new int [ 26 ] ; for ( char c : chars . toCharArray ()) ++ count [ c - 'a' ] ; for ( String word : words ) { int [] tempCount = Arrays . copyOf ( count , count . length ); for ( char c : word . toCharArray ()) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countCharacters ( self , words : List [ str ], chars : str ) -> int : ans = 0 count = collections . Counter ( chars ) for word in words : tempCount = count . copy () for c in word : tempCount [ c ] -= 1 if tempCount [ c ] < 0 : ans -= len ( word ) break ans += len ( word ) return ans","title":"1160. Find Words That Can Be Formed by Characters"},{"location":"problems/1160/#1160-find-words-that-can-be-formed-by-characters","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countCharacters ( vector < string >& words , string chars ) { int ans = 0 ; vector < int > count ( 26 ); for ( char c : chars ) ++ count [ c - 'a' ]; for ( const string & word : words ) { vector < int > tempCount = count ; for ( char c : word ) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int countCharacters ( String [] words , String chars ) { int ans = 0 ; int [] count = new int [ 26 ] ; for ( char c : chars . toCharArray ()) ++ count [ c - 'a' ] ; for ( String word : words ) { int [] tempCount = Arrays . copyOf ( count , count . length ); for ( char c : word . toCharArray ()) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countCharacters ( self , words : List [ str ], chars : str ) -> int : ans = 0 count = collections . Counter ( chars ) for word in words : tempCount = count . copy () for c in word : tempCount [ c ] -= 1 if tempCount [ c ] < 0 : ans -= len ( word ) break ans += len ( word ) return ans","title":"1160. Find Words That Can Be Formed by Characters"},{"location":"problems/1161/","text":"1161. Maximum Level Sum of a Binary Tree","title":"1161. Maximum Level Sum of a Binary Tree"},{"location":"problems/1161/#1161-maximum-level-sum-of-a-binary-tree","text":"","title":"1161. Maximum Level Sum of a Binary Tree"},{"location":"problems/1162/","text":"1162. As Far from Land as Possible","title":"1162. As Far from Land as Possible"},{"location":"problems/1162/#1162-as-far-from-land-as-possible","text":"","title":"1162. As Far from Land as Possible"},{"location":"problems/1163/","text":"1163. Last Substring in Lexicographical Order","title":"1163. Last Substring in Lexicographical Order"},{"location":"problems/1163/#1163-last-substring-in-lexicographical-order","text":"","title":"1163. Last Substring in Lexicographical Order"},{"location":"problems/1164/","text":"1164. Product Price at a Given Date \ud83d\udd12","title":"1164. Product Price at a Given Date"},{"location":"problems/1164/#1164-product-price-at-a-given-date","text":"","title":"1164. Product Price at a Given Date \ud83d\udd12"},{"location":"problems/1165/","text":"1165. Single-Row Keyboard \ud83d\udd12","title":"1165. Single-Row Keyboard"},{"location":"problems/1165/#1165-single-row-keyboard","text":"","title":"1165. Single-Row Keyboard \ud83d\udd12"},{"location":"problems/1166/","text":"1166. Design File System \ud83d\udd12","title":"1166. Design File System"},{"location":"problems/1166/#1166-design-file-system","text":"","title":"1166. Design File System \ud83d\udd12"},{"location":"problems/1167/","text":"1167. Minimum Cost to Connect Sticks \ud83d\udd12","title":"1167. Minimum Cost to Connect Sticks"},{"location":"problems/1167/#1167-minimum-cost-to-connect-sticks","text":"","title":"1167. Minimum Cost to Connect Sticks \ud83d\udd12"},{"location":"problems/1168/","text":"1168. Optimize Water Distribution in a Village \ud83d\udd12","title":"1168. Optimize Water Distribution in a Village"},{"location":"problems/1168/#1168-optimize-water-distribution-in-a-village","text":"","title":"1168. Optimize Water Distribution in a Village \ud83d\udd12"},{"location":"problems/1169/","text":"1169. Invalid Transactions Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < string > invalidTransactions ( vector < string >& transactions ) { unordered_set < string > ans ; unordered_map < string , vector < vector < string >>> nameToTransactions ; for ( const string & transaction : transactions ) { istringstream ss ( transaction ); vector < string > token ( 4 , \"\" ); for ( int i = 0 ; getline ( ss , token [ i ++ ], ',' );) ; if ( stoi ( token [ 2 ]) > 1000 ) ans . insert ( transaction ); for ( const auto & val : nameToTransactions [ token [ 0 ]]) if ( abs ( stoi ( val [ 1 ]) - stoi ( token [ 1 ])) <= 60 && val [ 3 ] != token [ 3 ]) { ans . insert ( transaction ); ans . insert ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ]); } nameToTransactions [ token [ 0 ]]. push_back ( { token [ 0 ], token [ 1 ], token [ 2 ], token [ 3 ]}); } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > invalidTransactions ( String [] transactions ) { Set < String > ans = new HashSet <> (); Map < String , List < String []>> nameToTransactions = new HashMap <> (); for ( final String transaction : transactions ) { String [] token = transaction . split ( \",\" ); if ( Integer . valueOf ( token [ 2 ] ) > 1000 ) ans . add ( transaction ); if ( nameToTransactions . containsKey ( token [ 0 ] )) for ( final String [] val : nameToTransactions . get ( token [ 0 ] )) if ( Math . abs ( Integer . valueOf ( val [ 1 ] ) - Integer . valueOf ( token [ 1 ] )) <= 60 && ! val [ 3 ] . equals ( token [ 3 ] )) { ans . add ( transaction ); ans . add ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ] ); } nameToTransactions . computeIfAbsent ( token [ 0 ] , k -> new ArrayList <> ()) . add ( new String [] { token [ 0 ] , token [ 1 ] , token [ 2 ] , token [ 3 ] }); } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def invalidTransactions ( self , transactions : List [ str ]) -> List [ str ]: ans = set () nameToTransactions = collections . defaultdict ( list ) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) nameToTransactions [ name ] . append ({ 'time' : time , 'city' : city }) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) if amount > 1000 : ans . add ( transaction ) elif name in nameToTransactions : for sameName in nameToTransactions [ name ]: if 0 <= abs ( sameName [ 'time' ] - time ) <= 60 and sameName [ 'city' ] != city : ans . add ( transaction ) return ans","title":"1169. Invalid Transactions"},{"location":"problems/1169/#1169-invalid-transactions","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < string > invalidTransactions ( vector < string >& transactions ) { unordered_set < string > ans ; unordered_map < string , vector < vector < string >>> nameToTransactions ; for ( const string & transaction : transactions ) { istringstream ss ( transaction ); vector < string > token ( 4 , \"\" ); for ( int i = 0 ; getline ( ss , token [ i ++ ], ',' );) ; if ( stoi ( token [ 2 ]) > 1000 ) ans . insert ( transaction ); for ( const auto & val : nameToTransactions [ token [ 0 ]]) if ( abs ( stoi ( val [ 1 ]) - stoi ( token [ 1 ])) <= 60 && val [ 3 ] != token [ 3 ]) { ans . insert ( transaction ); ans . insert ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ]); } nameToTransactions [ token [ 0 ]]. push_back ( { token [ 0 ], token [ 1 ], token [ 2 ], token [ 3 ]}); } return { begin ( ans ), end ( ans )}; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < String > invalidTransactions ( String [] transactions ) { Set < String > ans = new HashSet <> (); Map < String , List < String []>> nameToTransactions = new HashMap <> (); for ( final String transaction : transactions ) { String [] token = transaction . split ( \",\" ); if ( Integer . valueOf ( token [ 2 ] ) > 1000 ) ans . add ( transaction ); if ( nameToTransactions . containsKey ( token [ 0 ] )) for ( final String [] val : nameToTransactions . get ( token [ 0 ] )) if ( Math . abs ( Integer . valueOf ( val [ 1 ] ) - Integer . valueOf ( token [ 1 ] )) <= 60 && ! val [ 3 ] . equals ( token [ 3 ] )) { ans . add ( transaction ); ans . add ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ] ); } nameToTransactions . computeIfAbsent ( token [ 0 ] , k -> new ArrayList <> ()) . add ( new String [] { token [ 0 ] , token [ 1 ] , token [ 2 ] , token [ 3 ] }); } return new ArrayList <> ( ans ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def invalidTransactions ( self , transactions : List [ str ]) -> List [ str ]: ans = set () nameToTransactions = collections . defaultdict ( list ) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) nameToTransactions [ name ] . append ({ 'time' : time , 'city' : city }) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) if amount > 1000 : ans . add ( transaction ) elif name in nameToTransactions : for sameName in nameToTransactions [ name ]: if 0 <= abs ( sameName [ 'time' ] - time ) <= 60 and sameName [ 'city' ] != city : ans . add ( transaction ) return ans","title":"1169. Invalid Transactions"},{"location":"problems/1170/","text":"1170. Compare Strings by Frequency of the Smallest Character Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { vector < int > ans ; vector < int > wordsFreq ; for ( const string & word : words ) wordsFreq . push_back ( f ( word )); sort ( begin ( wordsFreq ), end ( wordsFreq )); for ( const string & query : queries ) { int freq = f ( query ); ans . push_back ( end ( wordsFreq ) - upper_bound ( begin ( wordsFreq ), end ( wordsFreq ), freq )); } return ans ; } private : int f ( const string & word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word ) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int [] numSmallerByFrequency ( String [] queries , String [] words ) { int [] ans = new int [ queries . length ] ; int [] wordsFreq = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) wordsFreq [ i ] = f ( words [ i ] ); Arrays . sort ( wordsFreq ); for ( int i = 0 ; i < queries . length ; ++ i ) { int freq = f ( queries [ i ] ); ans [ i ] = words . length - upper_bound ( wordsFreq , 0 , wordsFreq . length , freq ); } return ans ; } private int f ( String word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word . toCharArray ()) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } private int upper_bound ( int [] nums , int l , int r , int value ) { while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] <= value ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numSmallerByFrequency ( self , queries : List [ str ], words : List [ str ]) -> List [ int ]: ans = [] wordsFreq = sorted ([ word . count ( min ( word )) for word in words ]) for query in queries : count = query . count ( min ( query )) index = bisect . bisect ( wordsFreq , count ) ans . append ( len ( words ) - index ) return ans","title":"1170. Compare Strings by Frequency of the Smallest Character"},{"location":"problems/1170/#1170-compare-strings-by-frequency-of-the-smallest-character","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { vector < int > ans ; vector < int > wordsFreq ; for ( const string & word : words ) wordsFreq . push_back ( f ( word )); sort ( begin ( wordsFreq ), end ( wordsFreq )); for ( const string & query : queries ) { int freq = f ( query ); ans . push_back ( end ( wordsFreq ) - upper_bound ( begin ( wordsFreq ), end ( wordsFreq ), freq )); } return ans ; } private : int f ( const string & word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word ) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int [] numSmallerByFrequency ( String [] queries , String [] words ) { int [] ans = new int [ queries . length ] ; int [] wordsFreq = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) wordsFreq [ i ] = f ( words [ i ] ); Arrays . sort ( wordsFreq ); for ( int i = 0 ; i < queries . length ; ++ i ) { int freq = f ( queries [ i ] ); ans [ i ] = words . length - upper_bound ( wordsFreq , 0 , wordsFreq . length , freq ); } return ans ; } private int f ( String word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word . toCharArray ()) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } private int upper_bound ( int [] nums , int l , int r , int value ) { while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] <= value ) l = m + 1 ; else r = m ; } return l ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numSmallerByFrequency ( self , queries : List [ str ], words : List [ str ]) -> List [ int ]: ans = [] wordsFreq = sorted ([ word . count ( min ( word )) for word in words ]) for query in queries : count = query . count ( min ( query )) index = bisect . bisect ( wordsFreq , count ) ans . append ( len ( words ) - index ) return ans","title":"1170. Compare Strings by Frequency of the Smallest Character"},{"location":"problems/1171/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : ListNode * removeZeroSumSublists ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int prefixSum = 0 ; unordered_map < int , ListNode *> prefixSumToNode ; prefixSumToNode [ 0 ] = & dummy ; for (; head ; head = head -> next ) { prefixSum += head -> val ; prefixSumToNode [ prefixSum ] = head ; } prefixSum = 0 ; for ( head = & dummy ; head ; head = head -> next ) { prefixSum += head -> val ; head -> next = prefixSumToNode [ prefixSum ] -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public ListNode removeZeroSumSublists ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int prefixSum = 0 ; Map < Integer , ListNode > prefixSumToNode = new HashMap <> (); prefixSumToNode . put ( 0 , dummy ); for (; head != null ; head = head . next ) { prefixSum += head . val ; prefixSumToNode . put ( prefixSum , head ); } prefixSum = 0 ; for ( head = dummy ; head != null ; head = head . next ) { prefixSum += head . val ; head . next = prefixSumToNode . get ( prefixSum ). next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def removeZeroSumSublists ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prefixSum = 0 prefixSumToNode = { 0 : dummy } while head : prefixSum += head . val prefixSumToNode [ prefixSum ] = head head = head . next prefixSum = 0 head = dummy while head : prefixSum += head . val head . next = prefixSumToNode [ prefixSum ] . next head = head . next return dummy . next","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List"},{"location":"problems/1171/#1171-remove-zero-sum-consecutive-nodes-from-linked-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : ListNode * removeZeroSumSublists ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int prefixSum = 0 ; unordered_map < int , ListNode *> prefixSumToNode ; prefixSumToNode [ 0 ] = & dummy ; for (; head ; head = head -> next ) { prefixSum += head -> val ; prefixSumToNode [ prefixSum ] = head ; } prefixSum = 0 ; for ( head = & dummy ; head ; head = head -> next ) { prefixSum += head -> val ; head -> next = prefixSumToNode [ prefixSum ] -> next ; } return dummy . next ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public ListNode removeZeroSumSublists ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int prefixSum = 0 ; Map < Integer , ListNode > prefixSumToNode = new HashMap <> (); prefixSumToNode . put ( 0 , dummy ); for (; head != null ; head = head . next ) { prefixSum += head . val ; prefixSumToNode . put ( prefixSum , head ); } prefixSum = 0 ; for ( head = dummy ; head != null ; head = head . next ) { prefixSum += head . val ; head . next = prefixSumToNode . get ( prefixSum ). next ; } return dummy . next ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def removeZeroSumSublists ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prefixSum = 0 prefixSumToNode = { 0 : dummy } while head : prefixSum += head . val prefixSumToNode [ prefixSum ] = head head = head . next prefixSum = 0 head = dummy while head : prefixSum += head . val head . next = prefixSumToNode [ prefixSum ] . next head = head . next return dummy . next","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List"},{"location":"problems/1172/","text":"1172. Dinner Plate Stacks","title":"1172. Dinner Plate Stacks"},{"location":"problems/1172/#1172-dinner-plate-stacks","text":"","title":"1172. Dinner Plate Stacks"},{"location":"problems/1173/","text":"1173. Immediate Food Delivery I \ud83d\udd12","title":"1173. Immediate Food Delivery I"},{"location":"problems/1173/#1173-immediate-food-delivery-i","text":"","title":"1173. Immediate Food Delivery I \ud83d\udd12"},{"location":"problems/1174/","text":"1174. Immediate Food Delivery II \ud83d\udd12","title":"1174. Immediate Food Delivery II"},{"location":"problems/1174/#1174-immediate-food-delivery-ii","text":"","title":"1174. Immediate Food Delivery II \ud83d\udd12"},{"location":"problems/1175/","text":"1175. Prime Arrangements Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int numPrimeArrangements ( int n ) { const int kMod = 1e9 + 7 ; int count = countPrimes ( n ); return ( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ; } private : int countPrimes ( int n ) { vector < bool > prime ( n + 1 , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i <= sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } long factorial ( int n , const int kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int numPrimeArrangements ( int n ) { final long kMod = ( long ) 1e9 + 7 ; int count = countPrimes ( n ); return ( int ) (( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ); } private int countPrimes ( int n ) { boolean [] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , 2 , n + 1 , true ); for ( int i = 0 ; i * i <= n ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; int count = 0 ; for ( boolean p : prime ) if ( p ) ++ count ; return count ; } long factorial ( int n , final long kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def numPrimeArrangements ( self , n : int ) -> int : def countPrimes ( n : int ) -> int : isPrime = [ False ] * 2 + [ True ] * ( n - 1 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n + 1 , i ): isPrime [ j ] = False return sum ( isPrime ) def factorial ( n : int ) -> int : fact = 1 for i in range ( 1 , n + 1 ): fact = fact * i % kMod return fact kMod = int ( 1e9 + 7 ) count = countPrimes ( n ) return factorial ( count ) * factorial ( n - count ) % kMod","title":"1175. Prime Arrangements"},{"location":"problems/1175/#1175-prime-arrangements","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int numPrimeArrangements ( int n ) { const int kMod = 1e9 + 7 ; int count = countPrimes ( n ); return ( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ; } private : int countPrimes ( int n ) { vector < bool > prime ( n + 1 , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i <= sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } long factorial ( int n , const int kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int numPrimeArrangements ( int n ) { final long kMod = ( long ) 1e9 + 7 ; int count = countPrimes ( n ); return ( int ) (( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ); } private int countPrimes ( int n ) { boolean [] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , 2 , n + 1 , true ); for ( int i = 0 ; i * i <= n ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; int count = 0 ; for ( boolean p : prime ) if ( p ) ++ count ; return count ; } long factorial ( int n , final long kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def numPrimeArrangements ( self , n : int ) -> int : def countPrimes ( n : int ) -> int : isPrime = [ False ] * 2 + [ True ] * ( n - 1 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n + 1 , i ): isPrime [ j ] = False return sum ( isPrime ) def factorial ( n : int ) -> int : fact = 1 for i in range ( 1 , n + 1 ): fact = fact * i % kMod return fact kMod = int ( 1e9 + 7 ) count = countPrimes ( n ) return factorial ( count ) * factorial ( n - count ) % kMod","title":"1175. Prime Arrangements"},{"location":"problems/1176/","text":"1176. Diet Plan Performance \ud83d\udd12","title":"1176. Diet Plan Performance"},{"location":"problems/1176/#1176-diet-plan-performance","text":"","title":"1176. Diet Plan Performance \ud83d\udd12"},{"location":"problems/1177/","text":"1177. Can Make Palindrome from Substring Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < bool > canMakePaliQueries ( string s , vector < vector < int >>& queries ) { vector < bool > ans ; vector < int > dp ( s . length () + 1 ); for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s [ i - 1 ] - 'a' ); for ( vector < int >& query : queries ) { int odds = __builtin_popcount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]]); ans . push_back ( odds / 2 <= query [ 2 ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Boolean > canMakePaliQueries ( String s , int [][] queries ) { List < Boolean > ans = new ArrayList <> (); int [] dp = new int [ s . length () + 1 ] ; for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s . charAt ( i - 1 ) - 'a' ); for ( int [] query : queries ) { int odds = Integer . bitCount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]] ); ans . add ( odds / 2 <= query [ 2 ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canMakePaliQueries ( self , s : str , queries : List [ List [ int ]]) -> List [ bool ]: def ones ( x ): return bin ( x ) . count ( '1' ) dp = [ 0 ] * ( len ( s ) + 1 ) for i in range ( 1 , len ( s ) + 1 ): dp [ i ] = dp [ i - 1 ] ^ ( 1 << ord ( s [ i - 1 ]) - ord ( 'a' )) return [ ones ( dp [ right + 1 ] ^ dp [ left ]) // 2 <= k for left , right , k in queries ]","title":"1177. Can Make Palindrome from Substring"},{"location":"problems/1177/#1177-can-make-palindrome-from-substring","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < bool > canMakePaliQueries ( string s , vector < vector < int >>& queries ) { vector < bool > ans ; vector < int > dp ( s . length () + 1 ); for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s [ i - 1 ] - 'a' ); for ( vector < int >& query : queries ) { int odds = __builtin_popcount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]]); ans . push_back ( odds / 2 <= query [ 2 ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Boolean > canMakePaliQueries ( String s , int [][] queries ) { List < Boolean > ans = new ArrayList <> (); int [] dp = new int [ s . length () + 1 ] ; for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s . charAt ( i - 1 ) - 'a' ); for ( int [] query : queries ) { int odds = Integer . bitCount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]] ); ans . add ( odds / 2 <= query [ 2 ] ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canMakePaliQueries ( self , s : str , queries : List [ List [ int ]]) -> List [ bool ]: def ones ( x ): return bin ( x ) . count ( '1' ) dp = [ 0 ] * ( len ( s ) + 1 ) for i in range ( 1 , len ( s ) + 1 ): dp [ i ] = dp [ i - 1 ] ^ ( 1 << ord ( s [ i - 1 ]) - ord ( 'a' )) return [ ones ( dp [ right + 1 ] ^ dp [ left ]) // 2 <= k for left , right , k in queries ]","title":"1177. Can Make Palindrome from Substring"},{"location":"problems/1178/","text":"1178. Number of Valid Words for Each Puzzle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { vector < int > ans ; unordered_map < int , int > binaryCount ; for ( const string & word : words ) { int mask = 0 ; for ( char c : word ) mask |= 1 << ( c - 'a' ); ++ binaryCount [ mask ]; } for ( const string & puzzle : puzzles ) { int valid = 0 ; const int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle [ 0 ] - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if ( i & ( 1 << j )) mask |= 1 << ( puzzle [ j + 1 ] - 'a' ); if ( binaryCount . count ( mask )) valid += binaryCount [ mask ]; } ans . push_back ( valid ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < Integer > findNumOfValidWords ( String [] words , String [] puzzles ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > binaryCount = new HashMap <> (); for ( final String word : words ) { int mask = 0 ; for ( char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); binaryCount . put ( mask , binaryCount . getOrDefault ( mask , 0 ) + 1 ); } for ( final String puzzle : puzzles ) { int valid = 0 ; final int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle . charAt ( 0 ) - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if (( i & ( 1 << j )) > 0 ) mask |= 1 << ( puzzle . charAt ( j + 1 ) - 'a' ); if ( binaryCount . containsKey ( mask )) valid += binaryCount . get ( mask ); } ans . add ( valid ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findNumOfValidWords ( self , words : List [ str ], puzzles : List [ str ]) -> List [ int ]: ans = [] binaryCount = collections . Counter () for word in words : mask = 0 for c in word : mask |= 1 << ( ord ( c ) - ord ( 'a' )) binaryCount [ mask ] += 1 for puzzle in puzzles : valid = 0 n = len ( puzzle ) - 1 for i in range ( 1 << n ): mask = 1 << ( ord ( puzzle [ 0 ]) - ord ( 'a' )) for j in range ( n ): if i & ( 1 << j ): mask |= 1 << ( ord ( puzzle [ j + 1 ]) - ord ( 'a' )) if mask in binaryCount : valid += binaryCount [ mask ] ans . append ( valid ) return ans","title":"1178. Number of Valid Words for Each Puzzle"},{"location":"problems/1178/#1178-number-of-valid-words-for-each-puzzle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { vector < int > ans ; unordered_map < int , int > binaryCount ; for ( const string & word : words ) { int mask = 0 ; for ( char c : word ) mask |= 1 << ( c - 'a' ); ++ binaryCount [ mask ]; } for ( const string & puzzle : puzzles ) { int valid = 0 ; const int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle [ 0 ] - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if ( i & ( 1 << j )) mask |= 1 << ( puzzle [ j + 1 ] - 'a' ); if ( binaryCount . count ( mask )) valid += binaryCount [ mask ]; } ans . push_back ( valid ); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < Integer > findNumOfValidWords ( String [] words , String [] puzzles ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > binaryCount = new HashMap <> (); for ( final String word : words ) { int mask = 0 ; for ( char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); binaryCount . put ( mask , binaryCount . getOrDefault ( mask , 0 ) + 1 ); } for ( final String puzzle : puzzles ) { int valid = 0 ; final int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle . charAt ( 0 ) - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if (( i & ( 1 << j )) > 0 ) mask |= 1 << ( puzzle . charAt ( j + 1 ) - 'a' ); if ( binaryCount . containsKey ( mask )) valid += binaryCount . get ( mask ); } ans . add ( valid ); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findNumOfValidWords ( self , words : List [ str ], puzzles : List [ str ]) -> List [ int ]: ans = [] binaryCount = collections . Counter () for word in words : mask = 0 for c in word : mask |= 1 << ( ord ( c ) - ord ( 'a' )) binaryCount [ mask ] += 1 for puzzle in puzzles : valid = 0 n = len ( puzzle ) - 1 for i in range ( 1 << n ): mask = 1 << ( ord ( puzzle [ 0 ]) - ord ( 'a' )) for j in range ( n ): if i & ( 1 << j ): mask |= 1 << ( ord ( puzzle [ j + 1 ]) - ord ( 'a' )) if mask in binaryCount : valid += binaryCount [ mask ] ans . append ( valid ) return ans","title":"1178. Number of Valid Words for Each Puzzle"},{"location":"problems/1179/","text":"1179. Reformat Department Table","title":"1179. Reformat Department Table"},{"location":"problems/1179/#1179-reformat-department-table","text":"","title":"1179. Reformat Department Table"},{"location":"problems/1180/","text":"1180. Count Substrings with Only One Distinct Letter \ud83d\udd12","title":"1180. Count Substrings with Only One Distinct Letter"},{"location":"problems/1180/#1180-count-substrings-with-only-one-distinct-letter","text":"","title":"1180. Count Substrings with Only One Distinct Letter \ud83d\udd12"},{"location":"problems/1181/","text":"1181. Before and After Puzzle \ud83d\udd12","title":"1181. Before and After Puzzle"},{"location":"problems/1181/#1181-before-and-after-puzzle","text":"","title":"1181. Before and After Puzzle \ud83d\udd12"},{"location":"problems/1182/","text":"1182. Shortest Distance to Target Color \ud83d\udd12","title":"1182. Shortest Distance to Target Color"},{"location":"problems/1182/#1182-shortest-distance-to-target-color","text":"","title":"1182. Shortest Distance to Target Color \ud83d\udd12"},{"location":"problems/1183/","text":"1183. Maximum Number of Ones \ud83d\udd12","title":"1183. Maximum Number of Ones"},{"location":"problems/1183/#1183-maximum-number-of-ones","text":"","title":"1183. Maximum Number of Ones \ud83d\udd12"},{"location":"problems/1184/","text":"1184. Distance Between Bus Stops Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int distanceBetweenBusStops ( vector < int >& distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) swap ( start , destination ); for ( int i = 0 ; i < distance . size (); ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ]; else counterclockwise += distance [ i ]; } return min ( clockwise , counterclockwise ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int distanceBetweenBusStops ( int [] distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) { int temp = start ; start = destination ; destination = temp ; } for ( int i = 0 ; i < distance . length ; ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ] ; else counterclockwise += distance [ i ] ; } return Math . min ( clockwise , counterclockwise ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def distanceBetweenBusStops ( self , distance : List [ int ], start : int , destination : int ) -> int : clockwise = 0 counterclockwise = 0 if start > destination : start , destination = destination , start for i , d in enumerate ( distance ): if i >= start and i < destination : clockwise += d else : counterclockwise += d return min ( clockwise , counterclockwise )","title":"1184. Distance Between Bus Stops"},{"location":"problems/1184/#1184-distance-between-bus-stops","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int distanceBetweenBusStops ( vector < int >& distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) swap ( start , destination ); for ( int i = 0 ; i < distance . size (); ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ]; else counterclockwise += distance [ i ]; } return min ( clockwise , counterclockwise ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int distanceBetweenBusStops ( int [] distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) { int temp = start ; start = destination ; destination = temp ; } for ( int i = 0 ; i < distance . length ; ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ] ; else counterclockwise += distance [ i ] ; } return Math . min ( clockwise , counterclockwise ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def distanceBetweenBusStops ( self , distance : List [ int ], start : int , destination : int ) -> int : clockwise = 0 counterclockwise = 0 if start > destination : start , destination = destination , start for i , d in enumerate ( distance ): if i >= start and i < destination : clockwise += d else : counterclockwise += d return min ( clockwise , counterclockwise )","title":"1184. Distance Between Bus Stops"},{"location":"problems/1185/","text":"1185. Day of the Week Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string dayOfTheWeek ( int day , int month , int year ) { vector < string > week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ]; count += day ; return week [( count + 4 ) % 7 ]; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String dayOfTheWeek ( int day , int month , int year ) { String [] week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; int [] days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ] ; count += day ; return week [ ( count + 4 ) % 7 ] ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def dayOfTheWeek ( self , day : int , month : int , year : int ) -> str : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 week = [ \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" ] days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] count = 0 for i in range ( 1971 , year ): count += 366 if i % 4 == 0 else 365 for i in range ( month - 1 ): count += days [ i ] count += day return week [( count + 4 ) % 7 ]","title":"1185. Day of the Week"},{"location":"problems/1185/#1185-day-of-the-week","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string dayOfTheWeek ( int day , int month , int year ) { vector < string > week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ]; count += day ; return week [( count + 4 ) % 7 ]; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public String dayOfTheWeek ( int day , int month , int year ) { String [] week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; int [] days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ] ; count += day ; return week [ ( count + 4 ) % 7 ] ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def dayOfTheWeek ( self , day : int , month : int , year : int ) -> str : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 week = [ \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" ] days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] count = 0 for i in range ( 1971 , year ): count += 366 if i % 4 == 0 else 365 for i in range ( month - 1 ): count += days [ i ] count += day return week [( count + 4 ) % 7 ]","title":"1185. Day of the Week"},{"location":"problems/1186/","text":"1186. Maximum Subarray Sum with One Deletion","title":"1186. Maximum Subarray Sum with One Deletion"},{"location":"problems/1186/#1186-maximum-subarray-sum-with-one-deletion","text":"","title":"1186. Maximum Subarray Sum with One Deletion"},{"location":"problems/1187/","text":"1187. Make Array Strictly Increasing","title":"1187. Make Array Strictly Increasing"},{"location":"problems/1187/#1187-make-array-strictly-increasing","text":"","title":"1187. Make Array Strictly Increasing"},{"location":"problems/1188/","text":"1188. Design Bounded Blocking Queue \ud83d\udd12","title":"1188. Design Bounded Blocking Queue"},{"location":"problems/1188/#1188-design-bounded-blocking-queue","text":"","title":"1188. Design Bounded Blocking Queue \ud83d\udd12"},{"location":"problems/1189/","text":"1189. Maximum Number of Balloons Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxNumberOfBalloons ( string text ) { int ans = INT_MAX ; vector < int > count ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : string ( \"ban\" )) ans = min ( ans , count [ c - 'a' ]); for ( char c : string ( \"lo\" )) ans = min ( ans , count [ c - 'a' ] / 2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxNumberOfBalloons ( String text ) { int ans = Integer . MAX_VALUE ; int [] count = new int [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : new char [] { 'b' , 'a' , 'n' }) ans = Math . min ( ans , count [ c - 'a' ] ); for ( char c : new char [] { 'o' , 'l' }) ans = Math . min ( ans , count [ c - 'a' ] / 2 ); return ans ; } } Python 1 2 3 4 class Solution : def maxNumberOfBalloons ( self , text : str ) -> int : count = collections . Counter ( text ) return min ( count [ 'b' ], count [ 'a' ], count [ 'l' ] // 2 , count [ 'o' ] // 2 , count [ 'n' ])","title":"1189. Maximum Number of Balloons"},{"location":"problems/1189/#1189-maximum-number-of-balloons","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxNumberOfBalloons ( string text ) { int ans = INT_MAX ; vector < int > count ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : string ( \"ban\" )) ans = min ( ans , count [ c - 'a' ]); for ( char c : string ( \"lo\" )) ans = min ( ans , count [ c - 'a' ] / 2 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxNumberOfBalloons ( String text ) { int ans = Integer . MAX_VALUE ; int [] count = new int [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : new char [] { 'b' , 'a' , 'n' }) ans = Math . min ( ans , count [ c - 'a' ] ); for ( char c : new char [] { 'o' , 'l' }) ans = Math . min ( ans , count [ c - 'a' ] / 2 ); return ans ; } } Python 1 2 3 4 class Solution : def maxNumberOfBalloons ( self , text : str ) -> int : count = collections . Counter ( text ) return min ( count [ 'b' ], count [ 'a' ], count [ 'l' ] // 2 , count [ 'o' ] // 2 , count [ 'n' ])","title":"1189. Maximum Number of Balloons"},{"location":"problems/1190/","text":"1190. Reverse Substrings Between Each Pair of Parentheses","title":"1190. Reverse Substrings Between Each Pair of Parentheses"},{"location":"problems/1190/#1190-reverse-substrings-between-each-pair-of-parentheses","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses"},{"location":"problems/1191/","text":"1191. K-Concatenation Maximum Sum","title":"1191. K-Concatenation Maximum Sum"},{"location":"problems/1191/#1191-k-concatenation-maximum-sum","text":"","title":"1191. K-Concatenation Maximum Sum"},{"location":"problems/1192/","text":"1192. Critical Connections in a Network Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> criticalConnections ( int n , vector < vector < int >>& connections ) { vector < vector < int >> ans ; vector < vector < int >> graph ( n ); vector < int > ranks ( n , NO_RANK ); for ( const vector < int >& conn : connections ) { graph [ conn [ 0 ]]. push_back ( conn [ 1 ]); graph [ conn [ 1 ]]. push_back ( conn [ 0 ]); } // return the minRank that current node can (indirectly) reach function < int ( int , int ) > dfs = [ & ]( int node , int myRank ) { if ( ranks [ node ] != NO_RANK ) return ranks [ node ]; ranks [ node ] = myRank ; int minRank = myRank ; for ( const int neighbor : graph [ node ]) { // parent (that's why NO_RANK = -2 instead of -1) || visited if ( ranks [ neighbor ] == myRank - 1 || ranks [ neighbor ] == n ) continue ; const int neighborRank = dfs ( neighbor , myRank + 1 ); if ( neighborRank == myRank + 1 ) // path(node, neighbor) is the only way ans . push_back ({ node , neighbor }); // for node go to neighbor minRank = min ( minRank , neighborRank ); } ranks [ node ] = n ; // mark as visited return minRank ; }; dfs ( 0 , 0 ); return ans ; } private : const int NO_RANK = -2 ; };","title":"1192. Critical Connections in a Network"},{"location":"problems/1192/#1192-critical-connections-in-a-network","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < vector < int >> criticalConnections ( int n , vector < vector < int >>& connections ) { vector < vector < int >> ans ; vector < vector < int >> graph ( n ); vector < int > ranks ( n , NO_RANK ); for ( const vector < int >& conn : connections ) { graph [ conn [ 0 ]]. push_back ( conn [ 1 ]); graph [ conn [ 1 ]]. push_back ( conn [ 0 ]); } // return the minRank that current node can (indirectly) reach function < int ( int , int ) > dfs = [ & ]( int node , int myRank ) { if ( ranks [ node ] != NO_RANK ) return ranks [ node ]; ranks [ node ] = myRank ; int minRank = myRank ; for ( const int neighbor : graph [ node ]) { // parent (that's why NO_RANK = -2 instead of -1) || visited if ( ranks [ neighbor ] == myRank - 1 || ranks [ neighbor ] == n ) continue ; const int neighborRank = dfs ( neighbor , myRank + 1 ); if ( neighborRank == myRank + 1 ) // path(node, neighbor) is the only way ans . push_back ({ node , neighbor }); // for node go to neighbor minRank = min ( minRank , neighborRank ); } ranks [ node ] = n ; // mark as visited return minRank ; }; dfs ( 0 , 0 ); return ans ; } private : const int NO_RANK = -2 ; };","title":"1192. Critical Connections in a Network"},{"location":"problems/1193/","text":"1193. Monthly Transactions I \ud83d\udd12","title":"1193. Monthly Transactions I"},{"location":"problems/1193/#1193-monthly-transactions-i","text":"","title":"1193. Monthly Transactions I \ud83d\udd12"},{"location":"problems/1194/","text":"1194. Tournament Winners \ud83d\udd12","title":"1194. Tournament Winners"},{"location":"problems/1194/#1194-tournament-winners","text":"","title":"1194. Tournament Winners \ud83d\udd12"},{"location":"problems/1195/","text":"1195. Fizz Buzz Multithreaded","title":"1195. Fizz Buzz Multithreaded"},{"location":"problems/1195/#1195-fizz-buzz-multithreaded","text":"","title":"1195. Fizz Buzz Multithreaded"},{"location":"problems/1196/","text":"1196. How Many Apples Can You Put into the Basket \ud83d\udd12","title":"1196. How Many Apples Can You Put into the Basket"},{"location":"problems/1196/#1196-how-many-apples-can-you-put-into-the-basket","text":"","title":"1196. How Many Apples Can You Put into the Basket \ud83d\udd12"},{"location":"problems/1197/","text":"1197. Minimum Knight Moves \ud83d\udd12 Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int minKnightMoves ( int x , int y ) { unordered_map < pair < int , int > , int , pairHash > memo ; function < int ( int , int ) > dp = [ & ]( int x , int y ) { if ( memo . count ({ x , y })) return memo [{ x , y }]; if ( x + y == 0 ) // (0, 0) return 0 ; if ( x + y == 2 ) // (0, 2), (1, 1), (2, 0) return 2 ; return memo [{ x , y }] = min ( dp ( abs ( x - 1 ), abs ( y - 2 )), dp ( abs ( x - 2 ), abs ( y - 1 ))) + 1 ; }; return dp ( abs ( x ), abs ( y )); } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; };","title":"1197. Minimum Knight Moves"},{"location":"problems/1197/#1197-minimum-knight-moves","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int minKnightMoves ( int x , int y ) { unordered_map < pair < int , int > , int , pairHash > memo ; function < int ( int , int ) > dp = [ & ]( int x , int y ) { if ( memo . count ({ x , y })) return memo [{ x , y }]; if ( x + y == 0 ) // (0, 0) return 0 ; if ( x + y == 2 ) // (0, 2), (1, 1), (2, 0) return 2 ; return memo [{ x , y }] = min ( dp ( abs ( x - 1 ), abs ( y - 2 )), dp ( abs ( x - 2 ), abs ( y - 1 ))) + 1 ; }; return dp ( abs ( x ), abs ( y )); } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; };","title":"1197. Minimum Knight Moves \ud83d\udd12"},{"location":"problems/1198/","text":"1198. Find Smallest Common Element in All Rows \ud83d\udd12","title":"1198. Find Smallest Common Element in All Rows"},{"location":"problems/1198/#1198-find-smallest-common-element-in-all-rows","text":"","title":"1198. Find Smallest Common Element in All Rows \ud83d\udd12"},{"location":"problems/1199/","text":"1199. Minimum Time to Build Blocks \ud83d\udd12","title":"1199. Minimum Time to Build Blocks"},{"location":"problems/1199/#1199-minimum-time-to-build-blocks","text":"","title":"1199. Minimum Time to Build Blocks \ud83d\udd12"},{"location":"problems/1200/","text":"1200. Minimum Absolute Difference Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> minimumAbsDifference ( vector < int >& arr ) { vector < vector < int >> ans ; int min = INT_MAX ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i + 1 < arr . size (); ++ i ) { int diff = arr [ i + 1 ] - arr [ i ]; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . push_back ({ arr [ i ], arr [ i + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public List < List < Integer >> minimumAbsDifference ( int [] arr ) { List < List < Integer >> ans = new ArrayList <> (); int min = Integer . MAX_VALUE ; Arrays . sort ( arr ); for ( int i = 0 ; i + 1 < arr . length ; ++ i ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . add ( Arrays . asList ( arr [ i ] , arr [ i + 1 ] )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minimumAbsDifference ( self , arr : List [ int ]) -> List [ List [ int ]]: ans = [] min = float ( 'inf' ) arr . sort () for i in range ( len ( arr ) - 1 ): diff = arr [ i + 1 ] - arr [ i ] if diff < min : min = diff ans = [] if diff == min : ans . append ([ arr [ i ], arr [ i + 1 ]]) return ans","title":"1200. Minimum Absolute Difference"},{"location":"problems/1200/#1200-minimum-absolute-difference","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> minimumAbsDifference ( vector < int >& arr ) { vector < vector < int >> ans ; int min = INT_MAX ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i + 1 < arr . size (); ++ i ) { int diff = arr [ i + 1 ] - arr [ i ]; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . push_back ({ arr [ i ], arr [ i + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public List < List < Integer >> minimumAbsDifference ( int [] arr ) { List < List < Integer >> ans = new ArrayList <> (); int min = Integer . MAX_VALUE ; Arrays . sort ( arr ); for ( int i = 0 ; i + 1 < arr . length ; ++ i ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . add ( Arrays . asList ( arr [ i ] , arr [ i + 1 ] )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minimumAbsDifference ( self , arr : List [ int ]) -> List [ List [ int ]]: ans = [] min = float ( 'inf' ) arr . sort () for i in range ( len ( arr ) - 1 ): diff = arr [ i + 1 ] - arr [ i ] if diff < min : min = diff ans = [] if diff == min : ans . append ([ arr [ i ], arr [ i + 1 ]]) return ans","title":"1200. Minimum Absolute Difference"},{"location":"problems/1201/","text":"1201. Ugly Number III Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / __gcd ( a , b ); long ac = a * c / __gcd ( a , c ); long bc = b * c / __gcd ( b , c ); long abc = a * bc / __gcd ( a , bc ); int l = 1 ; int r = ( int ) 2 * 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / gcd ( a , b ); long ac = a * c / gcd ( a , c ); long bc = b * c / gcd ( b , c ); long abc = a * bc / gcd ( a , bc ); int l = 1 ; int r = 2 * ( int ) 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nthUglyNumber ( self , n : int , a : int , b : int , c : int ) -> int : ab = a * b // math . gcd ( a , b ) ac = a * c // math . gcd ( a , c ) bc = b * c // math . gcd ( b , c ) abc = a * bc // math . gcd ( a , bc ) l = 1 r = 2 * int ( 1e9 ) while l < r : m = ( l + r ) // 2 if m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc < n : l = m + 1 else : r = m return l","title":"1201. Ugly Number III"},{"location":"problems/1201/#1201-ugly-number-iii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / __gcd ( a , b ); long ac = a * c / __gcd ( a , c ); long bc = b * c / __gcd ( b , c ); long abc = a * bc / __gcd ( a , bc ); int l = 1 ; int r = ( int ) 2 * 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / gcd ( a , b ); long ac = a * c / gcd ( a , c ); long bc = b * c / gcd ( b , c ); long abc = a * bc / gcd ( a , bc ); int l = 1 ; int r = 2 * ( int ) 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nthUglyNumber ( self , n : int , a : int , b : int , c : int ) -> int : ab = a * b // math . gcd ( a , b ) ac = a * c // math . gcd ( a , c ) bc = b * c // math . gcd ( b , c ) abc = a * bc // math . gcd ( a , bc ) l = 1 r = 2 * int ( 1e9 ) while l < r : m = ( l + r ) // 2 if m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc < n : l = m + 1 else : r = m return l","title":"1201. Ugly Number III"},{"location":"problems/1202/","text":"1202. Smallest String With Swaps Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Solution { public : string smallestStringWithSwaps ( string s , vector < vector < int >>& pairs ) { string ans ; UF uf ( s . length ()); unordered_map < int , priority_queue < char , vector < char > , compare >> map ; for ( vector < int >& pair : pairs ) uf . union_ ( pair [ 0 ], pair [ 1 ]); for ( int i = 0 ; i < s . length (); ++ i ) map [ uf . find ( i )]. push ( s [ i ]); for ( int i = 0 ; i < s . length (); ++ i ) ans += map [ uf . find ( i )]. top (), map [ uf . find ( i )]. pop (); return ans ; } private : class UF { public : UF ( int n ) : size ( n ), id ( n ) { for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } void union_ ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ]) { id [ i ] = j ; size [ j ] += size [ i ]; } else { id [ j ] = i ; size [ i ] += size [ j ]; } } int find ( int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } private : vector < int > size ; vector < int > id ; }; struct compare { bool operator ()( const char a , const char b ) { return a > b ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String smallestStringWithSwaps ( String s , List < List < Integer >> pairs ) { StringBuilder ans = new StringBuilder (); UF uf = new UF ( s . length ()); Map < Integer , PriorityQueue < Character >> map = new HashMap <> (); for ( List < Integer > pair : pairs ) uf . union ( pair . get ( 0 ), pair . get ( 1 )); for ( int i = 0 ; i < s . length (); ++ i ) map . computeIfAbsent ( uf . find ( i ), k -> new PriorityQueue <> ()). offer ( s . charAt ( i )); for ( int i = 0 ; i < s . length (); ++ i ) ans . append ( map . get ( uf . find ( i )). poll ()); return ans . toString (); } private class UF { private int [] size ; private int [] id ; private UF ( int n ) { size = new int [ n ] ; id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } private void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ] ) { id [ i ] = j ; size [ j ] += size [ i ] ; } else { id [ j ] = i ; size [ i ] += size [ j ] ; } } private int find ( int i ) { while ( i != id [ i ] ) { id [ i ] = id [ id [ i ]] ; i = id [ i ] ; } return i ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def smallestStringWithSwaps ( self , s : str , pairs : List [ List [ int ]]) -> str : class UF : def __init__ ( self , n : int ): self . size = [ 1 ] * n self . id = list ( range ( n )) def union ( self , p : int , q : int ) -> None : i = self . find ( p ) j = self . find ( q ) if i == j : return if self . size [ i ] < self . size [ j ]: self . id [ i ] = j self . size [ j ] += self . size [ i ] else : self . id [ j ] = i self . size [ i ] += self . size [ j ] def find ( self , i : int ) -> int : while i != self . id [ i ]: self . id [ i ] = self . id [ self . id [ i ]] i = self . id [ i ] return i ans = \"\" uf = UF ( len ( s )) map = collections . defaultdict ( list ) for p , q in pairs : uf . union ( p , q ) for i in range ( len ( s )): map [ uf . find ( i )] . append ( s [ i ]) for key in map . keys (): map [ key ] . sort ( reverse = True ) for i in range ( len ( s )): ans += map [ uf . find ( i )] . pop () return ans","title":"1202. Smallest String With Swaps"},{"location":"problems/1202/#1202-smallest-string-with-swaps","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Solution { public : string smallestStringWithSwaps ( string s , vector < vector < int >>& pairs ) { string ans ; UF uf ( s . length ()); unordered_map < int , priority_queue < char , vector < char > , compare >> map ; for ( vector < int >& pair : pairs ) uf . union_ ( pair [ 0 ], pair [ 1 ]); for ( int i = 0 ; i < s . length (); ++ i ) map [ uf . find ( i )]. push ( s [ i ]); for ( int i = 0 ; i < s . length (); ++ i ) ans += map [ uf . find ( i )]. top (), map [ uf . find ( i )]. pop (); return ans ; } private : class UF { public : UF ( int n ) : size ( n ), id ( n ) { for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } void union_ ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ]) { id [ i ] = j ; size [ j ] += size [ i ]; } else { id [ j ] = i ; size [ i ] += size [ j ]; } } int find ( int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } private : vector < int > size ; vector < int > id ; }; struct compare { bool operator ()( const char a , const char b ) { return a > b ; } }; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String smallestStringWithSwaps ( String s , List < List < Integer >> pairs ) { StringBuilder ans = new StringBuilder (); UF uf = new UF ( s . length ()); Map < Integer , PriorityQueue < Character >> map = new HashMap <> (); for ( List < Integer > pair : pairs ) uf . union ( pair . get ( 0 ), pair . get ( 1 )); for ( int i = 0 ; i < s . length (); ++ i ) map . computeIfAbsent ( uf . find ( i ), k -> new PriorityQueue <> ()). offer ( s . charAt ( i )); for ( int i = 0 ; i < s . length (); ++ i ) ans . append ( map . get ( uf . find ( i )). poll ()); return ans . toString (); } private class UF { private int [] size ; private int [] id ; private UF ( int n ) { size = new int [ n ] ; id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } private void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ] ) { id [ i ] = j ; size [ j ] += size [ i ] ; } else { id [ j ] = i ; size [ i ] += size [ j ] ; } } private int find ( int i ) { while ( i != id [ i ] ) { id [ i ] = id [ id [ i ]] ; i = id [ i ] ; } return i ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def smallestStringWithSwaps ( self , s : str , pairs : List [ List [ int ]]) -> str : class UF : def __init__ ( self , n : int ): self . size = [ 1 ] * n self . id = list ( range ( n )) def union ( self , p : int , q : int ) -> None : i = self . find ( p ) j = self . find ( q ) if i == j : return if self . size [ i ] < self . size [ j ]: self . id [ i ] = j self . size [ j ] += self . size [ i ] else : self . id [ j ] = i self . size [ i ] += self . size [ j ] def find ( self , i : int ) -> int : while i != self . id [ i ]: self . id [ i ] = self . id [ self . id [ i ]] i = self . id [ i ] return i ans = \"\" uf = UF ( len ( s )) map = collections . defaultdict ( list ) for p , q in pairs : uf . union ( p , q ) for i in range ( len ( s )): map [ uf . find ( i )] . append ( s [ i ]) for key in map . keys (): map [ key ] . sort ( reverse = True ) for i in range ( len ( s )): ans += map [ uf . find ( i )] . pop () return ans","title":"1202. Smallest String With Swaps"},{"location":"problems/1203/","text":"1203. Sort Items by Groups Respecting Dependencies","title":"1203. Sort Items by Groups Respecting Dependencies"},{"location":"problems/1203/#1203-sort-items-by-groups-respecting-dependencies","text":"","title":"1203. Sort Items by Groups Respecting Dependencies"},{"location":"problems/1204/","text":"1204. Last Person to Fit in the Elevator \ud83d\udd12","title":"1204. Last Person to Fit in the Elevator"},{"location":"problems/1204/#1204-last-person-to-fit-in-the-elevator","text":"","title":"1204. Last Person to Fit in the Elevator \ud83d\udd12"},{"location":"problems/1205/","text":"1205. Monthly Transactions II \ud83d\udd12","title":"1205. Monthly Transactions II"},{"location":"problems/1205/#1205-monthly-transactions-ii","text":"","title":"1205. Monthly Transactions II \ud83d\udd12"},{"location":"problems/1206/","text":"1206. Design Skiplist","title":"1206. Design Skiplist"},{"location":"problems/1206/#1206-design-skiplist","text":"","title":"1206. Design Skiplist"},{"location":"problems/1207/","text":"1207. Unique Number of Occurrences Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool uniqueOccurrences ( vector < int >& arr ) { unordered_map < int , int > count ; unordered_set < int > occurrences ; for ( int a : arr ) ++ count [ a ]; for ( auto && [ _ , value ] : count ) if ( ! occurrences . insert ( value ). second ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean uniqueOccurrences ( int [] arr ) { Map < Integer , Integer > count = new HashMap <> (); Set < Integer > occurrences = new HashSet <> (); for ( int a : arr ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); for ( int value : count . values ()) if ( ! occurrences . add ( value )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniqueOccurrences ( self , arr : List [ int ]) -> bool : count = collections . Counter ( arr ) occurrences = set () for value in count . values (): if value in occurrences : return False occurrences . add ( value ) return True","title":"1207. Unique Number of Occurrences"},{"location":"problems/1207/#1207-unique-number-of-occurrences","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool uniqueOccurrences ( vector < int >& arr ) { unordered_map < int , int > count ; unordered_set < int > occurrences ; for ( int a : arr ) ++ count [ a ]; for ( auto && [ _ , value ] : count ) if ( ! occurrences . insert ( value ). second ) return false ; return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean uniqueOccurrences ( int [] arr ) { Map < Integer , Integer > count = new HashMap <> (); Set < Integer > occurrences = new HashSet <> (); for ( int a : arr ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); for ( int value : count . values ()) if ( ! occurrences . add ( value )) return false ; return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def uniqueOccurrences ( self , arr : List [ int ]) -> bool : count = collections . Counter ( arr ) occurrences = set () for value in count . values (): if value in occurrences : return False occurrences . add ( value ) return True","title":"1207. Unique Number of Occurrences"},{"location":"problems/1208/","text":"1208. Get Equal Substrings Within Budget Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int equalSubstring ( string s , string t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= abs ( s [ i ] - t [ i ]); if ( maxCost < 0 ) maxCost += abs ( s [ j ] - t [ j ++ ]); } return s . length () - j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int equalSubstring ( String s , String t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= Math . abs ( s . charAt ( i ) - t . charAt ( i )); if ( maxCost < 0 ) maxCost += Math . abs ( s . charAt ( j ) - t . charAt ( j ++ )); } return s . length () - j ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : j = 0 for i in range ( len ( s )): maxCost -= abs ( ord ( s [ i ]) - ord ( t [ i ])) if maxCost < 0 : maxCost += abs ( ord ( s [ j ]) - ord ( t [ j ])) j += 1 return len ( s ) - j","title":"1208. Get Equal Substrings Within Budget"},{"location":"problems/1208/#1208-get-equal-substrings-within-budget","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int equalSubstring ( string s , string t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= abs ( s [ i ] - t [ i ]); if ( maxCost < 0 ) maxCost += abs ( s [ j ] - t [ j ++ ]); } return s . length () - j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int equalSubstring ( String s , String t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= Math . abs ( s . charAt ( i ) - t . charAt ( i )); if ( maxCost < 0 ) maxCost += Math . abs ( s . charAt ( j ) - t . charAt ( j ++ )); } return s . length () - j ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : j = 0 for i in range ( len ( s )): maxCost -= abs ( ord ( s [ i ]) - ord ( t [ i ])) if maxCost < 0 : maxCost += abs ( ord ( s [ j ]) - ord ( t [ j ])) j += 1 return len ( s ) - j","title":"1208. Get Equal Substrings Within Budget"},{"location":"problems/1209/","text":"1209. Remove All Adjacent Duplicates in String II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string removeDuplicates ( const string & s , int k ) { string ans ; vector < pair < char , int >> stack ; for ( const char c : s ) if ( stack . empty () || stack . back (). first != c ) stack . push_back ({ c , 1 }); else if ( ++ stack . back (). second == k ) // stack.back() == c stack . pop_back (); for ( const auto & [ c , count ] : stack ) ans . append ( count , c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Item { char c ; int freq ; public Item ( char c , int freq ) { this . c = c ; this . freq = freq ; } } class Solution { public String removeDuplicates ( String s , int k ) { StringBuilder sb = new StringBuilder (); LinkedList < Item > stack = new LinkedList <> (); for ( final char c : s . toCharArray ()) { if ( ! stack . isEmpty () && stack . peek (). c == c ) ++ stack . peek (). freq ; else stack . push ( new Item ( c , 1 )); if ( stack . peek (). freq == k ) stack . pop (); } while ( ! stack . isEmpty ()) { Item item = stack . pop (); for ( int i = 0 ; i < item . freq ; ++ i ) sb . append ( item . c ); } return sb . reverse (). toString (); } }","title":"1209. Remove All Adjacent Duplicates in String II"},{"location":"problems/1209/#1209-remove-all-adjacent-duplicates-in-string-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : string removeDuplicates ( const string & s , int k ) { string ans ; vector < pair < char , int >> stack ; for ( const char c : s ) if ( stack . empty () || stack . back (). first != c ) stack . push_back ({ c , 1 }); else if ( ++ stack . back (). second == k ) // stack.back() == c stack . pop_back (); for ( const auto & [ c , count ] : stack ) ans . append ( count , c ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Item { char c ; int freq ; public Item ( char c , int freq ) { this . c = c ; this . freq = freq ; } } class Solution { public String removeDuplicates ( String s , int k ) { StringBuilder sb = new StringBuilder (); LinkedList < Item > stack = new LinkedList <> (); for ( final char c : s . toCharArray ()) { if ( ! stack . isEmpty () && stack . peek (). c == c ) ++ stack . peek (). freq ; else stack . push ( new Item ( c , 1 )); if ( stack . peek (). freq == k ) stack . pop (); } while ( ! stack . isEmpty ()) { Item item = stack . pop (); for ( int i = 0 ; i < item . freq ; ++ i ) sb . append ( item . c ); } return sb . reverse (). toString (); } }","title":"1209. Remove All Adjacent Duplicates in String II"},{"location":"problems/1210/","text":"1210. Minimum Moves to Reach Target with Rotations","title":"1210. Minimum Moves to Reach Target with Rotations"},{"location":"problems/1210/#1210-minimum-moves-to-reach-target-with-rotations","text":"","title":"1210. Minimum Moves to Reach Target with Rotations"},{"location":"problems/1211/","text":"1211. Queries Quality and Percentage \ud83d\udd12","title":"1211. Queries Quality and Percentage"},{"location":"problems/1211/#1211-queries-quality-and-percentage","text":"","title":"1211. Queries Quality and Percentage \ud83d\udd12"},{"location":"problems/1212/","text":"1212. Team Scores in Football Tournament \ud83d\udd12","title":"1212. Team Scores in Football Tournament"},{"location":"problems/1212/#1212-team-scores-in-football-tournament","text":"","title":"1212. Team Scores in Football Tournament \ud83d\udd12"},{"location":"problems/1213/","text":"1213. Intersection of Three Sorted Arrays \ud83d\udd12","title":"1213. Intersection of Three Sorted Arrays"},{"location":"problems/1213/#1213-intersection-of-three-sorted-arrays","text":"","title":"1213. Intersection of Three Sorted Arrays \ud83d\udd12"},{"location":"problems/1214/","text":"1214. Two Sum BSTs \ud83d\udd12","title":"1214. Two Sum BSTs"},{"location":"problems/1214/#1214-two-sum-bsts","text":"","title":"1214. Two Sum BSTs \ud83d\udd12"},{"location":"problems/1215/","text":"1215. Stepping Numbers \ud83d\udd12","title":"1215. Stepping Numbers"},{"location":"problems/1215/#1215-stepping-numbers","text":"","title":"1215. Stepping Numbers \ud83d\udd12"},{"location":"problems/1216/","text":"1216. Valid Palindrome III \ud83d\udd12 Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool isValidPalindrome ( string s , int k ) { return s . length () - longestPalindromeSubseq ( s ) <= k ; } private : // same as 516. Longest Palindromic Subsequence int longestPalindromeSubseq ( const string & s ) { const int n = s . length (); // dp[i][j] := LPS's length in s[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( s [ i ] == s [ j ]) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean isValidPalindrome ( String s , int k ) { return s . length () - longestPalindromeSubseq ( s ) <= k ; } // same as 516. Longest Palindromic Subsequence private int longestPalindromeSubseq ( final String s ) { final int n = s . length (); // dp[i][j] := LPS's length in s[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( s . charAt ( i ) == s . charAt ( j )) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i + 1 ][ j ] , dp [ i ][ j - 1 ] ); } return dp [ 0 ][ n - 1 ] ; } }","title":"1216. Valid Palindrome III"},{"location":"problems/1216/#1216-valid-palindrome-iii","text":"Time: $O(n^2)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool isValidPalindrome ( string s , int k ) { return s . length () - longestPalindromeSubseq ( s ) <= k ; } private : // same as 516. Longest Palindromic Subsequence int longestPalindromeSubseq ( const string & s ) { const int n = s . length (); // dp[i][j] := LPS's length in s[i..j] vector < vector < int >> dp ( n , vector < int > ( n )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { const int j = i + length - 1 ; if ( s [ i ] == s [ j ]) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ]; else dp [ i ][ j ] = max ( dp [ i + 1 ][ j ], dp [ i ][ j - 1 ]); } return dp [ 0 ][ n - 1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public boolean isValidPalindrome ( String s , int k ) { return s . length () - longestPalindromeSubseq ( s ) <= k ; } // same as 516. Longest Palindromic Subsequence private int longestPalindromeSubseq ( final String s ) { final int n = s . length (); // dp[i][j] := LPS's length in s[i..j] int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i + length - 1 < n ; ++ i ) { final int j = i + length - 1 ; if ( s . charAt ( i ) == s . charAt ( j )) dp [ i ][ j ] = 2 + dp [ i + 1 ][ j - 1 ] ; else dp [ i ][ j ] = Math . max ( dp [ i + 1 ][ j ] , dp [ i ][ j - 1 ] ); } return dp [ 0 ][ n - 1 ] ; } }","title":"1216. Valid Palindrome III \ud83d\udd12"},{"location":"problems/1217/","text":"1217. Play with Chips Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostToMoveChips ( vector < int >& chips ) { vector < int > count ( 2 ); for ( int chip : chips ) ++ count [ chip % 2 ]; return min ( count [ 0 ], count [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostToMoveChips ( int [] chips ) { int [] count = new int [ 2 ] ; for ( int chip : chips ) ++ count [ chip % 2 ] ; return Math . min ( count [ 0 ] , count [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minCostToMoveChips ( self , chips : List [ int ]) -> int : count = [ 0 ] * 2 for chip in chips : count [ chip % 2 ] += 1 return min ( count [ 0 ], count [ 1 ])","title":"1217. Play with Chips"},{"location":"problems/1217/#1217-play-with-chips","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostToMoveChips ( vector < int >& chips ) { vector < int > count ( 2 ); for ( int chip : chips ) ++ count [ chip % 2 ]; return min ( count [ 0 ], count [ 1 ]); } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostToMoveChips ( int [] chips ) { int [] count = new int [ 2 ] ; for ( int chip : chips ) ++ count [ chip % 2 ] ; return Math . min ( count [ 0 ] , count [ 1 ] ); } } Python 1 2 3 4 5 6 7 8 class Solution : def minCostToMoveChips ( self , chips : List [ int ]) -> int : count = [ 0 ] * 2 for chip in chips : count [ chip % 2 ] += 1 return min ( count [ 0 ], count [ 1 ])","title":"1217. Play with Chips"},{"location":"problems/1218/","text":"1218. Longest Arithmetic Subsequence of Given Difference Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int longestSubsequence ( vector < int >& arr , int difference ) { int ans = 0 ; unordered_map < int , int > lengthAt ; for ( int a : arr ) { if ( lengthAt . count ( a - difference )) lengthAt [ a ] = lengthAt [ a - difference ] + 1 ; else lengthAt [ a ] = 1 ; ans = max ( ans , lengthAt [ a ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int longestSubsequence ( int [] arr , int difference ) { int ans = 0 ; Map < Integer , Integer > lengthAt = new HashMap <> (); for ( int a : arr ) { lengthAt . put ( a , lengthAt . getOrDefault ( a - difference , 0 ) + 1 ); ans = Math . max ( ans , lengthAt . get ( a )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def longestSubsequence ( self , arr : List [ int ], difference : int ) -> int : ans = 0 lengthAt = {} for a in arr : lengthAt [ a ] = lengthAt . get ( a - difference , 0 ) + 1 ans = max ( ans , lengthAt [ a ]) return ans","title":"1218. Longest Arithmetic Subsequence of Given Difference"},{"location":"problems/1218/#1218-longest-arithmetic-subsequence-of-given-difference","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int longestSubsequence ( vector < int >& arr , int difference ) { int ans = 0 ; unordered_map < int , int > lengthAt ; for ( int a : arr ) { if ( lengthAt . count ( a - difference )) lengthAt [ a ] = lengthAt [ a - difference ] + 1 ; else lengthAt [ a ] = 1 ; ans = max ( ans , lengthAt [ a ]); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int longestSubsequence ( int [] arr , int difference ) { int ans = 0 ; Map < Integer , Integer > lengthAt = new HashMap <> (); for ( int a : arr ) { lengthAt . put ( a , lengthAt . getOrDefault ( a - difference , 0 ) + 1 ); ans = Math . max ( ans , lengthAt . get ( a )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def longestSubsequence ( self , arr : List [ int ], difference : int ) -> int : ans = 0 lengthAt = {} for a in arr : lengthAt [ a ] = lengthAt . get ( a - difference , 0 ) + 1 ans = max ( ans , lengthAt [ a ]) return ans","title":"1218. Longest Arithmetic Subsequence of Given Difference"},{"location":"problems/1219/","text":"1219. Path with Maximum Gold","title":"1219. Path with Maximum Gold"},{"location":"problems/1219/#1219-path-with-maximum-gold","text":"","title":"1219. Path with Maximum Gold"},{"location":"problems/1220/","text":"1220. Count Vowels Permutation Time: Space:","title":"1220. Count Vowels Permutation"},{"location":"problems/1220/#1220-count-vowels-permutation","text":"Time: Space:","title":"1220. Count Vowels Permutation"},{"location":"problems/1221/","text":"1221. Split a String in Balanced Strings Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int balancedStringSplit ( string s ) { int ans = 0 ; int count = 0 ; for ( const char c : s ) { count += c == 'L' ? 1 : -1 ; if ( count == 0 ) ++ ans ; } return ans ; } };","title":"1221. Split a String in Balanced Strings"},{"location":"problems/1221/#1221-split-a-string-in-balanced-strings","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int balancedStringSplit ( string s ) { int ans = 0 ; int count = 0 ; for ( const char c : s ) { count += c == 'L' ? 1 : -1 ; if ( count == 0 ) ++ ans ; } return ans ; } };","title":"1221. Split a String in Balanced Strings"},{"location":"problems/1222/","text":"1222. Queens That Can Attack the King Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> queensAttacktheKing ( vector < vector < int >>& queens , vector < int >& king ) { vector < vector < int >> ans ; unordered_set < int > queensSet ; for ( vector < int >& queen : queens ) queensSet . insert ( hash ( queen [ 0 ], queen [ 1 ])); vector < vector < int >> directions = {{ -1 , -1 }, { -1 , 0 }, { -1 , 1 }, { 0 , -1 }, { 0 , 1 }, { 1 , -1 }, { 1 , 0 }, { 1 , 1 }}; for ( vector < int > d : directions ) for ( int i = king [ 0 ] + d [ 0 ], j = king [ 1 ] + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) if ( queensSet . count ( hash ( i , j ))) { ans . push_back ({ i , j }); break ; } return ans ; } private : int hash ( int i , int j ) { return i * 8 + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> ans = new ArrayList <> (); Set < Integer > queensSet = new HashSet <> (); for ( int [] queen : queens ) queensSet . add ( hash ( queen [ 0 ] , queen [ 1 ] )); int [][] directions = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; for ( int [] d : directions ) for ( int i = king [ 0 ] + d [ 0 ] , j = king [ 1 ] + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) if ( queensSet . contains ( hash ( i , j ))) { ans . add ( Arrays . asList ( i , j )); break ; } return ans ; } private int hash ( int i , int j ) { return i * 8 + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def queensAttacktheKing ( self , queens : List [ List [ int ]], king : List [ int ]) -> List [ List [ int ]]: ans = [] queens = {( i , j ) for i , j in queens } for d in [[ - 1 , - 1 ], [ - 1 , 0 ], [ - 1 , 1 ], [ 0 , - 1 ], [ 0 , 1 ], [ 1 , - 1 ], [ 1 , 0 ], [ 1 , 1 ]]: i = king [ 0 ] + d [ 0 ] j = king [ 1 ] + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if ( i , j ) in queens : ans . append ([ i , j ]) break i += d [ 0 ] j += d [ 1 ] return ans","title":"1222. Queens That Can Attack the King"},{"location":"problems/1222/#1222-queens-that-can-attack-the-king","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> queensAttacktheKing ( vector < vector < int >>& queens , vector < int >& king ) { vector < vector < int >> ans ; unordered_set < int > queensSet ; for ( vector < int >& queen : queens ) queensSet . insert ( hash ( queen [ 0 ], queen [ 1 ])); vector < vector < int >> directions = {{ -1 , -1 }, { -1 , 0 }, { -1 , 1 }, { 0 , -1 }, { 0 , 1 }, { 1 , -1 }, { 1 , 0 }, { 1 , 1 }}; for ( vector < int > d : directions ) for ( int i = king [ 0 ] + d [ 0 ], j = king [ 1 ] + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) if ( queensSet . count ( hash ( i , j ))) { ans . push_back ({ i , j }); break ; } return ans ; } private : int hash ( int i , int j ) { return i * 8 + j ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> ans = new ArrayList <> (); Set < Integer > queensSet = new HashSet <> (); for ( int [] queen : queens ) queensSet . add ( hash ( queen [ 0 ] , queen [ 1 ] )); int [][] directions = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; for ( int [] d : directions ) for ( int i = king [ 0 ] + d [ 0 ] , j = king [ 1 ] + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) if ( queensSet . contains ( hash ( i , j ))) { ans . add ( Arrays . asList ( i , j )); break ; } return ans ; } private int hash ( int i , int j ) { return i * 8 + j ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def queensAttacktheKing ( self , queens : List [ List [ int ]], king : List [ int ]) -> List [ List [ int ]]: ans = [] queens = {( i , j ) for i , j in queens } for d in [[ - 1 , - 1 ], [ - 1 , 0 ], [ - 1 , 1 ], [ 0 , - 1 ], [ 0 , 1 ], [ 1 , - 1 ], [ 1 , 0 ], [ 1 , 1 ]]: i = king [ 0 ] + d [ 0 ] j = king [ 1 ] + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if ( i , j ) in queens : ans . append ([ i , j ]) break i += d [ 0 ] j += d [ 1 ] return ans","title":"1222. Queens That Can Attack the King"},{"location":"problems/1223/","text":"1223. Dice Roll Simulation Time: Space:","title":"1223. Dice Roll Simulation"},{"location":"problems/1223/#1223-dice-roll-simulation","text":"Time: Space:","title":"1223. Dice Roll Simulation"},{"location":"problems/1224/","text":"1224. Maximum Equal Frequency Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int maxEqualFreq ( vector < int >& nums ) { int ans = 0 ; int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , int > freq ; for ( int i = 0 ; i < nums . size (); ++ i ) { int num = nums [ i ]; -- freq [ count [ num ]]; ++ count [ num ]; ++ freq [ count [ num ]]; maxFreq = max ( maxFreq , count [ num ]); if ( maxFreq == 1 || maxFreq * freq [ maxFreq ] == i || ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i ) ans = i + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxEqualFreq ( int [] nums ) { int ans = 0 ; int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); Map < Integer , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int currentFreq = count . getOrDefault ( nums [ i ] , 0 ); freq . put ( currentFreq , freq . getOrDefault ( currentFreq , 0 ) - 1 ); int updatedFreq = currentFreq + 1 ; count . put ( nums [ i ] , updatedFreq ); freq . put ( updatedFreq , freq . getOrDefault ( updatedFreq , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , updatedFreq ); if ( maxFreq == 1 || maxFreq * freq . get ( maxFreq ) == i || ( maxFreq - 1 ) * ( freq . get ( maxFreq - 1 ) + 1 ) == i ) ans = i + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxEqualFreq ( self , nums : List [ int ]) -> int : ans = 0 maxFreq = 0 count = collections . Counter () freq = collections . Counter () for i , num in enumerate ( nums ): freq [ count [ num ]] -= 1 count [ num ] += 1 freq [ count [ num ]] += 1 maxFreq = max ( maxFreq , count [ num ]) if maxFreq == 1 or maxFreq * freq [ maxFreq ] == i or ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i : ans = i + 1 return ans","title":"1224. Maximum Equal Frequency"},{"location":"problems/1224/#1224-maximum-equal-frequency","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int maxEqualFreq ( vector < int >& nums ) { int ans = 0 ; int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , int > freq ; for ( int i = 0 ; i < nums . size (); ++ i ) { int num = nums [ i ]; -- freq [ count [ num ]]; ++ count [ num ]; ++ freq [ count [ num ]]; maxFreq = max ( maxFreq , count [ num ]); if ( maxFreq == 1 || maxFreq * freq [ maxFreq ] == i || ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i ) ans = i + 1 ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxEqualFreq ( int [] nums ) { int ans = 0 ; int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); Map < Integer , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int currentFreq = count . getOrDefault ( nums [ i ] , 0 ); freq . put ( currentFreq , freq . getOrDefault ( currentFreq , 0 ) - 1 ); int updatedFreq = currentFreq + 1 ; count . put ( nums [ i ] , updatedFreq ); freq . put ( updatedFreq , freq . getOrDefault ( updatedFreq , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , updatedFreq ); if ( maxFreq == 1 || maxFreq * freq . get ( maxFreq ) == i || ( maxFreq - 1 ) * ( freq . get ( maxFreq - 1 ) + 1 ) == i ) ans = i + 1 ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxEqualFreq ( self , nums : List [ int ]) -> int : ans = 0 maxFreq = 0 count = collections . Counter () freq = collections . Counter () for i , num in enumerate ( nums ): freq [ count [ num ]] -= 1 count [ num ] += 1 freq [ count [ num ]] += 1 maxFreq = max ( maxFreq , count [ num ]) if maxFreq == 1 or maxFreq * freq [ maxFreq ] == i or ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i : ans = i + 1 return ans","title":"1224. Maximum Equal Frequency"},{"location":"problems/1225/","text":"1225. Report Contiguous Dates \ud83d\udd12","title":"1225. Report Contiguous Dates"},{"location":"problems/1225/#1225-report-contiguous-dates","text":"","title":"1225. Report Contiguous Dates \ud83d\udd12"},{"location":"problems/1226/","text":"1226. The Dining Philosophers","title":"1226. The Dining Philosophers"},{"location":"problems/1226/#1226-the-dining-philosophers","text":"","title":"1226. The Dining Philosophers"},{"location":"problems/1227/","text":"1227. Airplane Seat Assignment Probability Time: Space: C++ 1 2 3 4 class Solution { public : double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } }; Java 1 2 3 4 5 class Solution { public double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } } Python 1 2 3 class Solution : def nthPersonGetsNthSeat ( self , n : int ) -> float : return 1 if n == 1 else 0.5","title":"1227. Airplane Seat Assignment Probability"},{"location":"problems/1227/#1227-airplane-seat-assignment-probability","text":"Time: Space: C++ 1 2 3 4 class Solution { public : double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } }; Java 1 2 3 4 5 class Solution { public double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } } Python 1 2 3 class Solution : def nthPersonGetsNthSeat ( self , n : int ) -> float : return 1 if n == 1 else 0.5","title":"1227. Airplane Seat Assignment Probability"},{"location":"problems/1228/","text":"1228. Missing Number In Arithmetic Progression \ud83d\udd12","title":"1228. Missing Number In Arithmetic Progression"},{"location":"problems/1228/#1228-missing-number-in-arithmetic-progression","text":"","title":"1228. Missing Number In Arithmetic Progression \ud83d\udd12"},{"location":"problems/1229/","text":"1229. Meeting Scheduler \ud83d\udd12","title":"1229. Meeting Scheduler"},{"location":"problems/1229/#1229-meeting-scheduler","text":"","title":"1229. Meeting Scheduler \ud83d\udd12"},{"location":"problems/1230/","text":"1230. Toss Strange Coins \ud83d\udd12","title":"1230. Toss Strange Coins"},{"location":"problems/1230/#1230-toss-strange-coins","text":"","title":"1230. Toss Strange Coins \ud83d\udd12"},{"location":"problems/1231/","text":"1231. Divide Chocolate \ud83d\udd12","title":"1231. Divide Chocolate"},{"location":"problems/1231/#1231-divide-chocolate","text":"","title":"1231. Divide Chocolate \ud83d\udd12"},{"location":"problems/1232/","text":"1232. Check If It Is a Straight Line Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool checkStraightLine ( vector < vector < int >>& coordinates ) { int x0 = coordinates [ 0 ][ 0 ]; int y0 = coordinates [ 0 ][ 1 ]; int x1 = coordinates [ 1 ][ 0 ]; int y1 = coordinates [ 1 ][ 1 ]; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . size (); ++ i ) { int x = coordinates [ i ][ 0 ]; int y = coordinates [ i ][ 1 ]; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean checkStraightLine ( int [][] coordinates ) { int x0 = coordinates [ 0 ][ 0 ] ; int y0 = coordinates [ 0 ][ 1 ] ; int x1 = coordinates [ 1 ][ 0 ] ; int y1 = coordinates [ 1 ][ 1 ] ; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . length ; ++ i ) { int x = coordinates [ i ][ 0 ] ; int y = coordinates [ i ][ 1 ] ; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } } Python 1 2 3 4 5 6 7 class Solution : def checkStraightLine ( self , coordinates : List [ List [ int ]]) -> bool : x0 , y0 , x1 , y1 = * coordinates [ 0 ], * coordinates [ 1 ] dx = x1 - x0 dy = y1 - y0 return all (( x - x0 ) * dy == ( y - y0 ) * dx for x , y in coordinates )","title":"1232. Check If It Is a Straight Line"},{"location":"problems/1232/#1232-check-if-it-is-a-straight-line","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool checkStraightLine ( vector < vector < int >>& coordinates ) { int x0 = coordinates [ 0 ][ 0 ]; int y0 = coordinates [ 0 ][ 1 ]; int x1 = coordinates [ 1 ][ 0 ]; int y1 = coordinates [ 1 ][ 1 ]; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . size (); ++ i ) { int x = coordinates [ i ][ 0 ]; int y = coordinates [ i ][ 1 ]; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean checkStraightLine ( int [][] coordinates ) { int x0 = coordinates [ 0 ][ 0 ] ; int y0 = coordinates [ 0 ][ 1 ] ; int x1 = coordinates [ 1 ][ 0 ] ; int y1 = coordinates [ 1 ][ 1 ] ; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . length ; ++ i ) { int x = coordinates [ i ][ 0 ] ; int y = coordinates [ i ][ 1 ] ; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } } Python 1 2 3 4 5 6 7 class Solution : def checkStraightLine ( self , coordinates : List [ List [ int ]]) -> bool : x0 , y0 , x1 , y1 = * coordinates [ 0 ], * coordinates [ 1 ] dx = x1 - x0 dy = y1 - y0 return all (( x - x0 ) * dy == ( y - y0 ) * dx for x , y in coordinates )","title":"1232. Check If It Is a Straight Line"},{"location":"problems/1233/","text":"1233. Remove Sub-Folders from the Filesystem Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > removeSubfolders ( vector < string >& folder ) { vector < string > ans ; string prev ; sort ( begin ( folder ), end ( folder )); for ( const string & f : folder ) { if ( ! prev . empty () && f . find ( prev ) == 0 && f [ prev . length ()] == '/' ) continue ; ans . push_back ( f ); prev = f ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < String > removeSubfolders ( String [] folder ) { List < String > ans = new ArrayList <> (); String prev = \"\" ; Arrays . sort ( folder ); for ( final String f : folder ) { if ( ! prev . isEmpty () && f . startsWith ( prev ) && f . charAt ( prev . length ()) == '/' ) continue ; ans . add ( f ); prev = f ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeSubfolders ( self , folder : List [ str ]) -> List [ str ]: ans = [] prev = \"\" folder . sort () for f in folder : if len ( prev ) > 0 and f . startswith ( prev ) and f [ len ( prev )] == '/' : continue ans . append ( f ) prev = f return ans","title":"1233. Remove Sub-Folders from the Filesystem"},{"location":"problems/1233/#1233-remove-sub-folders-from-the-filesystem","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > removeSubfolders ( vector < string >& folder ) { vector < string > ans ; string prev ; sort ( begin ( folder ), end ( folder )); for ( const string & f : folder ) { if ( ! prev . empty () && f . find ( prev ) == 0 && f [ prev . length ()] == '/' ) continue ; ans . push_back ( f ); prev = f ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < String > removeSubfolders ( String [] folder ) { List < String > ans = new ArrayList <> (); String prev = \"\" ; Arrays . sort ( folder ); for ( final String f : folder ) { if ( ! prev . isEmpty () && f . startsWith ( prev ) && f . charAt ( prev . length ()) == '/' ) continue ; ans . add ( f ); prev = f ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeSubfolders ( self , folder : List [ str ]) -> List [ str ]: ans = [] prev = \"\" folder . sort () for f in folder : if len ( prev ) > 0 and f . startswith ( prev ) and f [ len ( prev )] == '/' : continue ans . append ( f ) prev = f return ans","title":"1233. Remove Sub-Folders from the Filesystem"},{"location":"problems/1234/","text":"1234. Replace the Substring for Balanced String Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int balancedString ( string s ) { const int n = s . length (); const int k = n / 4 ; int ans = n ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s [ i ]]; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = min ( ans , i - j + 1 ); ++ count [ s [ j ]]; ++ j ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int balancedString ( String s ) { final int n = s . length (); final int k = n / 4 ; int ans = n ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) ] ; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = Math . min ( ans , i - j + 1 ); ++ count [ s . charAt ( j ) ] ; ++ j ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def balancedString ( self , s : str ) -> int : ans = len ( s ) count = collections . Counter ( s ) j = 0 for i , c in enumerate ( s ): count [ c ] -= 1 while j < len ( s ) and all ( count [ c ] <= len ( s ) // 4 for c in 'QWER' ): ans = min ( ans , i - j + 1 ) count [ s [ j ]] += 1 j += 1 return ans","title":"1234. Replace the Substring for Balanced String"},{"location":"problems/1234/#1234-replace-the-substring-for-balanced-string","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int balancedString ( string s ) { const int n = s . length (); const int k = n / 4 ; int ans = n ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s [ i ]]; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = min ( ans , i - j + 1 ); ++ count [ s [ j ]]; ++ j ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int balancedString ( String s ) { final int n = s . length (); final int k = n / 4 ; int ans = n ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) ] ; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = Math . min ( ans , i - j + 1 ); ++ count [ s . charAt ( j ) ] ; ++ j ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def balancedString ( self , s : str ) -> int : ans = len ( s ) count = collections . Counter ( s ) j = 0 for i , c in enumerate ( s ): count [ c ] -= 1 while j < len ( s ) and all ( count [ c ] <= len ( s ) // 4 for c in 'QWER' ): ans = min ( ans , i - j + 1 ) count [ s [ j ]] += 1 j += 1 return ans","title":"1234. Replace the Substring for Balanced String"},{"location":"problems/1235/","text":"1235. Maximum Profit in Job Scheduling","title":"1235. Maximum Profit in Job Scheduling"},{"location":"problems/1235/#1235-maximum-profit-in-job-scheduling","text":"","title":"1235. Maximum Profit in Job Scheduling"},{"location":"problems/1236/","text":"1236. Web Crawler \ud83d\udd12","title":"1236. Web Crawler"},{"location":"problems/1236/#1236-web-crawler","text":"","title":"1236. Web Crawler \ud83d\udd12"},{"location":"problems/1237/","text":"1237. Find Positive Integer Solution for a Given Equation Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> findSolution ( CustomFunction & customfunction , int z ) { vector < vector < int >> ans ; int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . push_back ({ x ++ , y -- }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < List < Integer >> findSolution ( CustomFunction customfunction , int z ) { List < List < Integer >> ans = new LinkedList <> (); int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . add ( Arrays . asList ( x ++ , y -- )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findSolution ( self , customfunction : 'CustomFunction' , z : int ) -> List [ List [ int ]]: ans = [] x = 1 y = 1000 while x <= 1000 and y >= 1 : f = customfunction . f ( x , y ) if f < z : x += 1 elif f > z : y -= 1 else : ans . append ([ x , y ]) x += 1 y -= 1 return ans","title":"1237. Find Positive Integer Solution for a Given Equation"},{"location":"problems/1237/#1237-find-positive-integer-solution-for-a-given-equation","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> findSolution ( CustomFunction & customfunction , int z ) { vector < vector < int >> ans ; int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . push_back ({ x ++ , y -- }); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < List < Integer >> findSolution ( CustomFunction customfunction , int z ) { List < List < Integer >> ans = new LinkedList <> (); int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . add ( Arrays . asList ( x ++ , y -- )); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findSolution ( self , customfunction : 'CustomFunction' , z : int ) -> List [ List [ int ]]: ans = [] x = 1 y = 1000 while x <= 1000 and y >= 1 : f = customfunction . f ( x , y ) if f < z : x += 1 elif f > z : y -= 1 else : ans . append ([ x , y ]) x += 1 y -= 1 return ans","title":"1237. Find Positive Integer Solution for a Given Equation"},{"location":"problems/1238/","text":"1238. Circular Permutation in Binary Representation Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > circularPermutation ( int n , int start ) { vector < int > ans ; for ( int i = 0 ; i < 1 << n ; ++ i ) ans . push_back ( start ^ i ^ i >> 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public List < Integer > circularPermutation ( int n , int start ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < 1 << n ; ++ i ) ans . add ( start ^ i ^ i >> 1 ); return ans ; } } Python 1 2 3 class Solution : def circularPermutation ( self , n : int , start : int ) -> List [ int ]: return [ start ^ i ^ i >> 1 for i in range ( 1 << n )]","title":"1238. Circular Permutation in Binary Representation"},{"location":"problems/1238/#1238-circular-permutation-in-binary-representation","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > circularPermutation ( int n , int start ) { vector < int > ans ; for ( int i = 0 ; i < 1 << n ; ++ i ) ans . push_back ( start ^ i ^ i >> 1 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public List < Integer > circularPermutation ( int n , int start ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < 1 << n ; ++ i ) ans . add ( start ^ i ^ i >> 1 ); return ans ; } } Python 1 2 3 class Solution : def circularPermutation ( self , n : int , start : int ) -> List [ int ]: return [ start ^ i ^ i >> 1 for i in range ( 1 << n )]","title":"1238. Circular Permutation in Binary Representation"},{"location":"problems/1239/","text":"1239. Maximum Length of a Concatenated String with Unique Characters","title":"1239. Maximum Length of a Concatenated String with Unique Characters"},{"location":"problems/1239/#1239-maximum-length-of-a-concatenated-string-with-unique-characters","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters"},{"location":"problems/1240/","text":"1240. Tiling a Rectangle with the Fewest Squares","title":"1240. Tiling a Rectangle with the Fewest Squares"},{"location":"problems/1240/#1240-tiling-a-rectangle-with-the-fewest-squares","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares"},{"location":"problems/1241/","text":"1241. Number of Comments per Post \ud83d\udd12","title":"1241. Number of Comments per Post"},{"location":"problems/1241/#1241-number-of-comments-per-post","text":"","title":"1241. Number of Comments per Post \ud83d\udd12"},{"location":"problems/1242/","text":"1242. Web Crawler Multithreaded \ud83d\udd12","title":"1242. Web Crawler Multithreaded"},{"location":"problems/1242/#1242-web-crawler-multithreaded","text":"","title":"1242. Web Crawler Multithreaded \ud83d\udd12"},{"location":"problems/1243/","text":"1243. Array Transformation \ud83d\udd12","title":"1243. Array Transformation"},{"location":"problems/1243/#1243-array-transformation","text":"","title":"1243. Array Transformation \ud83d\udd12"},{"location":"problems/1244/","text":"1244. Design A Leaderboard \ud83d\udd12","title":"1244. Design A Leaderboard"},{"location":"problems/1244/#1244-design-a-leaderboard","text":"","title":"1244. Design A Leaderboard \ud83d\udd12"},{"location":"problems/1245/","text":"1245. Tree Diameter \ud83d\udd12","title":"1245. Tree Diameter"},{"location":"problems/1245/#1245-tree-diameter","text":"","title":"1245. Tree Diameter \ud83d\udd12"},{"location":"problems/1246/","text":"1246. Palindrome Removal \ud83d\udd12","title":"1246. Palindrome Removal"},{"location":"problems/1246/#1246-palindrome-removal","text":"","title":"1246. Palindrome Removal \ud83d\udd12"},{"location":"problems/1247/","text":"1247. Minimum Swaps to Make Strings Equal","title":"1247. Minimum Swaps to Make Strings Equal"},{"location":"problems/1247/#1247-minimum-swaps-to-make-strings-equal","text":"","title":"1247. Minimum Swaps to Make Strings Equal"},{"location":"problems/1248/","text":"1248. Count Number of Nice Subarrays Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private : int numberOfSubarraysAtMost ( vector < int >& nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . size ();) if ( k >= 0 ) { ans += r - l ; if ( r == nums . size ()) break ; if ( nums [ r ] & 1 ) -- k ; ++ r ; } else { if ( nums [ l ] & 1 ) ++ k ; ++ l ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numberOfSubarrays ( int [] nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private int numberOfSubarraysAtMost ( int [] nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . length ;) if ( k >= 0 ) { ans += r - l ; if ( r == nums . length ) break ; if ( nums [ r ] % 2 == 1 ) -- k ; ++ r ; } else { if ( nums [ l ] % 2 == 1 ) ++ k ; ++ l ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numberOfSubarrays ( self , nums : List [ int ], k : int ) -> int : def numberOfSubarraysAtMost ( k : int ) -> int : ans = 0 l = 0 r = 0 while r <= len ( nums ): if k >= 0 : ans += r - l if r == len ( nums ): break if nums [ r ] & 1 : k -= 1 r += 1 else : if nums [ l ] & 1 : k += 1 l += 1 return ans return numberOfSubarraysAtMost ( k ) - numberOfSubarraysAtMost ( k - 1 )","title":"1248. Count Number of Nice Subarrays"},{"location":"problems/1248/#1248-count-number-of-nice-subarrays","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private : int numberOfSubarraysAtMost ( vector < int >& nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . size ();) if ( k >= 0 ) { ans += r - l ; if ( r == nums . size ()) break ; if ( nums [ r ] & 1 ) -- k ; ++ r ; } else { if ( nums [ l ] & 1 ) ++ k ; ++ l ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numberOfSubarrays ( int [] nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private int numberOfSubarraysAtMost ( int [] nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . length ;) if ( k >= 0 ) { ans += r - l ; if ( r == nums . length ) break ; if ( nums [ r ] % 2 == 1 ) -- k ; ++ r ; } else { if ( nums [ l ] % 2 == 1 ) ++ k ; ++ l ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numberOfSubarrays ( self , nums : List [ int ], k : int ) -> int : def numberOfSubarraysAtMost ( k : int ) -> int : ans = 0 l = 0 r = 0 while r <= len ( nums ): if k >= 0 : ans += r - l if r == len ( nums ): break if nums [ r ] & 1 : k -= 1 r += 1 else : if nums [ l ] & 1 : k += 1 l += 1 return ans return numberOfSubarraysAtMost ( k ) - numberOfSubarraysAtMost ( k - 1 )","title":"1248. Count Number of Nice Subarrays"},{"location":"problems/1249/","text":"1249. Minimum Remove to Make Valid Parentheses Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string minRemoveToMakeValid ( string s ) { stack < int > stack ; // unpaired '(' indicies for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] == '(' ) { stack . push ( i ); // record unpaired '(' index } else if ( s [ i ] == ')' ) { if ( stack . empty ()) { s [ i ] = '*' ; // mark unpaired ')' as '*' } else { stack . pop (); // find a pair! } } // mark unpaired '(' as '*' while ( ! stack . empty ()) s [ stack . top ()] = '*' , stack . pop (); s . erase ( remove ( begin ( s ), end ( s ), '*' ), begin ( s )); return s ; } };","title":"1249. Minimum Remove to Make Valid Parentheses"},{"location":"problems/1249/#1249-minimum-remove-to-make-valid-parentheses","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : string minRemoveToMakeValid ( string s ) { stack < int > stack ; // unpaired '(' indicies for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] == '(' ) { stack . push ( i ); // record unpaired '(' index } else if ( s [ i ] == ')' ) { if ( stack . empty ()) { s [ i ] = '*' ; // mark unpaired ')' as '*' } else { stack . pop (); // find a pair! } } // mark unpaired '(' as '*' while ( ! stack . empty ()) s [ stack . top ()] = '*' , stack . pop (); s . erase ( remove ( begin ( s ), end ( s ), '*' ), begin ( s )); return s ; } };","title":"1249. Minimum Remove to Make Valid Parentheses"},{"location":"problems/1250/","text":"1250. Check If It Is a Good Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool isGoodArray ( vector < int >& nums ) { int g = nums [ 0 ]; for ( const int num : nums ) g = __gcd ( g , num ); return g == 1 ; } };","title":"1250. Check If It Is a Good Array"},{"location":"problems/1250/#1250-check-if-it-is-a-good-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool isGoodArray ( vector < int >& nums ) { int g = nums [ 0 ]; for ( const int num : nums ) g = __gcd ( g , num ); return g == 1 ; } };","title":"1250. Check If It Is a Good Array"},{"location":"problems/1251/","text":"1251. Average Selling Price \ud83d\udd12","title":"1251. Average Selling Price"},{"location":"problems/1251/#1251-average-selling-price","text":"","title":"1251. Average Selling Price \ud83d\udd12"},{"location":"problems/1252/","text":"1252. Cells with Odd Values in a Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix"},{"location":"problems/1252/#1252-cells-with-odd-values-in-a-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix"},{"location":"problems/1253/","text":"1253. Reconstruct a 2-Row Binary Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < vector < int >> reconstructMatrix ( int upper , int lower , vector < int >& colsum ) { if ( upper + lower != accumulate ( begin ( colsum ), end ( colsum ), 0 )) return {}; if ( min ( upper , lower ) < count_if ( begin ( colsum ), end ( colsum ), []( int c ) { return c == 2 ; })) return {}; vector < vector < int >> ans ( 2 , vector < int > ( colsum . size ())); for ( int j = 0 ; j < colsum . size (); ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . size (); ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ]; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public List < List < Integer >> reconstructMatrix ( int upper , int lower , int [] colsum ) { if ( upper + lower != Arrays . stream ( colsum ). sum ()) return new ArrayList <> (); int count = 0 ; for ( int c : colsum ) if ( c == 2 ) ++ count ; if ( Math . min ( upper , lower ) < count ) return new ArrayList <> (); int [][] ans = new int [ 2 ][ colsum . length ] ; for ( int j = 0 ; j < colsum . length ; ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . length ; ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ] ; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return new ArrayList ( Arrays . asList ( ans [ 0 ] , ans [ 1 ] )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reconstructMatrix ( self , upper : int , lower : int , colsum : List [ int ]) -> List [ List [ int ]]: if upper + lower != sum ( colsum ): return [] if min ( upper , lower ) < colsum . count ( 2 ): return [] ans = [[ 0 ] * len ( colsum ) for _ in range ( 2 )] for j , c in enumerate ( colsum ): if c == 2 : ans [ 0 ][ j ] = 1 ans [ 1 ][ j ] = 1 upper -= 1 lower -= 1 for j , c in enumerate ( colsum ): if c == 1 and upper > 0 : ans [ 0 ][ j ] = 1 c -= 1 upper -= 1 if c == 1 and lower > 0 : ans [ 1 ][ j ] = 1 lower -= 1 return ans","title":"1253. Reconstruct a 2-Row Binary Matrix"},{"location":"problems/1253/#1253-reconstruct-a-2-row-binary-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : vector < vector < int >> reconstructMatrix ( int upper , int lower , vector < int >& colsum ) { if ( upper + lower != accumulate ( begin ( colsum ), end ( colsum ), 0 )) return {}; if ( min ( upper , lower ) < count_if ( begin ( colsum ), end ( colsum ), []( int c ) { return c == 2 ; })) return {}; vector < vector < int >> ans ( 2 , vector < int > ( colsum . size ())); for ( int j = 0 ; j < colsum . size (); ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . size (); ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ]; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public List < List < Integer >> reconstructMatrix ( int upper , int lower , int [] colsum ) { if ( upper + lower != Arrays . stream ( colsum ). sum ()) return new ArrayList <> (); int count = 0 ; for ( int c : colsum ) if ( c == 2 ) ++ count ; if ( Math . min ( upper , lower ) < count ) return new ArrayList <> (); int [][] ans = new int [ 2 ][ colsum . length ] ; for ( int j = 0 ; j < colsum . length ; ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . length ; ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ] ; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return new ArrayList ( Arrays . asList ( ans [ 0 ] , ans [ 1 ] )); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reconstructMatrix ( self , upper : int , lower : int , colsum : List [ int ]) -> List [ List [ int ]]: if upper + lower != sum ( colsum ): return [] if min ( upper , lower ) < colsum . count ( 2 ): return [] ans = [[ 0 ] * len ( colsum ) for _ in range ( 2 )] for j , c in enumerate ( colsum ): if c == 2 : ans [ 0 ][ j ] = 1 ans [ 1 ][ j ] = 1 upper -= 1 lower -= 1 for j , c in enumerate ( colsum ): if c == 1 and upper > 0 : ans [ 0 ][ j ] = 1 c -= 1 upper -= 1 if c == 1 and lower > 0 : ans [ 1 ][ j ] = 1 lower -= 1 return ans","title":"1253. Reconstruct a 2-Row Binary Matrix"},{"location":"problems/1254/","text":"1254. Number of Closed Islands","title":"1254. Number of Closed Islands"},{"location":"problems/1254/#1254-number-of-closed-islands","text":"","title":"1254. Number of Closed Islands"},{"location":"problems/1255/","text":"1255. Maximum Score Words Formed by Letters","title":"1255. Maximum Score Words Formed by Letters"},{"location":"problems/1255/#1255-maximum-score-words-formed-by-letters","text":"","title":"1255. Maximum Score Words Formed by Letters"},{"location":"problems/1256/","text":"1256. Encode Number \ud83d\udd12","title":"1256. Encode Number"},{"location":"problems/1256/#1256-encode-number","text":"","title":"1256. Encode Number \ud83d\udd12"},{"location":"problems/1257/","text":"1257. Smallest Common Region \ud83d\udd12","title":"1257. Smallest Common Region"},{"location":"problems/1257/#1257-smallest-common-region","text":"","title":"1257. Smallest Common Region \ud83d\udd12"},{"location":"problems/1258/","text":"1258. Synonymous Sentences \ud83d\udd12","title":"1258. Synonymous Sentences"},{"location":"problems/1258/#1258-synonymous-sentences","text":"","title":"1258. Synonymous Sentences \ud83d\udd12"},{"location":"problems/1259/","text":"1259. Handshakes That Don't Cross \ud83d\udd12","title":"1259. Handshakes That Don't Cross"},{"location":"problems/1259/#1259-handshakes-that-dont-cross","text":"","title":"1259. Handshakes That Don't Cross \ud83d\udd12"},{"location":"problems/1260/","text":"1260. Shift 2D Grid Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; ans [ x ][ y ] = grid [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> shiftGrid ( int [][] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); int [][] arr = new int [ m ][ n ] ; k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; arr [ x ][ y ] = grid [ i ][ j ] ; } for ( int [] row : arr ) ans . add ( Arrays . stream ( row ). boxed (). collect ( Collectors . toList ())); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def shiftGrid ( self , grid : List [ List [ int ]], k : int ) -> List [ List [ int ]]: m = len ( grid ) n = len ( grid [ 0 ]) ans = [[ 0 ] * n for _ in range ( m )] k %= m * n for i in range ( m ): for j in range ( n ): index = ( i * n + j + k ) % ( m * n ) x = index // n y = index % n ans [ x ][ y ] = grid [ i ][ j ] return ans","title":"1260. Shift 2D Grid"},{"location":"problems/1260/#1260-shift-2d-grid","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; ans [ x ][ y ] = grid [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List < List < Integer >> shiftGrid ( int [][] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); int [][] arr = new int [ m ][ n ] ; k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; arr [ x ][ y ] = grid [ i ][ j ] ; } for ( int [] row : arr ) ans . add ( Arrays . stream ( row ). boxed (). collect ( Collectors . toList ())); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def shiftGrid ( self , grid : List [ List [ int ]], k : int ) -> List [ List [ int ]]: m = len ( grid ) n = len ( grid [ 0 ]) ans = [[ 0 ] * n for _ in range ( m )] k %= m * n for i in range ( m ): for j in range ( n ): index = ( i * n + j + k ) % ( m * n ) x = index // n y = index % n ans [ x ][ y ] = grid [ i ][ j ] return ans","title":"1260. Shift 2D Grid"},{"location":"problems/1261/","text":"1261. Find Elements in a Contaminated Binary Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FindElements { public : FindElements ( TreeNode * root ) { dfs ( root , 0 ); } bool find ( int target ) { return vals . count ( target ); } private : unordered_set < int > vals ; void dfs ( TreeNode * root , int val ) { if ( ! root ) return ; root -> val = val ; vals . insert ( val ); dfs ( root -> left , val * 2 + 1 ); dfs ( root -> right , val * 2 + 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FindElements { public FindElements ( TreeNode root ) { dfs ( root , 0 ); } public boolean find ( int target ) { return vals . contains ( target ); } private Set < Integer > vals = new HashSet <> (); private void dfs ( TreeNode root , int val ) { if ( root == null ) return ; root . val = val ; vals . add ( val ); dfs ( root . left , val * 2 + 1 ); dfs ( root . right , val * 2 + 2 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class FindElements : def __init__ ( self , root : TreeNode ): self . vals = set () self . dfs ( root , 0 ) def find ( self , target : int ) -> bool : return target in self . vals def dfs ( self , root : TreeNode , val : int ) -> None : if not root : return root . val = val self . vals . add ( val ) self . dfs ( root . left , val * 2 + 1 ) self . dfs ( root . right , val * 2 + 2 )","title":"1261. Find Elements in a Contaminated Binary Tree"},{"location":"problems/1261/#1261-find-elements-in-a-contaminated-binary-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class FindElements { public : FindElements ( TreeNode * root ) { dfs ( root , 0 ); } bool find ( int target ) { return vals . count ( target ); } private : unordered_set < int > vals ; void dfs ( TreeNode * root , int val ) { if ( ! root ) return ; root -> val = val ; vals . insert ( val ); dfs ( root -> left , val * 2 + 1 ); dfs ( root -> right , val * 2 + 2 ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FindElements { public FindElements ( TreeNode root ) { dfs ( root , 0 ); } public boolean find ( int target ) { return vals . contains ( target ); } private Set < Integer > vals = new HashSet <> (); private void dfs ( TreeNode root , int val ) { if ( root == null ) return ; root . val = val ; vals . add ( val ); dfs ( root . left , val * 2 + 1 ); dfs ( root . right , val * 2 + 2 ); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class FindElements : def __init__ ( self , root : TreeNode ): self . vals = set () self . dfs ( root , 0 ) def find ( self , target : int ) -> bool : return target in self . vals def dfs ( self , root : TreeNode , val : int ) -> None : if not root : return root . val = val self . vals . add ( val ) self . dfs ( root . left , val * 2 + 1 ) self . dfs ( root . right , val * 2 + 2 )","title":"1261. Find Elements in a Contaminated Binary Tree"},{"location":"problems/1262/","text":"1262. Greatest Sum Divisible by Three","title":"1262. Greatest Sum Divisible by Three"},{"location":"problems/1262/#1262-greatest-sum-divisible-by-three","text":"","title":"1262. Greatest Sum Divisible by Three"},{"location":"problems/1263/","text":"1263. Minimum Moves to Move a Box to Their Target Location","title":"1263. Minimum Moves to Move a Box to Their Target Location"},{"location":"problems/1263/#1263-minimum-moves-to-move-a-box-to-their-target-location","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location"},{"location":"problems/1264/","text":"1264. Page Recommendations \ud83d\udd12","title":"1264. Page Recommendations"},{"location":"problems/1264/#1264-page-recommendations","text":"","title":"1264. Page Recommendations \ud83d\udd12"},{"location":"problems/1265/","text":"1265. Print Immutable Linked List in Reverse \ud83d\udd12","title":"1265. Print Immutable Linked List in Reverse"},{"location":"problems/1265/#1265-print-immutable-linked-list-in-reverse","text":"","title":"1265. Print Immutable Linked List in Reverse \ud83d\udd12"},{"location":"problems/1266/","text":"1266. Minimum Time Visiting All Points Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minTimeToVisitAllPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 1 ; i < points . size (); ++ i ) ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minTimeToVisitAllPoints ( int [][] points ) { int ans = 0 ; for ( int i = 1 ; i < points . length ; ++ i ) ans += Math . max ( Math . abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ] ), Math . abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ] )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def minTimeToVisitAllPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i in range ( 1 , len ( points )): ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])) return ans","title":"1266. Minimum Time Visiting All Points"},{"location":"problems/1266/#1266-minimum-time-visiting-all-points","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minTimeToVisitAllPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 1 ; i < points . size (); ++ i ) ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int minTimeToVisitAllPoints ( int [][] points ) { int ans = 0 ; for ( int i = 1 ; i < points . length ; ++ i ) ans += Math . max ( Math . abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ] ), Math . abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ] )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def minTimeToVisitAllPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i in range ( 1 , len ( points )): ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])) return ans","title":"1266. Minimum Time Visiting All Points"},{"location":"problems/1267/","text":"1267. Count Servers that Communicate Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int countServers ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > rows ( m ); vector < int > cols ( n ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ]; ++ cols [ j ]; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int countServers ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [] rows = new int [ m ] ; int [] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def countServers ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 rows = [ 0 ] * m cols = [ 0 ] * n for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : rows [ i ] += 1 cols [ j ] += 1 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 and ( rows [ i ] > 1 or cols [ j ] > 1 ): ans += 1 return ans","title":"1267. Count Servers that Communicate"},{"location":"problems/1267/#1267-count-servers-that-communicate","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int countServers ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > rows ( m ); vector < int > cols ( n ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ]; ++ cols [ j ]; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int countServers ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [] rows = new int [ m ] ; int [] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def countServers ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 rows = [ 0 ] * m cols = [ 0 ] * n for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : rows [ i ] += 1 cols [ j ] += 1 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 and ( rows [ i ] > 1 or cols [ j ] > 1 ): ans += 1 return ans","title":"1267. Count Servers that Communicate"},{"location":"problems/1268/","text":"1268. Search Suggestions System","title":"1268. Search Suggestions System"},{"location":"problems/1268/#1268-search-suggestions-system","text":"","title":"1268. Search Suggestions System"},{"location":"problems/1269/","text":"1269. Number of Ways to Stay in the Same Place After Some Steps Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numWays ( int steps , int arrLen ) { constexpr int kMod = 1e9 + 7 ; const int n = min ( arrLen , steps / 2 + 1 ); vector < long > dp ( n ); // dp[i] := # of ways to stay on index i dp [ 0 ] = 1 ; while ( steps -- ) { vector < long > newDp ( n ); for ( int i = 0 ; i < n ; ++ i ) { newDp [ i ] = dp [ i ]; if ( i - 1 >= 0 ) newDp [ i ] += dp [ i - 1 ]; if ( i + 1 < n ) newDp [ i ] += dp [ i + 1 ]; newDp [ i ] %= kMod ; } dp = move ( newDp ); } return dp [ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numWays ( int steps , int arrLen ) { final long kMod = ( long ) 1e9 + 7 ; final int n = Math . min ( arrLen , steps / 2 + 1 ); long [] dp = new long [ n ] ; // dp[i] := # of ways to stay on index i dp [ 0 ] = 1 ; while ( steps -- > 0 ) { long [] newDp = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { newDp [ i ] = dp [ i ] ; if ( i - 1 >= 0 ) newDp [ i ] += dp [ i - 1 ] ; if ( i + 1 < n ) newDp [ i ] += dp [ i + 1 ] ; newDp [ i ] %= kMod ; } dp = newDp ; } return ( int ) dp [ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numWays ( self , steps : int , arrLen : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) dp [ 0 ] = 1 for _ in range ( steps ): newDp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) for i , ways in enumerate ( dp ): if ways > 0 : for dx in ( - 1 , 0 , 1 ): nextIndex = i + dx if 0 <= nextIndex < len ( dp ): newDp [ nextIndex ] += ways newDp [ nextIndex ] %= kMod dp = newDp return dp [ 0 ]","title":"1269. Number of Ways to Stay in the Same Place After Some Steps"},{"location":"problems/1269/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numWays ( int steps , int arrLen ) { constexpr int kMod = 1e9 + 7 ; const int n = min ( arrLen , steps / 2 + 1 ); vector < long > dp ( n ); // dp[i] := # of ways to stay on index i dp [ 0 ] = 1 ; while ( steps -- ) { vector < long > newDp ( n ); for ( int i = 0 ; i < n ; ++ i ) { newDp [ i ] = dp [ i ]; if ( i - 1 >= 0 ) newDp [ i ] += dp [ i - 1 ]; if ( i + 1 < n ) newDp [ i ] += dp [ i + 1 ]; newDp [ i ] %= kMod ; } dp = move ( newDp ); } return dp [ 0 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numWays ( int steps , int arrLen ) { final long kMod = ( long ) 1e9 + 7 ; final int n = Math . min ( arrLen , steps / 2 + 1 ); long [] dp = new long [ n ] ; // dp[i] := # of ways to stay on index i dp [ 0 ] = 1 ; while ( steps -- > 0 ) { long [] newDp = new long [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { newDp [ i ] = dp [ i ] ; if ( i - 1 >= 0 ) newDp [ i ] += dp [ i - 1 ] ; if ( i + 1 < n ) newDp [ i ] += dp [ i + 1 ] ; newDp [ i ] %= kMod ; } dp = newDp ; } return ( int ) dp [ 0 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numWays ( self , steps : int , arrLen : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) dp [ 0 ] = 1 for _ in range ( steps ): newDp = [ 0 ] * min ( steps // 2 + 1 , arrLen ) for i , ways in enumerate ( dp ): if ways > 0 : for dx in ( - 1 , 0 , 1 ): nextIndex = i + dx if 0 <= nextIndex < len ( dp ): newDp [ nextIndex ] += ways newDp [ nextIndex ] %= kMod dp = newDp return dp [ 0 ]","title":"1269. Number of Ways to Stay in the Same Place After Some Steps"},{"location":"problems/1270/","text":"1270. All People Report to the Given Manager \ud83d\udd12","title":"1270. All People Report to the Given Manager"},{"location":"problems/1270/#1270-all-people-report-to-the-given-manager","text":"","title":"1270. All People Report to the Given Manager \ud83d\udd12"},{"location":"problems/1271/","text":"1271. Hexspeak \ud83d\udd12","title":"1271. Hexspeak"},{"location":"problems/1271/#1271-hexspeak","text":"","title":"1271. Hexspeak \ud83d\udd12"},{"location":"problems/1272/","text":"1272. Remove Interval \ud83d\udd12","title":"1272. Remove Interval"},{"location":"problems/1272/#1272-remove-interval","text":"","title":"1272. Remove Interval \ud83d\udd12"},{"location":"problems/1273/","text":"1273. Delete Tree Nodes \ud83d\udd12","title":"1273. Delete Tree Nodes"},{"location":"problems/1273/#1273-delete-tree-nodes","text":"","title":"1273. Delete Tree Nodes \ud83d\udd12"},{"location":"problems/1274/","text":"1274. Number of Ships in a Rectangle \ud83d\udd12","title":"1274. Number of Ships in a Rectangle"},{"location":"problems/1274/#1274-number-of-ships-in-a-rectangle","text":"","title":"1274. Number of Ships in a Rectangle \ud83d\udd12"},{"location":"problems/1275/","text":"1275. Find Winner on a Tic Tac Toe Game Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : string tictactoe ( vector < vector < int >>& moves ) { vector < vector < int >> row ( 2 , vector < int > ( 3 )); vector < vector < int >> col ( 2 , vector < int > ( 3 )); vector < int > diag1 ( 2 ); vector < int > diag2 ( 2 ); for ( int i = 0 ; i < moves . size (); ++ i ) { int r = moves [ i ][ 0 ]; int c = moves [ i ][ 1 ]; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . size () == 9 ? \"Draw\" : \"Pending\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String tictactoe ( int [][] moves ) { int [][] row = new int [ 2 ][ 3 ] ; int [][] col = new int [ 2 ][ 3 ] ; int [] diag1 = new int [ 2 ] ; int [] diag2 = new int [ 2 ] ; for ( int i = 0 ; i < moves . length ; ++ i ) { int r = moves [ i ][ 0 ] ; int c = moves [ i ][ 1 ] ; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . length == 9 ? \"Draw\" : \"Pending\" ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def tictactoe ( self , moves : List [ List [ int ]]) -> str : row = [[ 0 ] * 3 for _ in range ( 2 )] col = [[ 0 ] * 3 for _ in range ( 2 )] diag1 = [ 0 ] * 2 diag2 = [ 0 ] * 2 i = 0 for r , c in moves : row [ i ][ r ] += 1 col [ i ][ c ] += 1 diag1 [ i ] += r == c diag2 [ i ] += r + c == 2 if 3 in ( row [ i ][ r ], col [ i ][ c ], diag1 [ i ], diag2 [ i ]): return \"A\" if i == 0 else \"B\" i ^= 1 return \"Draw\" if len ( moves ) == 9 else \"Pending\"","title":"1275. Find Winner on a Tic Tac Toe Game"},{"location":"problems/1275/#1275-find-winner-on-a-tic-tac-toe-game","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : string tictactoe ( vector < vector < int >>& moves ) { vector < vector < int >> row ( 2 , vector < int > ( 3 )); vector < vector < int >> col ( 2 , vector < int > ( 3 )); vector < int > diag1 ( 2 ); vector < int > diag2 ( 2 ); for ( int i = 0 ; i < moves . size (); ++ i ) { int r = moves [ i ][ 0 ]; int c = moves [ i ][ 1 ]; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . size () == 9 ? \"Draw\" : \"Pending\" ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String tictactoe ( int [][] moves ) { int [][] row = new int [ 2 ][ 3 ] ; int [][] col = new int [ 2 ][ 3 ] ; int [] diag1 = new int [ 2 ] ; int [] diag2 = new int [ 2 ] ; for ( int i = 0 ; i < moves . length ; ++ i ) { int r = moves [ i ][ 0 ] ; int c = moves [ i ][ 1 ] ; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . length == 9 ? \"Draw\" : \"Pending\" ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def tictactoe ( self , moves : List [ List [ int ]]) -> str : row = [[ 0 ] * 3 for _ in range ( 2 )] col = [[ 0 ] * 3 for _ in range ( 2 )] diag1 = [ 0 ] * 2 diag2 = [ 0 ] * 2 i = 0 for r , c in moves : row [ i ][ r ] += 1 col [ i ][ c ] += 1 diag1 [ i ] += r == c diag2 [ i ] += r + c == 2 if 3 in ( row [ i ][ r ], col [ i ][ c ], diag1 [ i ], diag2 [ i ]): return \"A\" if i == 0 else \"B\" i ^= 1 return \"Draw\" if len ( moves ) == 9 else \"Pending\"","title":"1275. Find Winner on a Tic Tac Toe Game"},{"location":"problems/1276/","text":"1276. Number of Burgers with No Waste of Ingredients Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return {}; int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return { jumboBurgers , cheeseSlices - jumboBurgers }; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public List < Integer > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return new ArrayList <> (); int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return new ArrayList <> ( Arrays . asList ( jumboBurgers , cheeseSlices - jumboBurgers )); } } Python 1 2 3 4 5 6 7 8 class Solution : def numOfBurgers ( self , tomatoSlices : int , cheeseSlices : int ) -> List [ int ]: if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4 : return [] jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) // 2 return [ jumboBurgers , cheeseSlices - jumboBurgers ]","title":"1276. Number of Burgers with No Waste of Ingredients"},{"location":"problems/1276/#1276-number-of-burgers-with-no-waste-of-ingredients","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return {}; int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return { jumboBurgers , cheeseSlices - jumboBurgers }; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public List < Integer > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return new ArrayList <> (); int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return new ArrayList <> ( Arrays . asList ( jumboBurgers , cheeseSlices - jumboBurgers )); } } Python 1 2 3 4 5 6 7 8 class Solution : def numOfBurgers ( self , tomatoSlices : int , cheeseSlices : int ) -> List [ int ]: if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4 : return [] jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) // 2 return [ jumboBurgers , cheeseSlices - jumboBurgers ]","title":"1276. Number of Burgers with No Waste of Ingredients"},{"location":"problems/1277/","text":"1277. Count Square Submatrices with All Ones Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countSquares ( vector < vector < int >>& matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += min ({ matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]}); ans += matrix [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int countSquares ( int [][] matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += Math . min ( matrix [ i - 1 ][ j - 1 ] , Math . min ( matrix [ i - 1 ][ j ] , matrix [ i ][ j - 1 ] )); ans += matrix [ i ][ j ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def countSquares ( self , matrix : List [ List [ int ]]) -> int : for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 1 and i > 0 and j > 0 : matrix [ i ][ j ] += min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]) return sum ( sum ( row ) for row in matrix )","title":"1277. Count Square Submatrices with All Ones"},{"location":"problems/1277/#1277-count-square-submatrices-with-all-ones","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countSquares ( vector < vector < int >>& matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += min ({ matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]}); ans += matrix [ i ][ j ]; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int countSquares ( int [][] matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += Math . min ( matrix [ i - 1 ][ j - 1 ] , Math . min ( matrix [ i - 1 ][ j ] , matrix [ i ][ j - 1 ] )); ans += matrix [ i ][ j ] ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def countSquares ( self , matrix : List [ List [ int ]]) -> int : for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 1 and i > 0 and j > 0 : matrix [ i ][ j ] += min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]) return sum ( sum ( row ) for row in matrix )","title":"1277. Count Square Submatrices with All Ones"},{"location":"problems/1278/","text":"1278. Palindrome Partitioning III Approach 1: Bottom-up Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int palindromePartition ( string s , int K ) { const int n = s . length (); // dp[i][k] := min cost to make k palindromes by s[0..i) vector < vector < int >> dp ( n + 1 , vector < int > ( K + 1 , n )); vector < vector < int >> cost ( n , vector < int > ( n )); // cost[i][j] := min cost to make s[i..j] palindrome for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ][ 1 ] = cost [ 0 ][ i - 1 ]; for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j ][ k - 1 ] + cost [ j ][ i - 1 ]); return dp [ n ][ K ]; } }; Approach 2: Top-down Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int palindromePartition ( string s , int k ) { const int n = s . length (); vector < vector < int >> memo ( n + 1 , vector < int > ( k + 1 , n )); vector < vector < int >> cost ( n , vector < int > ( n )); // cost[i][j] := min cost to make s[i..j] palindrome for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; // dp(n, k) := min cost to make k palindromes by s[0..n) function < int ( int , int ) > dp = [ & ]( int n , int k ) { if ( k == 1 ) return cost [ 0 ][ n - 1 ]; int & ans = memo [ n ][ k ]; if ( ans < n ) return ans ; // try all possible partitions for ( int i = k - 1 ; i < n ; ++ i ) ans = min ( ans , dp ( i , k - 1 ) + cost [ i ][ n - 1 ]); return ans ; }; return dp ( n , k ); } };","title":"1278. Palindrome Partitioning III"},{"location":"problems/1278/#1278-palindrome-partitioning-iii","text":"","title":"1278. Palindrome Partitioning III"},{"location":"problems/1278/#approach-1-bottom-up","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int palindromePartition ( string s , int K ) { const int n = s . length (); // dp[i][k] := min cost to make k palindromes by s[0..i) vector < vector < int >> dp ( n + 1 , vector < int > ( K + 1 , n )); vector < vector < int >> cost ( n , vector < int > ( n )); // cost[i][j] := min cost to make s[i..j] palindrome for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; for ( int i = 1 ; i <= n ; ++ i ) dp [ i ][ 1 ] = cost [ 0 ][ i - 1 ]; for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j ][ k - 1 ] + cost [ j ][ i - 1 ]); return dp [ n ][ K ]; } };","title":"Approach 1: Bottom-up"},{"location":"problems/1278/#approach-2-top-down","text":"Time: $O(n^3)$ Space: $O(n^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int palindromePartition ( string s , int k ) { const int n = s . length (); vector < vector < int >> memo ( n + 1 , vector < int > ( k + 1 , n )); vector < vector < int >> cost ( n , vector < int > ( n )); // cost[i][j] := min cost to make s[i..j] palindrome for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; // dp(n, k) := min cost to make k palindromes by s[0..n) function < int ( int , int ) > dp = [ & ]( int n , int k ) { if ( k == 1 ) return cost [ 0 ][ n - 1 ]; int & ans = memo [ n ][ k ]; if ( ans < n ) return ans ; // try all possible partitions for ( int i = k - 1 ; i < n ; ++ i ) ans = min ( ans , dp ( i , k - 1 ) + cost [ i ][ n - 1 ]); return ans ; }; return dp ( n , k ); } };","title":"Approach 2: Top-down"},{"location":"problems/1279/","text":"1279. Traffic Light Controlled Intersection \ud83d\udd12","title":"1279. Traffic Light Controlled Intersection"},{"location":"problems/1279/#1279-traffic-light-controlled-intersection","text":"","title":"1279. Traffic Light Controlled Intersection \ud83d\udd12"},{"location":"problems/1280/","text":"1280. Students and Examinations \ud83d\udd12","title":"1280. Students and Examinations"},{"location":"problems/1280/#1280-students-and-examinations","text":"","title":"1280. Students and Examinations \ud83d\udd12"},{"location":"problems/1281/","text":"1281. Subtract the Product and Sum of Digits of an Integer Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def subtractProductAndSum ( self , n : int ) -> int : prod = 1 summ = 0 while n > 0 : prod *= n % 10 summ += n % 10 n //= 10 return prod - summ","title":"1281. Subtract the Product and Sum of Digits of an Integer"},{"location":"problems/1281/#1281-subtract-the-product-and-sum-of-digits-of-an-integer","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } } Python 1 2 3 4 5 6 7 8 9 10 11 class Solution : def subtractProductAndSum ( self , n : int ) -> int : prod = 1 summ = 0 while n > 0 : prod *= n % 10 summ += n % 10 n //= 10 return prod - summ","title":"1281. Subtract the Product and Sum of Digits of an Integer"},{"location":"problems/1282/","text":"1282. Group the People Given the Group Size They Belong To","title":"1282. Group the People Given the Group Size They Belong To"},{"location":"problems/1282/#1282-group-the-people-given-the-group-size-they-belong-to","text":"","title":"1282. Group the People Given the Group Size They Belong To"},{"location":"problems/1283/","text":"1283. Find the Smallest Divisor Given a Threshold","title":"1283. Find the Smallest Divisor Given a Threshold"},{"location":"problems/1283/#1283-find-the-smallest-divisor-given-a-threshold","text":"","title":"1283. Find the Smallest Divisor Given a Threshold"},{"location":"problems/1284/","text":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix"},{"location":"problems/1284/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix"},{"location":"problems/1285/","text":"1285. Find the Start and End Number of Continuous Ranges \ud83d\udd12","title":"1285. Find the Start and End Number of Continuous Ranges"},{"location":"problems/1285/#1285-find-the-start-and-end-number-of-continuous-ranges","text":"","title":"1285. Find the Start and End Number of Continuous Ranges \ud83d\udd12"},{"location":"problems/1286/","text":"1286. Iterator for Combination","title":"1286. Iterator for Combination"},{"location":"problems/1286/#1286-iterator-for-combination","text":"","title":"1286. Iterator for Combination"},{"location":"problems/1287/","text":"1287. Element Appearing More Than 25% In Sorted Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int findSpecialInteger ( vector < int >& arr ) { const int n = arr . size (); const int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ]) return arr [ i ]; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int findSpecialInteger ( int [] arr ) { final int n = arr . length ; final int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ] ) return arr [ i ] ; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def findSpecialInteger ( self , arr : List [ int ]) -> int : n = len ( arr ) quarter = n // 4 for i in range ( n - quarter ): if arr [ i ] == arr [ i + quarter ]: return arr [ i ]","title":"1287. Element Appearing More Than 25% In Sorted Array"},{"location":"problems/1287/#1287-element-appearing-more-than-25-in-sorted-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int findSpecialInteger ( vector < int >& arr ) { const int n = arr . size (); const int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ]) return arr [ i ]; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int findSpecialInteger ( int [] arr ) { final int n = arr . length ; final int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ] ) return arr [ i ] ; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 class Solution : def findSpecialInteger ( self , arr : List [ int ]) -> int : n = len ( arr ) quarter = n // 4 for i in range ( n - quarter ): if arr [ i ] == arr [ i + quarter ]: return arr [ i ]","title":"1287. Element Appearing More Than 25% In Sorted Array"},{"location":"problems/1288/","text":"1288. Remove Covered Intervals","title":"1288. Remove Covered Intervals"},{"location":"problems/1288/#1288-remove-covered-intervals","text":"","title":"1288. Remove Covered Intervals"},{"location":"problems/1289/","text":"1289. Minimum Falling Path Sum II","title":"1289. Minimum Falling Path Sum II"},{"location":"problems/1289/#1289-minimum-falling-path-sum-ii","text":"","title":"1289. Minimum Falling Path Sum II"},{"location":"problems/1290/","text":"1290. Convert Binary Number in a Linked List to Integer Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int getDecimalValue ( ListNode * head ) { int ans = 0 ; for (; head ; head = head -> next ) ans = ans * 2 + head -> val ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int getDecimalValue ( ListNode head ) { int ans = 0 ; for (; head != null ; head = head . next ) ans = ans * 2 + head . val ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def getDecimalValue ( self , head : ListNode ) -> int : ans = 0 while head : ans = ans * 2 + head . val head = head . next return ans","title":"1290. Convert Binary Number in a Linked List to Integer"},{"location":"problems/1290/#1290-convert-binary-number-in-a-linked-list-to-integer","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int getDecimalValue ( ListNode * head ) { int ans = 0 ; for (; head ; head = head -> next ) ans = ans * 2 + head -> val ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int getDecimalValue ( ListNode head ) { int ans = 0 ; for (; head != null ; head = head . next ) ans = ans * 2 + head . val ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def getDecimalValue ( self , head : ListNode ) -> int : ans = 0 while head : ans = ans * 2 + head . val head = head . next return ans","title":"1290. Convert Binary Number in a Linked List to Integer"},{"location":"problems/1291/","text":"1291. Sequential Digits","title":"1291. Sequential Digits"},{"location":"problems/1291/#1291-sequential-digits","text":"","title":"1291. Sequential Digits"},{"location":"problems/1292/","text":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int maxSideLength ( vector < vector < int >>& mat , int threshold ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; vector < vector < int >> prefixSum ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ]; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = max ( ans , length + 1 ); } return ans ; } private : int squareSum ( vector < vector < int >>& prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxSideLength ( int [][] mat , int threshold ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [][] prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < Math . min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = Math . max ( ans , length + 1 ); } return ans ; } private int squareSum ( int [][] prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def maxSideLength ( self , mat : List [ List [ int ]], threshold : int ) -> int : def squareSum ( r1 : int , c1 : int , r2 : int , c2 : int ) -> int : return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] m = len ( mat ) n = len ( mat [ 0 ]) ans = 0 prefixSum = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + \\ prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] for i in range ( m ): for j in range ( n ): for length in range ( ans , min ( m - i , n - j )): if squareSum ( i , j , i + length , j + length ) > threshold : break ans = max ( ans , length + 1 ) return ans","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold"},{"location":"problems/1292/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int maxSideLength ( vector < vector < int >>& mat , int threshold ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; vector < vector < int >> prefixSum ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ]; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = max ( ans , length + 1 ); } return ans ; } private : int squareSum ( vector < vector < int >>& prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxSideLength ( int [][] mat , int threshold ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [][] prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < Math . min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = Math . max ( ans , length + 1 ); } return ans ; } private int squareSum ( int [][] prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def maxSideLength ( self , mat : List [ List [ int ]], threshold : int ) -> int : def squareSum ( r1 : int , c1 : int , r2 : int , c2 : int ) -> int : return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] m = len ( mat ) n = len ( mat [ 0 ]) ans = 0 prefixSum = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + \\ prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] for i in range ( m ): for j in range ( n ): for length in range ( ans , min ( m - i , n - j )): if squareSum ( i , j , i + length , j + length ) > threshold : break ans = max ( ans , length + 1 ) return ans","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold"},{"location":"problems/1293/","text":"1293. Shortest Path in a Grid with Obstacles Elimination","title":"1293. Shortest Path in a Grid with Obstacles Elimination"},{"location":"problems/1293/#1293-shortest-path-in-a-grid-with-obstacles-elimination","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination"},{"location":"problems/1294/","text":"1294. Weather Type in Each Country \ud83d\udd12","title":"1294. Weather Type in Each Country"},{"location":"problems/1294/#1294-weather-type-in-each-country","text":"","title":"1294. Weather Type in Each Country \ud83d\udd12"},{"location":"problems/1295/","text":"1295. Find Numbers with Even Number of Digits Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int findNumbers ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int findNumbers ( int [] nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def findNumbers ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if 9 < num < 100 or 999 < num < 10000 or num == 100000 : ans += 1 return ans","title":"1295. Find Numbers with Even Number of Digits"},{"location":"problems/1295/#1295-find-numbers-with-even-number-of-digits","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int findNumbers ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int findNumbers ( int [] nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def findNumbers ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if 9 < num < 100 or 999 < num < 10000 or num == 100000 : ans += 1 return ans","title":"1295. Find Numbers with Even Number of Digits"},{"location":"problems/1296/","text":"1296. Divide Array in Sets of K Consecutive Numbers Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isPossibleDivide ( vector < int >& nums , int k ) { map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ key , _ ] : count ) { int value = count [ key ]; if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count [ i ] -= value ; if ( count [ i ] < 0 ) return false ; } } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isPossibleDivide ( int [] nums , int k ) { TreeMap < Integer , Integer > count = new TreeMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int key : count . keySet ()) { int value = count . getOrDefault ( key , 0 ); if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ); if ( count . get ( i ) < 0 ) return false ; } } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPossibleDivide ( self , nums : List [ int ], k : int ) -> bool : count = collections . Counter ( nums ) for key in sorted ( count ): value = count [ key ] if value > 0 : for i in range ( key , key + k ): count [ i ] -= value if count [ i ] < 0 : return False return True","title":"1296. Divide Array in Sets of K Consecutive Numbers"},{"location":"problems/1296/#1296-divide-array-in-sets-of-k-consecutive-numbers","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool isPossibleDivide ( vector < int >& nums , int k ) { map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ key , _ ] : count ) { int value = count [ key ]; if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count [ i ] -= value ; if ( count [ i ] < 0 ) return false ; } } return true ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public boolean isPossibleDivide ( int [] nums , int k ) { TreeMap < Integer , Integer > count = new TreeMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int key : count . keySet ()) { int value = count . getOrDefault ( key , 0 ); if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ); if ( count . get ( i ) < 0 ) return false ; } } return true ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPossibleDivide ( self , nums : List [ int ], k : int ) -> bool : count = collections . Counter ( nums ) for key in sorted ( count ): value = count [ key ] if value > 0 : for i in range ( key , key + k ): count [ i ] -= value if count [ i ] < 0 : return False return True","title":"1296. Divide Array in Sets of K Consecutive Numbers"},{"location":"problems/1297/","text":"1297. Maximum Number of Occurrences of a Substring","title":"1297. Maximum Number of Occurrences of a Substring"},{"location":"problems/1297/#1297-maximum-number-of-occurrences-of-a-substring","text":"","title":"1297. Maximum Number of Occurrences of a Substring"},{"location":"problems/1298/","text":"1298. Maximum Candies You Can Get from Boxes","title":"1298. Maximum Candies You Can Get from Boxes"},{"location":"problems/1298/#1298-maximum-candies-you-can-get-from-boxes","text":"","title":"1298. Maximum Candies You Can Get from Boxes"},{"location":"problems/1299/","text":"1299. Replace Elements with Greatest Element on Right Side Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int maxOfRight = -1 ; for ( int i = arr . size () - 1 ; i >= 0 ; -- i ) maxOfRight = max ( maxOfRight , exchange ( arr [ i ], maxOfRight )); return arr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] replaceElements ( int [] arr ) { int maxOfRight = - 1 ; for ( int i = arr . length - 1 ; i >= 0 ; -- i ) { int a = arr [ i ] ; arr [ i ] = maxOfRight ; maxOfRight = Math . max ( maxOfRight , a ); } return arr ; } } Python 1 2 3 4 5 6 7 8 class Solution : def replaceElements ( self , arr : List [ int ]) -> List [ int ]: maxOfRight = - 1 for i in range ( len ( arr ))[:: - 1 ]: arr [ i ], maxOfRight = maxOfRight , max ( maxOfRight , arr [ i ]) return arr","title":"1299. Replace Elements with Greatest Element on Right Side"},{"location":"problems/1299/#1299-replace-elements-with-greatest-element-on-right-side","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int maxOfRight = -1 ; for ( int i = arr . size () - 1 ; i >= 0 ; -- i ) maxOfRight = max ( maxOfRight , exchange ( arr [ i ], maxOfRight )); return arr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] replaceElements ( int [] arr ) { int maxOfRight = - 1 ; for ( int i = arr . length - 1 ; i >= 0 ; -- i ) { int a = arr [ i ] ; arr [ i ] = maxOfRight ; maxOfRight = Math . max ( maxOfRight , a ); } return arr ; } } Python 1 2 3 4 5 6 7 8 class Solution : def replaceElements ( self , arr : List [ int ]) -> List [ int ]: maxOfRight = - 1 for i in range ( len ( arr ))[:: - 1 ]: arr [ i ], maxOfRight = maxOfRight , max ( maxOfRight , arr [ i ]) return arr","title":"1299. Replace Elements with Greatest Element on Right Side"},{"location":"problems/1300/","text":"1300. Sum of Mutated Array Closest to Target Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findBestValue ( vector < int >& arr , int target ) { const int n = arr . size (); const double err = 1e-9 ; int prefixSum = 0 ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i < n ; ++ i ) { int ans = round (( target - prefixSum - err ) / ( double )( n - i )); if ( ans <= arr [ i ]) return ans ; prefixSum += arr [ i ]; } return arr . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findBestValue ( int [] arr , int target ) { final int n = arr . length ; final double err = 1e-9 ; int prefixSum = 0 ; Arrays . sort ( arr ); for ( int i = 0 ; i < n ; ++ i ) { int ans = ( int ) Math . round ((( float ) target - prefixSum - err ) / ( n - i )); if ( ans <= arr [ i ] ) return ans ; prefixSum += arr [ i ] ; } return arr [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findBestValue ( self , arr : List [ int ], target : int ) -> int : prefixSum = 0 arr . sort () for i , a in enumerate ( arr ): ans = round (( target - prefixSum ) / ( len ( arr ) - i )) if ans <= a : return ans prefixSum += a return arr [ - 1 ]","title":"1300. Sum of Mutated Array Closest to Target"},{"location":"problems/1300/#1300-sum-of-mutated-array-closest-to-target","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findBestValue ( vector < int >& arr , int target ) { const int n = arr . size (); const double err = 1e-9 ; int prefixSum = 0 ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i < n ; ++ i ) { int ans = round (( target - prefixSum - err ) / ( double )( n - i )); if ( ans <= arr [ i ]) return ans ; prefixSum += arr [ i ]; } return arr . back (); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findBestValue ( int [] arr , int target ) { final int n = arr . length ; final double err = 1e-9 ; int prefixSum = 0 ; Arrays . sort ( arr ); for ( int i = 0 ; i < n ; ++ i ) { int ans = ( int ) Math . round ((( float ) target - prefixSum - err ) / ( n - i )); if ( ans <= arr [ i ] ) return ans ; prefixSum += arr [ i ] ; } return arr [ n - 1 ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findBestValue ( self , arr : List [ int ], target : int ) -> int : prefixSum = 0 arr . sort () for i , a in enumerate ( arr ): ans = round (( target - prefixSum ) / ( len ( arr ) - i )) if ans <= a : return ans prefixSum += a return arr [ - 1 ]","title":"1300. Sum of Mutated Array Closest to Target"},{"location":"problems/1301/","text":"1301. Number of Paths with Max Score","title":"1301. Number of Paths with Max Score"},{"location":"problems/1301/#1301-number-of-paths-with-max-score","text":"","title":"1301. Number of Paths with Max Score"},{"location":"problems/1302/","text":"1302. Deepest Leaves Sum","title":"1302. Deepest Leaves Sum"},{"location":"problems/1302/#1302-deepest-leaves-sum","text":"","title":"1302. Deepest Leaves Sum"},{"location":"problems/1303/","text":"1303. Find the Team Size \ud83d\udd12","title":"1303. Find the Team Size"},{"location":"problems/1303/#1303-find-the-team-size","text":"","title":"1303. Find the Team Size \ud83d\udd12"},{"location":"problems/1304/","text":"1304. Find N Unique Integers Sum up to Zero Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > sumZero ( int n ) { vector < int > ans ( n ); for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int [] sumZero ( int n ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } } Python 1 2 3 class Solution : def sumZero ( self , n : int ) -> List [ int ]: return list ( range ( 1 - n , n , 2 ))","title":"1304. Find N Unique Integers Sum up to Zero"},{"location":"problems/1304/#1304-find-n-unique-integers-sum-up-to-zero","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > sumZero ( int n ) { vector < int > ans ( n ); for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int [] sumZero ( int n ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } } Python 1 2 3 class Solution : def sumZero ( self , n : int ) -> List [ int ]: return list ( range ( 1 - n , n , 2 ))","title":"1304. Find N Unique Integers Sum up to Zero"},{"location":"problems/1305/","text":"1305. All Elements in Two Binary Search Trees Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class BSTIterator { public : BSTIterator ( TreeNode * root ) { pushLeftsUntilNull ( root ); } int peek () { return stack . top () -> val ; } void next () { TreeNode * node = stack . top (); stack . pop (); pushLeftsUntilNull ( node -> right ); } bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; void pushLeftsUntilNull ( TreeNode * node ) { while ( node ) { stack . push ( node ); node = node -> left ; } } }; class Solution { public : vector < int > getAllElements ( TreeNode * root1 , TreeNode * root2 ) { vector < int > ans ; BSTIterator bstIterator1 ( root1 ); BSTIterator bstIterator2 ( root2 ); while ( bstIterator1 . hasNext () && bstIterator2 . hasNext ()) if ( bstIterator1 . peek () < bstIterator2 . peek ()) { ans . push_back ( bstIterator1 . peek ()); bstIterator1 . next (); } else { ans . push_back ( bstIterator2 . peek ()); bstIterator2 . next (); } while ( bstIterator1 . hasNext ()) { ans . push_back ( bstIterator1 . peek ()); bstIterator1 . next (); } while ( bstIterator2 . hasNext ()) { ans . push_back ( bstIterator2 . peek ()); bstIterator2 . next (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class BSTIterator { public BSTIterator ( TreeNode root ) { pushLeftsUntilNull ( root ); } public int peek () { return stack . peek (). val ; } public void next () { pushLeftsUntilNull ( stack . pop (). right ); } public boolean hasNext () { return ! stack . isEmpty (); } private Stack < TreeNode > stack = new Stack <> (); private void pushLeftsUntilNull ( TreeNode node ) { while ( node != null ) { stack . push ( node ); node = node . left ; } } } class Solution { public List < Integer > getAllElements ( TreeNode root1 , TreeNode root2 ) { List < Integer > ans = new ArrayList <> (); BSTIterator bstIterator1 = new BSTIterator ( root1 ); BSTIterator bstIterator2 = new BSTIterator ( root2 ); while ( bstIterator1 . hasNext () && bstIterator2 . hasNext ()) if ( bstIterator1 . peek () < bstIterator2 . peek ()) { ans . add ( bstIterator1 . peek ()); bstIterator1 . next (); } else { ans . add ( bstIterator2 . peek ()); bstIterator2 . next (); } while ( bstIterator1 . hasNext ()) { ans . add ( bstIterator1 . peek ()); bstIterator1 . next (); } while ( bstIterator2 . hasNext ()) { ans . add ( bstIterator2 . peek ()); bstIterator2 . next (); } return ans ; } }","title":"1305. All Elements in Two Binary Search Trees"},{"location":"problems/1305/#1305-all-elements-in-two-binary-search-trees","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class BSTIterator { public : BSTIterator ( TreeNode * root ) { pushLeftsUntilNull ( root ); } int peek () { return stack . top () -> val ; } void next () { TreeNode * node = stack . top (); stack . pop (); pushLeftsUntilNull ( node -> right ); } bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; void pushLeftsUntilNull ( TreeNode * node ) { while ( node ) { stack . push ( node ); node = node -> left ; } } }; class Solution { public : vector < int > getAllElements ( TreeNode * root1 , TreeNode * root2 ) { vector < int > ans ; BSTIterator bstIterator1 ( root1 ); BSTIterator bstIterator2 ( root2 ); while ( bstIterator1 . hasNext () && bstIterator2 . hasNext ()) if ( bstIterator1 . peek () < bstIterator2 . peek ()) { ans . push_back ( bstIterator1 . peek ()); bstIterator1 . next (); } else { ans . push_back ( bstIterator2 . peek ()); bstIterator2 . next (); } while ( bstIterator1 . hasNext ()) { ans . push_back ( bstIterator1 . peek ()); bstIterator1 . next (); } while ( bstIterator2 . hasNext ()) { ans . push_back ( bstIterator2 . peek ()); bstIterator2 . next (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class BSTIterator { public BSTIterator ( TreeNode root ) { pushLeftsUntilNull ( root ); } public int peek () { return stack . peek (). val ; } public void next () { pushLeftsUntilNull ( stack . pop (). right ); } public boolean hasNext () { return ! stack . isEmpty (); } private Stack < TreeNode > stack = new Stack <> (); private void pushLeftsUntilNull ( TreeNode node ) { while ( node != null ) { stack . push ( node ); node = node . left ; } } } class Solution { public List < Integer > getAllElements ( TreeNode root1 , TreeNode root2 ) { List < Integer > ans = new ArrayList <> (); BSTIterator bstIterator1 = new BSTIterator ( root1 ); BSTIterator bstIterator2 = new BSTIterator ( root2 ); while ( bstIterator1 . hasNext () && bstIterator2 . hasNext ()) if ( bstIterator1 . peek () < bstIterator2 . peek ()) { ans . add ( bstIterator1 . peek ()); bstIterator1 . next (); } else { ans . add ( bstIterator2 . peek ()); bstIterator2 . next (); } while ( bstIterator1 . hasNext ()) { ans . add ( bstIterator1 . peek ()); bstIterator1 . next (); } while ( bstIterator2 . hasNext ()) { ans . add ( bstIterator2 . peek ()); bstIterator2 . next (); } return ans ; } }","title":"1305. All Elements in Two Binary Search Trees"},{"location":"problems/1306/","text":"1306. Jump Game III","title":"1306. Jump Game III"},{"location":"problems/1306/#1306-jump-game-iii","text":"","title":"1306. Jump Game III"},{"location":"problems/1307/","text":"1307. Verbal Arithmetic Puzzle Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : bool isSolvable ( vector < string >& words , string result ) { usedDigit = vector < bool > ( 10 , false ); words . push_back ( result ); rows = words . size (); for ( const string & word : words ) cols = max ( cols , ( int ) word . length ()); return dfs ( words , 0 , 0 , 0 ); } private : unordered_map < char , int > letterToDigit ; vector < bool > usedDigit ; int rows ; int cols ; bool dfs ( vector < string >& words , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , 0 , col + 1 , sum / 10 ); string word = words [ row ]; if ( col >= word . length ()) return dfs ( words , row + 1 , col , sum ); char letter = word [ word . length () - col - 1 ]; int sign = row == rows - 1 ? -1 : 1 ; if ( letterToDigit . count ( letter ) && ( letterToDigit [ letter ] > 0 || col < word . length () - 1 )) return dfs ( words , row + 1 , col , sum + sign * letterToDigit [ letter ]); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col + 1 < word . length ())) { letterToDigit [ letter ] = digit ; usedDigit [ digit ] = true ; if ( dfs ( words , row + 1 , col , sum + sign * digit )) return true ; usedDigit [ digit ] = false ; letterToDigit . erase ( letter ); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public boolean isSolvable ( String [] words , String result ) { rows = words . length + 1 ; for ( final String word : words ) cols = Math . max ( cols , word . length ()); cols = Math . max ( cols , result . length ()); return dfs ( words , result , 0 , 0 , 0 ); } private Map < Character , Integer > letterToDigit = new HashMap <> (); private boolean [] usedDigit = new boolean [ 10 ] ; private int rows = 0 ; private int cols = 0 ; private boolean dfs ( String [] words , String result , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , result , 0 , col + 1 , sum / 10 ); String word = row == rows - 1 ? result : words [ row ] ; if ( col >= word . length ()) return dfs ( words , result , row + 1 , col , sum ); char letter = word . charAt ( word . length () - col - 1 ); int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . containsKey ( letter ) && ( letterToDigit . get ( letter ) > 0 || col < word . length () - 1 )) return dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter )); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col < word . length () - 1 )) { letterToDigit . put ( letter , digit ); usedDigit [ digit ] = true ; if ( dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ))) return true ; usedDigit [ digit ] = false ; letterToDigit . remove ( letter ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def isSolvable ( self , words : List [ str ], result : str ) -> bool : def dfs ( row : int , col : int , summ : int ) -> bool : if col == cols : return summ == 0 if row == rows : return summ % 10 == 0 and dfs ( 0 , col + 1 , summ // 10 ) word = words [ row ] if col >= len ( word ): return dfs ( row + 1 , col , summ ) letter = word [ ~ col ] sign = - 1 if row == rows - 1 else 1 if letter in letterToDigit and ( letterToDigit [ letter ] > 0 or col < len ( word ) - 1 ): return dfs ( row + 1 , col , summ + sign * letterToDigit [ letter ]) for digit , used in enumerate ( usedDigit ): if not used and ( digit > 0 or col < len ( word ) - 1 ): letterToDigit [ letter ] = digit usedDigit [ digit ] = True if dfs ( row + 1 , col , summ + sign * digit ): return True usedDigit [ digit ] = False if letter in letterToDigit : del letterToDigit [ letter ] return False words . append ( result ) rows = len ( words ) cols = max ( map ( len , words )) letterToDigit = {} usedDigit = [ False ] * 10 return dfs ( 0 , 0 , 0 )","title":"1307. Verbal Arithmetic Puzzle"},{"location":"problems/1307/#1307-verbal-arithmetic-puzzle","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : bool isSolvable ( vector < string >& words , string result ) { usedDigit = vector < bool > ( 10 , false ); words . push_back ( result ); rows = words . size (); for ( const string & word : words ) cols = max ( cols , ( int ) word . length ()); return dfs ( words , 0 , 0 , 0 ); } private : unordered_map < char , int > letterToDigit ; vector < bool > usedDigit ; int rows ; int cols ; bool dfs ( vector < string >& words , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , 0 , col + 1 , sum / 10 ); string word = words [ row ]; if ( col >= word . length ()) return dfs ( words , row + 1 , col , sum ); char letter = word [ word . length () - col - 1 ]; int sign = row == rows - 1 ? -1 : 1 ; if ( letterToDigit . count ( letter ) && ( letterToDigit [ letter ] > 0 || col < word . length () - 1 )) return dfs ( words , row + 1 , col , sum + sign * letterToDigit [ letter ]); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col + 1 < word . length ())) { letterToDigit [ letter ] = digit ; usedDigit [ digit ] = true ; if ( dfs ( words , row + 1 , col , sum + sign * digit )) return true ; usedDigit [ digit ] = false ; letterToDigit . erase ( letter ); } return false ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public boolean isSolvable ( String [] words , String result ) { rows = words . length + 1 ; for ( final String word : words ) cols = Math . max ( cols , word . length ()); cols = Math . max ( cols , result . length ()); return dfs ( words , result , 0 , 0 , 0 ); } private Map < Character , Integer > letterToDigit = new HashMap <> (); private boolean [] usedDigit = new boolean [ 10 ] ; private int rows = 0 ; private int cols = 0 ; private boolean dfs ( String [] words , String result , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , result , 0 , col + 1 , sum / 10 ); String word = row == rows - 1 ? result : words [ row ] ; if ( col >= word . length ()) return dfs ( words , result , row + 1 , col , sum ); char letter = word . charAt ( word . length () - col - 1 ); int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . containsKey ( letter ) && ( letterToDigit . get ( letter ) > 0 || col < word . length () - 1 )) return dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter )); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col < word . length () - 1 )) { letterToDigit . put ( letter , digit ); usedDigit [ digit ] = true ; if ( dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ))) return true ; usedDigit [ digit ] = false ; letterToDigit . remove ( letter ); } return false ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def isSolvable ( self , words : List [ str ], result : str ) -> bool : def dfs ( row : int , col : int , summ : int ) -> bool : if col == cols : return summ == 0 if row == rows : return summ % 10 == 0 and dfs ( 0 , col + 1 , summ // 10 ) word = words [ row ] if col >= len ( word ): return dfs ( row + 1 , col , summ ) letter = word [ ~ col ] sign = - 1 if row == rows - 1 else 1 if letter in letterToDigit and ( letterToDigit [ letter ] > 0 or col < len ( word ) - 1 ): return dfs ( row + 1 , col , summ + sign * letterToDigit [ letter ]) for digit , used in enumerate ( usedDigit ): if not used and ( digit > 0 or col < len ( word ) - 1 ): letterToDigit [ letter ] = digit usedDigit [ digit ] = True if dfs ( row + 1 , col , summ + sign * digit ): return True usedDigit [ digit ] = False if letter in letterToDigit : del letterToDigit [ letter ] return False words . append ( result ) rows = len ( words ) cols = max ( map ( len , words )) letterToDigit = {} usedDigit = [ False ] * 10 return dfs ( 0 , 0 , 0 )","title":"1307. Verbal Arithmetic Puzzle"},{"location":"problems/1308/","text":"1308. Running Total for Different Genders \ud83d\udd12","title":"1308. Running Total for Different Genders"},{"location":"problems/1308/#1308-running-total-for-different-genders","text":"","title":"1308. Running Total for Different Genders \ud83d\udd12"},{"location":"problems/1309/","text":"1309. Decrypt String from Alphabet to Integer Mapping Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string freqAlphabets ( string s ) { string ans ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s [ i + 2 ] == '#' ) { ans += stoi ( s . substr ( i , 2 )) + 'a' - 1 ; i += 3 ; } else { ans += ( s [ i ] - '0' ) + 'a' - 1 ; i += 1 ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String freqAlphabets ( String s ) { String ans = \"\" ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s . charAt ( i + 2 ) == '#' ) { ans += ( char ) ( Integer . valueOf ( s . substring ( i , i + 2 )) + 'a' - 1 ); i += 3 ; } else { ans += ( char ) (( s . charAt ( i ) - '0' ) + 'a' - 1 ); i += 1 ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def freqAlphabets ( self , s : str ) -> str : ans = '' i = 0 while i < len ( s ): if i + 2 < len ( s ) and s [ i + 2 ] == '#' : ans += chr ( int ( s [ i : i + 2 ]) + ord ( 'a' ) - 1 ) i += 3 else : ans += chr ( int ( s [ i ]) + ord ( 'a' ) - 1 ) i += 1 return ans","title":"1309. Decrypt String from Alphabet to Integer Mapping"},{"location":"problems/1309/#1309-decrypt-string-from-alphabet-to-integer-mapping","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string freqAlphabets ( string s ) { string ans ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s [ i + 2 ] == '#' ) { ans += stoi ( s . substr ( i , 2 )) + 'a' - 1 ; i += 3 ; } else { ans += ( s [ i ] - '0' ) + 'a' - 1 ; i += 1 ; } } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String freqAlphabets ( String s ) { String ans = \"\" ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s . charAt ( i + 2 ) == '#' ) { ans += ( char ) ( Integer . valueOf ( s . substring ( i , i + 2 )) + 'a' - 1 ); i += 3 ; } else { ans += ( char ) (( s . charAt ( i ) - '0' ) + 'a' - 1 ); i += 1 ; } } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def freqAlphabets ( self , s : str ) -> str : ans = '' i = 0 while i < len ( s ): if i + 2 < len ( s ) and s [ i + 2 ] == '#' : ans += chr ( int ( s [ i : i + 2 ]) + ord ( 'a' ) - 1 ) i += 3 else : ans += chr ( int ( s [ i ]) + ord ( 'a' ) - 1 ) i += 1 return ans","title":"1309. Decrypt String from Alphabet to Integer Mapping"},{"location":"problems/1310/","text":"1310. XOR Queries of a Subarray Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ] ; int [] xors = new int [ arr . length + 1 ] ; for ( int i = 0 ; i < arr . length ; ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ] ; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1310. XOR Queries of a Subarray"},{"location":"problems/1310/#1310-xor-queries-of-a-subarray","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ] ; int [] xors = new int [ arr . length + 1 ] ; for ( int i = 0 ; i < arr . length ; ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ] ; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1310. XOR Queries of a Subarray"},{"location":"problems/1311/","text":"1311. Get Watched Videos by Your Friends Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > watchedVideosByFriends ( vector < vector < string >>& watchedVideos , vector < vector < int >>& friends , int id , int level ) { vector < string > ans ; vector < bool > visited ( friends . size ()); visited [ id ] = true ; queue < int > queue {{ id }}; unordered_map < string , int > count ; set < pair < int , string >> freqAndVideo ; for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int f : friends [ queue . front ()]) if ( visited [ f ] == false ) { visited [ f ] = true ; queue . push ( f ); } queue . pop (); } for ( int i = queue . size (); i > 0 ; -- i ) { for ( const string & video : watchedVideos [ queue . front ()]) ++ count [ video ]; queue . pop (); } for ( const auto & [ video , freq ] : count ) freqAndVideo . insert ({ freq , video }); for ( const auto & [ _ , video ] : freqAndVideo ) ans . push_back ( video ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > watchedVideosByFriends ( List < List < String >> watchedVideos , int [][] friends , int id , int level ) { boolean [] visited = new boolean [ friends . length ] ; visited [ id ] = true ; Queue < Integer > queue = new LinkedList <> (); queue . add ( id ); Map < String , Integer > count = new HashMap <> (); for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int friend : friends [ queue . peek () ] ) if ( visited [ friend ] == false ) { visited [ friend ] = true ; queue . add ( friend ); } queue . poll (); } for ( int friend : queue ) for ( final String video : watchedVideos . get ( friend )) count . put ( video , count . getOrDefault ( video , 0 ) + 1 ); List < String > ans = new ArrayList <> ( count . keySet ()); ans . sort (( a , b ) -> count . get ( a ) == count . get ( b ) ? a . compareTo ( b ) : count . get ( a ) - count . get ( b )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def watchedVideosByFriends ( self , watchedVideos : List [ List [ str ]], friends : List [ List [ int ]], id : int , level : int ) -> List [ str ]: visited = [ False ] * 100 visited [ id ] = True queue = collections . deque ([ id ]) count = collections . Counter () for _ in range ( level ): for _ in range ( len ( queue )): curr = queue . popleft () for friend in friends [ curr ]: if not visited [ friend ]: visited [ friend ] = True queue . append ( friend ) for friend in queue : for video in watchedVideos [ friend ]: count [ video ] += 1 return sorted ( count . keys (), key = lambda video : ( count [ video ], video ))","title":"1311. Get Watched Videos by Your Friends"},{"location":"problems/1311/#1311-get-watched-videos-by-your-friends","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > watchedVideosByFriends ( vector < vector < string >>& watchedVideos , vector < vector < int >>& friends , int id , int level ) { vector < string > ans ; vector < bool > visited ( friends . size ()); visited [ id ] = true ; queue < int > queue {{ id }}; unordered_map < string , int > count ; set < pair < int , string >> freqAndVideo ; for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int f : friends [ queue . front ()]) if ( visited [ f ] == false ) { visited [ f ] = true ; queue . push ( f ); } queue . pop (); } for ( int i = queue . size (); i > 0 ; -- i ) { for ( const string & video : watchedVideos [ queue . front ()]) ++ count [ video ]; queue . pop (); } for ( const auto & [ video , freq ] : count ) freqAndVideo . insert ({ freq , video }); for ( const auto & [ _ , video ] : freqAndVideo ) ans . push_back ( video ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List < String > watchedVideosByFriends ( List < List < String >> watchedVideos , int [][] friends , int id , int level ) { boolean [] visited = new boolean [ friends . length ] ; visited [ id ] = true ; Queue < Integer > queue = new LinkedList <> (); queue . add ( id ); Map < String , Integer > count = new HashMap <> (); for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int friend : friends [ queue . peek () ] ) if ( visited [ friend ] == false ) { visited [ friend ] = true ; queue . add ( friend ); } queue . poll (); } for ( int friend : queue ) for ( final String video : watchedVideos . get ( friend )) count . put ( video , count . getOrDefault ( video , 0 ) + 1 ); List < String > ans = new ArrayList <> ( count . keySet ()); ans . sort (( a , b ) -> count . get ( a ) == count . get ( b ) ? a . compareTo ( b ) : count . get ( a ) - count . get ( b )); return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def watchedVideosByFriends ( self , watchedVideos : List [ List [ str ]], friends : List [ List [ int ]], id : int , level : int ) -> List [ str ]: visited = [ False ] * 100 visited [ id ] = True queue = collections . deque ([ id ]) count = collections . Counter () for _ in range ( level ): for _ in range ( len ( queue )): curr = queue . popleft () for friend in friends [ curr ]: if not visited [ friend ]: visited [ friend ] = True queue . append ( friend ) for friend in queue : for video in watchedVideos [ friend ]: count [ video ] += 1 return sorted ( count . keys (), key = lambda video : ( count [ video ], video ))","title":"1311. Get Watched Videos by Your Friends"},{"location":"problems/1312/","text":"1312. Minimum Insertion Steps to Make a String Palindrome","title":"1312. Minimum Insertion Steps to Make a String Palindrome"},{"location":"problems/1312/#1312-minimum-insertion-steps-to-make-a-string-palindrome","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome"},{"location":"problems/1313/","text":"1313. Decompress Run-Length Encoded List Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > decompressRLElist ( vector < int >& nums ) { vector < int > ans ; for ( int i = 0 ; i < nums . size (); i += 2 ) ans . insert ( end ( ans ), nums [ i ], nums [ i + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] decompressRLElist ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; i += 2 ) for ( int freq = 0 ; freq < nums [ i ] ; ++ freq ) ans . add ( nums [ i + 1 ] ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 class Solution : def decompressRLElist ( self , nums : List [ int ]) -> List [ int ]: ans = [] for i in range ( 0 , len ( nums ), 2 ): ans += [ nums [ i + 1 ]] * nums [ i ] return ans","title":"1313. Decompress Run-Length Encoded List"},{"location":"problems/1313/#1313-decompress-run-length-encoded-list","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > decompressRLElist ( vector < int >& nums ) { vector < int > ans ; for ( int i = 0 ; i < nums . size (); i += 2 ) ans . insert ( end ( ans ), nums [ i ], nums [ i + 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] decompressRLElist ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; i += 2 ) for ( int freq = 0 ; freq < nums [ i ] ; ++ freq ) ans . add ( nums [ i + 1 ] ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } Python 1 2 3 4 5 6 7 8 class Solution : def decompressRLElist ( self , nums : List [ int ]) -> List [ int ]: ans = [] for i in range ( 0 , len ( nums ), 2 ): ans += [ nums [ i + 1 ]] * nums [ i ] return ans","title":"1313. Decompress Run-Length Encoded List"},{"location":"problems/1314/","text":"1314. Matrix Block Sum","title":"1314. Matrix Block Sum"},{"location":"problems/1314/#1314-matrix-block-sum","text":"","title":"1314. Matrix Block Sum"},{"location":"problems/1315/","text":"1315. Sum of Nodes with Even-Valued Grandparent","title":"1315. Sum of Nodes with Even-Valued Grandparent"},{"location":"problems/1315/#1315-sum-of-nodes-with-even-valued-grandparent","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent"},{"location":"problems/1316/","text":"1316. Distinct Echo Substrings","title":"1316. Distinct Echo Substrings"},{"location":"problems/1316/#1316-distinct-echo-substrings","text":"","title":"1316. Distinct Echo Substrings"},{"location":"problems/1317/","text":"1317. Convert Integer to the Sum of Two No-Zero Integers Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( to_string ( A ). find ( '0' ) == string :: npos && to_string ( B ). find ( '0' ) == string :: npos ) return { A , B }; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( ! String . valueOf ( A ). contains ( \"0\" ) && ! String . valueOf ( B ). contains ( \"0\" )) return new int [] { A , B }; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 class Solution : def getNoZeroIntegers ( self , n : int ) -> List [ int ]: for A in range ( n ): B = n - A if '0' not in str ( A ) and '0' not in str ( B ): return A , B","title":"1317. Convert Integer to the Sum of Two No-Zero Integers"},{"location":"problems/1317/#1317-convert-integer-to-the-sum-of-two-no-zero-integers","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( to_string ( A ). find ( '0' ) == string :: npos && to_string ( B ). find ( '0' ) == string :: npos ) return { A , B }; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [] getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( ! String . valueOf ( A ). contains ( \"0\" ) && ! String . valueOf ( B ). contains ( \"0\" )) return new int [] { A , B }; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 class Solution : def getNoZeroIntegers ( self , n : int ) -> List [ int ]: for A in range ( n ): B = n - A if '0' not in str ( A ) and '0' not in str ( B ): return A , B","title":"1317. Convert Integer to the Sum of Two No-Zero Integers"},{"location":"problems/1318/","text":"1318. Minimum Flips to Make a OR b Equal to c","title":"1318. Minimum Flips to Make a OR b Equal to c"},{"location":"problems/1318/#1318-minimum-flips-to-make-a-or-b-equal-to-c","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c"},{"location":"problems/1319/","text":"1319. Number of Operations to Make Network Connected","title":"1319. Number of Operations to Make Network Connected"},{"location":"problems/1319/#1319-number-of-operations-to-make-network-connected","text":"","title":"1319. Number of Operations to Make Network Connected"},{"location":"problems/1320/","text":"1320. Minimum Distance to Type a Word Using Two Fingers","title":"1320. Minimum Distance to Type a Word Using Two Fingers"},{"location":"problems/1320/#1320-minimum-distance-to-type-a-word-using-two-fingers","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers"},{"location":"problems/1321/","text":"1321. Restaurant Growth \ud83d\udd12","title":"1321. Restaurant Growth"},{"location":"problems/1321/#1321-restaurant-growth","text":"","title":"1321. Restaurant Growth \ud83d\udd12"},{"location":"problems/1322/","text":"1322. Ads Performance \ud83d\udd12","title":"1322. Ads Performance"},{"location":"problems/1322/#1322-ads-performance","text":"","title":"1322. Ads Performance \ud83d\udd12"},{"location":"problems/1323/","text":"1323. Maximum 69 Number Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maximum69Number ( int num ) { string ans = to_string ( num ); for ( char & c : ans ) if ( c == '6' ) { c = '9' ; break ; } return stoi ( ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maximum69Number ( int num ) { char [] ans = String . valueOf ( num ). toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] == '6' ) { ans [ i ] = '9' ; break ; } return Integer . valueOf ( String . valueOf ( ans )); } } Python 1 2 3 class Solution : def maximum69Number ( self , num : int ) -> int : return int ( str ( num ) . replace ( '6' , '9' , 1 ))","title":"1323. Maximum 69 Number"},{"location":"problems/1323/#1323-maximum-69-number","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maximum69Number ( int num ) { string ans = to_string ( num ); for ( char & c : ans ) if ( c == '6' ) { c = '9' ; break ; } return stoi ( ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maximum69Number ( int num ) { char [] ans = String . valueOf ( num ). toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] == '6' ) { ans [ i ] = '9' ; break ; } return Integer . valueOf ( String . valueOf ( ans )); } } Python 1 2 3 class Solution : def maximum69Number ( self , num : int ) -> int : return int ( str ( num ) . replace ( '6' , '9' , 1 ))","title":"1323. Maximum 69 Number"},{"location":"problems/1324/","text":"1324. Print Words Vertically","title":"1324. Print Words Vertically"},{"location":"problems/1324/#1324-print-words-vertically","text":"","title":"1324. Print Words Vertically"},{"location":"problems/1325/","text":"1325. Delete Leaves With a Given Value","title":"1325. Delete Leaves With a Given Value"},{"location":"problems/1325/#1325-delete-leaves-with-a-given-value","text":"","title":"1325. Delete Leaves With a Given Value"},{"location":"problems/1326/","text":"1326. Minimum Number of Taps to Open to Water a Garden Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minTaps ( int n , vector < int >& ranges ) { vector < int > nums ( n + 1 ); for ( int i = 0 ; i <= n ; ++ i ) { int l = max ( 0 , i - ranges [ i ]); int r = min ( n , i + ranges [ i ]); nums [ l ] = max ( nums [ l ], r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minTaps ( int n , int [] ranges ) { int [] nums = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { int l = Math . max ( 0 , i - ranges [ i ] ); int r = Math . min ( n , i + ranges [ i ] ); nums [ l ] = Math . max ( nums [ l ] , r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def minTaps ( self , n : int , ranges : List [ int ]) -> int : nums = [ 0 ] * ( n + 1 ) for i , range_ in enumerate ( ranges ): l = max ( 0 , i - range_ ) r = min ( n , range_ + i ) nums [ l ] = max ( nums [ l ], r - l ) ans = 0 end = 0 farthest = 0 for i in range ( n ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans if end == n else - 1","title":"1326. Minimum Number of Taps to Open to Water a Garden"},{"location":"problems/1326/#1326-minimum-number-of-taps-to-open-to-water-a-garden","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minTaps ( int n , vector < int >& ranges ) { vector < int > nums ( n + 1 ); for ( int i = 0 ; i <= n ; ++ i ) { int l = max ( 0 , i - ranges [ i ]); int r = min ( n , i + ranges [ i ]); nums [ l ] = max ( nums [ l ], r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : -1 ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minTaps ( int n , int [] ranges ) { int [] nums = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { int l = Math . max ( 0 , i - ranges [ i ] ); int r = Math . min ( n , i + ranges [ i ] ); nums [ l ] = Math . max ( nums [ l ] , r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def minTaps ( self , n : int , ranges : List [ int ]) -> int : nums = [ 0 ] * ( n + 1 ) for i , range_ in enumerate ( ranges ): l = max ( 0 , i - range_ ) r = min ( n , range_ + i ) nums [ l ] = max ( nums [ l ], r - l ) ans = 0 end = 0 farthest = 0 for i in range ( n ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans if end == n else - 1","title":"1326. Minimum Number of Taps to Open to Water a Garden"},{"location":"problems/1327/","text":"1327. List the Products Ordered in a Period \ud83d\udd12","title":"1327. List the Products Ordered in a Period"},{"location":"problems/1327/#1327-list-the-products-ordered-in-a-period","text":"","title":"1327. List the Products Ordered in a Period \ud83d\udd12"},{"location":"problems/1328/","text":"1328. Break a Palindrome","title":"1328. Break a Palindrome"},{"location":"problems/1328/#1328-break-a-palindrome","text":"","title":"1328. Break a Palindrome"},{"location":"problems/1329/","text":"1329. Sort the Matrix Diagonally Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> diagonalSort ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); unordered_map < int , priority_queue < int >> count ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count [ i - j ]. push ( mat [ i ][ j ]); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) mat [ i ][ j ] = count [ i - j ]. top (), count [ i - j ]. pop (); return mat ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [][] diagonalSort ( int [][] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; Map < Integer , PriorityQueue < Integer >> count = new HashMap <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count . computeIfAbsent ( i - j , k -> new PriorityQueue <> ()). add ( mat [ i ][ j ] ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) mat [ i ][ j ] = count . get ( i - j ). poll (); return mat ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def diagonalSort ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( mat ) n = len ( mat [ 0 ]) count = collections . defaultdict ( list ) for i in range ( m ): for j in range ( n ): count [ i - j ] . append ( mat [ i ][ j ]) for value in count . values (): value . sort ( reverse = 1 ) for i in range ( m ): for j in range ( n ): mat [ i ][ j ] = count [ i - j ] . pop () return mat","title":"1329. Sort the Matrix Diagonally"},{"location":"problems/1329/#1329-sort-the-matrix-diagonally","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> diagonalSort ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); unordered_map < int , priority_queue < int >> count ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count [ i - j ]. push ( mat [ i ][ j ]); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) mat [ i ][ j ] = count [ i - j ]. top (), count [ i - j ]. pop (); return mat ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [][] diagonalSort ( int [][] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; Map < Integer , PriorityQueue < Integer >> count = new HashMap <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count . computeIfAbsent ( i - j , k -> new PriorityQueue <> ()). add ( mat [ i ][ j ] ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) mat [ i ][ j ] = count . get ( i - j ). poll (); return mat ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def diagonalSort ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( mat ) n = len ( mat [ 0 ]) count = collections . defaultdict ( list ) for i in range ( m ): for j in range ( n ): count [ i - j ] . append ( mat [ i ][ j ]) for value in count . values (): value . sort ( reverse = 1 ) for i in range ( m ): for j in range ( n ): mat [ i ][ j ] = count [ i - j ] . pop () return mat","title":"1329. Sort the Matrix Diagonally"},{"location":"problems/1330/","text":"1330. Reverse Subarray To Maximize Array Value Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxValueAfterReverse ( vector < int >& nums ) { int total = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; total += abs ( a - b ); min = std :: min ( min , std :: max ( a , b )); max = std :: max ( max , std :: min ( a , b )); } int diff = std :: max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; int headDiff = - abs ( a - b ) + abs ( nums . front () - b ); int tailDiff = - abs ( a - b ) + abs ( nums . back () - a ); diff = std :: max ({ diff , headDiff , tailDiff }); } return total + diff ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maxValueAfterReverse ( int [] nums ) { int total = 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; total += Math . abs ( a - b ); min = Math . min ( min , Math . max ( a , b )); max = Math . max ( max , Math . min ( a , b )); } int diff = Math . max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; int headDiff = - Math . abs ( a - b ) + Math . abs ( nums [ 0 ] - b ); int tailDiff = - Math . abs ( a - b ) + Math . abs ( nums [ nums . length - 1 ] - a ); diff = Math . max ( diff , Math . max ( headDiff , tailDiff )); } return total + diff ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxValueAfterReverse ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) for a , b in zip ( nums , nums [ 1 :]): mini = min ( mini , max ( a , b )) maxi = max ( maxi , min ( a , b )) diff = max ( 0 , ( maxi - mini ) * 2 ) for a , b in zip ( nums , nums [ 1 :]): headDiff = - abs ( a - b ) + abs ( nums [ 0 ] - b ) tailDiff = - abs ( a - b ) + abs ( nums [ - 1 ] - a ) diff = max ( diff , headDiff , tailDiff ) return sum ( abs ( a - b ) for a , b in zip ( nums , nums [ 1 :])) + diff","title":"1330. Reverse Subarray To Maximize Array Value"},{"location":"problems/1330/#1330-reverse-subarray-to-maximize-array-value","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxValueAfterReverse ( vector < int >& nums ) { int total = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; total += abs ( a - b ); min = std :: min ( min , std :: max ( a , b )); max = std :: max ( max , std :: min ( a , b )); } int diff = std :: max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; int headDiff = - abs ( a - b ) + abs ( nums . front () - b ); int tailDiff = - abs ( a - b ) + abs ( nums . back () - a ); diff = std :: max ({ diff , headDiff , tailDiff }); } return total + diff ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int maxValueAfterReverse ( int [] nums ) { int total = 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; total += Math . abs ( a - b ); min = Math . min ( min , Math . max ( a , b )); max = Math . max ( max , Math . min ( a , b )); } int diff = Math . max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; int headDiff = - Math . abs ( a - b ) + Math . abs ( nums [ 0 ] - b ); int tailDiff = - Math . abs ( a - b ) + Math . abs ( nums [ nums . length - 1 ] - a ); diff = Math . max ( diff , Math . max ( headDiff , tailDiff )); } return total + diff ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxValueAfterReverse ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) for a , b in zip ( nums , nums [ 1 :]): mini = min ( mini , max ( a , b )) maxi = max ( maxi , min ( a , b )) diff = max ( 0 , ( maxi - mini ) * 2 ) for a , b in zip ( nums , nums [ 1 :]): headDiff = - abs ( a - b ) + abs ( nums [ 0 ] - b ) tailDiff = - abs ( a - b ) + abs ( nums [ - 1 ] - a ) diff = max ( diff , headDiff , tailDiff ) return sum ( abs ( a - b ) for a , b in zip ( nums , nums [ 1 :])) + diff","title":"1330. Reverse Subarray To Maximize Array Value"},{"location":"problems/1331/","text":"1331. Rank Transform of an Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > arrayRankTransform ( vector < int >& arr ) { vector < int > sortedArr ( arr ); unordered_map < int , int > rank ; sort ( begin ( sortedArr ), end ( sortedArr )); for ( int a : sortedArr ) if ( ! rank . count ( a )) rank [ a ] = rank . size () + 1 ; for ( int & a : arr ) a = rank [ a ]; return arr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] arrayRankTransform ( int [] arr ) { int [] sortedArr = Arrays . copyOf ( arr , arr . length ); Map < Integer , Integer > rank = new HashMap <> (); Arrays . sort ( sortedArr ); for ( int a : sortedArr ) rank . putIfAbsent ( a , rank . size () + 1 ); for ( int i = 0 ; i < arr . length ; ++ i ) arr [ i ] = rank . get ( arr [ i ] ); return arr ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def arrayRankTransform ( self , arr : List [ int ]) -> List [ int ]: rank = {} for a in sorted ( arr ): if a not in rank : rank [ a ] = len ( rank ) + 1 return map ( rank . get , arr )","title":"1331. Rank Transform of an Array"},{"location":"problems/1331/#1331-rank-transform-of-an-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > arrayRankTransform ( vector < int >& arr ) { vector < int > sortedArr ( arr ); unordered_map < int , int > rank ; sort ( begin ( sortedArr ), end ( sortedArr )); for ( int a : sortedArr ) if ( ! rank . count ( a )) rank [ a ] = rank . size () + 1 ; for ( int & a : arr ) a = rank [ a ]; return arr ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [] arrayRankTransform ( int [] arr ) { int [] sortedArr = Arrays . copyOf ( arr , arr . length ); Map < Integer , Integer > rank = new HashMap <> (); Arrays . sort ( sortedArr ); for ( int a : sortedArr ) rank . putIfAbsent ( a , rank . size () + 1 ); for ( int i = 0 ; i < arr . length ; ++ i ) arr [ i ] = rank . get ( arr [ i ] ); return arr ; } } Python 1 2 3 4 5 6 7 8 9 class Solution : def arrayRankTransform ( self , arr : List [ int ]) -> List [ int ]: rank = {} for a in sorted ( arr ): if a not in rank : rank [ a ] = len ( rank ) + 1 return map ( rank . get , arr )","title":"1331. Rank Transform of an Array"},{"location":"problems/1332/","text":"1332. Remove Palindromic Subsequences","title":"1332. Remove Palindromic Subsequences"},{"location":"problems/1332/#1332-remove-palindromic-subsequences","text":"","title":"1332. Remove Palindromic Subsequences"},{"location":"problems/1333/","text":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > filterRestaurants ( vector < vector < int >>& restaurants , int veganFriendly , int maxPrice , int maxDistance ) { vector < int > ans ; vector < vector < int >> filtered ; for ( vector < int >& restaurant : restaurants ) if ( restaurant [ 2 ] >= veganFriendly && restaurant [ 3 ] <= maxPrice && restaurant [ 4 ] <= maxDistance ) filtered . push_back ( restaurant ); sort ( begin ( filtered ), end ( filtered ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] > b [ 1 ]; }); for ( vector < int >& f : filtered ) ans . push_back ( f [ 0 ]); return ans ; } }; Java 1 2 3 4 5 6 class Solution { public List < Integer > filterRestaurants ( int [][] restaurants , int veganFriendly , int maxPrice , int maxDistance ) { return Arrays . stream ( restaurants ). filter ( r -> r [ 2 ] >= veganFriendly && r [ 3 ] <= maxPrice && r [ 4 ] <= maxDistance ) . sorted (( a , b ) -> a [ 1 ] == b [ 1 ] ? b [ 0 ] - a [ 0 ] : b [ 1 ] - a [ 1 ] ). map ( i -> i [ 0 ] ). collect ( Collectors . toList ()); } } Python 1 2 3 4 class Solution : def filterRestaurants ( self , restaurants : List [ List [ int ]], veganFriendly : int , maxPrice : int , maxDistance : int ) -> List [ int ]: restaurants . sort ( key = lambda r : ( - r [ 1 ], - r [ 0 ])) return [ i for i , _ , v , p , d in restaurants if v >= veganFriendly and p <= maxPrice and d <= maxDistance ]","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance"},{"location":"problems/1333/#1333-filter-restaurants-by-vegan-friendly-price-and-distance","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > filterRestaurants ( vector < vector < int >>& restaurants , int veganFriendly , int maxPrice , int maxDistance ) { vector < int > ans ; vector < vector < int >> filtered ; for ( vector < int >& restaurant : restaurants ) if ( restaurant [ 2 ] >= veganFriendly && restaurant [ 3 ] <= maxPrice && restaurant [ 4 ] <= maxDistance ) filtered . push_back ( restaurant ); sort ( begin ( filtered ), end ( filtered ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] > b [ 1 ]; }); for ( vector < int >& f : filtered ) ans . push_back ( f [ 0 ]); return ans ; } }; Java 1 2 3 4 5 6 class Solution { public List < Integer > filterRestaurants ( int [][] restaurants , int veganFriendly , int maxPrice , int maxDistance ) { return Arrays . stream ( restaurants ). filter ( r -> r [ 2 ] >= veganFriendly && r [ 3 ] <= maxPrice && r [ 4 ] <= maxDistance ) . sorted (( a , b ) -> a [ 1 ] == b [ 1 ] ? b [ 0 ] - a [ 0 ] : b [ 1 ] - a [ 1 ] ). map ( i -> i [ 0 ] ). collect ( Collectors . toList ()); } } Python 1 2 3 4 class Solution : def filterRestaurants ( self , restaurants : List [ List [ int ]], veganFriendly : int , maxPrice : int , maxDistance : int ) -> List [ int ]: restaurants . sort ( key = lambda r : ( - r [ 1 ], - r [ 0 ])) return [ i for i , _ , v , p , d in restaurants if v >= veganFriendly and p <= maxPrice and d <= maxDistance ]","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance"},{"location":"problems/1334/","text":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"},{"location":"problems/1334/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","text":"","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"},{"location":"problems/1335/","text":"1335. Minimum Difficulty of a Job Schedule Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDifficulty ( vector < int >& jobDifficulty , int d ) { const int n = jobDifficulty . size (); if ( n < d ) return -1 ; vector < vector < int >> dp ( n + 1 , vector < int > ( d + 1 , INT_MAX / 2 )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]); dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int minDifficulty ( int [] jobDifficulty , int d ) { final int n = jobDifficulty . length ; if ( n < d ) return - 1 ; int [][] dp = new int [ n + 1 ][ d + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE / 2 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = Math . max ( maxDifficulty , jobDifficulty [ j - 1 ] ); dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minDifficulty ( self , jobDifficulty : List [ int ], d : int ) -> int : n = len ( jobDifficulty ) if d > n : return - 1 dp = [[ float ( 'inf' )] * ( d + 1 ) for _ in range ( n + 1 )] dp [ 0 ][ 0 ] = 0 for i in range ( 1 , n + 1 ): for k in range ( 1 , d + 1 ): maxDifficulty = 0 for j in range ( i , k - 1 , - 1 ): maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ) return dp [ n ][ d ]","title":"1335. Minimum Difficulty of a Job Schedule"},{"location":"problems/1335/#1335-minimum-difficulty-of-a-job-schedule","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDifficulty ( vector < int >& jobDifficulty , int d ) { const int n = jobDifficulty . size (); if ( n < d ) return -1 ; vector < vector < int >> dp ( n + 1 , vector < int > ( d + 1 , INT_MAX / 2 )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]); dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int minDifficulty ( int [] jobDifficulty , int d ) { final int n = jobDifficulty . length ; if ( n < d ) return - 1 ; int [][] dp = new int [ n + 1 ][ d + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE / 2 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = Math . max ( maxDifficulty , jobDifficulty [ j - 1 ] ); dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def minDifficulty ( self , jobDifficulty : List [ int ], d : int ) -> int : n = len ( jobDifficulty ) if d > n : return - 1 dp = [[ float ( 'inf' )] * ( d + 1 ) for _ in range ( n + 1 )] dp [ 0 ][ 0 ] = 0 for i in range ( 1 , n + 1 ): for k in range ( 1 , d + 1 ): maxDifficulty = 0 for j in range ( i , k - 1 , - 1 ): maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ) return dp [ n ][ d ]","title":"1335. Minimum Difficulty of a Job Schedule"},{"location":"problems/1336/","text":"1336. Number of Transactions per Visit \ud83d\udd12","title":"1336. Number of Transactions per Visit"},{"location":"problems/1336/#1336-number-of-transactions-per-visit","text":"","title":"1336. Number of Transactions per Visit \ud83d\udd12"},{"location":"problems/1337/","text":"1337. The K Weakest Rows in a Matrix Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > kWeakestRows ( vector < vector < int >>& mat , int k ) { vector < int > ans ; vector < vector < int >> rowSum ; for ( int i = 0 ; i < mat . size (); ++ i ) rowSum . push_back ({ accumulate ( begin ( mat [ i ]), end ( mat [ i ]), 0 ), i }); sort ( begin ( rowSum ), end ( rowSum ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( int i = 0 ; i < k ; ++ i ) ans . push_back ( rowSum [ i ][ 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] kWeakestRows ( int [][] mat , int k ) { int [] ans = new int [ k ] ; int [][] candidates = new int [ mat . length ][ 2 ] ; for ( int i = 0 ; i < mat . length ; ++ i ) { candidates [ i ][ 0 ] = IntStream . of ( mat [ i ] ). sum (); candidates [ i ][ 1 ] = i ; } Arrays . sort ( candidates , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ); for ( int i = 0 ; i < k ; ++ i ) ans [ i ] = candidates [ i ][ 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def kWeakestRows ( self , mat : List [ List [ int ]], k : int ) -> List [ int ]: candidates = [] for i , row in enumerate ( mat ): candidates . append ([ sum ( row ), i ]) candidates . sort ( key = lambda c : ( c [ 0 ], c [ 1 ])) return [ i for _ , i in candidates [: k ]]","title":"1337. The K Weakest Rows in a Matrix"},{"location":"problems/1337/#1337-the-k-weakest-rows-in-a-matrix","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > kWeakestRows ( vector < vector < int >>& mat , int k ) { vector < int > ans ; vector < vector < int >> rowSum ; for ( int i = 0 ; i < mat . size (); ++ i ) rowSum . push_back ({ accumulate ( begin ( mat [ i ]), end ( mat [ i ]), 0 ), i }); sort ( begin ( rowSum ), end ( rowSum ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( int i = 0 ; i < k ; ++ i ) ans . push_back ( rowSum [ i ][ 1 ]); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] kWeakestRows ( int [][] mat , int k ) { int [] ans = new int [ k ] ; int [][] candidates = new int [ mat . length ][ 2 ] ; for ( int i = 0 ; i < mat . length ; ++ i ) { candidates [ i ][ 0 ] = IntStream . of ( mat [ i ] ). sum (); candidates [ i ][ 1 ] = i ; } Arrays . sort ( candidates , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ); for ( int i = 0 ; i < k ; ++ i ) ans [ i ] = candidates [ i ][ 1 ] ; return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def kWeakestRows ( self , mat : List [ List [ int ]], k : int ) -> List [ int ]: candidates = [] for i , row in enumerate ( mat ): candidates . append ([ sum ( row ), i ]) candidates . sort ( key = lambda c : ( c [ 0 ], c [ 1 ])) return [ i for _ , i in candidates [: k ]]","title":"1337. The K Weakest Rows in a Matrix"},{"location":"problems/1338/","text":"1338. Reduce Array Size to The Half Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minSetSize ( vector < int >& arr ) { const int n = arr . size (); int sum = 0 ; unordered_map < int , int > map ; vector < pair < int , int >> count ; for ( int a : arr ) ++ map [ a ]; for ( const auto & [ a , freq ] : map ) count . push_back ( make_pair ( a , freq )); sort ( begin ( count ), end ( count ), []( const auto & a , const auto & b ) { return a . second > b . second ; }); for ( int i = 0 ; i < count . size (); ++ i ) { sum += count [ i ]. second ; if ( sum >= n / 2 ) return i + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int minSetSize ( int [] arr ) { final int n = arr . length ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int a : arr ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); int [][] count = new int [ map . size () ][ 2 ] ; int i = 0 ; for ( int key : map . keySet ()) { count [ i ][ 0 ] = key ; count [ i ++][ 1 ] = map . get ( key ); } Arrays . sort ( count , ( c1 , c2 ) -> c2 [ 1 ] - c1 [ 1 ] ); for ( i = 0 ; i < count . length ; ++ i ) { sum += count [ i ][ 1 ] ; if ( sum >= n / 2 ) return i + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minSetSize ( self , arr : List [ int ]) -> int : n = len ( arr ) count = collections . Counter ( arr ) . most_common () count . sort ( key = lambda c : - c [ 1 ]) sum = 0 for i , c in enumerate ( count ): sum += c [ 1 ] if sum >= n // 2 : return i + 1","title":"1338. Reduce Array Size to The Half"},{"location":"problems/1338/#1338-reduce-array-size-to-the-half","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minSetSize ( vector < int >& arr ) { const int n = arr . size (); int sum = 0 ; unordered_map < int , int > map ; vector < pair < int , int >> count ; for ( int a : arr ) ++ map [ a ]; for ( const auto & [ a , freq ] : map ) count . push_back ( make_pair ( a , freq )); sort ( begin ( count ), end ( count ), []( const auto & a , const auto & b ) { return a . second > b . second ; }); for ( int i = 0 ; i < count . size (); ++ i ) { sum += count [ i ]. second ; if ( sum >= n / 2 ) return i + 1 ; } throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int minSetSize ( int [] arr ) { final int n = arr . length ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int a : arr ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); int [][] count = new int [ map . size () ][ 2 ] ; int i = 0 ; for ( int key : map . keySet ()) { count [ i ][ 0 ] = key ; count [ i ++][ 1 ] = map . get ( key ); } Arrays . sort ( count , ( c1 , c2 ) -> c2 [ 1 ] - c1 [ 1 ] ); for ( i = 0 ; i < count . length ; ++ i ) { sum += count [ i ][ 1 ] ; if ( sum >= n / 2 ) return i + 1 ; } throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minSetSize ( self , arr : List [ int ]) -> int : n = len ( arr ) count = collections . Counter ( arr ) . most_common () count . sort ( key = lambda c : - c [ 1 ]) sum = 0 for i , c in enumerate ( count ): sum += c [ 1 ] if sum >= n // 2 : return i + 1","title":"1338. Reduce Array Size to The Half"},{"location":"problems/1339/","text":"1339. Maximum Product of Splitted Binary Tree","title":"1339. Maximum Product of Splitted Binary Tree"},{"location":"problems/1339/#1339-maximum-product-of-splitted-binary-tree","text":"","title":"1339. Maximum Product of Splitted Binary Tree"},{"location":"problems/1340/","text":"1340. Jump Game V","title":"1340. Jump Game V"},{"location":"problems/1340/#1340-jump-game-v","text":"","title":"1340. Jump Game V"},{"location":"problems/1341/","text":"1341. Movie Rating \ud83d\udd12","title":"1341. Movie Rating"},{"location":"problems/1341/#1341-movie-rating","text":"","title":"1341. Movie Rating \ud83d\udd12"},{"location":"problems/1342/","text":"1342. Number of Steps to Reduce a Number to Zero","title":"1342. Number of Steps to Reduce a Number to Zero"},{"location":"problems/1342/#1342-number-of-steps-to-reduce-a-number-to-zero","text":"","title":"1342. Number of Steps to Reduce a Number to Zero"},{"location":"problems/1343/","text":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"},{"location":"problems/1343/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold","text":"","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"},{"location":"problems/1344/","text":"1344. Angle Between Hands of a Clock Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = abs ( hourAngle - minuteAngle ); return min ( ans , 360 - ans ); } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = Math . abs ( hourAngle - minuteAngle ); return Math . min ( ans , 360 - ans ); } } Python 1 2 3 4 5 6 7 class Solution : def angleClock ( self , hour : int , minutes : int ) -> float : hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 minuteAngle = minutes * 6 ans = abs ( hourAngle - minuteAngle ) return min ( ans , 360 - ans )","title":"1344. Angle Between Hands of a Clock"},{"location":"problems/1344/#1344-angle-between-hands-of-a-clock","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = abs ( hourAngle - minuteAngle ); return min ( ans , 360 - ans ); } }; Java 1 2 3 4 5 6 7 8 9 class Solution { public double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = Math . abs ( hourAngle - minuteAngle ); return Math . min ( ans , 360 - ans ); } } Python 1 2 3 4 5 6 7 class Solution : def angleClock ( self , hour : int , minutes : int ) -> float : hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 minuteAngle = minutes * 6 ans = abs ( hourAngle - minuteAngle ) return min ( ans , 360 - ans )","title":"1344. Angle Between Hands of a Clock"},{"location":"problems/1345/","text":"1345. Jump Game IV","title":"1345. Jump Game IV"},{"location":"problems/1345/#1345-jump-game-iv","text":"","title":"1345. Jump Game IV"},{"location":"problems/1346/","text":"1346. Check If N and Its Double Exist","title":"1346. Check If N and Its Double Exist"},{"location":"problems/1346/#1346-check-if-n-and-its-double-exist","text":"","title":"1346. Check If N and Its Double Exist"},{"location":"problems/1347/","text":"1347. Minimum Number of Steps to Make Two Strings Anagram","title":"1347. Minimum Number of Steps to Make Two Strings Anagram"},{"location":"problems/1347/#1347-minimum-number-of-steps-to-make-two-strings-anagram","text":"","title":"1347. Minimum Number of Steps to Make Two Strings Anagram"},{"location":"problems/1348/","text":"1348. Tweet Counts Per Frequency","title":"1348. Tweet Counts Per Frequency"},{"location":"problems/1348/#1348-tweet-counts-per-frequency","text":"","title":"1348. Tweet Counts Per Frequency"},{"location":"problems/1349/","text":"1349. Maximum Students Taking Exam","title":"1349. Maximum Students Taking Exam"},{"location":"problems/1349/#1349-maximum-students-taking-exam","text":"","title":"1349. Maximum Students Taking Exam"},{"location":"problems/1350/","text":"1350. Students With Invalid Departments \ud83d\udd12","title":"1350. Students With Invalid Departments"},{"location":"problems/1350/#1350-students-with-invalid-departments","text":"","title":"1350. Students With Invalid Departments \ud83d\udd12"},{"location":"problems/1351/","text":"1351. Count Negative Numbers in a Sorted Matrix","title":"1351. Count Negative Numbers in a Sorted Matrix"},{"location":"problems/1351/#1351-count-negative-numbers-in-a-sorted-matrix","text":"","title":"1351. Count Negative Numbers in a Sorted Matrix"},{"location":"problems/1352/","text":"1352. Product of the Last K Numbers","title":"1352. Product of the Last K Numbers"},{"location":"problems/1352/#1352-product-of-the-last-k-numbers","text":"","title":"1352. Product of the Last K Numbers"},{"location":"problems/1353/","text":"1353. Maximum Number of Events That Can Be Attended","title":"1353. Maximum Number of Events That Can Be Attended"},{"location":"problems/1353/#1353-maximum-number-of-events-that-can-be-attended","text":"","title":"1353. Maximum Number of Events That Can Be Attended"},{"location":"problems/1354/","text":"1354. Construct Target Array With Multiple Sums","title":"1354. Construct Target Array With Multiple Sums"},{"location":"problems/1354/#1354-construct-target-array-with-multiple-sums","text":"","title":"1354. Construct Target Array With Multiple Sums"},{"location":"problems/1355/","text":"1355. Activity Participants \ud83d\udd12","title":"1355. Activity Participants"},{"location":"problems/1355/#1355-activity-participants","text":"","title":"1355. Activity Participants \ud83d\udd12"},{"location":"problems/1356/","text":"1356. Sort Integers by The Number of 1 Bits","title":"1356. Sort Integers by The Number of 1 Bits"},{"location":"problems/1356/#1356-sort-integers-by-the-number-of-1-bits","text":"","title":"1356. Sort Integers by The Number of 1 Bits"},{"location":"problems/1357/","text":"1357. Apply Discount Every n Orders","title":"1357. Apply Discount Every n Orders"},{"location":"problems/1357/#1357-apply-discount-every-n-orders","text":"","title":"1357. Apply Discount Every n Orders"},{"location":"problems/1358/","text":"1358. Number of Substrings Containing All Three Characters","title":"1358. Number of Substrings Containing All Three Characters"},{"location":"problems/1358/#1358-number-of-substrings-containing-all-three-characters","text":"","title":"1358. Number of Substrings Containing All Three Characters"},{"location":"problems/1359/","text":"1359. Count All Valid Pickup and Delivery Options Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int countOrders ( int n ) { const int kMod = 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int countOrders ( int n ) { final int kMod = ( int ) 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def countOrders ( self , n : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 1 for i in range ( 1 , n + 1 ): ans = ans * i * ( i * 2 - 1 ) % kMod return ans","title":"1359. Count All Valid Pickup and Delivery Options"},{"location":"problems/1359/#1359-count-all-valid-pickup-and-delivery-options","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int countOrders ( int n ) { const int kMod = 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int countOrders ( int n ) { final int kMod = ( int ) 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ( int ) ans ; } } Python 1 2 3 4 5 6 7 8 9 10 class Solution : def countOrders ( self , n : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 1 for i in range ( 1 , n + 1 ): ans = ans * i * ( i * 2 - 1 ) % kMod return ans","title":"1359. Count All Valid Pickup and Delivery Options"},{"location":"problems/1360/","text":"1360. Number of Days Between Two Dates","title":"1360. Number of Days Between Two Dates"},{"location":"problems/1360/#1360-number-of-days-between-two-dates","text":"","title":"1360. Number of Days Between Two Dates"},{"location":"problems/1361/","text":"1361. Validate Binary Tree Nodes","title":"1361. Validate Binary Tree Nodes"},{"location":"problems/1361/#1361-validate-binary-tree-nodes","text":"","title":"1361. Validate Binary Tree Nodes"},{"location":"problems/1362/","text":"1362. Closest Divisors Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > closestDivisors ( int num ) { for ( int root = sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : { num + 1 , num + 2 }) if ( cand % root == 0 ) return { root , cand / root }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int [] closestDivisors ( int num ) { for ( int root = ( int ) Math . sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : new int [] { num + 1 , num + 2 }) if ( cand % root == 0 ) return new int [] { root , cand / root }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 class Solution : def closestDivisors ( self , num : int ) -> List [ int ]: for root in range ( int ( sqrt ( num + 2 )) + 1 )[:: - 1 ]: for cand in [ num + 1 , num + 2 ]: if cand % root == 0 : return [ root , cand // root ]","title":"1362. Closest Divisors"},{"location":"problems/1362/#1362-closest-divisors","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : vector < int > closestDivisors ( int num ) { for ( int root = sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : { num + 1 , num + 2 }) if ( cand % root == 0 ) return { root , cand / root }; throw ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public int [] closestDivisors ( int num ) { for ( int root = ( int ) Math . sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : new int [] { num + 1 , num + 2 }) if ( cand % root == 0 ) return new int [] { root , cand / root }; throw new IllegalArgumentException (); } } Python 1 2 3 4 5 6 class Solution : def closestDivisors ( self , num : int ) -> List [ int ]: for root in range ( int ( sqrt ( num + 2 )) + 1 )[:: - 1 ]: for cand in [ num + 1 , num + 2 ]: if cand % root == 0 : return [ root , cand // root ]","title":"1362. Closest Divisors"},{"location":"problems/1363/","text":"1363. Largest Multiple of Three Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : string largestMultipleOfThree ( vector < int >& digits ) { string ans ; vector < int > mod1 { 1 , 4 , 7 , 2 , 5 , 8 }; vector < int > mod2 { 2 , 5 , 8 , 1 , 4 , 7 }; vector < int > count ( 10 ); int sum = accumulate ( begin ( digits ), end ( digits ), 0 ); for ( int digit : digits ) ++ count [ digit ]; while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ]) { -- count [ i ]; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans += string ( count [ digit ], '0' + digit ); return ans . size () && ans [ 0 ] == '0' ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public String largestMultipleOfThree ( int [] digits ) { StringBuilder ans = new StringBuilder (); int [] mod1 = new int [] { 1 , 4 , 7 , 2 , 5 , 8 }; int [] mod2 = new int [] { 2 , 5 , 8 , 1 , 4 , 7 }; int [] count = new int [ 10 ] ; int sum = 0 ; for ( int digit : digits ) { ++ count [ digit ] ; sum += digit ; } while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ] > 0 ) { -- count [ i ] ; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans . append ( Character . toString ( '0' + digit ). repeat ( count [ digit ] )); return ans . length () > 0 && ans . charAt ( 0 ) == '0' ? \"0\" : ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def largestMultipleOfThree ( self , digits : List [ int ]) -> str : ans = '' mod1 = [ 1 , 4 , 7 , 2 , 5 , 8 ] mod2 = [ 2 , 5 , 8 , 1 , 4 , 7 ] count = collections . Counter ( digits ) summ = sum ( digits ) while summ % 3 != 0 : for digit in ( mod1 if summ % 3 == 1 else mod2 ): if count [ digit ]: count [ digit ] -= 1 summ -= digit break for digit in range ( 9 , - 1 , - 1 ): ans += str ( digit ) * count [ digit ] return '0' if len ( ans ) and ans [ 0 ] == '0' else ans","title":"1363. Largest Multiple of Three"},{"location":"problems/1363/#1363-largest-multiple-of-three","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : string largestMultipleOfThree ( vector < int >& digits ) { string ans ; vector < int > mod1 { 1 , 4 , 7 , 2 , 5 , 8 }; vector < int > mod2 { 2 , 5 , 8 , 1 , 4 , 7 }; vector < int > count ( 10 ); int sum = accumulate ( begin ( digits ), end ( digits ), 0 ); for ( int digit : digits ) ++ count [ digit ]; while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ]) { -- count [ i ]; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans += string ( count [ digit ], '0' + digit ); return ans . size () && ans [ 0 ] == '0' ? \"0\" : ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public String largestMultipleOfThree ( int [] digits ) { StringBuilder ans = new StringBuilder (); int [] mod1 = new int [] { 1 , 4 , 7 , 2 , 5 , 8 }; int [] mod2 = new int [] { 2 , 5 , 8 , 1 , 4 , 7 }; int [] count = new int [ 10 ] ; int sum = 0 ; for ( int digit : digits ) { ++ count [ digit ] ; sum += digit ; } while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ] > 0 ) { -- count [ i ] ; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans . append ( Character . toString ( '0' + digit ). repeat ( count [ digit ] )); return ans . length () > 0 && ans . charAt ( 0 ) == '0' ? \"0\" : ans . toString (); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def largestMultipleOfThree ( self , digits : List [ int ]) -> str : ans = '' mod1 = [ 1 , 4 , 7 , 2 , 5 , 8 ] mod2 = [ 2 , 5 , 8 , 1 , 4 , 7 ] count = collections . Counter ( digits ) summ = sum ( digits ) while summ % 3 != 0 : for digit in ( mod1 if summ % 3 == 1 else mod2 ): if count [ digit ]: count [ digit ] -= 1 summ -= digit break for digit in range ( 9 , - 1 , - 1 ): ans += str ( digit ) * count [ digit ] return '0' if len ( ans ) and ans [ 0 ] == '0' else ans","title":"1363. Largest Multiple of Three"},{"location":"problems/1364/","text":"1364. Number of Trusted Contacts of a Customer \ud83d\udd12","title":"1364. Number of Trusted Contacts of a Customer"},{"location":"problems/1364/#1364-number-of-trusted-contacts-of-a-customer","text":"","title":"1364. Number of Trusted Contacts of a Customer \ud83d\udd12"},{"location":"problems/1365/","text":"1365. How Many Numbers Are Smaller Than the Current Number","title":"1365. How Many Numbers Are Smaller Than the Current Number"},{"location":"problems/1365/#1365-how-many-numbers-are-smaller-than-the-current-number","text":"","title":"1365. How Many Numbers Are Smaller Than the Current Number"},{"location":"problems/1366/","text":"1366. Rank Teams by Votes","title":"1366. Rank Teams by Votes"},{"location":"problems/1366/#1366-rank-teams-by-votes","text":"","title":"1366. Rank Teams by Votes"},{"location":"problems/1367/","text":"1367. Linked List in Binary Tree","title":"1367. Linked List in Binary Tree"},{"location":"problems/1367/#1367-linked-list-in-binary-tree","text":"","title":"1367. Linked List in Binary Tree"},{"location":"problems/1368/","text":"1368. Minimum Cost to Make at Least One Valid Path in a Grid","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid"},{"location":"problems/1368/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid","text":"","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid"},{"location":"problems/1369/","text":"1369. Get the Second Most Recent Activity \ud83d\udd12","title":"1369. Get the Second Most Recent Activity"},{"location":"problems/1369/#1369-get-the-second-most-recent-activity","text":"","title":"1369. Get the Second Most Recent Activity \ud83d\udd12"},{"location":"problems/1370/","text":"1370. Increasing Decreasing String","title":"1370. Increasing Decreasing String"},{"location":"problems/1370/#1370-increasing-decreasing-string","text":"","title":"1370. Increasing Decreasing String"},{"location":"problems/1371/","text":"1371. Find the Longest Substring Containing Vowels in Even Counts","title":"1371. Find the Longest Substring Containing Vowels in Even Counts"},{"location":"problems/1371/#1371-find-the-longest-substring-containing-vowels-in-even-counts","text":"","title":"1371. Find the Longest Substring Containing Vowels in Even Counts"},{"location":"problems/1372/","text":"1372. Longest ZigZag Path in a Binary Tree","title":"1372. Longest ZigZag Path in a Binary Tree"},{"location":"problems/1372/#1372-longest-zigzag-path-in-a-binary-tree","text":"","title":"1372. Longest ZigZag Path in a Binary Tree"},{"location":"problems/1373/","text":"1373. Maximum Sum BST in Binary Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxSumBST ( TreeNode * root ) { int ans = 0 ; dfs ( root , ans ); return ans ; } private : tuple < int , int , int , bool > dfs ( TreeNode * root , int & ans ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 , true }; auto [ leftMin , leftMax , leftSum , leftValid ] = dfs ( root -> left , ans ); auto [ rightMin , rightMax , rightSum , rightValid ] = dfs ( root -> right , ans ); bool valid = leftValid && rightValid && root -> val > leftMax && root -> val < rightMin ; int sum = valid ? root -> val + leftSum + rightSum : -1 ; ans = max ( ans , sum ); return { min ( root -> val , leftMin ), max ( root -> val , rightMax ), sum , valid }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int maxSumBST ( TreeNode root ) { dfs ( root ); return ans ; } private int ans = 0 ; private Info dfs ( TreeNode root ) { if ( root == null ) return new Info ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 , true ); Info left = dfs ( root . left ); Info right = dfs ( root . right ); boolean valid = left . valid && right . valid && root . val > left . max && root . val < right . min ; int sum = valid ? root . val + left . sum + right . sum : - 1 ; ans = Math . max ( ans , sum ); return new Info ( Math . min ( root . val , left . min ), Math . max ( root . val , right . max ), sum , valid ); } private class Info { int min ; int max ; int sum ; boolean valid ; public Info ( int min , int max , int sum , boolean valid ) { this . min = min ; this . max = max ; this . sum = sum ; this . valid = valid ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxSumBST ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode ) -> tuple : if not root : return float ( 'inf' ), float ( '-inf' ), 0 , True leftMin , leftMax , leftSum , leftValid = dfs ( root . left ) rightMin , rightMax , rightSum , rightValid = dfs ( root . right ) valid = leftValid and rightValid and root . val > leftMax and root . val < rightMin summ = root . val + leftSum + rightSum if valid else - 1 self . ans = max ( self . ans , summ ) return min ( root . val , leftMin ), max ( root . val , rightMax ), summ , valid self . ans = 0 dfs ( root ) return self . ans","title":"1373. Maximum Sum BST in Binary Tree"},{"location":"problems/1373/#1373-maximum-sum-bst-in-binary-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxSumBST ( TreeNode * root ) { int ans = 0 ; dfs ( root , ans ); return ans ; } private : tuple < int , int , int , bool > dfs ( TreeNode * root , int & ans ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 , true }; auto [ leftMin , leftMax , leftSum , leftValid ] = dfs ( root -> left , ans ); auto [ rightMin , rightMax , rightSum , rightValid ] = dfs ( root -> right , ans ); bool valid = leftValid && rightValid && root -> val > leftMax && root -> val < rightMin ; int sum = valid ? root -> val + leftSum + rightSum : -1 ; ans = max ( ans , sum ); return { min ( root -> val , leftMin ), max ( root -> val , rightMax ), sum , valid }; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int maxSumBST ( TreeNode root ) { dfs ( root ); return ans ; } private int ans = 0 ; private Info dfs ( TreeNode root ) { if ( root == null ) return new Info ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 , true ); Info left = dfs ( root . left ); Info right = dfs ( root . right ); boolean valid = left . valid && right . valid && root . val > left . max && root . val < right . min ; int sum = valid ? root . val + left . sum + right . sum : - 1 ; ans = Math . max ( ans , sum ); return new Info ( Math . min ( root . val , left . min ), Math . max ( root . val , right . max ), sum , valid ); } private class Info { int min ; int max ; int sum ; boolean valid ; public Info ( int min , int max , int sum , boolean valid ) { this . min = min ; this . max = max ; this . sum = sum ; this . valid = valid ; } } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxSumBST ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode ) -> tuple : if not root : return float ( 'inf' ), float ( '-inf' ), 0 , True leftMin , leftMax , leftSum , leftValid = dfs ( root . left ) rightMin , rightMax , rightSum , rightValid = dfs ( root . right ) valid = leftValid and rightValid and root . val > leftMax and root . val < rightMin summ = root . val + leftSum + rightSum if valid else - 1 self . ans = max ( self . ans , summ ) return min ( root . val , leftMin ), max ( root . val , rightMax ), summ , valid self . ans = 0 dfs ( root ) return self . ans","title":"1373. Maximum Sum BST in Binary Tree"},{"location":"problems/1374/","text":"1374. Generate a String With Characters That Have Odd Counts","title":"1374. Generate a String With Characters That Have Odd Counts"},{"location":"problems/1374/#1374-generate-a-string-with-characters-that-have-odd-counts","text":"","title":"1374. Generate a String With Characters That Have Odd Counts"},{"location":"problems/1375/","text":"1375. Bulb Switcher III","title":"1375. Bulb Switcher III"},{"location":"problems/1375/#1375-bulb-switcher-iii","text":"","title":"1375. Bulb Switcher III"},{"location":"problems/1376/","text":"1376. Time Needed to Inform All Employees","title":"1376. Time Needed to Inform All Employees"},{"location":"problems/1376/#1376-time-needed-to-inform-all-employees","text":"","title":"1376. Time Needed to Inform All Employees"},{"location":"problems/1377/","text":"1377. Frog Position After T Seconds Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { vector < double > prob ( n + 1 ); vector < bool > visited ( n + 1 ); queue < int > queue {{ 1 }}; vector < vector < int >> graph ( n + 1 ); prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; for ( vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } for ( int i = 0 ; i < t ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . front (); queue . pop (); int children = count_if ( begin ( graph [ curr ]), end ( graph [ curr ]), [ & visited ]( int child ) { return ! visited [ child ]; }); for ( int child : graph [ curr ]) if ( ! visited [ child ]) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . push ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } return prob [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public double frogPosition ( int n , int [][] edges , int t , int target ) { double [] prob = new double [ n + 1 ] ; boolean [] visited = new boolean [ n + 1 ] ; Queue < Integer > queue = new LinkedList <> (); List < Integer >[] graph = new List [ n + 1 ] ; prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; queue . add ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < t ; ++ i ) { for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . poll (); int children = 0 ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) ++ children ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . add ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } } return prob [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def frogPosition ( self , n : int , edges : List [ List [ int ]], t : int , target : int ) -> float : prob = [ 0 ] * ( n + 1 ) visited = [ False ] * ( n + 1 ) graph = [[] for _ in range ( n + 1 )] queue = collections . deque ([ 1 ]) prob [ 1 ] = 1 visited [ 1 ] = True for fr , to in edges : graph [ fr ] . append ( to ) graph [ to ] . append ( fr ) for _ in range ( t ): for _ in range ( len ( queue )): curr = queue . popleft () children = sum ( not visited [ child ] for child in graph [ curr ]) for child in graph [ curr ]: if not visited [ child ]: visited [ child ] = True prob [ child ] = prob [ curr ] / children queue . append ( child ) if children > 0 : prob [ curr ] = 0 return prob [ target ]","title":"1377. Frog Position After T Seconds"},{"location":"problems/1377/#1377-frog-position-after-t-seconds","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { vector < double > prob ( n + 1 ); vector < bool > visited ( n + 1 ); queue < int > queue {{ 1 }}; vector < vector < int >> graph ( n + 1 ); prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; for ( vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } for ( int i = 0 ; i < t ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . front (); queue . pop (); int children = count_if ( begin ( graph [ curr ]), end ( graph [ curr ]), [ & visited ]( int child ) { return ! visited [ child ]; }); for ( int child : graph [ curr ]) if ( ! visited [ child ]) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . push ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } return prob [ target ]; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public double frogPosition ( int n , int [][] edges , int t , int target ) { double [] prob = new double [ n + 1 ] ; boolean [] visited = new boolean [ n + 1 ] ; Queue < Integer > queue = new LinkedList <> (); List < Integer >[] graph = new List [ n + 1 ] ; prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; queue . add ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < t ; ++ i ) { for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . poll (); int children = 0 ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) ++ children ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . add ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } } return prob [ target ] ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def frogPosition ( self , n : int , edges : List [ List [ int ]], t : int , target : int ) -> float : prob = [ 0 ] * ( n + 1 ) visited = [ False ] * ( n + 1 ) graph = [[] for _ in range ( n + 1 )] queue = collections . deque ([ 1 ]) prob [ 1 ] = 1 visited [ 1 ] = True for fr , to in edges : graph [ fr ] . append ( to ) graph [ to ] . append ( fr ) for _ in range ( t ): for _ in range ( len ( queue )): curr = queue . popleft () children = sum ( not visited [ child ] for child in graph [ curr ]) for child in graph [ curr ]: if not visited [ child ]: visited [ child ] = True prob [ child ] = prob [ curr ] / children queue . append ( child ) if children > 0 : prob [ curr ] = 0 return prob [ target ]","title":"1377. Frog Position After T Seconds"},{"location":"problems/1378/","text":"1378. Replace Employee ID With The Unique Identifier \ud83d\udd12","title":"1378. Replace Employee ID With The Unique Identifier"},{"location":"problems/1378/#1378-replace-employee-id-with-the-unique-identifier","text":"","title":"1378. Replace Employee ID With The Unique Identifier \ud83d\udd12"},{"location":"problems/1379/","text":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"},{"location":"problems/1379/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree","text":"","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree"},{"location":"problems/1380/","text":"1380. Lucky Numbers in a Matrix","title":"1380. Lucky Numbers in a Matrix"},{"location":"problems/1380/#1380-lucky-numbers-in-a-matrix","text":"","title":"1380. Lucky Numbers in a Matrix"},{"location":"problems/1381/","text":"1381. Design a Stack With Increment Operation","title":"1381. Design a Stack With Increment Operation"},{"location":"problems/1381/#1381-design-a-stack-with-increment-operation","text":"","title":"1381. Design a Stack With Increment Operation"},{"location":"problems/1382/","text":"1382. Balance a Binary Search Tree","title":"1382. Balance a Binary Search Tree"},{"location":"problems/1382/#1382-balance-a-binary-search-tree","text":"","title":"1382. Balance a Binary Search Tree"},{"location":"problems/1383/","text":"1383. Maximum Performance of a Team","title":"1383. Maximum Performance of a Team"},{"location":"problems/1383/#1383-maximum-performance-of-a-team","text":"","title":"1383. Maximum Performance of a Team"},{"location":"problems/1384/","text":"1384. Total Sales Amount by Year \ud83d\udd12","title":"1384. Total Sales Amount by Year"},{"location":"problems/1384/#1384-total-sales-amount-by-year","text":"","title":"1384. Total Sales Amount by Year \ud83d\udd12"},{"location":"problems/1385/","text":"1385. Find the Distance Value Between Two Arrays","title":"1385. Find the Distance Value Between Two Arrays"},{"location":"problems/1385/#1385-find-the-distance-value-between-two-arrays","text":"","title":"1385. Find the Distance Value Between Two Arrays"},{"location":"problems/1386/","text":"1386. Cinema Seat Allocation","title":"1386. Cinema Seat Allocation"},{"location":"problems/1386/#1386-cinema-seat-allocation","text":"","title":"1386. Cinema Seat Allocation"},{"location":"problems/1387/","text":"1387. Sort Integers by The Power Value","title":"1387. Sort Integers by The Power Value"},{"location":"problems/1387/#1387-sort-integers-by-the-power-value","text":"","title":"1387. Sort Integers by The Power Value"},{"location":"problems/1388/","text":"1388. Pizza With 3n Slices","title":"1388. Pizza With 3n Slices"},{"location":"problems/1388/#1388-pizza-with-3n-slices","text":"","title":"1388. Pizza With 3n Slices"},{"location":"problems/1389/","text":"1389. Create Target Array in the Given Order","title":"1389. Create Target Array in the Given Order"},{"location":"problems/1389/#1389-create-target-array-in-the-given-order","text":"","title":"1389. Create Target Array in the Given Order"},{"location":"problems/1390/","text":"1390. Four Divisors Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int sumFourDivisors ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int sumFourDivisors ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumFourDivisors ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : divisor = 0 for i in range ( 2 , int ( sqrt ( num )) + 1 ): if num % i == 0 : if divisor == 0 : divisor = i else : divisor = 0 break if divisor > 0 and divisor * divisor < num : ans += 1 + num + divisor + num // divisor return ans","title":"1390. Four Divisors"},{"location":"problems/1390/#1390-four-divisors","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int sumFourDivisors ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int sumFourDivisors ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumFourDivisors ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : divisor = 0 for i in range ( 2 , int ( sqrt ( num )) + 1 ): if num % i == 0 : if divisor == 0 : divisor = i else : divisor = 0 break if divisor > 0 and divisor * divisor < num : ans += 1 + num + divisor + num // divisor return ans","title":"1390. Four Divisors"},{"location":"problems/1391/","text":"1391. Check if There is a Valid Path in a Grid","title":"1391. Check if There is a Valid Path in a Grid"},{"location":"problems/1391/#1391-check-if-there-is-a-valid-path-in-a-grid","text":"","title":"1391. Check if There is a Valid Path in a Grid"},{"location":"problems/1392/","text":"1392. Longest Happy Prefix","title":"1392. Longest Happy Prefix"},{"location":"problems/1392/#1392-longest-happy-prefix","text":"","title":"1392. Longest Happy Prefix"},{"location":"problems/1393/","text":"1393. Capital Gain/Loss \ud83d\udd12","title":"1393. Capital Gain/Loss"},{"location":"problems/1393/#1393-capital-gainloss","text":"","title":"1393. Capital Gain/Loss \ud83d\udd12"},{"location":"problems/1394/","text":"1394. Find Lucky Integer in an Array","title":"1394. Find Lucky Integer in an Array"},{"location":"problems/1394/#1394-find-lucky-integer-in-an-array","text":"","title":"1394. Find Lucky Integer in an Array"},{"location":"problems/1395/","text":"1395. Count Number of Teams","title":"1395. Count Number of Teams"},{"location":"problems/1395/#1395-count-number-of-teams","text":"","title":"1395. Count Number of Teams"},{"location":"problems/1396/","text":"1396. Design Underground System","title":"1396. Design Underground System"},{"location":"problems/1396/#1396-design-underground-system","text":"","title":"1396. Design Underground System"},{"location":"problems/1397/","text":"1397. Find All Good Strings","title":"1397. Find All Good Strings"},{"location":"problems/1397/#1397-find-all-good-strings","text":"","title":"1397. Find All Good Strings"},{"location":"problems/1398/","text":"1398. Customers Who Bought Products A and B but Not C \ud83d\udd12","title":"1398. Customers Who Bought Products A and B but Not C"},{"location":"problems/1398/#1398-customers-who-bought-products-a-and-b-but-not-c","text":"","title":"1398. Customers Who Bought Products A and B but Not C \ud83d\udd12"},{"location":"problems/1399/","text":"1399. Count Largest Group","title":"1399. Count Largest Group"},{"location":"problems/1399/#1399-count-largest-group","text":"","title":"1399. Count Largest Group"},{"location":"problems/1400/","text":"1400. Construct K Palindrome Strings","title":"1400. Construct K Palindrome Strings"},{"location":"problems/1400/#1400-construct-k-palindrome-strings","text":"","title":"1400. Construct K Palindrome Strings"},{"location":"problems/1401/","text":"1401. Circle and Rectangle Overlapping Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool checkOverlap ( int radius , int x_center , int y_center , int x1 , int y1 , int x2 , int y2 ) { auto clamp = [ & ]( int center , int mini , int maxi ) { return max ( mini , min ( maxi , center )); }; // the closest point to the circle within the rectangle int closestX = clamp ( x_center , x1 , x2 ); int closestY = clamp ( y_center , y1 , y2 ); // the distance between the circle's center and this closest point int distanceX = x_center - closestX ; int distanceY = y_center - closestY ; // if the distance is less than the circle's radius, an intersection occurs return ( distanceX * distanceX ) + ( distanceY * distanceY ) <= ( radius * radius ); } };","title":"1401. Circle and Rectangle Overlapping"},{"location":"problems/1401/#1401-circle-and-rectangle-overlapping","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool checkOverlap ( int radius , int x_center , int y_center , int x1 , int y1 , int x2 , int y2 ) { auto clamp = [ & ]( int center , int mini , int maxi ) { return max ( mini , min ( maxi , center )); }; // the closest point to the circle within the rectangle int closestX = clamp ( x_center , x1 , x2 ); int closestY = clamp ( y_center , y1 , y2 ); // the distance between the circle's center and this closest point int distanceX = x_center - closestX ; int distanceY = y_center - closestY ; // if the distance is less than the circle's radius, an intersection occurs return ( distanceX * distanceX ) + ( distanceY * distanceY ) <= ( radius * radius ); } };","title":"1401. Circle and Rectangle Overlapping"},{"location":"problems/1402/","text":"1402. Reducing Dishes","title":"1402. Reducing Dishes"},{"location":"problems/1402/#1402-reducing-dishes","text":"","title":"1402. Reducing Dishes"},{"location":"problems/1403/","text":"1403. Minimum Subsequence in Non-Increasing Order","title":"1403. Minimum Subsequence in Non-Increasing Order"},{"location":"problems/1403/#1403-minimum-subsequence-in-non-increasing-order","text":"","title":"1403. Minimum Subsequence in Non-Increasing Order"},{"location":"problems/1404/","text":"1404. Number of Steps to Reduce a Number in Binary Representation to One","title":"1404. Number of Steps to Reduce a Number in Binary Representation to One"},{"location":"problems/1404/#1404-number-of-steps-to-reduce-a-number-in-binary-representation-to-one","text":"","title":"1404. Number of Steps to Reduce a Number in Binary Representation to One"},{"location":"problems/1405/","text":"1405. Longest Happy String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string longestDiverseString ( int a , int b , int c , char A = 'a' , char B = 'b' , char C = 'c' ) { if ( a < b ) return longestDiverseString ( b , a , c , B , A , C ); if ( b < c ) return longestDiverseString ( a , c , b , A , C , B ); if ( b == 0 ) return string ( min ( a , 2 ), A ); const int useA = min ( a , 2 ); const int useB = ( a - useA >= b ) ? 1 : 0 ; return string ( useA , A ) + string ( useB , B ) + longestDiverseString ( a - useA , b - useB , c , A , B , C ); } };","title":"1405. Longest Happy String"},{"location":"problems/1405/#1405-longest-happy-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string longestDiverseString ( int a , int b , int c , char A = 'a' , char B = 'b' , char C = 'c' ) { if ( a < b ) return longestDiverseString ( b , a , c , B , A , C ); if ( b < c ) return longestDiverseString ( a , c , b , A , C , B ); if ( b == 0 ) return string ( min ( a , 2 ), A ); const int useA = min ( a , 2 ); const int useB = ( a - useA >= b ) ? 1 : 0 ; return string ( useA , A ) + string ( useB , B ) + longestDiverseString ( a - useA , b - useB , c , A , B , C ); } };","title":"1405. Longest Happy String"},{"location":"problems/1406/","text":"1406. Stone Game III Approach 1: Bottom-up Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); // dp[i] := max \"relative score\" Alice can make with stoneValue[i..n) vector < int > dp ( n + 1 , INT_MIN / 2 ); dp . back () = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; dp [ i ] = max ( dp [ i ], sum - dp [ j + 1 ]); } } const int score = dp [ 0 ]; return score > 0 ? \"Alice\" : score < 0 ? \"Bob\" : \"Tie\" ; } }; Approach 2: Top-down Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); vector < int > memo ( n , INT_MIN ); // dp(i) := max \"\"relative score\"\" Alice can make with stoneValue[i..n) function < int ( int ) > dp = [ & ]( int i ) { if ( i == n ) return 0 ; int & ans = memo [ i ]; if ( ans > INT_MIN ) return ans ; int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; ans = max ( ans , sum - dp ( j + 1 )); } return ans ; }; const int score = dp ( 0 ); return score > 0 ? \"\" Alice \"\" : score < 0 ? \"\" Bob \"\" : \"\" Tie \"\" ; } };","title":"1406. Stone Game III"},{"location":"problems/1406/#1406-stone-game-iii","text":"","title":"1406. Stone Game III"},{"location":"problems/1406/#approach-1-bottom-up","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); // dp[i] := max \"relative score\" Alice can make with stoneValue[i..n) vector < int > dp ( n + 1 , INT_MIN / 2 ); dp . back () = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; dp [ i ] = max ( dp [ i ], sum - dp [ j + 1 ]); } } const int score = dp [ 0 ]; return score > 0 ? \"Alice\" : score < 0 ? \"Bob\" : \"Tie\" ; } };","title":"Approach 1: Bottom-up"},{"location":"problems/1406/#approach-2-top-down","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); vector < int > memo ( n , INT_MIN ); // dp(i) := max \"\"relative score\"\" Alice can make with stoneValue[i..n) function < int ( int ) > dp = [ & ]( int i ) { if ( i == n ) return 0 ; int & ans = memo [ i ]; if ( ans > INT_MIN ) return ans ; int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; ans = max ( ans , sum - dp ( j + 1 )); } return ans ; }; const int score = dp ( 0 ); return score > 0 ? \"\" Alice \"\" : score < 0 ? \"\" Bob \"\" : \"\" Tie \"\" ; } };","title":"Approach 2: Top-down"},{"location":"problems/1407/","text":"1407. Top Travellers \ud83d\udd12","title":"1407. Top Travellers"},{"location":"problems/1407/#1407-top-travellers","text":"","title":"1407. Top Travellers \ud83d\udd12"},{"location":"problems/1408/","text":"1408. String Matching in an Array","title":"1408. String Matching in an Array"},{"location":"problems/1408/#1408-string-matching-in-an-array","text":"","title":"1408. String Matching in an Array"},{"location":"problems/1409/","text":"1409. Queries on a Permutation With Key","title":"1409. Queries on a Permutation With Key"},{"location":"problems/1409/#1409-queries-on-a-permutation-with-key","text":"","title":"1409. Queries on a Permutation With Key"},{"location":"problems/1410/","text":"1410. HTML Entity Parser","title":"1410. HTML Entity Parser"},{"location":"problems/1410/#1410-html-entity-parser","text":"","title":"1410. HTML Entity Parser"},{"location":"problems/1411/","text":"1411. Number of Ways to Paint N \u00d7 3 Grid Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numOfWays ( int n ) { const int kMod = 1e9 + 7 ; long color2 = 6 ; // pattern 121 long color3 = 6 ; // pattern 123 for ( int i = 1 ; i < n ; ++ i ) { const long nextColor2 = color2 * 3 + color3 * 2 ; const long nextColor3 = color2 * 2 + color3 * 2 ; color2 = nextColor2 % kMod ; color3 = nextColor3 % kMod ; } return ( color2 + color3 ) % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numOfWays ( int n ) { final long kMod = ( long ) 1e9 + 7 ; long color2 = 6 ; // pattern 121 long color3 = 6 ; // pattern 123 for ( int i = 1 ; i < n ; ++ i ) { final long nextColor2 = color2 * 3 + color3 * 2 ; final long nextColor3 = color2 * 2 + color3 * 2 ; color2 = nextColor2 % kMod ; color3 = nextColor3 % kMod ; } return ( int ) (( color2 + color3 ) % kMod ); } }","title":"1411. Number of Ways to Paint N \u00d7 3 Grid"},{"location":"problems/1411/#1411-number-of-ways-to-paint-n-3-grid","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numOfWays ( int n ) { const int kMod = 1e9 + 7 ; long color2 = 6 ; // pattern 121 long color3 = 6 ; // pattern 123 for ( int i = 1 ; i < n ; ++ i ) { const long nextColor2 = color2 * 3 + color3 * 2 ; const long nextColor3 = color2 * 2 + color3 * 2 ; color2 = nextColor2 % kMod ; color3 = nextColor3 % kMod ; } return ( color2 + color3 ) % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numOfWays ( int n ) { final long kMod = ( long ) 1e9 + 7 ; long color2 = 6 ; // pattern 121 long color3 = 6 ; // pattern 123 for ( int i = 1 ; i < n ; ++ i ) { final long nextColor2 = color2 * 3 + color3 * 2 ; final long nextColor3 = color2 * 2 + color3 * 2 ; color2 = nextColor2 % kMod ; color3 = nextColor3 % kMod ; } return ( int ) (( color2 + color3 ) % kMod ); } }","title":"1411. Number of Ways to Paint N \u00d7 3 Grid"},{"location":"problems/1412/","text":"1412. Find the Quiet Students in All Exams \ud83d\udd12","title":"1412. Find the Quiet Students in All Exams"},{"location":"problems/1412/#1412-find-the-quiet-students-in-all-exams","text":"","title":"1412. Find the Quiet Students in All Exams \ud83d\udd12"},{"location":"problems/1413/","text":"1413. Minimum Value to Get Positive Step by Step Sum","title":"1413. Minimum Value to Get Positive Step by Step Sum"},{"location":"problems/1413/#1413-minimum-value-to-get-positive-step-by-step-sum","text":"","title":"1413. Minimum Value to Get Positive Step by Step Sum"},{"location":"problems/1414/","text":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"},{"location":"problems/1414/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","text":"","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"},{"location":"problems/1415/","text":"1415. The k-th Lexicographical String of All Happy Strings of Length n","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n"},{"location":"problems/1415/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n","text":"","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n"},{"location":"problems/1416/","text":"1416. Restore The Array Approach 1: Bottom-up Time: $O(n\\log k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); // dp[i] := # of arrays to restore s[i..n) with k vector < int > dp ( n + 1 ); dp . back () = 1 ; // empty string \"\" for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) continue ; // leading zero long num = 0 ; for ( int j = i ; j < n ; ++ j ) { num = num * 10 + ( s [ j ] - '0' ); if ( num > k ) break ; dp [ i ] = ( dp [ i ] + dp [ j + 1 ]) % kMod ; } } return dp [ 0 ]; } }; Approach 2: Top-down Time: $O(n\\log k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); vector < int > memo ( n , -1 ); // dp(i) := # of arrays to restore s[i..n) with k function < int ( int ) > dp = [ & ]( int i ) { if ( i == n ) return 1 ; // empty string \"\"\"\" if ( s [ i ] == '0' ) return 0 ; // leading zero if ( memo [ i ] >= 0 ) return memo [ i ]; int ans = 0 ; long num = 0 ; for ( int j = i ; j < n ; ++ j ) { num = num * 10 + ( s [ j ] - '0' ); if ( num > k ) break ; ans = ( ans + dp ( j + 1 )) % kMod ; } return memo [ i ] = ans ; }; return dp ( 0 ); } };","title":"1416. Restore The Array"},{"location":"problems/1416/#1416-restore-the-array","text":"","title":"1416. Restore The Array"},{"location":"problems/1416/#approach-1-bottom-up","text":"Time: $O(n\\log k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); // dp[i] := # of arrays to restore s[i..n) with k vector < int > dp ( n + 1 ); dp . back () = 1 ; // empty string \"\" for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) continue ; // leading zero long num = 0 ; for ( int j = i ; j < n ; ++ j ) { num = num * 10 + ( s [ j ] - '0' ); if ( num > k ) break ; dp [ i ] = ( dp [ i ] + dp [ j + 1 ]) % kMod ; } } return dp [ 0 ]; } };","title":"Approach 1: Bottom-up"},{"location":"problems/1416/#approach-2-top-down","text":"Time: $O(n\\log k)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); vector < int > memo ( n , -1 ); // dp(i) := # of arrays to restore s[i..n) with k function < int ( int ) > dp = [ & ]( int i ) { if ( i == n ) return 1 ; // empty string \"\"\"\" if ( s [ i ] == '0' ) return 0 ; // leading zero if ( memo [ i ] >= 0 ) return memo [ i ]; int ans = 0 ; long num = 0 ; for ( int j = i ; j < n ; ++ j ) { num = num * 10 + ( s [ j ] - '0' ); if ( num > k ) break ; ans = ( ans + dp ( j + 1 )) % kMod ; } return memo [ i ] = ans ; }; return dp ( 0 ); } };","title":"Approach 2: Top-down"},{"location":"problems/1417/","text":"1417. Reformat The String","title":"1417. Reformat The String"},{"location":"problems/1417/#1417-reformat-the-string","text":"","title":"1417. Reformat The String"},{"location":"problems/1418/","text":"1418. Display Table of Food Orders in a Restaurant","title":"1418. Display Table of Food Orders in a Restaurant"},{"location":"problems/1418/#1418-display-table-of-food-orders-in-a-restaurant","text":"","title":"1418. Display Table of Food Orders in a Restaurant"},{"location":"problems/1419/","text":"1419. Minimum Number of Frogs Croaking","title":"1419. Minimum Number of Frogs Croaking"},{"location":"problems/1419/#1419-minimum-number-of-frogs-croaking","text":"","title":"1419. Minimum Number of Frogs Croaking"},{"location":"problems/1420/","text":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons"},{"location":"problems/1420/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons","text":"","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons"},{"location":"problems/1421/","text":"1421. NPV Queries \ud83d\udd12","title":"1421. NPV Queries"},{"location":"problems/1421/#1421-npv-queries","text":"","title":"1421. NPV Queries \ud83d\udd12"},{"location":"problems/1422/","text":"1422. Maximum Score After Splitting a String","title":"1422. Maximum Score After Splitting a String"},{"location":"problems/1422/#1422-maximum-score-after-splitting-a-string","text":"","title":"1422. Maximum Score After Splitting a String"},{"location":"problems/1423/","text":"1423. Maximum Points You Can Obtain from Cards","title":"1423. Maximum Points You Can Obtain from Cards"},{"location":"problems/1423/#1423-maximum-points-you-can-obtain-from-cards","text":"","title":"1423. Maximum Points You Can Obtain from Cards"},{"location":"problems/1424/","text":"1424. Diagonal Traverse II Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& nums ) { vector < int > ans ; unordered_map < int , vector < int >> keyToNums ; // key = row + col int maxKey = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < nums [ i ]. size (); ++ j ) { const int key = i + j ; keyToNums [ key ]. push_back ( nums [ i ][ j ]); maxKey = max ( maxKey , key ); } for ( int i = 0 ; i <= maxKey ; ++ i ) for ( auto it = rbegin ( keyToNums [ i ]); it != rend ( keyToNums [ i ]); ++ it ) ans . push_back ( * it ); return ans ; } };","title":"1424. Diagonal Traverse II"},{"location":"problems/1424/#1424-diagonal-traverse-ii","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& nums ) { vector < int > ans ; unordered_map < int , vector < int >> keyToNums ; // key = row + col int maxKey = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = 0 ; j < nums [ i ]. size (); ++ j ) { const int key = i + j ; keyToNums [ key ]. push_back ( nums [ i ][ j ]); maxKey = max ( maxKey , key ); } for ( int i = 0 ; i <= maxKey ; ++ i ) for ( auto it = rbegin ( keyToNums [ i ]); it != rend ( keyToNums [ i ]); ++ it ) ans . push_back ( * it ); return ans ; } };","title":"1424. Diagonal Traverse II"},{"location":"problems/1425/","text":"1425. Constrained Subsequence Sum Time: $O(n)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int constrainedSubsetSum ( vector < int >& nums , int k ) { int ans = INT_MIN ; vector < int > dp ( nums . size ()); deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( q . empty ()) dp [ i ] = nums [ i ]; else dp [ i ] = max ( q . front (), 0 ) + nums [ i ]; ans = max ( ans , dp [ i ]); while ( ! q . empty () && q . back () < dp [ i ]) q . pop_back (); q . push_back ( dp [ i ]); if ( i >= k && dp [ i - k ] == q . front ()) q . pop_front (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int constrainedSubsetSum ( int [] nums , int k ) { int ans = Integer . MIN_VALUE ; int [] dp = new int [ nums . length ] ; Deque < Integer > q = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( q . isEmpty ()) dp [ i ] = nums [ i ] ; else dp [ i ] = Math . max ( q . peekFirst (), 0 ) + nums [ i ] ; ans = Math . max ( ans , dp [ i ] ); while ( ! q . isEmpty () && q . peekLast () < dp [ i ] ) q . pollLast (); q . offerLast ( dp [ i ] ); if ( i >= k && dp [ i - k ] == q . peekFirst ()) q . pollFirst (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def constrainedSubsetSum ( self , nums : List [ int ], k : int ) -> int : ans = float ( '-inf' ) dp = [ 0 ] * len ( nums ) q = collections . deque () for i , num in enumerate ( nums ): if q : dp [ i ] = max ( q [ 0 ], 0 ) + num else : dp [ i ] = num ans = max ( ans , dp [ i ]) while q and q [ - 1 ] < dp [ i ]: q . pop () q . append ( dp [ i ]) if i >= k and dp [ i - k ] == q [ 0 ]: q . popleft () return ans","title":"1425. Constrained Subsequence Sum"},{"location":"problems/1425/#1425-constrained-subsequence-sum","text":"Time: $O(n)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int constrainedSubsetSum ( vector < int >& nums , int k ) { int ans = INT_MIN ; vector < int > dp ( nums . size ()); deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( q . empty ()) dp [ i ] = nums [ i ]; else dp [ i ] = max ( q . front (), 0 ) + nums [ i ]; ans = max ( ans , dp [ i ]); while ( ! q . empty () && q . back () < dp [ i ]) q . pop_back (); q . push_back ( dp [ i ]); if ( i >= k && dp [ i - k ] == q . front ()) q . pop_front (); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int constrainedSubsetSum ( int [] nums , int k ) { int ans = Integer . MIN_VALUE ; int [] dp = new int [ nums . length ] ; Deque < Integer > q = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( q . isEmpty ()) dp [ i ] = nums [ i ] ; else dp [ i ] = Math . max ( q . peekFirst (), 0 ) + nums [ i ] ; ans = Math . max ( ans , dp [ i ] ); while ( ! q . isEmpty () && q . peekLast () < dp [ i ] ) q . pollLast (); q . offerLast ( dp [ i ] ); if ( i >= k && dp [ i - k ] == q . peekFirst ()) q . pollFirst (); } return ans ; } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def constrainedSubsetSum ( self , nums : List [ int ], k : int ) -> int : ans = float ( '-inf' ) dp = [ 0 ] * len ( nums ) q = collections . deque () for i , num in enumerate ( nums ): if q : dp [ i ] = max ( q [ 0 ], 0 ) + num else : dp [ i ] = num ans = max ( ans , dp [ i ]) while q and q [ - 1 ] < dp [ i ]: q . pop () q . append ( dp [ i ]) if i >= k and dp [ i - k ] == q [ 0 ]: q . popleft () return ans","title":"1425. Constrained Subsequence Sum"},{"location":"problems/1426/","text":"1426. Counting Elements \ud83d\udd12","title":"1426. Counting Elements"},{"location":"problems/1426/#1426-counting-elements","text":"","title":"1426. Counting Elements \ud83d\udd12"},{"location":"problems/1427/","text":"1427. Perform String Shifts \ud83d\udd12","title":"1427. Perform String Shifts"},{"location":"problems/1427/#1427-perform-string-shifts","text":"","title":"1427. Perform String Shifts \ud83d\udd12"},{"location":"problems/1428/","text":"1428. Leftmost Column with at Least a One \ud83d\udd12 Approach 1: Binary Search Time: $O(m\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int row, int col); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { const vector < int > dimensions = binaryMatrix . dimensions (); const int m = dimensions [ 0 ]; const int n = dimensions [ 1 ]; int ans = -1 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { const int mid = l + ( r - l ) / 2 ; if ( existOne ( binaryMatrix , m , mid )) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } private : bool existOne ( BinaryMatrix & binaryMatrix , int m , int col ) { for ( int i = 0 ; i < m ; ++ i ) if ( binaryMatrix . get ( i , col ) == 1 ) return true ; return false ; } }; Approach 2: Linear Search Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int row, int col); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { const vector < int > dimensions = binaryMatrix . dimensions (); const int m = dimensions [ 0 ]; const int n = dimensions [ 1 ]; int ans = -1 ; int i = 0 ; int j = n - 1 ; while ( i < m && j >= 0 ) if ( binaryMatrix . get ( i , j ) == 1 ) { ans = j ; -- j ; } else { ++ i ; } return ans ; } };","title":"1428. Leftmost Column with at Least a One"},{"location":"problems/1428/#1428-leftmost-column-with-at-least-a-one","text":"","title":"1428. Leftmost Column with at Least a One \ud83d\udd12"},{"location":"problems/1428/#approach-1-binary-search","text":"Time: $O(m\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int row, int col); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { const vector < int > dimensions = binaryMatrix . dimensions (); const int m = dimensions [ 0 ]; const int n = dimensions [ 1 ]; int ans = -1 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { const int mid = l + ( r - l ) / 2 ; if ( existOne ( binaryMatrix , m , mid )) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } private : bool existOne ( BinaryMatrix & binaryMatrix , int m , int col ) { for ( int i = 0 ; i < m ; ++ i ) if ( binaryMatrix . get ( i , col ) == 1 ) return true ; return false ; } };","title":"Approach 1: Binary Search"},{"location":"problems/1428/#approach-2-linear-search","text":"Time: $O(m + n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int row, int col); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { const vector < int > dimensions = binaryMatrix . dimensions (); const int m = dimensions [ 0 ]; const int n = dimensions [ 1 ]; int ans = -1 ; int i = 0 ; int j = n - 1 ; while ( i < m && j >= 0 ) if ( binaryMatrix . get ( i , j ) == 1 ) { ans = j ; -- j ; } else { ++ i ; } return ans ; } };","title":"Approach 2: Linear Search"},{"location":"problems/1429/","text":"1429. First Unique Number \ud83d\udd12","title":"1429. First Unique Number"},{"location":"problems/1429/#1429-first-unique-number","text":"","title":"1429. First Unique Number \ud83d\udd12"},{"location":"problems/1430/","text":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree \ud83d\udd12","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree"},{"location":"problems/1430/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree","text":"","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree \ud83d\udd12"},{"location":"problems/1431/","text":"1431. Kids With the Greatest Number of Candies","title":"1431. Kids With the Greatest Number of Candies"},{"location":"problems/1431/#1431-kids-with-the-greatest-number-of-candies","text":"","title":"1431. Kids With the Greatest Number of Candies"},{"location":"problems/1432/","text":"1432. Max Difference You Can Get From Changing an Integer","title":"1432. Max Difference You Can Get From Changing an Integer"},{"location":"problems/1432/#1432-max-difference-you-can-get-from-changing-an-integer","text":"","title":"1432. Max Difference You Can Get From Changing an Integer"},{"location":"problems/1433/","text":"1433. Check If a String Can Break Another String","title":"1433. Check If a String Can Break Another String"},{"location":"problems/1433/#1433-check-if-a-string-can-break-another-string","text":"","title":"1433. Check If a String Can Break Another String"},{"location":"problems/1434/","text":"1434. Number of Ways to Wear Different Hats to Each Other","title":"1434. Number of Ways to Wear Different Hats to Each Other"},{"location":"problems/1434/#1434-number-of-ways-to-wear-different-hats-to-each-other","text":"","title":"1434. Number of Ways to Wear Different Hats to Each Other"},{"location":"problems/1435/","text":"1435. Create a Session Bar Chart \ud83d\udd12","title":"1435. Create a Session Bar Chart"},{"location":"problems/1435/#1435-create-a-session-bar-chart","text":"","title":"1435. Create a Session Bar Chart \ud83d\udd12"},{"location":"problems/1436/","text":"1436. Destination City Time: Space:","title":"1436. Destination City"},{"location":"problems/1436/#1436-destination-city","text":"Time: Space:","title":"1436. Destination City"},{"location":"problems/1437/","text":"1437. Check If All 1's Are at Least Length K Places Away Time: Space:","title":"1437. Check If All 1's Are at Least Length K Places Away"},{"location":"problems/1437/#1437-check-if-all-1s-are-at-least-length-k-places-away","text":"Time: Space:","title":"1437. Check If All 1's Are at Least Length K Places Away"},{"location":"problems/1438/","text":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int longestSubarray ( vector < int >& nums , int limit ) { int ans = 1 ; deque < int > minDeque ; deque < int > maxDeque ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { while ( ! minDeque . empty () && minDeque . back () > nums [ r ]) minDeque . pop_back (); minDeque . push_back ( nums [ r ]); while ( ! maxDeque . empty () && maxDeque . back () < nums [ r ]) maxDeque . pop_back (); maxDeque . push_back ( nums [ r ]); while ( maxDeque . front () - minDeque . front () > limit ) { if ( minDeque . front () == nums [ l ]) minDeque . pop_front (); if ( maxDeque . front () == nums [ l ]) maxDeque . pop_front (); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"},{"location":"problems/1438/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int longestSubarray ( vector < int >& nums , int limit ) { int ans = 1 ; deque < int > minDeque ; deque < int > maxDeque ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { while ( ! minDeque . empty () && minDeque . back () > nums [ r ]) minDeque . pop_back (); minDeque . push_back ( nums [ r ]); while ( ! maxDeque . empty () && maxDeque . back () < nums [ r ]) maxDeque . pop_back (); maxDeque . push_back ( nums [ r ]); while ( maxDeque . front () - minDeque . front () > limit ) { if ( minDeque . front () == nums [ l ]) minDeque . pop_front (); if ( maxDeque . front () == nums [ l ]) maxDeque . pop_front (); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"},{"location":"problems/1439/","text":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows Time: $O(|matrix| \\cdot k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Item { int i ; int j ; int sum ; // nums1[i] + nums2[j] }; class Solution { public : int kthSmallest ( vector < vector < int >>& mat , int k ) { vector < int > row = mat [ 0 ]; for ( int i = 1 ; i < mat . size (); ++ i ) row = kSmallestPairSums ( row , mat [ i ], k ); return row . back (); } private : // very similar to 373. Find K Pairs with Smallest Sums vector < int > kSmallestPairSums ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; auto compare = [ & ]( const Item & a , const Item & b ) { return a . sum > b . sum ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < nums1 . size (); ++ i ) pq . push ({ i , 0 , nums1 [ i ] + nums2 [ 0 ]}); while ( ! pq . empty () && ans . size () < k ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); ans . push_back ( nums1 [ i ] + nums2 [ j ]); if ( j + 1 < nums2 . size ()) pq . push ({ i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Item { public int i ; public int j ; public int sum ; // nums1[i] + nums2[j] public Item ( int i , int j , int sum ) { this . i = i ; this . j = j ; this . sum = sum ; } } class Solution { public int kthSmallest ( int [][] mat , int k ) { int [] row = mat [ 0 ] ; for ( int i = 1 ; i < mat . length ; ++ i ) row = kSmallestPairSums ( row , mat [ i ] , k ); return row [ k - 1 ] ; } // very similar to 373. Find K Pairs with Smallest Sums private int [] kSmallestPairSums ( int [] nums1 , int [] nums2 , int k ) { List < Integer > ans = new ArrayList <> (); PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . sum - b . sum ); for ( int i = 0 ; i < k && i < nums1 . length ; ++ i ) pq . offer ( new Item ( i , 0 , nums1 [ i ] + nums2 [ 0 ] )); while ( ! pq . isEmpty () && ans . size () < k ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; ans . add ( nums1 [ i ] + nums2 [ j ] ); if ( j + 1 < nums2 . length ) pq . offer ( new Item ( i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ] )); } return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows"},{"location":"problems/1439/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","text":"Time: $O(|matrix| \\cdot k\\log k)$ Space: $O(k)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct Item { int i ; int j ; int sum ; // nums1[i] + nums2[j] }; class Solution { public : int kthSmallest ( vector < vector < int >>& mat , int k ) { vector < int > row = mat [ 0 ]; for ( int i = 1 ; i < mat . size (); ++ i ) row = kSmallestPairSums ( row , mat [ i ], k ); return row . back (); } private : // very similar to 373. Find K Pairs with Smallest Sums vector < int > kSmallestPairSums ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; auto compare = [ & ]( const Item & a , const Item & b ) { return a . sum > b . sum ; }; priority_queue < Item , vector < Item > , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < k && i < nums1 . size (); ++ i ) pq . push ({ i , 0 , nums1 [ i ] + nums2 [ 0 ]}); while ( ! pq . empty () && ans . size () < k ) { const auto [ i , j , _ ] = pq . top (); pq . pop (); ans . push_back ( nums1 [ i ] + nums2 [ j ]); if ( j + 1 < nums2 . size ()) pq . push ({ i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ]}); } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Item { public int i ; public int j ; public int sum ; // nums1[i] + nums2[j] public Item ( int i , int j , int sum ) { this . i = i ; this . j = j ; this . sum = sum ; } } class Solution { public int kthSmallest ( int [][] mat , int k ) { int [] row = mat [ 0 ] ; for ( int i = 1 ; i < mat . length ; ++ i ) row = kSmallestPairSums ( row , mat [ i ] , k ); return row [ k - 1 ] ; } // very similar to 373. Find K Pairs with Smallest Sums private int [] kSmallestPairSums ( int [] nums1 , int [] nums2 , int k ) { List < Integer > ans = new ArrayList <> (); PriorityQueue < Item > pq = new PriorityQueue <> (( a , b ) -> a . sum - b . sum ); for ( int i = 0 ; i < k && i < nums1 . length ; ++ i ) pq . offer ( new Item ( i , 0 , nums1 [ i ] + nums2 [ 0 ] )); while ( ! pq . isEmpty () && ans . size () < k ) { final int i = pq . peek (). i ; final int j = pq . poll (). j ; ans . add ( nums1 [ i ] + nums2 [ j ] ); if ( j + 1 < nums2 . length ) pq . offer ( new Item ( i , j + 1 , nums1 [ i ] + nums2 [ j + 1 ] )); } return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows"},{"location":"problems/1440/","text":"1440. Evaluate Boolean Expression \ud83d\udd12","title":"1440. Evaluate Boolean Expression"},{"location":"problems/1440/#1440-evaluate-boolean-expression","text":"","title":"1440. Evaluate Boolean Expression \ud83d\udd12"},{"location":"problems/1441/","text":"1441. Build an Array With Stack Operations Time: Space:","title":"1441. Build an Array With Stack Operations"},{"location":"problems/1441/#1441-build-an-array-with-stack-operations","text":"Time: Space:","title":"1441. Build an Array With Stack Operations"},{"location":"problems/1442/","text":"1442. Count Triplets That Can Form Two Arrays of Equal XOR Time: Space:","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR"},{"location":"problems/1442/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor","text":"Time: Space:","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR"},{"location":"problems/1443/","text":"1443. Minimum Time to Collect All Apples in a Tree Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int minTime ( int n , vector < vector < int >>& edges , vector < bool >& hasApple ) { vector < vector < int >> graph ( n ); vector < bool > seen ( n ); for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < int ( int ) > dfs = [ & ]( int num ) { seen [ num ] = true ; int totalCost = 0 ; for ( int child : graph [ num ]) { if ( seen [ child ]) continue ; int cost = dfs ( child ); if ( cost > 0 || hasApple [ child ]) totalCost += cost + 2 ; } return totalCost ; }; return dfs ( 0 ); } };","title":"1443. Minimum Time to Collect All Apples in a Tree"},{"location":"problems/1443/#1443-minimum-time-to-collect-all-apples-in-a-tree","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int minTime ( int n , vector < vector < int >>& edges , vector < bool >& hasApple ) { vector < vector < int >> graph ( n ); vector < bool > seen ( n ); for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < int ( int ) > dfs = [ & ]( int num ) { seen [ num ] = true ; int totalCost = 0 ; for ( int child : graph [ num ]) { if ( seen [ child ]) continue ; int cost = dfs ( child ); if ( cost > 0 || hasApple [ child ]) totalCost += cost + 2 ; } return totalCost ; }; return dfs ( 0 ); } };","title":"1443. Minimum Time to Collect All Apples in a Tree"},{"location":"problems/1444/","text":"1444. Number of Ways of Cutting a Pizza Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : int ways ( vector < string >& pizza , int k ) { constexpr int kMod = 1e9 + 7 ; const int M = pizza . size (); const int N = pizza [ 0 ]. size (); vector < vector < vector < int >>> memo ( M , vector < vector < int >> ( N , vector < int > ( k , -1 ))); vector < vector < int >> prefixSum ( M + 1 , vector < int > ( N + 1 )); for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) prefixSum [ i + 1 ][ j + 1 ] = prefixSum [ i ][ j + 1 ] + prefixSum [ i + 1 ][ j ] + ( pizza [ i ][ j ] == 'A' ) - prefixSum [ i ][ j ]; // hasApple of pizza[row1:row2)[col1:col2) auto hasApple = [ & prefixSum ]( int row1 , int row2 , int col1 , int col2 ) { return ( prefixSum [ row2 ][ col2 ] - prefixSum [ row1 ][ col2 ] - prefixSum [ row2 ][ col1 ] + prefixSum [ row1 ][ col1 ]) > 0 ; }; // dp(m, n, k) := # of ways to cut pizza[m:M)[n:N) with k cuts function < int ( int , int , int ) > dp = [ & ]( int m , int n , int k ) -> int { if ( k == 0 ) return 1 ; int & ans = memo [ m ][ n ][ k ]; if ( ans >= 0 ) return ans ; ans = 0 ; for ( int i = m + 1 ; i < M ; ++ i ) // cut horizontally if ( hasApple ( m , i , n , N ) && hasApple ( i , M , n , N )) ans = ( ans + dp ( i , n , k - 1 )) % kMod ; for ( int j = n + 1 ; j < N ; ++ j ) // cut vertically if ( hasApple ( m , M , n , j ) && hasApple ( m , M , j , N )) ans = ( ans + dp ( m , j , k - 1 )) % kMod ; return ans ; }; return dp ( 0 , 0 , k - 1 ); } };","title":"1444. Number of Ways of Cutting a Pizza"},{"location":"problems/1444/#1444-number-of-ways-of-cutting-a-pizza","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : int ways ( vector < string >& pizza , int k ) { constexpr int kMod = 1e9 + 7 ; const int M = pizza . size (); const int N = pizza [ 0 ]. size (); vector < vector < vector < int >>> memo ( M , vector < vector < int >> ( N , vector < int > ( k , -1 ))); vector < vector < int >> prefixSum ( M + 1 , vector < int > ( N + 1 )); for ( int i = 0 ; i < M ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) prefixSum [ i + 1 ][ j + 1 ] = prefixSum [ i ][ j + 1 ] + prefixSum [ i + 1 ][ j ] + ( pizza [ i ][ j ] == 'A' ) - prefixSum [ i ][ j ]; // hasApple of pizza[row1:row2)[col1:col2) auto hasApple = [ & prefixSum ]( int row1 , int row2 , int col1 , int col2 ) { return ( prefixSum [ row2 ][ col2 ] - prefixSum [ row1 ][ col2 ] - prefixSum [ row2 ][ col1 ] + prefixSum [ row1 ][ col1 ]) > 0 ; }; // dp(m, n, k) := # of ways to cut pizza[m:M)[n:N) with k cuts function < int ( int , int , int ) > dp = [ & ]( int m , int n , int k ) -> int { if ( k == 0 ) return 1 ; int & ans = memo [ m ][ n ][ k ]; if ( ans >= 0 ) return ans ; ans = 0 ; for ( int i = m + 1 ; i < M ; ++ i ) // cut horizontally if ( hasApple ( m , i , n , N ) && hasApple ( i , M , n , N )) ans = ( ans + dp ( i , n , k - 1 )) % kMod ; for ( int j = n + 1 ; j < N ; ++ j ) // cut vertically if ( hasApple ( m , M , n , j ) && hasApple ( m , M , j , N )) ans = ( ans + dp ( m , j , k - 1 )) % kMod ; return ans ; }; return dp ( 0 , 0 , k - 1 ); } };","title":"1444. Number of Ways of Cutting a Pizza"},{"location":"problems/1445/","text":"1445. Apples & Oranges \ud83d\udd12","title":"1445. Apples & Oranges"},{"location":"problems/1445/#1445-apples-oranges","text":"","title":"1445. Apples &amp; Oranges \ud83d\udd12"},{"location":"problems/1446/","text":"1446. Consecutive Characters","title":"1446. Consecutive Characters"},{"location":"problems/1446/#1446-consecutive-characters","text":"","title":"1446. Consecutive Characters"},{"location":"problems/1447/","text":"1447. Simplified Fractions","title":"1447. Simplified Fractions"},{"location":"problems/1447/#1447-simplified-fractions","text":"","title":"1447. Simplified Fractions"},{"location":"problems/1448/","text":"1448. Count Good Nodes in Binary Tree","title":"1448. Count Good Nodes in Binary Tree"},{"location":"problems/1448/#1448-count-good-nodes-in-binary-tree","text":"","title":"1448. Count Good Nodes in Binary Tree"},{"location":"problems/1449/","text":"1449. Form Largest Integer With Digits That Add up to Target Time: $O(target)$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string largestNumber ( vector < int >& cost , int target ) { // dp[i] := max length that cost i can achieve vector < int > dp ( target + 1 , INT_MIN ); dp [ 0 ] = 0 ; // when cost = 0, the best is empty string \"\" for ( int i = 1 ; i <= target ; ++ i ) for ( int d = 0 ; d < 9 ; ++ d ) if ( i >= cost [ d ]) dp [ i ] = max ( dp [ i ], dp [ i - cost [ d ]] + 1 ); if ( dp [ target ] < 0 ) return \"0\" ; string ans ; // greedily build the ans string for ( int d = 8 ; d >= 0 ; -- d ) while ( target >= cost [ d ] && dp [ target ] == dp [ target - cost [ d ]] + 1 ) { target -= cost [ d ]; ans += '1' + d ; } return ans ; } };","title":"1449. Form Largest Integer With Digits That Add up to Target"},{"location":"problems/1449/#1449-form-largest-integer-with-digits-that-add-up-to-target","text":"Time: $O(target)$ Space: $O(target)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : string largestNumber ( vector < int >& cost , int target ) { // dp[i] := max length that cost i can achieve vector < int > dp ( target + 1 , INT_MIN ); dp [ 0 ] = 0 ; // when cost = 0, the best is empty string \"\" for ( int i = 1 ; i <= target ; ++ i ) for ( int d = 0 ; d < 9 ; ++ d ) if ( i >= cost [ d ]) dp [ i ] = max ( dp [ i ], dp [ i - cost [ d ]] + 1 ); if ( dp [ target ] < 0 ) return \"0\" ; string ans ; // greedily build the ans string for ( int d = 8 ; d >= 0 ; -- d ) while ( target >= cost [ d ] && dp [ target ] == dp [ target - cost [ d ]] + 1 ) { target -= cost [ d ]; ans += '1' + d ; } return ans ; } };","title":"1449. Form Largest Integer With Digits That Add up to Target"},{"location":"problems/1450/","text":"1450. Number of Students Doing Homework at a Given Time Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int busyStudent ( vector < int >& startTime , vector < int >& endTime , int queryTime ) { const int n = startTime . size (); int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( startTime [ i ] <= queryTime && queryTime <= endTime [ i ]) ++ ans ; return ans ; } };","title":"1450. Number of Students Doing Homework at a Given Time"},{"location":"problems/1450/#1450-number-of-students-doing-homework-at-a-given-time","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int busyStudent ( vector < int >& startTime , vector < int >& endTime , int queryTime ) { const int n = startTime . size (); int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( startTime [ i ] <= queryTime && queryTime <= endTime [ i ]) ++ ans ; return ans ; } };","title":"1450. Number of Students Doing Homework at a Given Time"},{"location":"problems/1451/","text":"1451. Rearrange Words in a Sentence Time: Space:","title":"1451. Rearrange Words in a Sentence"},{"location":"problems/1451/#1451-rearrange-words-in-a-sentence","text":"Time: Space:","title":"1451. Rearrange Words in a Sentence"},{"location":"problems/1452/","text":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List Time: Space:","title":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List"},{"location":"problems/1452/#1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list","text":"Time: Space:","title":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List"},{"location":"problems/1453/","text":"1453. Maximum Number of Darts Inside of a Circular Dartboard","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard"},{"location":"problems/1453/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard","text":"","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard"},{"location":"problems/1454/","text":"1454. Active Users \ud83d\udd12","title":"1454. Active Users"},{"location":"problems/1454/#1454-active-users","text":"","title":"1454. Active Users \ud83d\udd12"},{"location":"problems/1455/","text":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence Time: Space:","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"},{"location":"problems/1455/#1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence","text":"Time: Space:","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"},{"location":"problems/1456/","text":"1456. Maximum Number of Vowels in a Substring of Given Length Time: Space:","title":"1456. Maximum Number of Vowels in a Substring of Given Length"},{"location":"problems/1456/#1456-maximum-number-of-vowels-in-a-substring-of-given-length","text":"Time: Space:","title":"1456. Maximum Number of Vowels in a Substring of Given Length"},{"location":"problems/1457/","text":"1457. Pseudo-Palindromic Paths in a Binary Tree Time: Space:","title":"1457. Pseudo-Palindromic Paths in a Binary Tree"},{"location":"problems/1457/#1457-pseudo-palindromic-paths-in-a-binary-tree","text":"Time: Space:","title":"1457. Pseudo-Palindromic Paths in a Binary Tree"},{"location":"problems/1458/","text":"1458. Max Dot Product of Two Subsequences Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxDotProduct ( vector < int >& nums1 , vector < int >& nums2 ) { const int m = nums1 . size (); const int n = nums2 . size (); // dp[i][j] := max dot product of two subsequences nums[0..i) and nums2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MIN )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = max ({ dp [ i - 1 ][ j ], dp [ i ][ j - 1 ], max ( 0 , dp [ i - 1 ][ j - 1 ]) + nums1 [ i - 1 ] * nums2 [ j - 1 ] }); return dp [ m ][ n ]; } };","title":"1458. Max Dot Product of Two Subsequences"},{"location":"problems/1458/#1458-max-dot-product-of-two-subsequences","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxDotProduct ( vector < int >& nums1 , vector < int >& nums2 ) { const int m = nums1 . size (); const int n = nums2 . size (); // dp[i][j] := max dot product of two subsequences nums[0..i) and nums2[0..j) vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MIN )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = max ({ dp [ i - 1 ][ j ], dp [ i ][ j - 1 ], max ( 0 , dp [ i - 1 ][ j - 1 ]) + nums1 [ i - 1 ] * nums2 [ j - 1 ] }); return dp [ m ][ n ]; } };","title":"1458. Max Dot Product of Two Subsequences"},{"location":"problems/1459/","text":"1459. Rectangles Area","title":"1459. Rectangles Area"},{"location":"problems/1459/#1459-rectangles-area","text":"","title":"1459. Rectangles Area"},{"location":"problems/1460/","text":"1460. Make Two Arrays Equal by Reversing Sub-arrays","title":"1460. Make Two Arrays Equal by Reversing Sub-arrays"},{"location":"problems/1460/#1460-make-two-arrays-equal-by-reversing-sub-arrays","text":"","title":"1460. Make Two Arrays Equal by Reversing Sub-arrays"},{"location":"problems/1461/","text":"1461. Check If a String Contains All Binary Codes of Size K","title":"1461. Check If a String Contains All Binary Codes of Size K"},{"location":"problems/1461/#1461-check-if-a-string-contains-all-binary-codes-of-size-k","text":"","title":"1461. Check If a String Contains All Binary Codes of Size K"},{"location":"problems/1462/","text":"1462. Course Schedule IV","title":"1462. Course Schedule IV"},{"location":"problems/1462/#1462-course-schedule-iv","text":"","title":"1462. Course Schedule IV"},{"location":"problems/1463/","text":"1463. Cherry Pickup II Approach 1: Bottom-up Time: $O(mn^2)$ Space: $O(mn^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); // dp[x][y1][y2] := max cherries we can collect with // robot #1 on (x - 1, y1 - 1) and robot #2 on (x - 1, y2 - 1) first vector < vector < vector < int >>> dp ( m + 2 , vector < vector < int >> ( n + 2 , vector < int > ( n + 2 ))); for ( int x = m ; x >= 1 ; -- x ) for ( int y1 = 1 ; y1 <= n ; ++ y1 ) for ( int y2 = 1 ; y2 <= n ; ++ y2 ) { const int currRow = grid [ x - 1 ][ y1 - 1 ] + ( y1 != y2 ) * grid [ x - 1 ][ y2 - 1 ]; int & ans = dp [ x ][ y1 ][ y2 ]; for ( int d1 = -1 ; d1 <= 1 ; ++ d1 ) for ( int d2 = -1 ; d2 <= 1 ; ++ d2 ) ans = max ( ans , currRow + dp [ x + 1 ][ y1 + d1 ][ y2 + d2 ]); } return dp [ 1 ][ 1 ][ n ]; } }; Approach 2: Top-down Time: $O(mn^2)$ Space: $O(mn^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < vector < int >>> memo ( m , vector < vector < int >> ( n , vector < int > ( n , -1 ))); // dp(x, y1, y2) := max cherries we can collect with // robot #1 on (x, y1) and robot #2 on (x, y2) first function < int ( int , int , int ) > dp = [ & ]( int x , int y1 , int y2 ) { if ( x == m ) return 0 ; if ( y1 < 0 || y1 == n || y2 < 0 || y2 == n ) return 0 ; int & ans = memo [ x ][ y1 ][ y2 ]; if ( ans != -1 ) return ans ; const int currRow = grid [ x ][ y1 ] + ( y1 != y2 ) * grid [ x ][ y2 ]; for ( int d1 = -1 ; d1 <= 1 ; ++ d1 ) for ( int d2 = -1 ; d2 <= 1 ; ++ d2 ) ans = max ( ans , currRow + dp ( x + 1 , y1 + d1 , y2 + d2 )); return ans ; }; return dp ( 0 , 0 , n - 1 ); } };","title":"1463. Cherry Pickup II"},{"location":"problems/1463/#1463-cherry-pickup-ii","text":"","title":"1463. Cherry Pickup II"},{"location":"problems/1463/#approach-1-bottom-up","text":"Time: $O(mn^2)$ Space: $O(mn^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); // dp[x][y1][y2] := max cherries we can collect with // robot #1 on (x - 1, y1 - 1) and robot #2 on (x - 1, y2 - 1) first vector < vector < vector < int >>> dp ( m + 2 , vector < vector < int >> ( n + 2 , vector < int > ( n + 2 ))); for ( int x = m ; x >= 1 ; -- x ) for ( int y1 = 1 ; y1 <= n ; ++ y1 ) for ( int y2 = 1 ; y2 <= n ; ++ y2 ) { const int currRow = grid [ x - 1 ][ y1 - 1 ] + ( y1 != y2 ) * grid [ x - 1 ][ y2 - 1 ]; int & ans = dp [ x ][ y1 ][ y2 ]; for ( int d1 = -1 ; d1 <= 1 ; ++ d1 ) for ( int d2 = -1 ; d2 <= 1 ; ++ d2 ) ans = max ( ans , currRow + dp [ x + 1 ][ y1 + d1 ][ y2 + d2 ]); } return dp [ 1 ][ 1 ][ n ]; } };","title":"Approach 1: Bottom-up"},{"location":"problems/1463/#approach-2-top-down","text":"Time: $O(mn^2)$ Space: $O(mn^2)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int cherryPickup ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < vector < int >>> memo ( m , vector < vector < int >> ( n , vector < int > ( n , -1 ))); // dp(x, y1, y2) := max cherries we can collect with // robot #1 on (x, y1) and robot #2 on (x, y2) first function < int ( int , int , int ) > dp = [ & ]( int x , int y1 , int y2 ) { if ( x == m ) return 0 ; if ( y1 < 0 || y1 == n || y2 < 0 || y2 == n ) return 0 ; int & ans = memo [ x ][ y1 ][ y2 ]; if ( ans != -1 ) return ans ; const int currRow = grid [ x ][ y1 ] + ( y1 != y2 ) * grid [ x ][ y2 ]; for ( int d1 = -1 ; d1 <= 1 ; ++ d1 ) for ( int d2 = -1 ; d2 <= 1 ; ++ d2 ) ans = max ( ans , currRow + dp ( x + 1 , y1 + d1 , y2 + d2 )); return ans ; }; return dp ( 0 , 0 , n - 1 ); } };","title":"Approach 2: Top-down"},{"location":"problems/1464/","text":"1464. Maximum Product of Two Elements in an Array","title":"1464. Maximum Product of Two Elements in an Array"},{"location":"problems/1464/#1464-maximum-product-of-two-elements-in-an-array","text":"","title":"1464. Maximum Product of Two Elements in an Array"},{"location":"problems/1465/","text":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts","title":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"},{"location":"problems/1465/#1465-maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts","text":"","title":"1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"},{"location":"problems/1466/","text":"1466. Reorder Routes to Make All Paths Lead to the City Zero","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero"},{"location":"problems/1466/#1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero","text":"","title":"1466. Reorder Routes to Make All Paths Lead to the City Zero"},{"location":"problems/1467/","text":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls"},{"location":"problems/1467/#1467-probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","text":"","title":"1467. Probability of a Two Boxes Having The Same Number of Distinct Balls"},{"location":"problems/1468/","text":"1468. Calculate Salaries","title":"1468. Calculate Salaries"},{"location":"problems/1468/#1468-calculate-salaries","text":"","title":"1468. Calculate Salaries"},{"location":"problems/1469/","text":"1469. Find All The Lonely Nodes","title":"1469. Find All The Lonely Nodes"},{"location":"problems/1469/#1469-find-all-the-lonely-nodes","text":"","title":"1469. Find All The Lonely Nodes"},{"location":"problems/1470/","text":"1470. Shuffle the Array","title":"1470. Shuffle the Array"},{"location":"problems/1470/#1470-shuffle-the-array","text":"","title":"1470. Shuffle the Array"},{"location":"problems/1471/","text":"1471. The k Strongest Values in an Array","title":"1471. The k Strongest Values in an Array"},{"location":"problems/1471/#1471-the-k-strongest-values-in-an-array","text":"","title":"1471. The k Strongest Values in an Array"},{"location":"problems/1472/","text":"1472. Design Browser History","title":"1472. Design Browser History"},{"location":"problems/1472/#1472-design-browser-history","text":"","title":"1472. Design Browser History"},{"location":"problems/1473/","text":"1473. Paint House III Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int minCost ( vector < int >& houses , vector < vector < int >>& cost , int m , int n , int target ) { constexpr int kMax = 1000001 ; vector < vector < vector < int >>> memo ( target + 1 , vector < vector < int >> ( m , vector < int > ( n + 1 ))); // dp(k, i, c) := min cost to paint houses[i..m) to k neighborhoods // with houses[i - 1]'s color = prevColor function < int ( int , int , int ) > dp = [ & ]( int k , int i , int prevColor ) -> int { if ( i == m || k < 0 ) return k == 0 ? 0 : kMax ; int & ans = memo [ k ][ i ][ prevColor ]; if ( ans > 0 ) return ans ; if ( houses [ i ] != 0 ) // painted last year return dp ( k - ( prevColor != houses [ i ]), i + 1 , houses [ i ]); ans = kMax ; // try to paint houses[i] with each color in 1..n for ( int color = 1 ; color <= n ; ++ color ) ans = min ( ans , cost [ i ][ color - 1 ] + dp ( k - ( prevColor != color ), i + 1 , color )); return ans ; }; // init: prevColor = 0 (virtual neighbor) const int minCost = dp ( target , 0 , 0 ); return minCost == kMax ? -1 : minCost ; } };","title":"1473. Paint House III"},{"location":"problems/1473/#1473-paint-house-iii","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int minCost ( vector < int >& houses , vector < vector < int >>& cost , int m , int n , int target ) { constexpr int kMax = 1000001 ; vector < vector < vector < int >>> memo ( target + 1 , vector < vector < int >> ( m , vector < int > ( n + 1 ))); // dp(k, i, c) := min cost to paint houses[i..m) to k neighborhoods // with houses[i - 1]'s color = prevColor function < int ( int , int , int ) > dp = [ & ]( int k , int i , int prevColor ) -> int { if ( i == m || k < 0 ) return k == 0 ? 0 : kMax ; int & ans = memo [ k ][ i ][ prevColor ]; if ( ans > 0 ) return ans ; if ( houses [ i ] != 0 ) // painted last year return dp ( k - ( prevColor != houses [ i ]), i + 1 , houses [ i ]); ans = kMax ; // try to paint houses[i] with each color in 1..n for ( int color = 1 ; color <= n ; ++ color ) ans = min ( ans , cost [ i ][ color - 1 ] + dp ( k - ( prevColor != color ), i + 1 , color )); return ans ; }; // init: prevColor = 0 (virtual neighbor) const int minCost = dp ( target , 0 , 0 ); return minCost == kMax ? -1 : minCost ; } };","title":"1473. Paint House III"},{"location":"problems/1474/","text":"1474. Delete N Nodes After M Nodes of a Linked List","title":"1474. Delete N Nodes After M Nodes of a Linked List"},{"location":"problems/1474/#1474-delete-n-nodes-after-m-nodes-of-a-linked-list","text":"","title":"1474. Delete N Nodes After M Nodes of a Linked List"},{"location":"problems/1475/","text":"1475. Final Prices With a Special Discount in a Shop","title":"1475. Final Prices With a Special Discount in a Shop"},{"location":"problems/1475/#1475-final-prices-with-a-special-discount-in-a-shop","text":"","title":"1475. Final Prices With a Special Discount in a Shop"},{"location":"problems/1476/","text":"1476. Subrectangle Queries","title":"1476. Subrectangle Queries"},{"location":"problems/1476/#1476-subrectangle-queries","text":"","title":"1476. Subrectangle Queries"},{"location":"problems/1477/","text":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum"},{"location":"problems/1477/#1477-find-two-non-overlapping-sub-arrays-each-with-target-sum","text":"","title":"1477. Find Two Non-overlapping Sub-arrays Each With Target Sum"},{"location":"problems/1478/","text":"1478. Allocate Mailboxes","title":"1478. Allocate Mailboxes"},{"location":"problems/1478/#1478-allocate-mailboxes","text":"","title":"1478. Allocate Mailboxes"},{"location":"problems/1479/","text":"1479. Sales by Day of the Week","title":"1479. Sales by Day of the Week"},{"location":"problems/1479/#1479-sales-by-day-of-the-week","text":"","title":"1479. Sales by Day of the Week"},{"location":"problems/1480/","text":"1480. Running Sum of 1d Array","title":"1480. Running Sum of 1d Array"},{"location":"problems/1480/#1480-running-sum-of-1d-array","text":"","title":"1480. Running Sum of 1d Array"},{"location":"problems/1481/","text":"1481. Least Number of Unique Integers after K Removals","title":"1481. Least Number of Unique Integers after K Removals"},{"location":"problems/1481/#1481-least-number-of-unique-integers-after-k-removals","text":"","title":"1481. Least Number of Unique Integers after K Removals"},{"location":"problems/1482/","text":"1482. Minimum Number of Days to Make m Bouquets","title":"1482. Minimum Number of Days to Make m Bouquets"},{"location":"problems/1482/#1482-minimum-number-of-days-to-make-m-bouquets","text":"","title":"1482. Minimum Number of Days to Make m Bouquets"},{"location":"problems/1483/","text":"1483. Kth Ancestor of a Tree Node Time: $O(n\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class TreeAncestor { public : TreeAncestor ( int n , vector < int >& parent ) : maxLevel ( 32 - __builtin_clz ( n )), dp ( n , vector < int > ( maxLevel )) { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < maxLevel ; ++ j ) if ( j == 0 ) // node i's 2^0 ancestor is its direct parent dp [ i ][ j ] = parent [ i ]; else if ( dp [ i ][ j - 1 ] == -1 ) // no such ancestor dp [ i ][ j ] = -1 ; else // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1}) dp [ i ][ j ] = dp [ dp [ i ][ j - 1 ]][ j - 1 ]; } int getKthAncestor ( int node , int k ) { for ( int j = 0 ; j < maxLevel && node != -1 ; ++ j ) if ( k & ( 1 << j )) node = dp [ node ][ j ]; return node ; } private : const int maxLevel ; vector < vector < int >> dp ; // dp[i][j] := node i's 2^j-th ancestor };","title":"1483. Kth Ancestor of a Tree Node"},{"location":"problems/1483/#1483-kth-ancestor-of-a-tree-node","text":"Time: $O(n\\log n)$ Space: $O(n\\log n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class TreeAncestor { public : TreeAncestor ( int n , vector < int >& parent ) : maxLevel ( 32 - __builtin_clz ( n )), dp ( n , vector < int > ( maxLevel )) { for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < maxLevel ; ++ j ) if ( j == 0 ) // node i's 2^0 ancestor is its direct parent dp [ i ][ j ] = parent [ i ]; else if ( dp [ i ][ j - 1 ] == -1 ) // no such ancestor dp [ i ][ j ] = -1 ; else // A(i, 2^j) = A(A(i, 2^{j - 1}), 2^{j - 1}) dp [ i ][ j ] = dp [ dp [ i ][ j - 1 ]][ j - 1 ]; } int getKthAncestor ( int node , int k ) { for ( int j = 0 ; j < maxLevel && node != -1 ; ++ j ) if ( k & ( 1 << j )) node = dp [ node ][ j ]; return node ; } private : const int maxLevel ; vector < vector < int >> dp ; // dp[i][j] := node i's 2^j-th ancestor };","title":"1483. Kth Ancestor of a Tree Node"},{"location":"problems/1484/","text":"1484. Group Sold Products By The Date","title":"1484. Group Sold Products By The Date"},{"location":"problems/1484/#1484-group-sold-products-by-the-date","text":"","title":"1484. Group Sold Products By The Date"},{"location":"problems/1485/","text":"1485. Clone Binary Tree With Random Pointer Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : NodeCopy * copyRandomBinaryTree ( Node * root ) { if ( ! root ) return nullptr ; if ( map . count ( root )) return map [ root ]; NodeCopy * newNode = new NodeCopy ( root -> val ); map [ root ] = newNode ; newNode -> left = copyRandomBinaryTree ( root -> left ); newNode -> right = copyRandomBinaryTree ( root -> right ); newNode -> random = copyRandomBinaryTree ( root -> random ); return newNode ; } private : unordered_map < Node * , NodeCopy *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public NodeCopy copyRandomBinaryTree ( Node root ) { if ( root == null ) return null ; if ( map . containsKey ( root )) return map . get ( root ); NodeCopy newNode = new NodeCopy ( root . val ); map . put ( root , newNode ); newNode . left = copyRandomBinaryTree ( root . left ); newNode . right = copyRandomBinaryTree ( root . right ); newNode . random = copyRandomBinaryTree ( root . random ); return newNode ; } private Map < Node , NodeCopy > map = new HashMap <> (); }","title":"1485. Clone Binary Tree With Random Pointer"},{"location":"problems/1485/#1485-clone-binary-tree-with-random-pointer","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : NodeCopy * copyRandomBinaryTree ( Node * root ) { if ( ! root ) return nullptr ; if ( map . count ( root )) return map [ root ]; NodeCopy * newNode = new NodeCopy ( root -> val ); map [ root ] = newNode ; newNode -> left = copyRandomBinaryTree ( root -> left ); newNode -> right = copyRandomBinaryTree ( root -> right ); newNode -> random = copyRandomBinaryTree ( root -> random ); return newNode ; } private : unordered_map < Node * , NodeCopy *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public NodeCopy copyRandomBinaryTree ( Node root ) { if ( root == null ) return null ; if ( map . containsKey ( root )) return map . get ( root ); NodeCopy newNode = new NodeCopy ( root . val ); map . put ( root , newNode ); newNode . left = copyRandomBinaryTree ( root . left ); newNode . right = copyRandomBinaryTree ( root . right ); newNode . random = copyRandomBinaryTree ( root . random ); return newNode ; } private Map < Node , NodeCopy > map = new HashMap <> (); }","title":"1485. Clone Binary Tree With Random Pointer"},{"location":"problems/1486/","text":"1486. XOR Operation in an Array","title":"1486. XOR Operation in an Array"},{"location":"problems/1486/#1486-xor-operation-in-an-array","text":"","title":"1486. XOR Operation in an Array"},{"location":"problems/1487/","text":"1487. Making File Names Unique","title":"1487. Making File Names Unique"},{"location":"problems/1487/#1487-making-file-names-unique","text":"","title":"1487. Making File Names Unique"},{"location":"problems/1488/","text":"1488. Avoid Flood in The City","title":"1488. Avoid Flood in The City"},{"location":"problems/1488/#1488-avoid-flood-in-the-city","text":"","title":"1488. Avoid Flood in The City"},{"location":"problems/1489/","text":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree"},{"location":"problems/1489/#1489-find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree","text":"","title":"1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree"},{"location":"problems/1490/","text":"1490. Clone N-ary Tree Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * cloneTree ( Node * root ) { if ( ! root ) return nullptr ; if ( map . count ( root )) return map [ root ]; Node * newNode = new Node ( root -> val ); map [ root ] = newNode ; for ( Node * child : root -> children ) newNode -> children . push_back ( cloneTree ( child )); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node cloneTree ( Node root ) { if ( root == null ) return null ; if ( map . containsKey ( root )) return map . get ( root ); Node newNode = new Node ( root . val ); map . put ( root , newNode ); for ( Node child : root . children ) newNode . children . add ( cloneTree ( child )); return newNode ; } private Map < Node , Node > map = new HashMap <> (); }","title":"1490. Clone N-ary Tree"},{"location":"problems/1490/#1490-clone-n-ary-tree","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * cloneTree ( Node * root ) { if ( ! root ) return nullptr ; if ( map . count ( root )) return map [ root ]; Node * newNode = new Node ( root -> val ); map [ root ] = newNode ; for ( Node * child : root -> children ) newNode -> children . push_back ( cloneTree ( child )); return newNode ; } private : unordered_map < Node * , Node *> map ; }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public Node cloneTree ( Node root ) { if ( root == null ) return null ; if ( map . containsKey ( root )) return map . get ( root ); Node newNode = new Node ( root . val ); map . put ( root , newNode ); for ( Node child : root . children ) newNode . children . add ( cloneTree ( child )); return newNode ; } private Map < Node , Node > map = new HashMap <> (); }","title":"1490. Clone N-ary Tree"},{"location":"problems/1491/","text":"1491. Average Salary Excluding the Minimum and Maximum Salary","title":"1491. Average Salary Excluding the Minimum and Maximum Salary"},{"location":"problems/1491/#1491-average-salary-excluding-the-minimum-and-maximum-salary","text":"","title":"1491. Average Salary Excluding the Minimum and Maximum Salary"},{"location":"problems/1492/","text":"1492. The kth Factor of n","title":"1492. The kth Factor of n"},{"location":"problems/1492/#1492-the-kth-factor-of-n","text":"","title":"1492. The kth Factor of n"},{"location":"problems/1493/","text":"1493. Longest Subarray of 1's After Deleting One Element","title":"1493. Longest Subarray of 1's After Deleting One Element"},{"location":"problems/1493/#1493-longest-subarray-of-1s-after-deleting-one-element","text":"","title":"1493. Longest Subarray of 1's After Deleting One Element"},{"location":"problems/1494/","text":"1494. Parallel Courses II","title":"1494. Parallel Courses II"},{"location":"problems/1494/#1494-parallel-courses-ii","text":"","title":"1494. Parallel Courses II"},{"location":"problems/1495/","text":"1495. Friendly Movies Streamed Last Month","title":"1495. Friendly Movies Streamed Last Month"},{"location":"problems/1495/#1495-friendly-movies-streamed-last-month","text":"","title":"1495. Friendly Movies Streamed Last Month"},{"location":"problems/1496/","text":"1496. Path Crossing Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : bool isPathCrossing ( string path ) { set < int > seen ; seen . insert ( 0 ); int x = 0 ; int y = 0 ; for ( const char c : path ) { switch ( c ) { case 'N' : ++ y ; break ; case 'S' : -- y ; break ; case 'E' : ++ x ; break ; case 'W' : -- x ; break ; } const int key = x * 20001 + y ; if ( seen . count ( key )) return true ; seen . insert ( key ); } return false ; } };","title":"1496. Path Crossing"},{"location":"problems/1496/#1496-path-crossing","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : bool isPathCrossing ( string path ) { set < int > seen ; seen . insert ( 0 ); int x = 0 ; int y = 0 ; for ( const char c : path ) { switch ( c ) { case 'N' : ++ y ; break ; case 'S' : -- y ; break ; case 'E' : ++ x ; break ; case 'W' : -- x ; break ; } const int key = x * 20001 + y ; if ( seen . count ( key )) return true ; seen . insert ( key ); } return false ; } };","title":"1496. Path Crossing"},{"location":"problems/1497/","text":"1497. Check If Array Pairs Are Divisible by k Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canArrange ( vector < int >& arr , int k ) { vector < int > bucket ( k ); for ( const int a : arr ) { int i = a % k ; if ( i < 0 ) i += k ; ++ bucket [ i ]; } for ( int i = 0 ; i < k ; ++ i ) { if ( i == 0 ) { if ( bucket [ i ] % 2 != 0 ) return false ; } else if (( bucket [ i ] + bucket [ k - i ]) % 2 != 0 ) return false ; } return true ; } };","title":"1497. Check If Array Pairs Are Divisible by k"},{"location":"problems/1497/#1497-check-if-array-pairs-are-divisible-by-k","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canArrange ( vector < int >& arr , int k ) { vector < int > bucket ( k ); for ( const int a : arr ) { int i = a % k ; if ( i < 0 ) i += k ; ++ bucket [ i ]; } for ( int i = 0 ; i < k ; ++ i ) { if ( i == 0 ) { if ( bucket [ i ] % 2 != 0 ) return false ; } else if (( bucket [ i ] + bucket [ k - i ]) % 2 != 0 ) return false ; } return true ; } };","title":"1497. Check If Array Pairs Are Divisible by k"},{"location":"problems/1498/","text":"1498. Number of Subsequences That Satisfy the Given Sum Condition Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numSubseq ( vector < int >& nums , int target ) { constexpr int kMod = 1e9 + 7 ; const int n = nums . size (); int ans = 0 ; vector < int > pows ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = pows [ i - 1 ] * 2 % kMod ; sort ( begin ( nums ), end ( nums )); for ( int l = 0 , r = n - 1 ; l <= r ;) if ( nums [ l ] + nums [ r ] <= target ) { ans = ( ans + pows [ r - l ]) % kMod ; ++ l ; } else { -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numSubseq ( int [] nums , int target ) { final int kMod = ( int ) 1e9 + 7 ; final int n = nums . length ; int ans = 0 ; int [] pows = new int [ n ] ; pows [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = pows [ i - 1 ] * 2 % kMod ; Arrays . sort ( nums ); for ( int l = 0 , r = n - 1 ; l <= r ;) if ( nums [ l ] + nums [ r ] <= target ) { ans = ( ans + pows [ r - l ] ) % kMod ; ++ l ; } else { -- r ; } return ans ; } }","title":"1498. Number of Subsequences That Satisfy the Given Sum Condition"},{"location":"problems/1498/#1498-number-of-subsequences-that-satisfy-the-given-sum-condition","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int numSubseq ( vector < int >& nums , int target ) { constexpr int kMod = 1e9 + 7 ; const int n = nums . size (); int ans = 0 ; vector < int > pows ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = pows [ i - 1 ] * 2 % kMod ; sort ( begin ( nums ), end ( nums )); for ( int l = 0 , r = n - 1 ; l <= r ;) if ( nums [ l ] + nums [ r ] <= target ) { ans = ( ans + pows [ r - l ]) % kMod ; ++ l ; } else { -- r ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int numSubseq ( int [] nums , int target ) { final int kMod = ( int ) 1e9 + 7 ; final int n = nums . length ; int ans = 0 ; int [] pows = new int [ n ] ; pows [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pows [ i ] = pows [ i - 1 ] * 2 % kMod ; Arrays . sort ( nums ); for ( int l = 0 , r = n - 1 ; l <= r ;) if ( nums [ l ] + nums [ r ] <= target ) { ans = ( ans + pows [ r - l ] ) % kMod ; ++ l ; } else { -- r ; } return ans ; } }","title":"1498. Number of Subsequences That Satisfy the Given Sum Condition"},{"location":"problems/1499/","text":"1499. Max Value of Equation Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int findMaxValueOfEquation ( vector < vector < int >>& points , int k ) { int ans = INT_MIN ; deque < pair < int , int >> q ; // {y - x, x} for ( const vector < int >& point : points ) { const int x = point [ 0 ]; const int y = point [ 1 ]; // remove invalid points (xj - xi > k) while ( ! q . empty () && x - q . front (). second > k ) q . pop_front (); if ( ! q . empty ()) ans = max ( ans , x + y + q . front (). first ); while ( ! q . empty () && y - x >= q . back (). first ) q . pop_back (); q . push_back ({ y - x , x }); } return ans ; } };","title":"1499. Max Value of Equation"},{"location":"problems/1499/#1499-max-value-of-equation","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int findMaxValueOfEquation ( vector < vector < int >>& points , int k ) { int ans = INT_MIN ; deque < pair < int , int >> q ; // {y - x, x} for ( const vector < int >& point : points ) { const int x = point [ 0 ]; const int y = point [ 1 ]; // remove invalid points (xj - xi > k) while ( ! q . empty () && x - q . front (). second > k ) q . pop_front (); if ( ! q . empty ()) ans = max ( ans , x + y + q . front (). first ); while ( ! q . empty () && y - x >= q . back (). first ) q . pop_back (); q . push_back ({ y - x , x }); } return ans ; } };","title":"1499. Max Value of Equation"},{"location":"problems/1500/","text":"1500. Design a File Sharing System","title":"1500. Design a File Sharing System"},{"location":"problems/1500/#1500-design-a-file-sharing-system","text":"","title":"1500. Design a File Sharing System"},{"location":"problems/1501/","text":"1501. Countries You Can Safely Invest In \ud83d\udd12","title":"1501. Countries You Can Safely Invest In"},{"location":"problems/1501/#1501-countries-you-can-safely-invest-in","text":"","title":"1501. Countries You Can Safely Invest In \ud83d\udd12"},{"location":"problems/1502/","text":"1502. Can Make Arithmetic Progression From Sequence Approach 1: $O(n)$ space Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canMakeArithmeticProgression ( vector < int >& arr ) { const int n = arr . size (); const int max = * max_element ( begin ( arr ), end ( arr )); const int min = * min_element ( begin ( arr ), end ( arr )); const int range = max - min ; if ( range % ( n - 1 ) != 0 ) return false ; const int diff = range / ( n - 1 ); if ( diff == 0 ) return true ; unordered_set < int > seen ; for ( const int a : arr ) { if (( a - min ) % diff != 0 ) return false ; if ( ! seen . insert ( a ). second ) return false ; } return true ; } }; Approach 2: $O(1)$ space Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool canMakeArithmeticProgression ( vector < int >& arr ) { const int n = arr . size (); const int max = * max_element ( begin ( arr ), end ( arr )); const int min = * min_element ( begin ( arr ), end ( arr )); const int range = max - min ; if ( range % ( n - 1 ) != 0 ) return false ; const int diff = range / ( n - 1 ); if ( diff == 0 ) return true ; for ( int i = 0 ; i < n ;) { const int gap = arr [ i ] - min ; if ( gap % diff != 0 ) return false ; if ( gap == i * diff ) { ++ i ; } else { const int rightIndex = gap / diff ; swap ( arr [ i ], arr [ rightIndex ]); } } return true ; } };","title":"1502. Can Make Arithmetic Progression From Sequence"},{"location":"problems/1502/#1502-can-make-arithmetic-progression-from-sequence","text":"","title":"1502. Can Make Arithmetic Progression From Sequence"},{"location":"problems/1502/#approach-1-on-space","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool canMakeArithmeticProgression ( vector < int >& arr ) { const int n = arr . size (); const int max = * max_element ( begin ( arr ), end ( arr )); const int min = * min_element ( begin ( arr ), end ( arr )); const int range = max - min ; if ( range % ( n - 1 ) != 0 ) return false ; const int diff = range / ( n - 1 ); if ( diff == 0 ) return true ; unordered_set < int > seen ; for ( const int a : arr ) { if (( a - min ) % diff != 0 ) return false ; if ( ! seen . insert ( a ). second ) return false ; } return true ; } };","title":"Approach 1: $O(n)$ space"},{"location":"problems/1502/#approach-2-o1-space","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool canMakeArithmeticProgression ( vector < int >& arr ) { const int n = arr . size (); const int max = * max_element ( begin ( arr ), end ( arr )); const int min = * min_element ( begin ( arr ), end ( arr )); const int range = max - min ; if ( range % ( n - 1 ) != 0 ) return false ; const int diff = range / ( n - 1 ); if ( diff == 0 ) return true ; for ( int i = 0 ; i < n ;) { const int gap = arr [ i ] - min ; if ( gap % diff != 0 ) return false ; if ( gap == i * diff ) { ++ i ; } else { const int rightIndex = gap / diff ; swap ( arr [ i ], arr [ rightIndex ]); } } return true ; } };","title":"Approach 2: $O(1)$ space"},{"location":"problems/1503/","text":"1503. Last Moment Before All Ants Fall Out of a Plank Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int getLastMoment ( int n , vector < int >& left , vector < int >& right ) { const int maxLeft = left . empty () ? 0 : * max_element ( begin ( left ), end ( left )); const int minRight = right . empty () ? n : * min_element ( begin ( right ), end ( right )); return max ( maxLeft , n - minRight ); } };","title":"1503. Last Moment Before All Ants Fall Out of a Plank"},{"location":"problems/1503/#1503-last-moment-before-all-ants-fall-out-of-a-plank","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 class Solution { public : int getLastMoment ( int n , vector < int >& left , vector < int >& right ) { const int maxLeft = left . empty () ? 0 : * max_element ( begin ( left ), end ( left )); const int minRight = right . empty () ? n : * min_element ( begin ( right ), end ( right )); return max ( maxLeft , n - minRight ); } };","title":"1503. Last Moment Before All Ants Fall Out of a Plank"},{"location":"problems/1504/","text":"1504. Count Submatrices With All Ones Time: $O(m^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int numSubmat ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; for ( int baseCol = 0 ; baseCol < m ; ++ baseCol ) { vector < int > row ( n , 1 ); for ( int i = baseCol ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) row [ j ] &= mat [ i ][ j ]; ans += count ( row ); } } return ans ; } private : int count ( vector < int >& row ) { int ans = 0 ; int length = 0 ; for ( const int a : row ) { length = a == 0 ? 0 : length + 1 ; ans += length ; } return ans ; } };","title":"1504. Count Submatrices With All Ones"},{"location":"problems/1504/#1504-count-submatrices-with-all-ones","text":"Time: $O(m^2n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : int numSubmat ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; for ( int baseCol = 0 ; baseCol < m ; ++ baseCol ) { vector < int > row ( n , 1 ); for ( int i = baseCol ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) row [ j ] &= mat [ i ][ j ]; ans += count ( row ); } } return ans ; } private : int count ( vector < int >& row ) { int ans = 0 ; int length = 0 ; for ( const int a : row ) { length = a == 0 ? 0 : length + 1 ; ans += length ; } return ans ; } };","title":"1504. Count Submatrices With All Ones"},{"location":"problems/1505/","text":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class Solution { public : string minInteger ( string num , int k ) { const int n = num . length (); string ans ; FenwickTree tree ( n ); vector < bool > used ( n ); vector < queue < int >> numToIndices ( 10 ); for ( int i = 0 ; i < n ; ++ i ) numToIndices [ num [ i ] - '0' ]. push ( i ); while ( k > 0 && ans . length () < n ) for ( int d = 0 ; d < 10 ; ++ d ) { if ( numToIndices [ d ]. empty ()) continue ; const int i = numToIndices [ d ]. front (); const int cost = i - tree . get ( i ); // note the offset 1 in FenwickTree if ( cost > k ) continue ; k -= cost ; ans += '0' + d ; used [ i ] = true ; tree . update ( i + 1 , 1 ); numToIndices [ d ]. pop (); break ; // scan from 0 -> 9 again } for ( int i = 0 ; i < n ; ++ i ) if ( ! used [ i ]) ans += num [ i ]; return ans ; } };","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits"},{"location":"problems/1505/#1505-minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","text":"Time: $O(n\\log n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & - i ; } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & - i ; } return sum ; } private : vector < int > sums ; }; class Solution { public : string minInteger ( string num , int k ) { const int n = num . length (); string ans ; FenwickTree tree ( n ); vector < bool > used ( n ); vector < queue < int >> numToIndices ( 10 ); for ( int i = 0 ; i < n ; ++ i ) numToIndices [ num [ i ] - '0' ]. push ( i ); while ( k > 0 && ans . length () < n ) for ( int d = 0 ; d < 10 ; ++ d ) { if ( numToIndices [ d ]. empty ()) continue ; const int i = numToIndices [ d ]. front (); const int cost = i - tree . get ( i ); // note the offset 1 in FenwickTree if ( cost > k ) continue ; k -= cost ; ans += '0' + d ; used [ i ] = true ; tree . update ( i + 1 , 1 ); numToIndices [ d ]. pop (); break ; // scan from 0 -> 9 again } for ( int i = 0 ; i < n ; ++ i ) if ( ! used [ i ]) ans += num [ i ]; return ans ; } };","title":"1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits"},{"location":"problems/1506/","text":"1506. Find Root of N-Ary Tree \ud83d\udd12","title":"1506. Find Root of N-Ary Tree"},{"location":"problems/1506/#1506-find-root-of-n-ary-tree","text":"","title":"1506. Find Root of N-Ary Tree \ud83d\udd12"},{"location":"problems/1507/","text":"1507. Reformat Date","title":"1507. Reformat Date"},{"location":"problems/1507/#1507-reformat-date","text":"","title":"1507. Reformat Date"},{"location":"problems/1508/","text":"1508. Range Sum of Sorted Subarray Sums Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : int rangeSum ( vector < int >& nums , int n , int left , int right ) { constexpr int kMod = 1e9 + 7 ; auto subarraysAndSumNoGreaterThan = [ & ]( int m ) -> pair < int , long > { int count = 0 ; // # of subarrays <= m long total = 0 ; // sum(subarrays) int sum = 0 ; // current sum (will be added to `total` in each loop) int window = 0 ; // window sum (can be extend and shrink) for ( int i = 0 , j = 0 ; j < n ; ++ j ) { sum += nums [ j ] * ( j - i + 1 ); window += nums [ j ]; // extend each subarray ends w/ j while ( window > m ) { sum -= window ; window -= nums [ i ++ ]; // shrink the window } count += j - i + 1 ; total += sum ; } return { count , total }; }; // [L, R] is the possible range of the sum of any subarray const int L = * min_element ( begin ( nums ), end ( nums )); const int R = accumulate ( begin ( nums ), end ( nums ), 0 ); auto firstKSubarraysSum = [ & ]( int k ) { int l = L ; int r = R ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( subarraysAndSumNoGreaterThan ( m ). first < k ) l = m + 1 ; else r = m ; } const auto & [ count , total ] = subarraysAndSumNoGreaterThan ( l ); // when count != k, there're subarray(s) have the same sum as l return total - l * ( count - k ); }; return firstKSubarraysSum ( right ) - firstKSubarraysSum ( left - 1 ); } };","title":"1508. Range Sum of Sorted Subarray Sums"},{"location":"problems/1508/#1508-range-sum-of-sorted-subarray-sums","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : int rangeSum ( vector < int >& nums , int n , int left , int right ) { constexpr int kMod = 1e9 + 7 ; auto subarraysAndSumNoGreaterThan = [ & ]( int m ) -> pair < int , long > { int count = 0 ; // # of subarrays <= m long total = 0 ; // sum(subarrays) int sum = 0 ; // current sum (will be added to `total` in each loop) int window = 0 ; // window sum (can be extend and shrink) for ( int i = 0 , j = 0 ; j < n ; ++ j ) { sum += nums [ j ] * ( j - i + 1 ); window += nums [ j ]; // extend each subarray ends w/ j while ( window > m ) { sum -= window ; window -= nums [ i ++ ]; // shrink the window } count += j - i + 1 ; total += sum ; } return { count , total }; }; // [L, R] is the possible range of the sum of any subarray const int L = * min_element ( begin ( nums ), end ( nums )); const int R = accumulate ( begin ( nums ), end ( nums ), 0 ); auto firstKSubarraysSum = [ & ]( int k ) { int l = L ; int r = R ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( subarraysAndSumNoGreaterThan ( m ). first < k ) l = m + 1 ; else r = m ; } const auto & [ count , total ] = subarraysAndSumNoGreaterThan ( l ); // when count != k, there're subarray(s) have the same sum as l return total - l * ( count - k ); }; return firstKSubarraysSum ( right ) - firstKSubarraysSum ( left - 1 ); } };","title":"1508. Range Sum of Sorted Subarray Sums"},{"location":"problems/1509/","text":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minDifference ( vector < int >& nums ) { const int n = nums . size (); if ( n < 5 ) return 0 ; int ans = INT_MAX ; sort ( begin ( nums ), end ( nums )); // change nums[0..i) to nums[i] and // change nums[n - 3 + i..n) to nums[n - 4 + i] for ( int i = 0 ; i <= 3 ; ++ i ) ans = min ( ans , nums [ n - 4 + i ] - nums [ i ]); return ans ; } };","title":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves"},{"location":"problems/1509/#1509-minimum-difference-between-largest-and-smallest-value-in-three-moves","text":"Time: $O(n\\log n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minDifference ( vector < int >& nums ) { const int n = nums . size (); if ( n < 5 ) return 0 ; int ans = INT_MAX ; sort ( begin ( nums ), end ( nums )); // change nums[0..i) to nums[i] and // change nums[n - 3 + i..n) to nums[n - 4 + i] for ( int i = 0 ; i <= 3 ; ++ i ) ans = min ( ans , nums [ n - 4 + i ] - nums [ i ]); return ans ; } };","title":"1509. Minimum Difference Between Largest and Smallest Value in Three Moves"},{"location":"problems/1510/","text":"1510. Stone Game IV Time: $O(n^{1.5})$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool winnerSquareGame ( int n ) { vector < bool > dp ( n + 1 ); // dp[i] := Alice wins the game with i stones for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) if ( ! dp [ i - j * j ]) { dp [ i ] = true ; break ; } return dp [ n ]; } };","title":"1510. Stone Game IV"},{"location":"problems/1510/#1510-stone-game-iv","text":"Time: $O(n^{1.5})$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool winnerSquareGame ( int n ) { vector < bool > dp ( n + 1 ); // dp[i] := Alice wins the game with i stones for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) if ( ! dp [ i - j * j ]) { dp [ i ] = true ; break ; } return dp [ n ]; } };","title":"1510. Stone Game IV"},{"location":"problems/1511/","text":"1511. Customer Order Frequency \ud83d\udd12","title":"1511. Customer Order Frequency"},{"location":"problems/1511/#1511-customer-order-frequency","text":"","title":"1511. Customer Order Frequency \ud83d\udd12"},{"location":"problems/1512/","text":"1512. Number of Good Pairs Time: $O(n)$ Space: $O(101)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int numIdenticalPairs ( vector < int >& nums ) { int ans = 0 ; vector < int > count ( 101 ); for ( const int num : nums ) ans += count [ num ] ++ ; return ans ; } };","title":"1512. Number of Good Pairs"},{"location":"problems/1512/#1512-number-of-good-pairs","text":"Time: $O(n)$ Space: $O(101)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int numIdenticalPairs ( vector < int >& nums ) { int ans = 0 ; vector < int > count ( 101 ); for ( const int num : nums ) ans += count [ num ] ++ ; return ans ; } };","title":"1512. Number of Good Pairs"},{"location":"problems/1513/","text":"1513. Number of Substrings With Only 1s Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSub ( string s ) { constexpr int kMod = 1e9 + 7 ; int ans = 0 ; int l = -1 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '0' ) l = i ; // handle reset value ans = ( ans + i - l ) % kMod ; } return ans ; } };","title":"1513. Number of Substrings With Only 1s"},{"location":"problems/1513/#1513-number-of-substrings-with-only-1s","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSub ( string s ) { constexpr int kMod = 1e9 + 7 ; int ans = 0 ; int l = -1 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '0' ) l = i ; // handle reset value ans = ( ans + i - l ) % kMod ; } return ans ; } };","title":"1513. Number of Substrings With Only 1s"},{"location":"problems/1514/","text":"1514. Path with Maximum Probability Time: $O(|E|\\log|E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double maxProbability ( int n , vector < vector < int >>& edges , vector < double >& succProb , int start , int end ) { vector < vector < pair < int , double >>> graph ( n ); // {a: {b, prob_ab}} vector < bool > seen ( n ); vector < double > probs ( n ); // probs[i] := max prob to reach node i priority_queue < pair < double , int >> pq ; // {prob, node}: max-heap sorted by prob pq . push ({ 1.0 , start }); for ( int i = 0 ; i < edges . size (); ++ i ) { const int a = edges [ i ][ 0 ]; const int b = edges [ i ][ 1 ]; const double prob = succProb [ i ]; graph [ a ]. push_back ({ b , prob }); graph [ b ]. push_back ({ a , prob }); } while ( ! pq . empty ()) { const auto [ prob , node ] = pq . top (); pq . pop (); if ( seen [ node ]) continue ; seen [ node ] = true ; for ( const auto & [ nextNode , edgeProb ] : graph [ node ]) if ( probs [ nextNode ] < prob * edgeProb ) { probs [ nextNode ] = prob * edgeProb ; pq . push ({ probs [ nextNode ], nextNode }); } } return probs [ end ]; } };","title":"1514. Path with Maximum Probability"},{"location":"problems/1514/#1514-path-with-maximum-probability","text":"Time: $O(|E|\\log|E|)$ Space: $O(|V| + |E|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : double maxProbability ( int n , vector < vector < int >>& edges , vector < double >& succProb , int start , int end ) { vector < vector < pair < int , double >>> graph ( n ); // {a: {b, prob_ab}} vector < bool > seen ( n ); vector < double > probs ( n ); // probs[i] := max prob to reach node i priority_queue < pair < double , int >> pq ; // {prob, node}: max-heap sorted by prob pq . push ({ 1.0 , start }); for ( int i = 0 ; i < edges . size (); ++ i ) { const int a = edges [ i ][ 0 ]; const int b = edges [ i ][ 1 ]; const double prob = succProb [ i ]; graph [ a ]. push_back ({ b , prob }); graph [ b ]. push_back ({ a , prob }); } while ( ! pq . empty ()) { const auto [ prob , node ] = pq . top (); pq . pop (); if ( seen [ node ]) continue ; seen [ node ] = true ; for ( const auto & [ nextNode , edgeProb ] : graph [ node ]) if ( probs [ nextNode ] < prob * edgeProb ) { probs [ nextNode ] = prob * edgeProb ; pq . push ({ probs [ nextNode ], nextNode }); } } return probs [ end ]; } };","title":"1514. Path with Maximum Probability"},{"location":"problems/1515/","text":"1515. Best Position for a Service Centre","title":"1515. Best Position for a Service Centre"},{"location":"problems/1515/#1515-best-position-for-a-service-centre","text":"","title":"1515. Best Position for a Service Centre"},{"location":"problems/1516/","text":"1516. Move Sub-Tree of N-Ary Tree \ud83d\udd12","title":"1516. Move Sub-Tree of N-Ary Tree"},{"location":"problems/1516/#1516-move-sub-tree-of-n-ary-tree","text":"","title":"1516. Move Sub-Tree of N-Ary Tree \ud83d\udd12"},{"location":"problems/1517/","text":"1517. Find Users With Valid E-Mails \ud83d\udd12","title":"1517. Find Users With Valid E-Mails"},{"location":"problems/1517/#1517-find-users-with-valid-e-mails","text":"","title":"1517. Find Users With Valid E-Mails \ud83d\udd12"},{"location":"problems/1518/","text":"1518. Water Bottles Approach 1: $O(\\log numBottles)$ space Time: $O(\\log numBottles)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numWaterBottles ( int numBottles , int numExchange ) { int ans = numBottles ; while ( numBottles >= numExchange ) { ans += numBottles / numExchange ; numBottles = numBottles / numExchange + numBottles % numExchange ; } return ans ; } }; Approach 2: $O(1)$ space Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int numWaterBottles ( int numBottles , int numExchange ) { return numBottles + ( numBottles - 1 ) / ( numExchange - 1 ); } };","title":"1518. Water Bottles"},{"location":"problems/1518/#1518-water-bottles","text":"","title":"1518. Water Bottles"},{"location":"problems/1518/#approach-1-olog-numbottles-space","text":"Time: $O(\\log numBottles)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numWaterBottles ( int numBottles , int numExchange ) { int ans = numBottles ; while ( numBottles >= numExchange ) { ans += numBottles / numExchange ; numBottles = numBottles / numExchange + numBottles % numExchange ; } return ans ; } };","title":"Approach 1: $O(\\log numBottles)$ space"},{"location":"problems/1518/#approach-2-o1-space","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int numWaterBottles ( int numBottles , int numExchange ) { return numBottles + ( numBottles - 1 ) / ( numExchange - 1 ); } };","title":"Approach 2: $O(1)$ space"},{"location":"problems/1519/","text":"1519. Number of Nodes in the Sub-Tree With the Same Label Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < int > countSubTrees ( int n , vector < vector < int >>& edges , string labels ) { vector < int > ans ( n ); vector < vector < int >> graph ( n ); for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < vector < int > ( int node , int parent ) > dfs = [ & ]( int node , int parent ) { vector < int > count ( 26 ); // count of letters down from this node for ( const int child : graph [ node ]) if ( child != parent ) { // avoid duplicate visiting vector < int > subCount = dfs ( child , node ); for ( int i = 0 ; i < 26 ; ++ i ) count [ i ] += subCount [ i ]; } ans [ node ] = ++ count [ labels [ node ] - 'a' ]; // the node itself return count ; }; dfs ( 0 , -1 ); return ans ; } };","title":"1519. Number of Nodes in the Sub-Tree With the Same Label"},{"location":"problems/1519/#1519-number-of-nodes-in-the-sub-tree-with-the-same-label","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < int > countSubTrees ( int n , vector < vector < int >>& edges , string labels ) { vector < int > ans ( n ); vector < vector < int >> graph ( n ); for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } function < vector < int > ( int node , int parent ) > dfs = [ & ]( int node , int parent ) { vector < int > count ( 26 ); // count of letters down from this node for ( const int child : graph [ node ]) if ( child != parent ) { // avoid duplicate visiting vector < int > subCount = dfs ( child , node ); for ( int i = 0 ; i < 26 ; ++ i ) count [ i ] += subCount [ i ]; } ans [ node ] = ++ count [ labels [ node ] - 'a' ]; // the node itself return count ; }; dfs ( 0 , -1 ); return ans ; } };","title":"1519. Number of Nodes in the Sub-Tree With the Same Label"},{"location":"problems/1520/","text":"1520. Maximum Number of Non-Overlapping Substrings Time: $O(26n) = O(n)$ Space: $|ans|$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > maxNumOfSubstrings ( string s ) { const int n = s . length (); vector < string > ans ; vector < int > leftmost ( 26 , n ); // leftmost index of each letter vector < int > rightmost ( 26 , -1 ); // rightmost index of each letter for ( int i = 0 ; i < n ; ++ i ) { leftmost [ s [ i ] - 'a' ] = min ( leftmost [ s [ i ] - 'a' ], i ); rightmost [ s [ i ] - 'a' ] = i ; } auto getNewRight = [ & ]( int i ) { int right = rightmost [ s [ i ] - 'a' ]; for ( int j = i ; j <= right ; ++ j ) { if ( leftmost [ s [ j ] - 'a' ] < i ) // find a letter's first index < i return -1 ; right = max ( right , rightmost [ s [ j ] - 'a' ]); // right expands dynamically } return right ; }; int right = -1 ; // last substring's rightmost index for ( int i = 0 ; i < n ; ++ i ) { if ( i == leftmost [ s [ i ] - 'a' ]) { // current index is the first appearance const int newRight = getNewRight ( i ); if ( newRight == -1 ) continue ; // find a letter's first index < i if ( i <= right && ! ans . empty ()) ans . back () = s . substr ( i , newRight - i + 1 ); else ans . push_back ( s . substr ( i , newRight - i + 1 )); right = newRight ; } } return ans ; } };","title":"1520. Maximum Number of Non-Overlapping Substrings"},{"location":"problems/1520/#1520-maximum-number-of-non-overlapping-substrings","text":"Time: $O(26n) = O(n)$ Space: $|ans|$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > maxNumOfSubstrings ( string s ) { const int n = s . length (); vector < string > ans ; vector < int > leftmost ( 26 , n ); // leftmost index of each letter vector < int > rightmost ( 26 , -1 ); // rightmost index of each letter for ( int i = 0 ; i < n ; ++ i ) { leftmost [ s [ i ] - 'a' ] = min ( leftmost [ s [ i ] - 'a' ], i ); rightmost [ s [ i ] - 'a' ] = i ; } auto getNewRight = [ & ]( int i ) { int right = rightmost [ s [ i ] - 'a' ]; for ( int j = i ; j <= right ; ++ j ) { if ( leftmost [ s [ j ] - 'a' ] < i ) // find a letter's first index < i return -1 ; right = max ( right , rightmost [ s [ j ] - 'a' ]); // right expands dynamically } return right ; }; int right = -1 ; // last substring's rightmost index for ( int i = 0 ; i < n ; ++ i ) { if ( i == leftmost [ s [ i ] - 'a' ]) { // current index is the first appearance const int newRight = getNewRight ( i ); if ( newRight == -1 ) continue ; // find a letter's first index < i if ( i <= right && ! ans . empty ()) ans . back () = s . substr ( i , newRight - i + 1 ); else ans . push_back ( s . substr ( i , newRight - i + 1 )); right = newRight ; } } return ans ; } };","title":"1520. Maximum Number of Non-Overlapping Substrings"},{"location":"problems/1521/","text":"1521. Find a Value of a Mysterious Function Closest to Target Time: $O(n\\log\\max(arr))$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int closestToTarget ( vector < int >& arr , int target ) { int ans = INT_MAX ; // s(j) := arr[i] & arr[i + 1] & ... & arr[j] for all 0 <= i <= j (fixed) unordered_set < int > s ; for ( const int a : arr ) { unordered_set < int > s2 { a }; for ( const int b : s ) s2 . insert ( a & b ); for ( const int c : s = s2 ) ans = min ( ans , abs ( c - target )); } return ans ; } };","title":"1521. Find a Value of a Mysterious Function Closest to Target"},{"location":"problems/1521/#1521-find-a-value-of-a-mysterious-function-closest-to-target","text":"Time: $O(n\\log\\max(arr))$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int closestToTarget ( vector < int >& arr , int target ) { int ans = INT_MAX ; // s(j) := arr[i] & arr[i + 1] & ... & arr[j] for all 0 <= i <= j (fixed) unordered_set < int > s ; for ( const int a : arr ) { unordered_set < int > s2 { a }; for ( const int b : s ) s2 . insert ( a & b ); for ( const int c : s = s2 ) ans = min ( ans , abs ( c - target )); } return ans ; } };","title":"1521. Find a Value of a Mysterious Function Closest to Target"},{"location":"problems/1522/","text":"1522. Diameter of N-Ary Tree \ud83d\udd12","title":"1522. Diameter of N-Ary Tree"},{"location":"problems/1522/#1522-diameter-of-n-ary-tree","text":"","title":"1522. Diameter of N-Ary Tree \ud83d\udd12"},{"location":"problems/1523/","text":"1523. Count Odd Numbers in an Interval Range Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int countOdds ( int low , int high ) { return ( high + 1 ) / 2 - low / 2 ; } };","title":"1523. Count Odd Numbers in an Interval Range"},{"location":"problems/1523/#1523-count-odd-numbers-in-an-interval-range","text":"Time: $O(1)$ Space: $O(1)$ C++ 1 2 3 4 5 6 class Solution { public : int countOdds ( int low , int high ) { return ( high + 1 ) / 2 - low / 2 ; } };","title":"1523. Count Odd Numbers in an Interval Range"},{"location":"problems/1524/","text":"1524. Number of Sub-arrays With Odd Sum Approach 1: $O(n)$ space Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numOfSubarrays ( vector < int >& arr ) { constexpr int kMod = 1e9 + 7 ; const int n = arr . size (); long ans = 0 ; vector < int > dp0 ( n + 1 ); // dp0[i] := # of subarrays ends with arr[i - 1] have even sum vector < int > dp1 ( n + 1 ); // dp1[i] := # of subarrays ends with arr[i - 1] have odd sum for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] & 1 ) { dp0 [ i ] = dp1 [ i - 1 ]; dp1 [ i ] = dp0 [ i - 1 ] + 1 ; } else { dp0 [ i ] = dp0 [ i - 1 ] + 1 ; dp1 [ i ] = dp1 [ i - 1 ]; } ans = ( ans + dp1 [ i ]) % kMod ; } return ans ; } }; Approach 2: $O(1)$ space Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numOfSubarrays ( vector < int >& arr ) { constexpr int kMod = 1e9 + 7 ; long ans = 0 ; long dp0 = 0 ; long dp1 = 0 ; for ( const int a : arr ) { if ( a & 1 ) { const int cache = dp0 ; dp0 = dp1 ; dp1 = cache + 1 ; } else { ++ dp0 ; } ans = ( ans + dp1 ) % kMod ; } return ans ; } };","title":"1524. Number of Sub-arrays With Odd Sum"},{"location":"problems/1524/#1524-number-of-sub-arrays-with-odd-sum","text":"","title":"1524. Number of Sub-arrays With Odd Sum"},{"location":"problems/1524/#approach-1-on-space","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numOfSubarrays ( vector < int >& arr ) { constexpr int kMod = 1e9 + 7 ; const int n = arr . size (); long ans = 0 ; vector < int > dp0 ( n + 1 ); // dp0[i] := # of subarrays ends with arr[i - 1] have even sum vector < int > dp1 ( n + 1 ); // dp1[i] := # of subarrays ends with arr[i - 1] have odd sum for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] & 1 ) { dp0 [ i ] = dp1 [ i - 1 ]; dp1 [ i ] = dp0 [ i - 1 ] + 1 ; } else { dp0 [ i ] = dp0 [ i - 1 ] + 1 ; dp1 [ i ] = dp1 [ i - 1 ]; } ans = ( ans + dp1 [ i ]) % kMod ; } return ans ; } };","title":"Approach 1: $O(n)$ space"},{"location":"problems/1524/#approach-2-o1-space","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int numOfSubarrays ( vector < int >& arr ) { constexpr int kMod = 1e9 + 7 ; long ans = 0 ; long dp0 = 0 ; long dp1 = 0 ; for ( const int a : arr ) { if ( a & 1 ) { const int cache = dp0 ; dp0 = dp1 ; dp1 = cache + 1 ; } else { ++ dp0 ; } ans = ( ans + dp1 ) % kMod ; } return ans ; } };","title":"Approach 2: $O(1)$ space"},{"location":"problems/1525/","text":"1525. Number of Good Ways to Split a String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numSplits ( string s ) { const int n = s . length (); int ans = 0 ; unordered_set < int > seen ; vector < int > prefix ( n ); // # prefix[i] := of unique letters in s[0..i] vector < int > suffix ( n ); // # suffix[i] := of unique letters in s[i..n) for ( int i = 0 ; i < n ; ++ i ) { seen . insert ( s [ i ]); prefix [ i ] = seen . size (); } seen . clear (); for ( int i = n - 1 ; i >= 0 ; -- i ) { seen . insert ( s [ i ]); suffix [ i ] = seen . size (); } for ( int i = 0 ; i + 1 < n ; ++ i ) if ( prefix [ i ] == suffix [ i + 1 ]) ++ ans ; return ans ; } };","title":"1525. Number of Good Ways to Split a String"},{"location":"problems/1525/#1525-number-of-good-ways-to-split-a-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int numSplits ( string s ) { const int n = s . length (); int ans = 0 ; unordered_set < int > seen ; vector < int > prefix ( n ); // # prefix[i] := of unique letters in s[0..i] vector < int > suffix ( n ); // # suffix[i] := of unique letters in s[i..n) for ( int i = 0 ; i < n ; ++ i ) { seen . insert ( s [ i ]); prefix [ i ] = seen . size (); } seen . clear (); for ( int i = n - 1 ; i >= 0 ; -- i ) { seen . insert ( s [ i ]); suffix [ i ] = seen . size (); } for ( int i = 0 ; i + 1 < n ; ++ i ) if ( prefix [ i ] == suffix [ i + 1 ]) ++ ans ; return ans ; } };","title":"1525. Number of Good Ways to Split a String"},{"location":"problems/1526/","text":"1526. Minimum Number of Increments on Subarrays to Form a Target Array Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minNumberOperations ( vector < int >& target ) { int ans = target . front (); for ( int i = 1 ; i < target . size (); ++ i ) if ( target [ i ] > target [ i - 1 ]) ans += target [ i ] - target [ i - 1 ]; return ans ; } };","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array"},{"location":"problems/1526/#1526-minimum-number-of-increments-on-subarrays-to-form-a-target-array","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int minNumberOperations ( vector < int >& target ) { int ans = target . front (); for ( int i = 1 ; i < target . size (); ++ i ) if ( target [ i ] > target [ i - 1 ]) ans += target [ i ] - target [ i - 1 ]; return ans ; } };","title":"1526. Minimum Number of Increments on Subarrays to Form a Target Array"},{"location":"problems/1527/","text":"1527. Patients With a Condition \ud83d\udd12","title":"1527. Patients With a Condition"},{"location":"problems/1527/#1527-patients-with-a-condition","text":"","title":"1527. Patients With a Condition \ud83d\udd12"},{"location":"problems/1528/","text":"1528. Shuffle String Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : string restoreString ( string s , vector < int >& indices ) { string ans ( s . length (), '.' ); for ( int i = 0 ; i < indices . size (); ++ i ) ans [ indices [ i ]] = s [ i ]; return ans ; } };","title":"1528. Shuffle String"},{"location":"problems/1528/#1528-shuffle-string","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : string restoreString ( string s , vector < int >& indices ) { string ans ( s . length (), '.' ); for ( int i = 0 ; i < indices . size (); ++ i ) ans [ indices [ i ]] = s [ i ]; return ans ; } };","title":"1528. Shuffle String"},{"location":"problems/1529/","text":"1529. Bulb Switcher IV Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minFlips ( string target ) { int ans = 0 ; int state = 0 ; for ( const char c : target ) if ( c - '0' != state ) { state = c - '0' ; ++ ans ; } return ans ; } };","title":"1529. Bulb Switcher IV"},{"location":"problems/1529/#1529-bulb-switcher-iv","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minFlips ( string target ) { int ans = 0 ; int state = 0 ; for ( const char c : target ) if ( c - '0' != state ) { state = c - '0' ; ++ ans ; } return ans ; } };","title":"1529. Bulb Switcher IV"},{"location":"problems/1530/","text":"1530. Number of Good Leaf Nodes Pairs Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int countPairs ( TreeNode * root , int distance ) { int ans = 0 ; function < vector < int > ( TreeNode * ) > dfs = [ & ]( TreeNode * root ) { vector < int > d ( distance + 1 ); // {distance: # of leaf nodes} if ( ! root ) return d ; if ( ! root -> left && ! root -> right ) { d [ 0 ] = 1 ; return d ; } vector < int > dl = dfs ( root -> left ); vector < int > dr = dfs ( root -> right ); for ( int i = 0 ; i < distance ; ++ i ) for ( int j = 0 ; j < distance ; ++ j ) if ( i + j + 2 <= distance ) ans += dl [ i ] * dr [ j ]; for ( int i = 0 ; i < distance ; ++ i ) d [ i + 1 ] = dl [ i ] + dr [ i ]; return d ; }; dfs ( root ); return ans ; } };","title":"1530. Number of Good Leaf Nodes Pairs"},{"location":"problems/1530/#1530-number-of-good-leaf-nodes-pairs","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : int countPairs ( TreeNode * root , int distance ) { int ans = 0 ; function < vector < int > ( TreeNode * ) > dfs = [ & ]( TreeNode * root ) { vector < int > d ( distance + 1 ); // {distance: # of leaf nodes} if ( ! root ) return d ; if ( ! root -> left && ! root -> right ) { d [ 0 ] = 1 ; return d ; } vector < int > dl = dfs ( root -> left ); vector < int > dr = dfs ( root -> right ); for ( int i = 0 ; i < distance ; ++ i ) for ( int j = 0 ; j < distance ; ++ j ) if ( i + j + 2 <= distance ) ans += dl [ i ] * dr [ j ]; for ( int i = 0 ; i < distance ; ++ i ) d [ i + 1 ] = dl [ i ] + dr [ i ]; return d ; }; dfs ( root ); return ans ; } };","title":"1530. Number of Good Leaf Nodes Pairs"},{"location":"problems/1531/","text":"1531. String Compression II","title":"1531. String Compression II"},{"location":"problems/1531/#1531-string-compression-ii","text":"","title":"1531. String Compression II"},{"location":"problems/1532/","text":"1532. The Most Recent Three Orders \ud83d\udd12","title":"1532. The Most Recent Three Orders"},{"location":"problems/1532/#1532-the-most-recent-three-orders","text":"","title":"1532. The Most Recent Three Orders \ud83d\udd12"},{"location":"problems/1533/","text":"1533. Find the Index of the Large Integer \ud83d\udd12","title":"1533. Find the Index of the Large Integer"},{"location":"problems/1533/#1533-find-the-index-of-the-large-integer","text":"","title":"1533. Find the Index of the Large Integer \ud83d\udd12"},{"location":"problems/1534/","text":"1534. Count Good Triplets","title":"1534. Count Good Triplets"},{"location":"problems/1534/#1534-count-good-triplets","text":"","title":"1534. Count Good Triplets"},{"location":"problems/1535/","text":"1535. Find the Winner of an Array Game","title":"1535. Find the Winner of an Array Game"},{"location":"problems/1535/#1535-find-the-winner-of-an-array-game","text":"","title":"1535. Find the Winner of an Array Game"},{"location":"problems/1536/","text":"1536. Minimum Swaps to Arrange a Binary Grid","title":"1536. Minimum Swaps to Arrange a Binary Grid"},{"location":"problems/1536/#1536-minimum-swaps-to-arrange-a-binary-grid","text":"","title":"1536. Minimum Swaps to Arrange a Binary Grid"},{"location":"problems/1537/","text":"1537. Get the Maximum Score","title":"1537. Get the Maximum Score"},{"location":"problems/1537/#1537-get-the-maximum-score","text":"","title":"1537. Get the Maximum Score"},{"location":"problems/1538/","text":"1538. Guess the Majority in a Hidden Array \ud83d\udd12","title":"1538. Guess the Majority in a Hidden Array"},{"location":"problems/1538/#1538-guess-the-majority-in-a-hidden-array","text":"","title":"1538. Guess the Majority in a Hidden Array \ud83d\udd12"},{"location":"problems/1539/","text":"1539. Kth Missing Positive Number","title":"1539. Kth Missing Positive Number"},{"location":"problems/1539/#1539-kth-missing-positive-number","text":"","title":"1539. Kth Missing Positive Number"},{"location":"problems/1540/","text":"1540. Can Convert String in K Moves","title":"1540. Can Convert String in K Moves"},{"location":"problems/1540/#1540-can-convert-string-in-k-moves","text":"","title":"1540. Can Convert String in K Moves"},{"location":"problems/1541/","text":"1541. Minimum Insertions to Balance a Parentheses String","title":"1541. Minimum Insertions to Balance a Parentheses String"},{"location":"problems/1541/#1541-minimum-insertions-to-balance-a-parentheses-string","text":"","title":"1541. Minimum Insertions to Balance a Parentheses String"},{"location":"problems/1542/","text":"1542. Find Longest Awesome Substring","title":"1542. Find Longest Awesome Substring"},{"location":"problems/1542/#1542-find-longest-awesome-substring","text":"","title":"1542. Find Longest Awesome Substring"},{"location":"problems/1543/","text":"1543. Fix Product Name Format \ud83d\udd12","title":"1543. Fix Product Name Format"},{"location":"problems/1543/#1543-fix-product-name-format","text":"","title":"1543. Fix Product Name Format \ud83d\udd12"},{"location":"problems/1544/","text":"1544. Make The String Great","title":"1544. Make The String Great"},{"location":"problems/1544/#1544-make-the-string-great","text":"","title":"1544. Make The String Great"},{"location":"problems/1545/","text":"1545. Find Kth Bit in Nth Binary String","title":"1545. Find Kth Bit in Nth Binary String"},{"location":"problems/1545/#1545-find-kth-bit-in-nth-binary-string","text":"","title":"1545. Find Kth Bit in Nth Binary String"},{"location":"problems/1546/","text":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"},{"location":"problems/1546/#1546-maximum-number-of-non-overlapping-subarrays-with-sum-equals-target","text":"","title":"1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target"},{"location":"problems/1547/","text":"1547. Minimum Cost to Cut a Stick","title":"1547. Minimum Cost to Cut a Stick"},{"location":"problems/1547/#1547-minimum-cost-to-cut-a-stick","text":"","title":"1547. Minimum Cost to Cut a Stick"},{"location":"problems/1548/","text":"1548. The Most Similar Path in a Graph \ud83d\udd12","title":"1548. The Most Similar Path in a Graph"},{"location":"problems/1548/#1548-the-most-similar-path-in-a-graph","text":"","title":"1548. The Most Similar Path in a Graph \ud83d\udd12"},{"location":"problems/1549/","text":"1549. The Most Recent Orders for Each Product \ud83d\udd12","title":"1549. The Most Recent Orders for Each Product"},{"location":"problems/1549/#1549-the-most-recent-orders-for-each-product","text":"","title":"1549. The Most Recent Orders for Each Product \ud83d\udd12"},{"location":"problems/1550/","text":"1550. Three Consecutive Odds","title":"1550. Three Consecutive Odds"},{"location":"problems/1550/#1550-three-consecutive-odds","text":"","title":"1550. Three Consecutive Odds"},{"location":"problems/1551/","text":"1551. Minimum Operations to Make Array Equal","title":"1551. Minimum Operations to Make Array Equal"},{"location":"problems/1551/#1551-minimum-operations-to-make-array-equal","text":"","title":"1551. Minimum Operations to Make Array Equal"},{"location":"problems/1552/","text":"1552. Magnetic Force Between Two Balls","title":"1552. Magnetic Force Between Two Balls"},{"location":"problems/1552/#1552-magnetic-force-between-two-balls","text":"","title":"1552. Magnetic Force Between Two Balls"},{"location":"problems/1553/","text":"1553. Minimum Number of Days to Eat N Oranges","title":"1553. Minimum Number of Days to Eat N Oranges"},{"location":"problems/1553/#1553-minimum-number-of-days-to-eat-n-oranges","text":"","title":"1553. Minimum Number of Days to Eat N Oranges"},{"location":"problems/1554/","text":"1554. Strings Differ by One Character \ud83d\udd12","title":"1554. Strings Differ by One Character"},{"location":"problems/1554/#1554-strings-differ-by-one-character","text":"","title":"1554. Strings Differ by One Character \ud83d\udd12"},{"location":"problems/1555/","text":"1555. Bank Account Summary \ud83d\udd12","title":"1555. Bank Account Summary"},{"location":"problems/1555/#1555-bank-account-summary","text":"","title":"1555. Bank Account Summary \ud83d\udd12"},{"location":"problems/1556/","text":"1556. Thousand Separator","title":"1556. Thousand Separator"},{"location":"problems/1556/#1556-thousand-separator","text":"","title":"1556. Thousand Separator"},{"location":"problems/1557/","text":"1557. Minimum Number of Vertices to Reach All Nodes","title":"1557. Minimum Number of Vertices to Reach All Nodes"},{"location":"problems/1557/#1557-minimum-number-of-vertices-to-reach-all-nodes","text":"","title":"1557. Minimum Number of Vertices to Reach All Nodes"},{"location":"problems/1558/","text":"1558. Minimum Numbers of Function Calls to Make Target Array","title":"1558. Minimum Numbers of Function Calls to Make Target Array"},{"location":"problems/1558/#1558-minimum-numbers-of-function-calls-to-make-target-array","text":"","title":"1558. Minimum Numbers of Function Calls to Make Target Array"},{"location":"problems/1559/","text":"1559. Detect Cycles in 2D Grid","title":"1559. Detect Cycles in 2D Grid"},{"location":"problems/1559/#1559-detect-cycles-in-2d-grid","text":"","title":"1559. Detect Cycles in 2D Grid"},{"location":"problems/1560/","text":"1560. Most Visited Sector in a Circular Track","title":"1560. Most Visited Sector in a Circular Track"},{"location":"problems/1560/#1560-most-visited-sector-in-a-circular-track","text":"","title":"1560. Most Visited Sector in a Circular Track"},{"location":"problems/1561/","text":"1561. Maximum Number of Coins You Can Get","title":"1561. Maximum Number of Coins You Can Get"},{"location":"problems/1561/#1561-maximum-number-of-coins-you-can-get","text":"","title":"1561. Maximum Number of Coins You Can Get"},{"location":"problems/1562/","text":"1562. Find Latest Group of Size M","title":"1562. Find Latest Group of Size M"},{"location":"problems/1562/#1562-find-latest-group-of-size-m","text":"","title":"1562. Find Latest Group of Size M"},{"location":"problems/1563/","text":"1563. Stone Game V","title":"1563. Stone Game V"},{"location":"problems/1563/#1563-stone-game-v","text":"","title":"1563. Stone Game V"},{"location":"problems/1564/","text":"1564. Put Boxes Into the Warehouse I \ud83d\udd12","title":"1564. Put Boxes Into the Warehouse I"},{"location":"problems/1564/#1564-put-boxes-into-the-warehouse-i","text":"","title":"1564. Put Boxes Into the Warehouse I \ud83d\udd12"},{"location":"problems/1565/","text":"1565. Unique Orders and Customers Per Month \ud83d\udd12","title":"1565. Unique Orders and Customers Per Month"},{"location":"problems/1565/#1565-unique-orders-and-customers-per-month","text":"","title":"1565. Unique Orders and Customers Per Month \ud83d\udd12"},{"location":"problems/1566/","text":"1566. Detect Pattern of Length M Repeated K or More Times","title":"1566. Detect Pattern of Length M Repeated K or More Times"},{"location":"problems/1566/#1566-detect-pattern-of-length-m-repeated-k-or-more-times","text":"","title":"1566. Detect Pattern of Length M Repeated K or More Times"},{"location":"problems/1567/","text":"1567. Maximum Length of Subarray With Positive Product","title":"1567. Maximum Length of Subarray With Positive Product"},{"location":"problems/1567/#1567-maximum-length-of-subarray-with-positive-product","text":"","title":"1567. Maximum Length of Subarray With Positive Product"},{"location":"problems/1568/","text":"1568. Minimum Number of Days to Disconnect Island","title":"1568. Minimum Number of Days to Disconnect Island"},{"location":"problems/1568/#1568-minimum-number-of-days-to-disconnect-island","text":"","title":"1568. Minimum Number of Days to Disconnect Island"},{"location":"problems/1569/","text":"1569. Number of Ways to Reorder Array to Get Same BST","title":"1569. Number of Ways to Reorder Array to Get Same BST"},{"location":"problems/1569/#1569-number-of-ways-to-reorder-array-to-get-same-bst","text":"","title":"1569. Number of Ways to Reorder Array to Get Same BST"},{"location":"problems/1570/","text":"1570. Dot Product of Two Sparse Vectors \ud83d\udd12 Approach 1: Hash Table Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class SparseVector { public : SparseVector ( vector < int >& nums ) { for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ]) indexToNum [ i ] = nums [ i ]; } // Return the dotProduct of two sparse vectors int dotProduct ( SparseVector & vec ) { int ans = 0 ; for ( const auto & [ index , num ] : vec . indexToNum ) if ( indexToNum . count ( index )) ans += num * indexToNum [ index ]; return ans ; } private : unordered_map < int , int > indexToNum ; // {index: num} }; Approach 2: Two Pointers Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SparseVector { public : SparseVector ( vector < int >& nums ) { for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ]) v . push_back ({ i , nums [ i ]}); } // Return the dotProduct of two sparse vectors int dotProduct ( SparseVector & vec ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < v . size () && j < vec . v . size ();) if ( v [ i ]. first == vec . v [ j ]. first ) ans += v [ i ++ ]. second * vec . v [ j ++ ]. second ; else if ( v [ i ]. first < vec . v [ j ]. first ) ++ i ; else ++ j ; return ans ; } private : vector < pair < int , int >> v ; // {index, num} };","title":"1570. Dot Product of Two Sparse Vectors"},{"location":"problems/1570/#1570-dot-product-of-two-sparse-vectors","text":"","title":"1570. Dot Product of Two Sparse Vectors \ud83d\udd12"},{"location":"problems/1570/#approach-1-hash-table","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class SparseVector { public : SparseVector ( vector < int >& nums ) { for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ]) indexToNum [ i ] = nums [ i ]; } // Return the dotProduct of two sparse vectors int dotProduct ( SparseVector & vec ) { int ans = 0 ; for ( const auto & [ index , num ] : vec . indexToNum ) if ( indexToNum . count ( index )) ans += num * indexToNum [ index ]; return ans ; } private : unordered_map < int , int > indexToNum ; // {index: num} };","title":"Approach 1: Hash Table"},{"location":"problems/1570/#approach-2-two-pointers","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SparseVector { public : SparseVector ( vector < int >& nums ) { for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ]) v . push_back ({ i , nums [ i ]}); } // Return the dotProduct of two sparse vectors int dotProduct ( SparseVector & vec ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < v . size () && j < vec . v . size ();) if ( v [ i ]. first == vec . v [ j ]. first ) ans += v [ i ++ ]. second * vec . v [ j ++ ]. second ; else if ( v [ i ]. first < vec . v [ j ]. first ) ++ i ; else ++ j ; return ans ; } private : vector < pair < int , int >> v ; // {index, num} };","title":"Approach 2: Two Pointers"},{"location":"problems/1571/","text":"1571. Warehouse Manager \ud83d\udd12","title":"1571. Warehouse Manager"},{"location":"problems/1571/#1571-warehouse-manager","text":"","title":"1571. Warehouse Manager \ud83d\udd12"},{"location":"problems/1572/","text":"1572. Matrix Diagonal Sum","title":"1572. Matrix Diagonal Sum"},{"location":"problems/1572/#1572-matrix-diagonal-sum","text":"","title":"1572. Matrix Diagonal Sum"},{"location":"problems/1573/","text":"1573. Number of Ways to Split a String","title":"1573. Number of Ways to Split a String"},{"location":"problems/1573/#1573-number-of-ways-to-split-a-string","text":"","title":"1573. Number of Ways to Split a String"},{"location":"problems/1574/","text":"1574. Shortest Subarray to be Removed to Make Array Sorted","title":"1574. Shortest Subarray to be Removed to Make Array Sorted"},{"location":"problems/1574/#1574-shortest-subarray-to-be-removed-to-make-array-sorted","text":"","title":"1574. Shortest Subarray to be Removed to Make Array Sorted"},{"location":"problems/1575/","text":"1575. Count All Possible Routes","title":"1575. Count All Possible Routes"},{"location":"problems/1575/#1575-count-all-possible-routes","text":"","title":"1575. Count All Possible Routes"},{"location":"problems/1576/","text":"1576. Replace All ?'s to Avoid Consecutive Repeating Characters","title":"1576. Replace All ?'s to Avoid Consecutive Repeating Characters"},{"location":"problems/1576/#1576-replace-all-s-to-avoid-consecutive-repeating-characters","text":"","title":"1576. Replace All ?'s to Avoid Consecutive Repeating Characters"},{"location":"problems/1577/","text":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers","title":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers"},{"location":"problems/1577/#1577-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers","text":"","title":"1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers"},{"location":"problems/1578/","text":"1578. Minimum Deletion Cost to Avoid Repeating Letters","title":"1578. Minimum Deletion Cost to Avoid Repeating Letters"},{"location":"problems/1578/#1578-minimum-deletion-cost-to-avoid-repeating-letters","text":"","title":"1578. Minimum Deletion Cost to Avoid Repeating Letters"},{"location":"problems/1579/","text":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable"},{"location":"problems/1579/#1579-remove-max-number-of-edges-to-keep-graph-fully-traversable","text":"","title":"1579. Remove Max Number of Edges to Keep Graph Fully Traversable"},{"location":"problems/1580/","text":"1580. Put Boxes Into the Warehouse II \ud83d\udd12","title":"1580. Put Boxes Into the Warehouse II"},{"location":"problems/1580/#1580-put-boxes-into-the-warehouse-ii","text":"","title":"1580. Put Boxes Into the Warehouse II \ud83d\udd12"},{"location":"problems/1581/","text":"1581. Customer Who Visited but Did Not Make Any Transactions \ud83d\udd12","title":"1581. Customer Who Visited but Did Not Make Any Transactions"},{"location":"problems/1581/#1581-customer-who-visited-but-did-not-make-any-transactions","text":"","title":"1581. Customer Who Visited but Did Not Make Any Transactions \ud83d\udd12"},{"location":"problems/1582/","text":"1582. Special Positions in a Binary Matrix","title":"1582. Special Positions in a Binary Matrix"},{"location":"problems/1582/#1582-special-positions-in-a-binary-matrix","text":"","title":"1582. Special Positions in a Binary Matrix"},{"location":"problems/1583/","text":"1583. Count Unhappy Friends","title":"1583. Count Unhappy Friends"},{"location":"problems/1583/#1583-count-unhappy-friends","text":"","title":"1583. Count Unhappy Friends"},{"location":"problems/1584/","text":"1584. Min Cost to Connect All Points","title":"1584. Min Cost to Connect All Points"},{"location":"problems/1584/#1584-min-cost-to-connect-all-points","text":"","title":"1584. Min Cost to Connect All Points"},{"location":"problems/1585/","text":"1585. Check If String Is Transformable With Substring Sort Operations","title":"1585. Check If String Is Transformable With Substring Sort Operations"},{"location":"problems/1585/#1585-check-if-string-is-transformable-with-substring-sort-operations","text":"","title":"1585. Check If String Is Transformable With Substring Sort Operations"},{"location":"problems/1586/","text":"1586. Binary Search Tree Iterator II","title":"1586. Binary Search Tree Iterator II"},{"location":"problems/1586/#1586-binary-search-tree-iterator-ii","text":"","title":"1586. Binary Search Tree Iterator II"},{"location":"problems/1587/","text":"1587. Bank Account Summary II","title":"1587. Bank Account Summary II"},{"location":"problems/1587/#1587-bank-account-summary-ii","text":"","title":"1587. Bank Account Summary II"},{"location":"problems/1588/","text":"1588. Sum of All Odd Length Subarrays","title":"1588. Sum of All Odd Length Subarrays"},{"location":"problems/1588/#1588-sum-of-all-odd-length-subarrays","text":"","title":"1588. Sum of All Odd Length Subarrays"},{"location":"problems/1589/","text":"1589. Maximum Sum Obtained of Any Permutation","title":"1589. Maximum Sum Obtained of Any Permutation"},{"location":"problems/1589/#1589-maximum-sum-obtained-of-any-permutation","text":"","title":"1589. Maximum Sum Obtained of Any Permutation"},{"location":"problems/1590/","text":"1590. Make Sum Divisible by P","title":"1590. Make Sum Divisible by P"},{"location":"problems/1590/#1590-make-sum-divisible-by-p","text":"","title":"1590. Make Sum Divisible by P"},{"location":"problems/1591/","text":"1591. Strange Printer II","title":"1591. Strange Printer II"},{"location":"problems/1591/#1591-strange-printer-ii","text":"","title":"1591. Strange Printer II"},{"location":"problems/1592/","text":"1592. Rearrange Spaces Between Words Time: $O(|text|)$ Space: $O(|text|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string reorderSpaces ( string text ) { const int spaces = count ( begin ( text ), end ( text ), ' ' ); string ans ; vector < string > words ; istringstream iss ( text ); string word ; while ( iss >> word ) words . push_back ( word ); if ( words . size () == 1 ) return word + string ( spaces , ' ' ); const int gapSize = spaces / ( words . size () - 1 ); const int remains = spaces % ( words . size () - 1 ); for ( int i = 0 ; i < words . size () - 1 ; ++ i ) ans += words [ i ] + string ( gapSize , ' ' ); ans += words . back () + string ( remains , ' ' ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public String reorderSpaces ( String text ) { final String [] words = text . trim (). split ( \"\\\\s+\" ); final int spaces = ( int ) text . chars (). filter ( c -> c == ' ' ). count (); final int n = words . length ; final int gapSize = n == 1 ? 0 : spaces / ( n - 1 ); final int remains = n == 1 ? spaces : spaces % ( n - 1 ); return String . join ( \" \" . repeat ( gapSize ), words ) + \" \" . repeat ( remains ); } }","title":"1592. Rearrange Spaces Between Words"},{"location":"problems/1592/#1592-rearrange-spaces-between-words","text":"Time: $O(|text|)$ Space: $O(|text|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string reorderSpaces ( string text ) { const int spaces = count ( begin ( text ), end ( text ), ' ' ); string ans ; vector < string > words ; istringstream iss ( text ); string word ; while ( iss >> word ) words . push_back ( word ); if ( words . size () == 1 ) return word + string ( spaces , ' ' ); const int gapSize = spaces / ( words . size () - 1 ); const int remains = spaces % ( words . size () - 1 ); for ( int i = 0 ; i < words . size () - 1 ; ++ i ) ans += words [ i ] + string ( gapSize , ' ' ); ans += words . back () + string ( remains , ' ' ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 class Solution { public String reorderSpaces ( String text ) { final String [] words = text . trim (). split ( \"\\\\s+\" ); final int spaces = ( int ) text . chars (). filter ( c -> c == ' ' ). count (); final int n = words . length ; final int gapSize = n == 1 ? 0 : spaces / ( n - 1 ); final int remains = n == 1 ? spaces : spaces % ( n - 1 ); return String . join ( \" \" . repeat ( gapSize ), words ) + \" \" . repeat ( remains ); } }","title":"1592. Rearrange Spaces Between Words"},{"location":"problems/1593/","text":"1593. Split a String Into the Max Number of Unique Substrings Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maxUniqueSplit ( string s ) { size_t ans = 0 ; unordered_set < string > seen ; function < void ( int ) > dfs = [ & ]( int start ) { if ( start == s . length ()) { ans = max ( ans , seen . size ()); return ; } for ( int i = 1 ; start + i <= s . length (); ++ i ) { const string cand = s . substr ( start , i ); if ( seen . count ( cand )) continue ; seen . insert ( cand ); dfs ( start + i ); seen . erase ( cand ); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxUniqueSplit ( String s ) { Set < String > seen = new HashSet <> (); dfs ( s , 0 , seen ); return ans ; } private int ans = 0 ; private void dfs ( final String s , int start , Set < String > seen ) { if ( start == s . length ()) { ans = Math . max ( ans , seen . size ()); return ; } for ( int i = start + 1 ; i <= s . length (); ++ i ) { final String cand = s . substring ( start , i ); if ( seen . contains ( cand )) continue ; seen . add ( cand ); dfs ( s , i , seen ); seen . remove ( cand ); } } }","title":"1593. Split a String Into the Max Number of Unique Substrings"},{"location":"problems/1593/#1593-split-a-string-into-the-max-number-of-unique-substrings","text":"Time: $O(2^n)$ Space: $O(2^n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int maxUniqueSplit ( string s ) { size_t ans = 0 ; unordered_set < string > seen ; function < void ( int ) > dfs = [ & ]( int start ) { if ( start == s . length ()) { ans = max ( ans , seen . size ()); return ; } for ( int i = 1 ; start + i <= s . length (); ++ i ) { const string cand = s . substr ( start , i ); if ( seen . count ( cand )) continue ; seen . insert ( cand ); dfs ( start + i ); seen . erase ( cand ); } }; dfs ( 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxUniqueSplit ( String s ) { Set < String > seen = new HashSet <> (); dfs ( s , 0 , seen ); return ans ; } private int ans = 0 ; private void dfs ( final String s , int start , Set < String > seen ) { if ( start == s . length ()) { ans = Math . max ( ans , seen . size ()); return ; } for ( int i = start + 1 ; i <= s . length (); ++ i ) { final String cand = s . substring ( start , i ); if ( seen . contains ( cand )) continue ; seen . add ( cand ); dfs ( s , i , seen ); seen . remove ( cand ); } } }","title":"1593. Split a String Into the Max Number of Unique Substrings"},{"location":"problems/1594/","text":"1594. Maximum Non Negative Product in a Matrix Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int maxProductPath ( vector < vector < int >>& grid ) { constexpr int kMod = 1e9 + 7 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); // dpMin[i][j] := the min product from (0, 0) to (i, j) // dpMax[i][j] := the max product from (0, 0) to (i, j) vector < vector < long >> dpMin ( m , vector < long > ( n )); vector < vector < long >> dpMax ( m , vector < long > ( n )); dpMin [ 0 ][ 0 ] = dpMax [ 0 ][ 0 ] = grid [ 0 ][ 0 ]; for ( int i = 1 ; i < m ; ++ i ) dpMin [ i ][ 0 ] = dpMax [ i ][ 0 ] = dpMin [ i - 1 ][ 0 ] * grid [ i ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) dpMin [ 0 ][ j ] = dpMax [ 0 ][ j ] = dpMin [ 0 ][ j - 1 ] * grid [ 0 ][ j ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( grid [ i ][ j ] < 0 ) { dpMin [ i ][ j ] = max ( dpMax [ i - 1 ][ j ], dpMax [ i ][ j - 1 ]) * grid [ i ][ j ]; dpMax [ i ][ j ] = min ( dpMin [ i - 1 ][ j ], dpMin [ i ][ j - 1 ]) * grid [ i ][ j ]; } else { dpMin [ i ][ j ] = min ( dpMin [ i - 1 ][ j ], dpMin [ i ][ j - 1 ]) * grid [ i ][ j ]; dpMax [ i ][ j ] = max ( dpMax [ i - 1 ][ j ], dpMax [ i ][ j - 1 ]) * grid [ i ][ j ]; } const long maxi = max ( dpMin . back (). back (), dpMax . back (). back ()); return maxi < 0 ? -1 : maxi % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maxProductPath ( int [][] grid ) { final int kMod = ( int ) 1e9 + 7 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; // dpMin[i][j] := the min product from (0, 0) to (i, j) // dpMax[i][j] := the max product from (0, 0) to (i, j) long [][] dpMin = new long [ m ][ n ] ; long [][] dpMax = new long [ m ][ n ] ; dpMin [ 0 ][ 0 ] = dpMax [ 0 ][ 0 ] = grid [ 0 ][ 0 ] ; for ( int i = 1 ; i < m ; ++ i ) dpMin [ i ][ 0 ] = dpMax [ i ][ 0 ] = dpMin [ i - 1 ][ 0 ] * grid [ i ][ 0 ] ; for ( int j = 1 ; j < n ; ++ j ) dpMin [ 0 ][ j ] = dpMax [ 0 ][ j ] = dpMin [ 0 ][ j - 1 ] * grid [ 0 ][ j ] ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( grid [ i ][ j ] < 0 ) { dpMin [ i ][ j ] = Math . max ( dpMax [ i - 1 ][ j ] , dpMax [ i ][ j - 1 ] ) * grid [ i ][ j ] ; dpMax [ i ][ j ] = Math . min ( dpMin [ i - 1 ][ j ] , dpMin [ i ][ j - 1 ] ) * grid [ i ][ j ] ; } else { dpMin [ i ][ j ] = Math . min ( dpMin [ i - 1 ][ j ] , dpMin [ i ][ j - 1 ] ) * grid [ i ][ j ] ; dpMax [ i ][ j ] = Math . max ( dpMax [ i - 1 ][ j ] , dpMax [ i ][ j - 1 ] ) * grid [ i ][ j ] ; } final long max = Math . max ( dpMin [ m - 1 ][ n - 1 ] , dpMax [ m - 1 ][ n - 1 ] ); return max < 0 ? - 1 : ( int ) ( max % kMod ); } }","title":"1594. Maximum Non Negative Product in a Matrix"},{"location":"problems/1594/#1594-maximum-non-negative-product-in-a-matrix","text":"Time: $O(mn)$ Space: $O(mn)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int maxProductPath ( vector < vector < int >>& grid ) { constexpr int kMod = 1e9 + 7 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); // dpMin[i][j] := the min product from (0, 0) to (i, j) // dpMax[i][j] := the max product from (0, 0) to (i, j) vector < vector < long >> dpMin ( m , vector < long > ( n )); vector < vector < long >> dpMax ( m , vector < long > ( n )); dpMin [ 0 ][ 0 ] = dpMax [ 0 ][ 0 ] = grid [ 0 ][ 0 ]; for ( int i = 1 ; i < m ; ++ i ) dpMin [ i ][ 0 ] = dpMax [ i ][ 0 ] = dpMin [ i - 1 ][ 0 ] * grid [ i ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) dpMin [ 0 ][ j ] = dpMax [ 0 ][ j ] = dpMin [ 0 ][ j - 1 ] * grid [ 0 ][ j ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( grid [ i ][ j ] < 0 ) { dpMin [ i ][ j ] = max ( dpMax [ i - 1 ][ j ], dpMax [ i ][ j - 1 ]) * grid [ i ][ j ]; dpMax [ i ][ j ] = min ( dpMin [ i - 1 ][ j ], dpMin [ i ][ j - 1 ]) * grid [ i ][ j ]; } else { dpMin [ i ][ j ] = min ( dpMin [ i - 1 ][ j ], dpMin [ i ][ j - 1 ]) * grid [ i ][ j ]; dpMax [ i ][ j ] = max ( dpMax [ i - 1 ][ j ], dpMax [ i ][ j - 1 ]) * grid [ i ][ j ]; } const long maxi = max ( dpMin . back (). back (), dpMax . back (). back ()); return maxi < 0 ? -1 : maxi % kMod ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maxProductPath ( int [][] grid ) { final int kMod = ( int ) 1e9 + 7 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; // dpMin[i][j] := the min product from (0, 0) to (i, j) // dpMax[i][j] := the max product from (0, 0) to (i, j) long [][] dpMin = new long [ m ][ n ] ; long [][] dpMax = new long [ m ][ n ] ; dpMin [ 0 ][ 0 ] = dpMax [ 0 ][ 0 ] = grid [ 0 ][ 0 ] ; for ( int i = 1 ; i < m ; ++ i ) dpMin [ i ][ 0 ] = dpMax [ i ][ 0 ] = dpMin [ i - 1 ][ 0 ] * grid [ i ][ 0 ] ; for ( int j = 1 ; j < n ; ++ j ) dpMin [ 0 ][ j ] = dpMax [ 0 ][ j ] = dpMin [ 0 ][ j - 1 ] * grid [ 0 ][ j ] ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( grid [ i ][ j ] < 0 ) { dpMin [ i ][ j ] = Math . max ( dpMax [ i - 1 ][ j ] , dpMax [ i ][ j - 1 ] ) * grid [ i ][ j ] ; dpMax [ i ][ j ] = Math . min ( dpMin [ i - 1 ][ j ] , dpMin [ i ][ j - 1 ] ) * grid [ i ][ j ] ; } else { dpMin [ i ][ j ] = Math . min ( dpMin [ i - 1 ][ j ] , dpMin [ i ][ j - 1 ] ) * grid [ i ][ j ] ; dpMax [ i ][ j ] = Math . max ( dpMax [ i - 1 ][ j ] , dpMax [ i ][ j - 1 ] ) * grid [ i ][ j ] ; } final long max = Math . max ( dpMin [ m - 1 ][ n - 1 ] , dpMax [ m - 1 ][ n - 1 ] ); return max < 0 ? - 1 : ( int ) ( max % kMod ); } }","title":"1594. Maximum Non Negative Product in a Matrix"},{"location":"problems/1595/","text":"1595. Minimum Cost to Connect Two Groups of Points","title":"1595. Minimum Cost to Connect Two Groups of Points"},{"location":"problems/1595/#1595-minimum-cost-to-connect-two-groups-of-points","text":"","title":"1595. Minimum Cost to Connect Two Groups of Points"},{"location":"problems/1596/","text":"1596. The Most Frequently Ordered Products for Each Customer","title":"1596. The Most Frequently Ordered Products for Each Customer"},{"location":"problems/1596/#1596-the-most-frequently-ordered-products-for-each-customer","text":"","title":"1596. The Most Frequently Ordered Products for Each Customer"},{"location":"problems/1597/","text":"1597. Build Binary Expression Tree From Infix Expression Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : Node * expTree ( string s ) { stack < Node *> nodes ; // stores nodes (new Node(val)) stack < char > ops ; // stores operators and parentheses for ( const char c : s ) if ( isdigit ( c )) { nodes . push ( new Node ( c )); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); ops . pop (); // remove '(' } else if ( c == '+' || c == '-' || c == '*' || c == '/' ) { while ( ! ops . empty () && compare ( ops . top (), c )) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); ops . push ( c ); } while ( ! ops . empty ()) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); return nodes . top (); } private : Node * buildNode ( char op , Node * right , Node * left ) { return new Node ( op , left , right ); } // return true if op1 is a operator and priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } Node * pop ( stack < Node *>& nodes ) { Node * node = nodes . top (); nodes . pop (); return node ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public Node expTree ( String s ) { Stack < Node > nodes = new Stack <> (); // stores nodes (new Node(val)) Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) { nodes . push ( new Node ( c )); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); ops . push ( c ); } while ( ! ops . isEmpty ()) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); return nodes . peek (); } private Node buildNode ( char op , Node right , Node left ) { return new Node ( op , left , right ); } // return true if op1 is a operator and priority(op1) >= priority(op2) boolean compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"1597. Build Binary Expression Tree From Infix Expression"},{"location":"problems/1597/#1597-build-binary-expression-tree-from-infix-expression","text":"Time: $O(n)$ Space: $O(n)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public : Node * expTree ( string s ) { stack < Node *> nodes ; // stores nodes (new Node(val)) stack < char > ops ; // stores operators and parentheses for ( const char c : s ) if ( isdigit ( c )) { nodes . push ( new Node ( c )); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . top () != '(' ) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); ops . pop (); // remove '(' } else if ( c == '+' || c == '-' || c == '*' || c == '/' ) { while ( ! ops . empty () && compare ( ops . top (), c )) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); ops . push ( c ); } while ( ! ops . empty ()) nodes . push ( buildNode ( pop ( ops ), pop ( nodes ), pop ( nodes ))); return nodes . top (); } private : Node * buildNode ( char op , Node * right , Node * left ) { return new Node ( op , left , right ); } // return true if op1 is a operator and priority(op1) >= priority(op2) bool compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } char pop ( stack < char >& ops ) { const char op = ops . top (); ops . pop (); return op ; } Node * pop ( stack < Node *>& nodes ) { Node * node = nodes . top (); nodes . pop (); return node ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public Node expTree ( String s ) { Stack < Node > nodes = new Stack <> (); // stores nodes (new Node(val)) Stack < Character > ops = new Stack <> (); // stores operators and parentheses for ( final char c : s . toCharArray ()) if ( Character . isDigit ( c )) { nodes . push ( new Node ( c )); } else if ( c == '(' ) { ops . push ( c ); } else if ( c == ')' ) { while ( ops . peek () != '(' ) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); ops . pop (); // remove '(' } else { // c == '+' || c == '-' || c == '*' || c == '/' while ( ! ops . isEmpty () && compare ( ops . peek (), c )) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); ops . push ( c ); } while ( ! ops . isEmpty ()) nodes . push ( buildNode ( ops . pop (), nodes . pop (), nodes . pop ())); return nodes . peek (); } private Node buildNode ( char op , Node right , Node left ) { return new Node ( op , left , right ); } // return true if op1 is a operator and priority(op1) >= priority(op2) boolean compare ( char op1 , char op2 ) { if ( op1 == '(' || op1 == ')' ) return false ; return op1 == '*' || op1 == '/' || op2 == '+' || op2 == '-' ; } }","title":"1597. Build Binary Expression Tree From Infix Expression"},{"location":"problems/1598/","text":"1598. Crawler Log Folder Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minOperations ( vector < string >& logs ) { int ans = 0 ; for ( const string & log : logs ) { if ( log == \"./\" ) continue ; if ( log == \"../\" ) ans = max ( 0 , ans - 1 ); else ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minOperations ( String [] logs ) { int ans = 0 ; for ( final String log : logs ) { if ( log . equals ( \"./\" )) continue ; if ( log . equals ( \"../\" )) ans = Math . max ( 0 , ans - 1 ); else ++ ans ; } return ans ; } }","title":"1598. Crawler Log Folder"},{"location":"problems/1598/#1598-crawler-log-folder","text":"Time: $O(n)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minOperations ( vector < string >& logs ) { int ans = 0 ; for ( const string & log : logs ) { if ( log == \"./\" ) continue ; if ( log == \"../\" ) ans = max ( 0 , ans - 1 ); else ++ ans ; } return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minOperations ( String [] logs ) { int ans = 0 ; for ( final String log : logs ) { if ( log . equals ( \"./\" )) continue ; if ( log . equals ( \"../\" )) ans = Math . max ( 0 , ans - 1 ); else ++ ans ; } return ans ; } }","title":"1598. Crawler Log Folder"},{"location":"problems/1599/","text":"1599. Maximum Profit of Operating a Centennial Wheel Time: $O(\\Sigma|customers_i| / 4)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int minOperationsMaxProfit ( vector < int >& customers , int boardingCost , int runningCost ) { int waiting = 0 ; int profit = 0 ; int maxProfit = 0 ; int rotate = 0 ; int maxRotate = -1 ; int i = 0 ; while ( waiting > 0 || i < customers . size ()) { if ( i < customers . size ()) waiting += customers [ i ++ ]; // onboard new customers const int newOnboard = min ( waiting , 4 ); waiting -= newOnboard ; profit += newOnboard * boardingCost - runningCost ; ++ rotate ; if ( profit > maxProfit ) { maxProfit = profit ; maxRotate = rotate ; } } return maxRotate ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minOperationsMaxProfit ( int [] customers , int boardingCost , int runningCost ) { int waiting = 0 ; int profit = 0 ; int maxProfit = 0 ; int rotate = 0 ; int maxRotate = - 1 ; int i = 0 ; while ( waiting > 0 || i < customers . length ) { if ( i < customers . length ) waiting += customers [ i ++] ; // onboard new customers final int newOnboard = Math . min ( waiting , 4 ); waiting -= newOnboard ; profit += newOnboard * boardingCost - runningCost ; ++ rotate ; if ( profit > maxProfit ) { maxProfit = profit ; maxRotate = rotate ; } } return maxRotate ; } }","title":"1599. Maximum Profit of Operating a Centennial Wheel"},{"location":"problems/1599/#1599-maximum-profit-of-operating-a-centennial-wheel","text":"Time: $O(\\Sigma|customers_i| / 4)$ Space: $O(1)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int minOperationsMaxProfit ( vector < int >& customers , int boardingCost , int runningCost ) { int waiting = 0 ; int profit = 0 ; int maxProfit = 0 ; int rotate = 0 ; int maxRotate = -1 ; int i = 0 ; while ( waiting > 0 || i < customers . size ()) { if ( i < customers . size ()) waiting += customers [ i ++ ]; // onboard new customers const int newOnboard = min ( waiting , 4 ); waiting -= newOnboard ; profit += newOnboard * boardingCost - runningCost ; ++ rotate ; if ( profit > maxProfit ) { maxProfit = profit ; maxRotate = rotate ; } } return maxRotate ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minOperationsMaxProfit ( int [] customers , int boardingCost , int runningCost ) { int waiting = 0 ; int profit = 0 ; int maxProfit = 0 ; int rotate = 0 ; int maxRotate = - 1 ; int i = 0 ; while ( waiting > 0 || i < customers . length ) { if ( i < customers . length ) waiting += customers [ i ++] ; // onboard new customers final int newOnboard = Math . min ( waiting , 4 ); waiting -= newOnboard ; profit += newOnboard * boardingCost - runningCost ; ++ rotate ; if ( profit > maxProfit ) { maxProfit = profit ; maxRotate = rotate ; } } return maxRotate ; } }","title":"1599. Maximum Profit of Operating a Centennial Wheel"},{"location":"problems/1600/","text":"1600. Throne Inheritance Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class ThroneInheritance { public : ThroneInheritance ( string kingName ) : kingName ( kingName ) {} void birth ( string parentName , string childName ) { family [ parentName ]. push_back ( childName ); } void death ( string name ) { dead . insert ( name ); } vector < string > getInheritanceOrder () { vector < string > ans ; dfs ( kingName , ans ); return ans ; } private : unordered_set < string > dead ; unordered_map < string , vector < string >> family ; string kingName ; void dfs ( const string & name , vector < string >& ans ) { if ( ! dead . count ( name )) ans . push_back ( name ); if ( ! family . count ( name )) return ; for ( const string & child : family [ name ]) dfs ( child , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ThroneInheritance { public ThroneInheritance ( String kingName ) { this . kingName = kingName ; } public void birth ( String parentName , String childName ) { family . putIfAbsent ( parentName , new ArrayList <> ()); family . get ( parentName ). add ( childName ); } public void death ( String name ) { dead . add ( name ); } public List < String > getInheritanceOrder () { List < String > ans = new ArrayList <> (); dfs ( kingName , ans ); return ans ; } private Set < String > dead = new HashSet <> (); private Map < String , List < String >> family = new HashMap <> (); private String kingName ; private void dfs ( final String name , List < String > ans ) { if ( ! dead . contains ( name )) ans . add ( name ); if ( ! family . containsKey ( name )) return ; for ( final String child : family . get ( name )) dfs ( child , ans ); } }","title":"1600. Throne Inheritance"},{"location":"problems/1600/#1600-throne-inheritance","text":"Time: Space: C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class ThroneInheritance { public : ThroneInheritance ( string kingName ) : kingName ( kingName ) {} void birth ( string parentName , string childName ) { family [ parentName ]. push_back ( childName ); } void death ( string name ) { dead . insert ( name ); } vector < string > getInheritanceOrder () { vector < string > ans ; dfs ( kingName , ans ); return ans ; } private : unordered_set < string > dead ; unordered_map < string , vector < string >> family ; string kingName ; void dfs ( const string & name , vector < string >& ans ) { if ( ! dead . count ( name )) ans . push_back ( name ); if ( ! family . count ( name )) return ; for ( const string & child : family [ name ]) dfs ( child , ans ); } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class ThroneInheritance { public ThroneInheritance ( String kingName ) { this . kingName = kingName ; } public void birth ( String parentName , String childName ) { family . putIfAbsent ( parentName , new ArrayList <> ()); family . get ( parentName ). add ( childName ); } public void death ( String name ) { dead . add ( name ); } public List < String > getInheritanceOrder () { List < String > ans = new ArrayList <> (); dfs ( kingName , ans ); return ans ; } private Set < String > dead = new HashSet <> (); private Map < String , List < String >> family = new HashMap <> (); private String kingName ; private void dfs ( final String name , List < String > ans ) { if ( ! dead . contains ( name )) ans . add ( name ); if ( ! family . containsKey ( name )) return ; for ( final String child : family . get ( name )) dfs ( child , ans ); } }","title":"1600. Throne Inheritance"},{"location":"problems/1601/","text":"1601. Maximum Number of Achievable Transfer Requests Time: $O(n \\cdot 2^|requests|)$ Space: $O(n + |requests|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int maximumRequests ( int n , vector < vector < int >>& requests ) { int ans = 0 ; vector < int > degree ( n ); // degree[i] := degree of building i function < void ( int , int ) > dfs = [ & ]( int i , int processedReqs ) { if ( i == requests . size ()) { if ( all_of ( begin ( degree ), end ( degree ), []( int d ) { return d == 0 ; })) ans = max ( ans , processedReqs ); return ; } // skip requests[i] dfs ( i + 1 , processedReqs ); // process requests[i] -- degree [ requests [ i ][ 0 ]]; ++ degree [ requests [ i ][ 1 ]]; dfs ( i + 1 , processedReqs + 1 ); -- degree [ requests [ i ][ 1 ]]; ++ degree [ requests [ i ][ 0 ]]; }; dfs ( 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maximumRequests ( int n , int [][] requests ) { dfs ( 0 , 0 , requests , new int [ n ] ); return ans ; } private int ans = 0 ; private void dfs ( int i , int processedReqs , int [][] requests , int [] degree ) { if ( i == requests . length ) { if ( Arrays . stream ( degree ). allMatch ( d -> d == 0 )) ans = Math . max ( ans , processedReqs ); return ; } // skip requests[i] dfs ( i + 1 , processedReqs , requests , degree ); // process requests[i] -- degree [ requests [ i ][ 0 ]] ; ++ degree [ requests [ i ][ 1 ]] ; dfs ( i + 1 , processedReqs + 1 , requests , degree ); -- degree [ requests [ i ][ 1 ]] ; ++ degree [ requests [ i ][ 0 ]] ; } }","title":"1601. Maximum Number of Achievable Transfer Requests"},{"location":"problems/1601/#1601-maximum-number-of-achievable-transfer-requests","text":"Time: $O(n \\cdot 2^|requests|)$ Space: $O(n + |requests|)$ C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int maximumRequests ( int n , vector < vector < int >>& requests ) { int ans = 0 ; vector < int > degree ( n ); // degree[i] := degree of building i function < void ( int , int ) > dfs = [ & ]( int i , int processedReqs ) { if ( i == requests . size ()) { if ( all_of ( begin ( degree ), end ( degree ), []( int d ) { return d == 0 ; })) ans = max ( ans , processedReqs ); return ; } // skip requests[i] dfs ( i + 1 , processedReqs ); // process requests[i] -- degree [ requests [ i ][ 0 ]]; ++ degree [ requests [ i ][ 1 ]]; dfs ( i + 1 , processedReqs + 1 ); -- degree [ requests [ i ][ 1 ]]; ++ degree [ requests [ i ][ 0 ]]; }; dfs ( 0 , 0 ); return ans ; } }; Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maximumRequests ( int n , int [][] requests ) { dfs ( 0 , 0 , requests , new int [ n ] ); return ans ; } private int ans = 0 ; private void dfs ( int i , int processedReqs , int [][] requests , int [] degree ) { if ( i == requests . length ) { if ( Arrays . stream ( degree ). allMatch ( d -> d == 0 )) ans = Math . max ( ans , processedReqs ); return ; } // skip requests[i] dfs ( i + 1 , processedReqs , requests , degree ); // process requests[i] -- degree [ requests [ i ][ 0 ]] ; ++ degree [ requests [ i ][ 1 ]] ; dfs ( i + 1 , processedReqs + 1 , requests , degree ); -- degree [ requests [ i ][ 1 ]] ; ++ degree [ requests [ i ][ 0 ]] ; } }","title":"1601. Maximum Number of Achievable Transfer Requests"}]}